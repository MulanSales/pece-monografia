{"commit":"ef9fad50aec643b2d02b3cd3835f1dfd0cd3281b","subject":"","message":"\n\n\ngit-svn-id: 75210f800c74dac7ab89a5be233e5d30c702c3e4@346 a0bf3537-8e53-448f-ae4a-0b965e85af5e\n","repos":"ericoldre\/NoraGrace-Chess","old_file":"Sinobyl\/Sinobyl.Engine\/ChessMoveBuffer.cs","new_file":"Sinobyl\/Sinobyl.Engine\/ChessMoveBuffer.cs","new_contents":"\ufeffusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Sinobyl.Engine\r\n{\r\n    public class ChessMoveBuffer\r\n    {\r\n        List<PlyBuffer> _plyBuffers = new List<PlyBuffer>();\r\n\r\n        public ChessMoveBuffer(int plyCapacity = 50)\r\n        {\r\n            while (_plyBuffers.Count < plyCapacity)\r\n            {\r\n                _plyBuffers.Add(new PlyBuffer());\r\n            }\r\n        }\r\n\r\n        public PlyBuffer this[int ply]\r\n        {\r\n            get\r\n            {\r\n                if (ply > _plyBuffers.Count)\r\n                {\r\n                    for (int i = 0; i < 10; i++)\r\n                    {\r\n                        _plyBuffers.Add(new PlyBuffer());\r\n                    }\r\n                }\r\n                return _plyBuffers[ply];\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    public class PlyBuffer\r\n    {\r\n\r\n        private class KillerInfo\r\n        {\r\n            public ChessMove move1 { get; private set; }\r\n            public ChessMove move2 { get; private set; }\r\n\r\n            public void RegisterKiller(ChessMove move)\r\n            {\r\n                if (move != move1)\r\n                {\r\n                    move2 = move1;\r\n                    move1 = move;\r\n                }\r\n            }\r\n\r\n            public bool IsKiller(ChessMove move)\r\n            {\r\n                return move == move1 || move == move2;\r\n            }\r\n        }\r\n\r\n        private readonly ChessMoveData[] _array = new ChessMoveData[192];\r\n        private int _moveCount;\r\n        private int _moveCurrent;\r\n\r\n        private readonly KillerInfo[] _playerKillers = new KillerInfo[2];\r\n        private readonly ChessMove[][] _counterMoves = new ChessMove[16][]; \/\/[16][64];\r\n        public PlyBuffer()\r\n        {\r\n            _playerKillers[0] = new KillerInfo();\r\n            _playerKillers[1] = new KillerInfo();\r\n            for (int i = 0; i <= _counterMoves.GetUpperBound(0); i++) { _counterMoves[i] = new ChessMove[64]; }\r\n        }\r\n\r\n        public void Initialize(ChessBoard board, bool capsOnly = false)\r\n        {\r\n            _moveCount = ChessMoveInfo.GenMovesArray(_array, board, capsOnly);\r\n            _moveCurrent = 0;\r\n        }\r\n\r\n        public int MoveCount\r\n        {\r\n            get { return _moveCount; }\r\n        }\r\n\r\n        public ChessMove NextMove()\r\n        {\r\n            if (_moveCurrent < _moveCount)\r\n            {\r\n                return _array[_moveCurrent++].Move;\r\n            }\r\n            else\r\n            {\r\n                return ChessMove.EMPTY;\r\n            }\r\n        }\r\n\r\n        public ChessMoveData NextMoveData()\r\n        {\r\n            if (_moveCurrent < _moveCount)\r\n            {\r\n                return _array[_moveCurrent++];\r\n            }\r\n            else\r\n            {\r\n                return new ChessMoveData() { Move = ChessMove.EMPTY };\r\n            }\r\n\r\n        }\r\n\r\n        public void RegisterCutoff(ChessBoard board, ChessMove move)\r\n        {\r\n            if (board.PieceAt(move.To()) == ChessPiece.EMPTY)\r\n            {\r\n                _playerKillers[(int)board.WhosTurn].RegisterKiller(move);\r\n\r\n                if (board.HistoryCount > 0 && board.MovesSinceNull > 0)\r\n                {\r\n                    \/\/register counter move hueristic.\r\n                    ChessMove prevMove = board.HistMove(1);\r\n                    ChessPiece prevPiece = board.PieceAt(prevMove.To());\r\n                    System.Diagnostics.Debug.Assert(prevPiece.PieceToPlayer() == board.WhosTurn.PlayerOther());\r\n                    _counterMoves[(int)prevPiece][(int)prevMove.To()] = move;\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        public void Sort(ChessBoard board, bool useSEE, ChessMove ttMove)\r\n        {\r\n            \/\/useSEE = true;\r\n            var killers = _playerKillers[(int)board.WhosTurn];\r\n\r\n            ChessMove killer1 = killers.move1;\r\n            ChessMove killer2 = killers.move2;\r\n\r\n            \/\/find previous move and last quiet move used to counter it.\r\n            ChessMove counterMove = ChessMove.EMPTY;\r\n            if (board.HistoryCount > 0)\r\n            {\r\n                ChessMove prevMove = board.HistMove(1);\r\n                ChessPiece prevPiece = board.PieceAt(prevMove.To());\r\n                \/\/System.Diagnostics.Debug.Assert(prevPiece.PieceToPlayer() == board.WhosTurn.PlayerOther());\r\n                counterMove = _counterMoves[(int)prevPiece][(int)prevMove.To()];\r\n            }\r\n\r\n\r\n            \/\/first score moves\r\n            for (int i = 0; i < _moveCount; i++)\r\n            {\r\n                ChessMove move = _array[i].Move;\r\n                ChessPiece piece = board.PieceAt(move.From());\r\n                bool isCap = board.PieceAt(move.To()) != ChessPiece.EMPTY;\r\n\r\n                System.Diagnostics.Debug.Assert(move != ChessMove.EMPTY);\r\n\r\n                \/\/calc pcsq value;\r\n                PhasedScore pcSq = 0;\r\n                board.PcSqEvaluator.PcSqValuesRemove(piece, move.From(), ref pcSq);\r\n                board.PcSqEvaluator.PcSqValuesAdd(piece, move.To(), ref pcSq);\r\n                if (board.WhosTurn == ChessPlayer.Black) { pcSq = pcSq.Negate(); }\r\n\r\n                int see = 0;\r\n\r\n                \/\/calc flags\r\n                MoveFlags flags = 0;\r\n                if (move == ttMove) { flags |= MoveFlags.TransTable; }\r\n                if (move.Promote() != ChessPiece.EMPTY) { flags |= MoveFlags.Promote; }\r\n\r\n                if (isCap)\r\n                {\r\n                    flags |= MoveFlags.Capture;\r\n                    see = ChessMoveSEE.CompEstScoreSEE(move, board);\r\n                    \/\/if (see > 0) { flags |= MoveFlags.CapturePositive; }\r\n                    \/\/if (see == 0) { flags |= MoveFlags.CaptureEqual; }\r\n                }\r\n\r\n                \/\/if(piece.ToPieceType() == ChessPieceType.Pawn && (move.To.GetRank() == ChessRank.Rank7 || move.To.GetRank() == ChessRank.Rank2))\r\n                \/\/{\r\n                \/\/    flags |= MoveFlags.Pawn7th;\r\n                \/\/}\r\n\r\n                if (move == counterMove || move == killer1 || move == killer2)\r\n                {\r\n                    flags |= MoveFlags.Killer;\r\n                }\r\n\r\n                \/\/if (killers.IsKiller(move)) { flags |= MoveFlags.Killer; }\r\n\r\n                _array[i].SEE = see;\r\n                _array[i].PcSq = pcSq.Opening();\r\n                _array[i].Flags = flags;\r\n                _array[i].Score = _array[i].ScoreCalc();\r\n\r\n            }\r\n\r\n            \/\/now sort array.\r\n            for (int i = 1; i < _moveCount; i++)\r\n            {\r\n                for (int ii = i; ii > 0; ii--)\r\n                {\r\n                    if (_array[ii].Score > _array[ii - 1].Score)\r\n                    {\r\n                        var tmp = _array[ii];\r\n                        _array[ii] = _array[ii - 1];\r\n                        _array[ii - 1] = tmp;\r\n                    }\r\n                    else\r\n                    {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        public IEnumerable<ChessMove> SortedMoves()\r\n        {\r\n            for (int i = 0; i < _moveCount; i++)\r\n            {\r\n                yield return _array[i].Move;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    public class PlyBuffer2\r\n    {\r\n\r\n        private class KillerInfo\r\n        {\r\n            public ChessMove move1 { get; private set; }\r\n            public ChessMove move2 { get; private set; }\r\n\r\n\r\n            public void RegisterKiller(ChessMove move)\r\n            {\r\n                if (move != move1)\r\n                {\r\n                    move2 = move1;\r\n                    move1 = move;\r\n                }\r\n            }\r\n\r\n\r\n            public bool IsKiller(ChessMove move)\r\n            {\r\n                return move == move1 || move == move2;\r\n            }\r\n\r\n            public ChessMove this[int index]\r\n            {\r\n                get\r\n                {\r\n                    if (index == 0) { return move1; }\r\n                    if (index == 1) { return move2; }\r\n                    throw new ArgumentOutOfRangeException();\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        private enum steps\r\n        {\r\n            ttMove,\r\n            InitCaps,\r\n            GoodCaps,\r\n            Killers,\r\n            BadCaps,\r\n            InitQuiet,\r\n            Quiet,\r\n        }\r\n\r\n        private readonly ChessMoveData[] _array = new ChessMoveData[192];\r\n        \r\n        private readonly KillerInfo[] _playerKillers = new KillerInfo[2];\r\n\r\n        private readonly ChessMove[] _killers = new ChessMove[3];\r\n        private ChessMove _ttMove;\r\n        private ChessBoard _board;\r\n        private long _boardZob;\r\n        private bool _capsOnly;\r\n        private steps _currStep;\r\n        private ChessMoveData _tmpData;\r\n        private int _capsCount;\r\n        private int _capsGoodCount;\r\n        private int _currIndex;\r\n        private int _killerCount;\r\n        private int _quietCount;\r\n\r\n        public PlyBuffer2()\r\n        {\r\n            _playerKillers[0] = new KillerInfo();\r\n            _playerKillers[1] = new KillerInfo();\r\n            \r\n        }\r\n\r\n        public void Initialize(ChessBoard board, ChessMove ttMove = ChessMove.EMPTY, bool capsOnly = false)\r\n        {\r\n            _board = board;\r\n            _boardZob = board.Zobrist;\r\n            _ttMove = ttMove;\r\n            _capsOnly = capsOnly;\r\n            _currStep = 0;\r\n            _capsCount = 0;\r\n            _capsGoodCount = 0;\r\n            _currIndex = 0;\r\n            _killerCount = 0;\r\n            _quietCount = 0;\r\n            \/\/_moveCount = ChessMoveInfo.GenMovesArray(_array, board, capsOnly);\r\n            \/\/_moveCurrent = 0;\r\n        }\r\n\r\n\r\n        public ChessMoveData NextMoveData()\r\n        {\r\n            System.Diagnostics.Debug.Assert(_board.Zobrist == _boardZob);\r\n            switch (_currStep)\r\n            {\r\n                case steps.ttMove:\r\n                    if (_ttMove != ChessMove.EMPTY)\r\n                    {\r\n                        System.Diagnostics.Debug.Assert(_ttMove.IsPsuedoLegal(_board));\r\n                        _currStep++;\r\n                        _tmpData.Move = _ttMove;\r\n                        _tmpData.Flags = MoveFlags.TransTable;\r\n                        return _tmpData;\r\n                    }\r\n                    else\r\n                    {\r\n                        _currIndex = 0;\r\n                        _currStep++;\r\n                        return NextMoveData();\r\n                    }\r\n\r\n                case steps.InitCaps:\r\n                    _capsCount = ChessMoveInfo.GenCapsNonCaps(_array, _board, true, 0);\r\n                    for (int i = 0; i < _capsCount; i++)\r\n                    {\r\n                        _array[i].SEE = ChessMoveSEE.CompEstScoreSEE(_array[i].Move, _board); \/\/calculate if winning capture.\r\n                        _array[i].Flags = MoveFlags.Capture;\r\n                        if (_array[i].SEE >= 0) { _capsGoodCount++; } \/\/incr good cap count.\r\n                        for (int ii = i; ii > 0; ii--)\r\n                        {\r\n                            if (_array[ii].SEE > _array[ii - 1].SEE)\r\n                            {\r\n                                _tmpData = _array[ii];\r\n                                _array[ii] = _array[ii - 1];\r\n                                _array[ii - 1] = _tmpData;\r\n                            }\r\n                            else\r\n                            {\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    _currIndex = 0;\r\n                    _currStep++;\r\n                    return NextMoveData();\r\n                case steps.GoodCaps:\r\n                    if (_currIndex < _capsGoodCount)\r\n                    {\r\n                        return _array[_currIndex++];\r\n                    }\r\n                    else\r\n                    {\r\n                        _currStep++;\r\n                        _currIndex = 0;\r\n                        return NextMoveData();\r\n                    }\r\n\r\n                case steps.Killers:\r\n                    if (_capsOnly)\r\n                    {\r\n                        _currIndex = 0;\r\n                        _currStep++;\r\n                        return NextMoveData();\r\n                    }\r\n                    var killerInfo = _playerKillers[(int)_board.WhosTurn];\r\n                    if (_currIndex < _killerCount)\r\n                    {\r\n                        ChessMove move = killerInfo[_currIndex];\r\n                        if (move.IsPsuedoLegal(_board))\r\n                        {\r\n                            _tmpData.Move = move;\r\n                            _tmpData.Flags = MoveFlags.Killer;\r\n                            _currIndex++;\r\n                            return _tmpData;\r\n                        }\r\n                        else\r\n                        {\r\n                            _currIndex++;\r\n                            return NextMoveData();\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        _currIndex = 0;\r\n                        _currStep++;\r\n                        return NextMoveData();\r\n                    }\r\n                case steps.BadCaps:\r\n                    int badCapIndex = _currIndex + _capsGoodCount;\r\n                    if (badCapIndex < _capsCount)\r\n                    {\r\n                        _currIndex++;\r\n                        return _array[badCapIndex];\r\n                    }\r\n                    else\r\n                    {\r\n                        _currStep++;\r\n                        _currIndex = 0;\r\n                        return NextMoveData();\r\n                    }\r\n                case steps.InitQuiet:\r\n                    if (_capsOnly)\r\n                    {\r\n                        _currIndex = 0;\r\n                        _currStep++;\r\n                        return NextMoveData();\r\n                    }\r\n\r\n                    _quietCount = ChessMoveInfo.GenCapsNonCaps(_array, _board, false, 0);\r\n                    for (int i = 0; i < _quietCount; i++)\r\n                    {\r\n                        _array[i].SEE = 0;\r\n                        _array[i].Flags = 0;\r\n                        \/\/if (_array[i].SEE >= 0) { _capsGoodCount++; } \/\/incr good cap count.\r\n                        \/\/for (int ii = i; ii > 0; ii--)\r\n                        \/\/{\r\n                        \/\/    if (_array[ii].SEE > _array[ii - 1].SEE)\r\n                        \/\/    {\r\n                        \/\/        _tmpData = _array[ii];\r\n                        \/\/        _array[ii] = _array[ii - 1];\r\n                        \/\/        _array[ii - 1] = _tmpData;\r\n                        \/\/    }\r\n                        \/\/    else\r\n                        \/\/    {\r\n                        \/\/        break;\r\n                        \/\/    }\r\n                        \/\/}\r\n                    }\r\n                    _currIndex = 0;\r\n                    _currStep++;\r\n                    return NextMoveData();\r\n                case steps.Quiet:\r\n                    if (_capsOnly)\r\n                    {\r\n                        _tmpData.Move = ChessMove.EMPTY;\r\n                        return _tmpData;\r\n                    }\r\n\r\n                    if (_currIndex < _quietCount)\r\n                    {\r\n                        var m = _array[_currIndex].Move;\r\n\r\n                        if (!_playerKillers[(int)_board.WhosTurn].IsKiller(m))\r\n                        {\r\n                            return _array[_currIndex++];\r\n                        }\r\n                        else\r\n                        {\r\n                            _currIndex++;\r\n                            return NextMoveData();\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        _tmpData.Move = ChessMove.EMPTY;\r\n                        return _tmpData;\r\n                    }\r\n                    break;\r\n                default:\r\n                    System.Diagnostics.Debug.Assert(false);\r\n                    throw new ArgumentOutOfRangeException();\r\n            }\r\n        }\r\n\r\n        public IEnumerable<ChessMove> SortedMoves()\r\n        {\r\n            ChessMoveData moveData;\r\n\r\n            while ((moveData = NextMoveData()).Move != ChessMove.EMPTY)\r\n            {\r\n                yield return moveData.Move;\r\n            }\r\n        }\r\n\r\n        public void RegisterCutoff(ChessBoard board, ChessMove move)\r\n        {\r\n            if (board.PieceAt(move.To()) == ChessPiece.EMPTY)\r\n            {\r\n                _playerKillers[(int)board.WhosTurn].RegisterKiller(move);\r\n\r\n                \/\/if (board.HistoryCount > 0 && board.MovesSinceNull > 0)\r\n                \/\/{\r\n                \/\/    \/\/register counter move hueristic.\r\n                \/\/    ChessMove prevMove = board.HistMove(1);\r\n                \/\/    ChessPiece prevPiece = board.PieceAt(prevMove.To());\r\n                \/\/    System.Diagnostics.Debug.Assert(prevPiece.PieceToPlayer() == board.WhosTurn.PlayerOther());\r\n                \/\/    _counterMoves[(int)prevPiece][(int)prevMove.To()] = move;\r\n                \/\/}\r\n\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n\r\n    [System.Diagnostics.DebuggerDisplay(@\"{Move.Description()} SEE:{SEE} PcSq:{PcSq} Flags:{Flags}\")]\r\n    public struct ChessMoveData\r\n    {\r\n        public ChessMove Move;\r\n        public int SEE;\r\n        public int PcSq;\r\n        public MoveFlags Flags;\r\n        public int Score;\r\n\r\n        public int ScoreCalc()\r\n        {\r\n            return SEE + PcSq\r\n                + ((Flags & MoveFlags.TransTable) != 0 ? 1000000 : 0)\r\n                + ((Flags & MoveFlags.Capture) != 0 && SEE >= 0 ? 100000 : 0)\r\n                + ((Flags & MoveFlags.Killer) != 0 ? 10000 : 0)\r\n                + ((Flags & MoveFlags.Capture) != 0 ? 1000 : 0);\r\n        }\r\n\r\n\r\n        \/\/public void SetScores(ChessMove move, int see, int pcSq, MoveFlags flags)\r\n        \/\/{\r\n        \/\/    Move = move;\r\n        \/\/    SEE = see;\r\n        \/\/    PcSq = pcSq;\r\n        \/\/    Flags = flags;\r\n        \/\/}\r\n\r\n        \/\/private const MoveFlags _orderFlags = MoveFlags.TransTable | MoveFlags.Promote | MoveFlags.CapturePositive | MoveFlags.CaptureEqual | MoveFlags.Killer;\r\n    }\r\n\r\n    [Flags]\r\n    public enum MoveFlags\r\n    {\r\n        Killer = (1 << 0),\r\n        Capture = (1 << 1),\r\n        Promote = (1 << 2),\r\n        TransTable = (1 << 3),\r\n    }\r\n}\r\n","old_contents":"\ufeffusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Sinobyl.Engine\r\n{\r\n    public class ChessMoveBuffer\r\n    {\r\n        List<PlyBuffer> _plyBuffers = new List<PlyBuffer>();\r\n\r\n        public ChessMoveBuffer(int plyCapacity = 50)\r\n        {\r\n            while (_plyBuffers.Count < plyCapacity)\r\n            {\r\n                _plyBuffers.Add(new PlyBuffer());\r\n            }\r\n        }\r\n\r\n        public PlyBuffer this[int ply]\r\n        {\r\n            get\r\n            {\r\n                if (ply > _plyBuffers.Count)\r\n                {\r\n                    for (int i = 0; i < 10; i++)\r\n                    {\r\n                        _plyBuffers.Add(new PlyBuffer());\r\n                    }\r\n                }\r\n                return _plyBuffers[ply];\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    public class PlyBuffer\r\n    {\r\n\r\n        private class KillerInfo\r\n        {\r\n            public ChessMove move1 { get; private set; }\r\n            public ChessMove move2 { get; private set; }\r\n\r\n            public void RegisterKiller(ChessMove move)\r\n            {\r\n                if (move != move1)\r\n                {\r\n                    move2 = move1;\r\n                    move1 = move;\r\n                }\r\n            }\r\n\r\n            public bool IsKiller(ChessMove move)\r\n            {\r\n                return move == move1 || move == move2;\r\n            }\r\n        }\r\n\r\n        private readonly ChessMoveData[] _array = new ChessMoveData[192];\r\n        private int _moveCount;\r\n        private int _moveCurrent;\r\n\r\n        private readonly KillerInfo[] _playerKillers = new KillerInfo[2];\r\n        private readonly ChessMove[][] _counterMoves = new ChessMove[16][]; \/\/[16][64];\r\n        public PlyBuffer()\r\n        {\r\n            _playerKillers[0] = new KillerInfo();\r\n            _playerKillers[1] = new KillerInfo();\r\n            for (int i = 0; i <= _counterMoves.GetUpperBound(0); i++) { _counterMoves[i] = new ChessMove[64]; }\r\n        }\r\n\r\n        public void Initialize(ChessBoard board, bool capsOnly = false)\r\n        {\r\n            _moveCount = ChessMoveInfo.GenMovesArray(_array, board, capsOnly);\r\n            _moveCurrent = 0;\r\n        }\r\n\r\n        public int MoveCount\r\n        {\r\n            get { return _moveCount; }\r\n        }\r\n\r\n        public ChessMove NextMove()\r\n        {\r\n            if (_moveCurrent < _moveCount)\r\n            {\r\n                return _array[_moveCurrent++].Move;\r\n            }\r\n            else\r\n            {\r\n                return ChessMove.EMPTY;\r\n            }\r\n        }\r\n\r\n        public ChessMoveData NextMoveData()\r\n        {\r\n            if (_moveCurrent < _moveCount)\r\n            {\r\n                return _array[_moveCurrent++];\r\n            }\r\n            else\r\n            {\r\n                return new ChessMoveData() { Move = ChessMove.EMPTY };\r\n            }\r\n\r\n        }\r\n\r\n        public void RegisterCutoff(ChessBoard board, ChessMove move)\r\n        {\r\n            if (board.PieceAt(move.To()) == ChessPiece.EMPTY)\r\n            {\r\n                _playerKillers[(int)board.WhosTurn].RegisterKiller(move);\r\n\r\n                if (board.HistoryCount > 0 && board.MovesSinceNull > 0)\r\n                {\r\n                    \/\/register counter move hueristic.\r\n                    ChessMove prevMove = board.HistMove(1);\r\n                    ChessPiece prevPiece = board.PieceAt(prevMove.To());\r\n                    System.Diagnostics.Debug.Assert(prevPiece.PieceToPlayer() == board.WhosTurn.PlayerOther());\r\n                    _counterMoves[(int)prevPiece][(int)prevMove.To()] = move;\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        public void Sort(ChessBoard board, bool useSEE, ChessMove ttMove)\r\n        {\r\n            \/\/useSEE = true;\r\n            var killers = _playerKillers[(int)board.WhosTurn];\r\n\r\n            ChessMove killer1 = killers.move1;\r\n            ChessMove killer2 = killers.move2;\r\n\r\n            \/\/find previous move and last quiet move used to counter it.\r\n            ChessMove counterMove = ChessMove.EMPTY;\r\n            if (board.HistoryCount > 0)\r\n            {\r\n                ChessMove prevMove = board.HistMove(1);\r\n                ChessPiece prevPiece = board.PieceAt(prevMove.To());\r\n                \/\/System.Diagnostics.Debug.Assert(prevPiece.PieceToPlayer() == board.WhosTurn.PlayerOther());\r\n                counterMove = _counterMoves[(int)prevPiece][(int)prevMove.To()];\r\n            }\r\n\r\n\r\n            \/\/first score moves\r\n            for (int i = 0; i < _moveCount; i++)\r\n            {\r\n                ChessMove move = _array[i].Move;\r\n                ChessPiece piece = board.PieceAt(move.From());\r\n                bool isCap = board.PieceAt(move.To()) != ChessPiece.EMPTY;\r\n\r\n                System.Diagnostics.Debug.Assert(move != ChessMove.EMPTY);\r\n\r\n                \/\/calc pcsq value;\r\n                PhasedScore pcSq = 0;\r\n                board.PcSqEvaluator.PcSqValuesRemove(piece, move.From(), ref pcSq);\r\n                board.PcSqEvaluator.PcSqValuesAdd(piece, move.To(), ref pcSq);\r\n                if (board.WhosTurn == ChessPlayer.Black) { pcSq = pcSq.Negate(); }\r\n\r\n                int see = 0;\r\n\r\n                \/\/calc flags\r\n                MoveFlags flags = 0;\r\n                if (move == ttMove) { flags |= MoveFlags.TransTable; }\r\n                if (move.Promote() != ChessPiece.EMPTY) { flags |= MoveFlags.Promote; }\r\n\r\n                if (isCap)\r\n                {\r\n                    flags |= MoveFlags.Capture;\r\n                    see = ChessMoveSEE.CompEstScoreSEE(move, board);\r\n                    \/\/if (see > 0) { flags |= MoveFlags.CapturePositive; }\r\n                    \/\/if (see == 0) { flags |= MoveFlags.CaptureEqual; }\r\n                }\r\n\r\n                \/\/if(piece.ToPieceType() == ChessPieceType.Pawn && (move.To.GetRank() == ChessRank.Rank7 || move.To.GetRank() == ChessRank.Rank2))\r\n                \/\/{\r\n                \/\/    flags |= MoveFlags.Pawn7th;\r\n                \/\/}\r\n\r\n                if (move == counterMove || move == killer1 || move == killer2)\r\n                {\r\n                    flags |= MoveFlags.Killer;\r\n                }\r\n\r\n                \/\/if (killers.IsKiller(move)) { flags |= MoveFlags.Killer; }\r\n\r\n                _array[i].SEE = see;\r\n                _array[i].PcSq = pcSq.Opening();\r\n                _array[i].Flags = flags;\r\n                _array[i].Score = _array[i].ScoreCalc();\r\n\r\n            }\r\n\r\n            \/\/now sort array.\r\n            for (int i = 1; i < _moveCount; i++)\r\n            {\r\n                for (int ii = i; ii > 0; ii--)\r\n                {\r\n                    if (_array[ii].Score > _array[ii - 1].Score)\r\n                    {\r\n                        var tmp = _array[ii];\r\n                        _array[ii] = _array[ii - 1];\r\n                        _array[ii - 1] = tmp;\r\n                    }\r\n                    else\r\n                    {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        public IEnumerable<ChessMove> SortedMoves()\r\n        {\r\n            for (int i = 0; i < _moveCount; i++)\r\n            {\r\n                yield return _array[i].Move;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    public class PlyBuffer2\r\n    {\r\n\r\n        private class KillerInfo\r\n        {\r\n            public ChessMove move1 { get; private set; }\r\n            public ChessMove move2 { get; private set; }\r\n\r\n\r\n            public void RegisterKiller(ChessMove move)\r\n            {\r\n                if (move != move1)\r\n                {\r\n                    move2 = move1;\r\n                    move1 = move;\r\n                }\r\n            }\r\n\r\n\r\n            public bool IsKiller(ChessMove move)\r\n            {\r\n                return move == move1 || move == move2;\r\n            }\r\n\r\n            public ChessMove this[int index]\r\n            {\r\n                get\r\n                {\r\n                    if (index == 0) { return move1; }\r\n                    if (index == 1) { return move2; }\r\n                    throw new ArgumentOutOfRangeException();\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        private enum steps\r\n        {\r\n            ttMove,\r\n            InitCaps,\r\n            GoodCaps,\r\n            Killers,\r\n            BadCaps,\r\n            InitQuiet,\r\n            Quiet,\r\n        }\r\n\r\n        private readonly ChessMoveData[] _array = new ChessMoveData[192];\r\n        \r\n        private readonly KillerInfo[] _playerKillers = new KillerInfo[2];\r\n\r\n        private readonly ChessMove[] _killers = new ChessMove[3];\r\n        private ChessMove _ttMove;\r\n        private ChessBoard _board;\r\n        private long _boardZob;\r\n        private bool _capsOnly;\r\n        private steps _currStep;\r\n        private ChessMoveData _tmpData;\r\n        private int _capsCount;\r\n        private int _capsGoodCount;\r\n        private int _currIndex;\r\n        private int _killerCount;\r\n        private int _quietCount;\r\n\r\n        public PlyBuffer2()\r\n        {\r\n            _playerKillers[0] = new KillerInfo();\r\n            _playerKillers[1] = new KillerInfo();\r\n            \r\n        }\r\n\r\n        public void Initialize(ChessBoard board, ChessMove ttMove, ChessMove lastMove, bool capsOnly = false)\r\n        {\r\n            _board = board;\r\n            _boardZob = board.Zobrist;\r\n            _ttMove = ttMove;\r\n            _capsOnly = capsOnly;\r\n            _currStep = 0;\r\n            _capsCount = 0;\r\n            _capsGoodCount = 0;\r\n            _currIndex = 0;\r\n            _killerCount = 0;\r\n            _quietCount = 0;\r\n            \/\/_moveCount = ChessMoveInfo.GenMovesArray(_array, board, capsOnly);\r\n            \/\/_moveCurrent = 0;\r\n        }\r\n\r\n\r\n        public ChessMoveData NextMoveData()\r\n        {\r\n            System.Diagnostics.Debug.Assert(_board.Zobrist == _boardZob);\r\n            switch (_currStep)\r\n            {\r\n                case steps.ttMove:\r\n                    if (_ttMove != ChessMove.EMPTY)\r\n                    {\r\n                        System.Diagnostics.Debug.Assert(_ttMove.IsPsuedoLegal(_board));\r\n                        _currStep++;\r\n                        _tmpData.Move = _ttMove;\r\n                        _tmpData.Flags = MoveFlags.TransTable;\r\n                        return _tmpData;\r\n                    }\r\n                    else\r\n                    {\r\n                        _currIndex = 0;\r\n                        _currStep++;\r\n                        return NextMoveData();\r\n                    }\r\n\r\n                case steps.InitCaps:\r\n                    _capsCount = ChessMoveInfo.GenCapsNonCaps(_array, _board, true, 0);\r\n                    for (int i = 0; i < _capsCount; i++)\r\n                    {\r\n                        _array[i].SEE = ChessMoveSEE.CompEstScoreSEE(_array[i].Move, _board); \/\/calculate if winning capture.\r\n                        _array[i].Flags = MoveFlags.Capture;\r\n                        if (_array[i].SEE >= 0) { _capsGoodCount++; } \/\/incr good cap count.\r\n                        for (int ii = i; ii > 0; ii--)\r\n                        {\r\n                            if (_array[ii].SEE > _array[ii - 1].SEE)\r\n                            {\r\n                                _tmpData = _array[ii];\r\n                                _array[ii] = _array[ii - 1];\r\n                                _array[ii - 1] = _tmpData;\r\n                            }\r\n                            else\r\n                            {\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    _currIndex = 0;\r\n                    _currStep++;\r\n                    return NextMoveData();\r\n                case steps.GoodCaps:\r\n                    if (_currIndex < _capsGoodCount)\r\n                    {\r\n                        return _array[_currIndex++];\r\n                    }\r\n                    else\r\n                    {\r\n                        _currStep++;\r\n                        _currIndex = 0;\r\n                        return NextMoveData();\r\n                    }\r\n\r\n                case steps.Killers:\r\n                    var killerInfo = _playerKillers[(int)_board.WhosTurn];\r\n                    if (_currIndex < _killerCount)\r\n                    {\r\n                        ChessMove move = killerInfo[_currIndex];\r\n                        if (move.IsPsuedoLegal(_board))\r\n                        {\r\n                            _tmpData.Move = move;\r\n                            _tmpData.Flags = MoveFlags.Killer;\r\n                            _currIndex++;\r\n                            return _tmpData;\r\n                        }\r\n                        else\r\n                        {\r\n                            _currIndex++;\r\n                            return NextMoveData();\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        _currIndex = 0;\r\n                        _currStep++;\r\n                        return NextMoveData();\r\n                    }\r\n                case steps.BadCaps:\r\n                    int badCapIndex = _currIndex + _capsGoodCount;\r\n                    if (badCapIndex < _capsCount)\r\n                    {\r\n                        _currIndex++;\r\n                        return _array[badCapIndex];\r\n                    }\r\n                    else\r\n                    {\r\n                        _currStep++;\r\n                        _currIndex = 0;\r\n                        return NextMoveData();\r\n                    }\r\n                case steps.InitQuiet:\r\n                    _quietCount = ChessMoveInfo.GenCapsNonCaps(_array, _board, false, 0);\r\n                    for (int i = 0; i < _quietCount; i++)\r\n                    {\r\n                        _array[i].SEE = 0;\r\n                        _array[i].Flags = 0;\r\n                        \/\/if (_array[i].SEE >= 0) { _capsGoodCount++; } \/\/incr good cap count.\r\n                        \/\/for (int ii = i; ii > 0; ii--)\r\n                        \/\/{\r\n                        \/\/    if (_array[ii].SEE > _array[ii - 1].SEE)\r\n                        \/\/    {\r\n                        \/\/        _tmpData = _array[ii];\r\n                        \/\/        _array[ii] = _array[ii - 1];\r\n                        \/\/        _array[ii - 1] = _tmpData;\r\n                        \/\/    }\r\n                        \/\/    else\r\n                        \/\/    {\r\n                        \/\/        break;\r\n                        \/\/    }\r\n                        \/\/}\r\n                    }\r\n                    _currIndex = 0;\r\n                    _currStep++;\r\n                    return NextMoveData();\r\n                case steps.Quiet:\r\n                    if (_currIndex < _quietCount)\r\n                    {\r\n                        var m = _array[_currIndex].Move;\r\n\r\n                        if (!_playerKillers[(int)_board.WhosTurn].IsKiller(m))\r\n                        {\r\n                            return _array[_currIndex++];\r\n                        }\r\n                        else\r\n                        {\r\n                            _currIndex++;\r\n                            return NextMoveData();\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        _tmpData.Move = ChessMove.EMPTY;\r\n                        return _tmpData;\r\n                    }\r\n                    break;\r\n                default:\r\n                    System.Diagnostics.Debug.Assert(false);\r\n                    throw new ArgumentOutOfRangeException();\r\n            }\r\n        }\r\n\r\n        public void RegisterCutoff(ChessBoard board, ChessMove move)\r\n        {\r\n            if (board.PieceAt(move.To()) == ChessPiece.EMPTY)\r\n            {\r\n                _playerKillers[(int)board.WhosTurn].RegisterKiller(move);\r\n\r\n                \/\/if (board.HistoryCount > 0 && board.MovesSinceNull > 0)\r\n                \/\/{\r\n                \/\/    \/\/register counter move hueristic.\r\n                \/\/    ChessMove prevMove = board.HistMove(1);\r\n                \/\/    ChessPiece prevPiece = board.PieceAt(prevMove.To());\r\n                \/\/    System.Diagnostics.Debug.Assert(prevPiece.PieceToPlayer() == board.WhosTurn.PlayerOther());\r\n                \/\/    _counterMoves[(int)prevPiece][(int)prevMove.To()] = move;\r\n                \/\/}\r\n\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n\r\n    [System.Diagnostics.DebuggerDisplay(@\"{Move.Description()} SEE:{SEE} PcSq:{PcSq} Flags:{Flags}\")]\r\n    public struct ChessMoveData\r\n    {\r\n        public ChessMove Move;\r\n        public int SEE;\r\n        public int PcSq;\r\n        public MoveFlags Flags;\r\n        public int Score;\r\n\r\n        public int ScoreCalc()\r\n        {\r\n            return SEE + PcSq\r\n                + ((Flags & MoveFlags.TransTable) != 0 ? 1000000 : 0)\r\n                + ((Flags & MoveFlags.Capture) != 0 && SEE >= 0 ? 100000 : 0)\r\n                + ((Flags & MoveFlags.Killer) != 0 ? 10000 : 0)\r\n                + ((Flags & MoveFlags.Capture) != 0 ? 1000 : 0);\r\n        }\r\n\r\n\r\n        \/\/public void SetScores(ChessMove move, int see, int pcSq, MoveFlags flags)\r\n        \/\/{\r\n        \/\/    Move = move;\r\n        \/\/    SEE = see;\r\n        \/\/    PcSq = pcSq;\r\n        \/\/    Flags = flags;\r\n        \/\/}\r\n\r\n        \/\/private const MoveFlags _orderFlags = MoveFlags.TransTable | MoveFlags.Promote | MoveFlags.CapturePositive | MoveFlags.CaptureEqual | MoveFlags.Killer;\r\n    }\r\n\r\n    [Flags]\r\n    public enum MoveFlags\r\n    {\r\n        Killer = (1 << 0),\r\n        Capture = (1 << 1),\r\n        Promote = (1 << 2),\r\n        TransTable = (1 << 3),\r\n    }\r\n}\r\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"d6dab905f89d762417b4da74dc30f6019415d85c","subject":"Added a failing serialization test \"NullableSample2WithNullAttributeTest\" where a null attribute preferably shouldn't be present in the XML.","message":"Added a failing serialization test \"NullableSample2WithNullAttributeTest\" where a null attribute preferably shouldn't be present in the XML.\n","repos":"gingsjo\/YAXLib,gingsjo\/YAXLib,sinairv\/YAXLib","old_file":"YAXLibTests\/SerializationTest.cs","new_file":"YAXLibTests\/SerializationTest.cs","new_contents":"\ufeff\/\/ Copyright 2009 - 2010 Sina Iravanian - <sina@sinairv.com>\r\n\/\/\r\n\/\/ This source file(s) may be redistributed, altered and customized\r\n\/\/ by any means PROVIDING the authors name and all copyright\r\n\/\/ notices remain intact.\r\n\/\/ THIS SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n\/\/ EXPRESS OR IMPLIED. USE IT AT YOUR OWN RISK. THE AUTHOR ACCEPTS NO\r\n\/\/ LIABILITY FOR ANY DATA DAMAGE\/LOSS THAT THIS PRODUCT MAY CAUSE.\r\n\/\/-----------------------------------------------------------------------\r\n\r\nusing System;\r\nusing System.Collections.Generic;\r\n\r\nusing NUnit.Framework;\r\n\r\nusing YAXLib;\r\nusing System.Threading;\r\nusing System.Globalization;\r\nusing YAXLibTests.SampleClasses;\r\n\r\nnamespace YAXLibTests\r\n{\r\n    [TestFixture]\r\n    public class SerializationTest\r\n    {\r\n        [TestFixtureSetUp]\r\n        public void TestFixtureSetUp()\r\n        {\r\n            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;\r\n        }\r\n\r\n        [Test]\r\n        public void BasicTypeSerializationTest()\r\n        {\r\n            var objs = new object[] {123, 654.321, \"SomeString\", 24234L};\r\n            var types = new [] {typeof (int), typeof (double), typeof (string), typeof (long)};\r\n            var serializedResults = new[] { \"<Int32>123<\/Int32>\", \"<Double>654.321<\/Double>\", \"<String>SomeString<\/String>\", \"<Int64>24234<\/Int64>\" };\r\n\r\n            for (int i = 0; i < objs.Length; i++)\r\n            {\r\n                var serializer = new YAXSerializer(objs[i].GetType());\r\n                var got = serializer.Serialize(objs[i]);\r\n                Assert.That(got, Is.EqualTo(serializedResults[i]));\r\n\r\n                var deser = new YAXSerializer(types[i]);\r\n                var obj = deser.Deserialize(got);\r\n                Assert.That(objs[i], Is.EqualTo(obj));\r\n            }\r\n\r\n        }\r\n\r\n        [Test]\r\n        public void BookTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example demonstrates serailizing a very simple class -->\r\n<Book>\r\n  <Title>Inside C#<\/Title>\r\n  <Author>Tom Archer &amp; Andrew Whitechapel<\/Author>\r\n  <PublishYear>2002<\/PublishYear>\r\n  <Price>30.5<\/Price>\r\n<\/Book>\";\r\n            var serializer = new YAXSerializer(typeof(Book), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(Book.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void ThreadingTest()\r\n        {\r\n            try\r\n            {\r\n                for (int i = 0; i < 100; i++)\r\n                {\r\n                    var th = new Thread(() =>\r\n                        {\r\n                            var serializer = new YAXSerializer(typeof(Book), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n                            string got = serializer.Serialize(Book.GetSampleInstance());\r\n                            var deserializer = new YAXSerializer(typeof(Book), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n                            var book = deserializer.Deserialize(got) as Book;\r\n                            Assert.That(book, Is.Not.Null);\r\n                        }\r\n                    );\r\n\r\n                    th.Start();\r\n                }\r\n            }\r\n            catch\r\n            {\r\n                Assert.Fail(\"Exception fired in threading method\");\r\n            }\r\n\r\n        }\r\n\r\n        [Test]\r\n        public void BookWithDecimalPriceTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example demonstrates serailizing a very simple class -->\r\n<SimpleBookClassWithDecimalPrice>\r\n  <Title>Inside C#<\/Title>\r\n  <Author>Tom Archer &amp; Andrew Whitechapel<\/Author>\r\n  <PublishYear>2002<\/PublishYear>\r\n  <Price>32.20<\/Price>\r\n<\/SimpleBookClassWithDecimalPrice>\";\r\n            var serializer = new YAXSerializer(typeof(SimpleBookClassWithDecimalPrice), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(SimpleBookClassWithDecimalPrice.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void CultureChangeTest()\r\n        {\r\n            var curCulture = CultureInfo.CurrentCulture;\r\n\r\n            Thread.CurrentThread.CurrentCulture = CultureInfo.GetCultureInfo(\"fr-FR\");\r\n            var serializer = new YAXSerializer(typeof(CultureSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string frResult = serializer.Serialize(CultureSample.GetSampleInstance());\r\n\r\n            Thread.CurrentThread.CurrentCulture = CultureInfo.GetCultureInfo(\"fa-IR\");\r\n            serializer = new YAXSerializer(typeof(CultureSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string faResult = serializer.Serialize(CultureSample.GetSampleInstance());\r\n\r\n            Thread.CurrentThread.CurrentCulture = CultureInfo.GetCultureInfo(\"de-DE\");\r\n            serializer = new YAXSerializer(typeof(CultureSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string deResult = serializer.Serialize(CultureSample.GetSampleInstance());\r\n\r\n            Thread.CurrentThread.CurrentCulture = CultureInfo.GetCultureInfo(\"en-US\");\r\n            serializer = new YAXSerializer(typeof(CultureSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string usResult = serializer.Serialize(CultureSample.GetSampleInstance());\r\n\r\n            Thread.CurrentThread.CurrentCulture = curCulture;\r\n\r\n            Assert.That(faResult, Is.EqualTo(frResult), \"Comparing FR and FA\");\r\n            Assert.That(deResult, Is.EqualTo(faResult), \"Comparing FA and DE\");\r\n            Assert.That(usResult, Is.EqualTo(deResult), \"Comparing DE and US\");\r\n\r\n            const string expected =\r\n@\"<!-- This class contains fields that are vulnerable to culture changes! -->\r\n<CultureSample Number2=\"\"32243.67676\"\" Dec2=\"\"19232389.18391912318232131\"\" Date2=\"\"09\/20\/2011 04:10:30\"\">\r\n  <Number1>123123.1233<\/Number1>\r\n  <Number3>21313.123123<\/Number3>\r\n  <Numbers>\r\n    <Double>23213.2132<\/Double>\r\n    <Double>123.213<\/Double>\r\n    <Double>1.2323E+34<\/Double>\r\n  <\/Numbers>\r\n  <Dec1>192389183919123.18232131<\/Dec1>\r\n  <Date1>10\/11\/2010 18:20:30<\/Date1>\r\n<\/CultureSample>\";\r\n\r\n            Assert.That(expected, Is.EqualTo(usResult), \"Checking US is as expected!\");\r\n        }\r\n\r\n        [Test]\r\n        public void BookStructTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example demonstrates serailizing a very simple struct -->\r\n<BookStruct>\r\n  <Title>Reinforcement Learning an Introduction<\/Title>\r\n  <Author>R. S. Sutton &amp; A. G. Barto<\/Author>\r\n  <PublishYear>1998<\/PublishYear>\r\n  <Price>38.75<\/Price>\r\n<\/BookStruct>\";\r\n            var serializer = new YAXSerializer(typeof(BookStruct), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(BookStruct.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void WarehouseSimpleTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example is our basic hypothetical warehouse -->\r\n<WarehouseSimple>\r\n  <Name>Foo Warehousing Ltd.<\/Name>\r\n  <Address>No. 10, Some Ave., Some City, Some Country<\/Address>\r\n  <Area>120000.5<\/Area>\r\n<\/WarehouseSimple>\";\r\n            var serializer = new YAXSerializer(typeof(WarehouseSimple), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(WarehouseSimple.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void WarehouseStructuredTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example shows our hypothetical warehouse, a little bit structured -->\r\n<WarehouseStructured Name=\"\"Foo Warehousing Ltd.\"\">\r\n  <SiteInfo address=\"\"No. 10, Some Ave., Some City, Some Country\"\">\r\n    <SurfaceArea>120000.5<\/SurfaceArea>\r\n  <\/SiteInfo>\r\n<\/WarehouseStructured>\";\r\n            var serializer = new YAXSerializer(typeof(WarehouseStructured), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(WarehouseStructured.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void WarehouseWithArrayTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example shows the serialization of arrays -->\r\n<WarehouseWithArray Name=\"\"Foo Warehousing Ltd.\"\">\r\n  <SiteInfo address=\"\"No. 10, Some Ave., Some City, Some Country\"\">\r\n    <SurfaceArea>120000.5<\/SurfaceArea>\r\n  <\/SiteInfo>\r\n  <StoreableItems>Item3, Item6, Item9, Item12<\/StoreableItems>\r\n<\/WarehouseWithArray>\";\r\n            var serializer = new YAXSerializer(typeof(WarehouseWithArray), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(WarehouseWithArray.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void WarehouseWithDictionaryTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example shows the serialization of Dictionary -->\r\n<WarehouseWithDictionary Name=\"\"Foo Warehousing Ltd.\"\">\r\n  <SiteInfo address=\"\"No. 10, Some Ave., Some City, Some Country\"\">\r\n    <SurfaceArea>120000.5<\/SurfaceArea>\r\n  <\/SiteInfo>\r\n  <StoreableItems>Item3, Item6, Item9, Item12<\/StoreableItems>\r\n  <ItemQuantities>\r\n    <ItemInfo Item=\"\"Item3\"\" Count=\"\"10\"\" \/>\r\n    <ItemInfo Item=\"\"Item6\"\" Count=\"\"120\"\" \/>\r\n    <ItemInfo Item=\"\"Item9\"\" Count=\"\"600\"\" \/>\r\n    <ItemInfo Item=\"\"Item12\"\" Count=\"\"25\"\" \/>\r\n  <\/ItemQuantities>\r\n<\/WarehouseWithDictionary>\";\r\n            var serializer = new YAXSerializer(typeof(WarehouseWithDictionary), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(WarehouseWithDictionary.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void WarehouseNestedObjectTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example demonstrates serializing nested objects -->\r\n<WarehouseNestedObjectExample Name=\"\"Foo Warehousing Ltd.\"\">\r\n  <SiteInfo address=\"\"No. 10, Some Ave., Some City, Some Country\"\">\r\n    <SurfaceArea>120000.5<\/SurfaceArea>\r\n  <\/SiteInfo>\r\n  <StoreableItems>Item3, Item6, Item9, Item12<\/StoreableItems>\r\n  <ItemQuantities>\r\n    <ItemInfo Item=\"\"Item3\"\" Count=\"\"10\"\" \/>\r\n    <ItemInfo Item=\"\"Item6\"\" Count=\"\"120\"\" \/>\r\n    <ItemInfo Item=\"\"Item9\"\" Count=\"\"600\"\" \/>\r\n    <ItemInfo Item=\"\"Item12\"\" Count=\"\"25\"\" \/>\r\n  <\/ItemQuantities>\r\n  <Owner SSN=\"\"123456789\"\">\r\n    <Identification Name=\"\"John\"\" Family=\"\"Doe\"\" \/>\r\n    <Age>50<\/Age>\r\n  <\/Owner>\r\n<\/WarehouseNestedObjectExample>\";\r\n            var serializer = new YAXSerializer(typeof(WarehouseNestedObjectExample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(WarehouseNestedObjectExample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void ProgrammingLanguageTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example is used in the article to show YAXLib exception handling policies -->\r\n<ProgrammingLanguage>\r\n  <LanguageName>C#<\/LanguageName>\r\n  <IsCaseSensitive>True<\/IsCaseSensitive>\r\n<\/ProgrammingLanguage>\";\r\n            var serializer = new YAXSerializer(typeof(ProgrammingLanguage), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(ProgrammingLanguage.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void ColorExampleTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example shows a technique for serializing classes without a default constructor -->\r\n<ColorExample>\r\n  <TheColor>#FF0000FF<\/TheColor>\r\n<\/ColorExample>\";\r\n            var serializer = new YAXSerializer(typeof(ColorExample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(ColorExample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void MultiLevelClassTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example shows a multi-level class, which helps to test -->\r\n<!-- the null references identity problem. -->\r\n<!-- Thanks go to Anton Levshunov for proposing this example, -->\r\n<!-- and a disussion on this matter. -->\r\n<MultilevelClass>\r\n  <items>\r\n    <FirstLevelClass>\r\n      <ID>1<\/ID>\r\n      <Second>\r\n        <SecondID>1-2<\/SecondID>\r\n      <\/Second>\r\n    <\/FirstLevelClass>\r\n    <FirstLevelClass>\r\n      <ID>2<\/ID>\r\n      <Second \/>\r\n    <\/FirstLevelClass>\r\n  <\/items>\r\n<\/MultilevelClass>\";\r\n            var serializer = new YAXSerializer(typeof(MultilevelClass), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(MultilevelClass.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void FormattingTest()\r\n        {\r\n            string result =\r\n@\"<!-- This example shows how to apply format strings to a class properties -->\r\n<FormattingExample>\r\n  <CreationDate>{0}<\/CreationDate>\r\n  <ModificationDate>{1}<\/ModificationDate>\r\n  <PI>3.14159<\/PI>\r\n  <NaturalExp>\r\n    <Double>2.718<\/Double>\r\n    <Double>7.389<\/Double>\r\n    <Double>20.086<\/Double>\r\n    <Double>54.598<\/Double>\r\n  <\/NaturalExp>\r\n  <SomeLogarithmExample>\r\n    <KeyValuePairOfDoubleDouble>\r\n      <Key>1.50<\/Key>\r\n      <Value>0.40547<\/Value>\r\n    <\/KeyValuePairOfDoubleDouble>\r\n    <KeyValuePairOfDoubleDouble>\r\n      <Key>3.00<\/Key>\r\n      <Value>1.09861<\/Value>\r\n    <\/KeyValuePairOfDoubleDouble>\r\n    <KeyValuePairOfDoubleDouble>\r\n      <Key>6.00<\/Key>\r\n      <Value>1.79176<\/Value>\r\n    <\/KeyValuePairOfDoubleDouble>\r\n  <\/SomeLogarithmExample>\r\n<\/FormattingExample>\";\r\n\r\n            result = String.Format(result,\r\n                FormattingExample.GetSampleInstance().CreationDate.ToLongDateString(),\r\n                FormattingExample.GetSampleInstance().ModificationDate.ToShortDateString()\r\n                );\r\n\r\n            var serializer = new YAXSerializer(typeof(FormattingExample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(FormattingExample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void PathsExampleTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example demonstrates how not to use -->\r\n<!-- white spaces as separators while serializing -->\r\n<!-- collection classes serially -->\r\n<PathsExample>\r\n  <Paths>C:\\SomeFile.txt;C:\\SomeFolder\\SomeFile.txt;C:\\Some Folder With Space Such As\\Program Files<\/Paths>\r\n<\/PathsExample>\";\r\n            var serializer = new YAXSerializer(typeof(PathsExample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(PathsExample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void MoreComplexExampleTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example tries to show almost all features of YAXLib which were not shown before. -->\r\n<!-- FamousPoints - shows a dictionary with a non-primitive value member. -->\r\n<!-- IntEnumerable - shows serializing properties of type IEnumerable<> -->\r\n<!-- Students - shows the usage of YAXNotCollection attribute -->\r\n<MoreComplexExample xmlns:yaxlib=\"\"http:\/\/www.sinairv.com\/yaxlib\/\"\">\r\n  <FamousPoints>\r\n    <PointInfo PName=\"\"Center\"\">\r\n      <ThePoint X=\"\"0\"\" Y=\"\"0\"\" \/>\r\n    <\/PointInfo>\r\n    <PointInfo PName=\"\"Q1\"\">\r\n      <ThePoint X=\"\"1\"\" Y=\"\"1\"\" \/>\r\n    <\/PointInfo>\r\n    <PointInfo PName=\"\"Q2\"\">\r\n      <ThePoint X=\"\"-1\"\" Y=\"\"1\"\" \/>\r\n    <\/PointInfo>\r\n  <\/FamousPoints>\r\n  <IntEnumerable yaxlib:realtype=\"\"System.Collections.Generic.List`1[[System.Int32, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]\"\">\r\n    <Int32>1<\/Int32>\r\n    <Int32>3<\/Int32>\r\n    <Int32>5<\/Int32>\r\n    <Int32>7<\/Int32>\r\n  <\/IntEnumerable>\r\n  <Students>\r\n    <Count>3<\/Count>\r\n    <Names>\r\n      <String>Ali<\/String>\r\n      <String>Dave<\/String>\r\n      <String>John<\/String>\r\n    <\/Names>\r\n    <Families>\r\n      <String>Alavi<\/String>\r\n      <String>Black<\/String>\r\n      <String>Doe<\/String>\r\n    <\/Families>\r\n  <\/Students>\r\n<\/MoreComplexExample>\";\r\n            var serializer = new YAXSerializer(typeof(MoreComplexExample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(MoreComplexExample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void NestedDicSampleTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example demonstrates usage of recursive collection serialization -->\r\n<!-- and deserialization. In this case a Dictionary whose Key, or Value is -->\r\n<!-- another dictionary or collection has been used. -->\r\n<NestedDicSample>\r\n  <SomeDic>\r\n    <KeyValuePairOfDictionaryOfDoubleDictionaryOfInt32Int32DictionaryOfDictionaryOfStringStringListOfDouble>\r\n      <Key>\r\n        <KeyValuePairOfDoubleDictionaryOfInt32Int32>\r\n          <Key>0.99999<\/Key>\r\n          <Value>\r\n            <KeyValuePairOfInt32Int32>\r\n              <Key>1<\/Key>\r\n              <Value>1<\/Value>\r\n            <\/KeyValuePairOfInt32Int32>\r\n            <KeyValuePairOfInt32Int32>\r\n              <Key>2<\/Key>\r\n              <Value>2<\/Value>\r\n            <\/KeyValuePairOfInt32Int32>\r\n            <KeyValuePairOfInt32Int32>\r\n              <Key>3<\/Key>\r\n              <Value>3<\/Value>\r\n            <\/KeyValuePairOfInt32Int32>\r\n            <KeyValuePairOfInt32Int32>\r\n              <Key>4<\/Key>\r\n              <Value>4<\/Value>\r\n            <\/KeyValuePairOfInt32Int32>\r\n          <\/Value>\r\n        <\/KeyValuePairOfDoubleDictionaryOfInt32Int32>\r\n        <KeyValuePairOfDoubleDictionaryOfInt32Int32>\r\n          <Key>3.14<\/Key>\r\n          <Value>\r\n            <KeyValuePairOfInt32Int32>\r\n              <Key>9<\/Key>\r\n              <Value>1<\/Value>\r\n            <\/KeyValuePairOfInt32Int32>\r\n            <KeyValuePairOfInt32Int32>\r\n              <Key>8<\/Key>\r\n              <Value>2<\/Value>\r\n            <\/KeyValuePairOfInt32Int32>\r\n          <\/Value>\r\n        <\/KeyValuePairOfDoubleDictionaryOfInt32Int32>\r\n      <\/Key>\r\n      <Value>\r\n        <KeyValuePairOfDictionaryOfStringStringListOfDouble>\r\n          <Key>\r\n            <KeyValuePairOfStringString>\r\n              <Key>Test<\/Key>\r\n              <Value>123<\/Value>\r\n            <\/KeyValuePairOfStringString>\r\n            <KeyValuePairOfStringString>\r\n              <Key>Test2<\/Key>\r\n              <Value>456<\/Value>\r\n            <\/KeyValuePairOfStringString>\r\n          <\/Key>\r\n          <Value>\r\n            <Double>0.98767<\/Double>\r\n            <Double>232<\/Double>\r\n            <Double>13.124<\/Double>\r\n          <\/Value>\r\n        <\/KeyValuePairOfDictionaryOfStringStringListOfDouble>\r\n        <KeyValuePairOfDictionaryOfStringStringListOfDouble>\r\n          <Key>\r\n            <KeyValuePairOfStringString>\r\n              <Key>Num1<\/Key>\r\n              <Value>123<\/Value>\r\n            <\/KeyValuePairOfStringString>\r\n            <KeyValuePairOfStringString>\r\n              <Key>Num2<\/Key>\r\n              <Value>456<\/Value>\r\n            <\/KeyValuePairOfStringString>\r\n          <\/Key>\r\n          <Value>\r\n            <Double>9.8767<\/Double>\r\n            <Double>23.2<\/Double>\r\n            <Double>1.34<\/Double>\r\n          <\/Value>\r\n        <\/KeyValuePairOfDictionaryOfStringStringListOfDouble>\r\n      <\/Value>\r\n    <\/KeyValuePairOfDictionaryOfDoubleDictionaryOfInt32Int32DictionaryOfDictionaryOfStringStringListOfDouble>\r\n  <\/SomeDic>\r\n<\/NestedDicSample>\";\r\n            var serializer = new YAXSerializer(typeof(NestedDicSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(NestedDicSample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void GuidDemoTest()\r\n        {\r\n            Guid g1 = Guid.NewGuid();\r\n            Guid g2 = Guid.NewGuid();\r\n            Guid g3 = Guid.NewGuid();\r\n            Guid g4 = Guid.NewGuid();\r\n\r\n            string result = String.Format(\r\n@\"<!-- This example shows serialization and deserialization of GUID obejcts -->\r\n<GUIDTest>\r\n  <StandaloneGuid>{3}<\/StandaloneGuid>\r\n  <SomeDic>\r\n    <KeyValuePairOfGuidInt32>\r\n      <Key>{0}<\/Key>\r\n      <Value>1<\/Value>\r\n    <\/KeyValuePairOfGuidInt32>\r\n    <KeyValuePairOfGuidInt32>\r\n      <Key>{1}<\/Key>\r\n      <Value>2<\/Value>\r\n    <\/KeyValuePairOfGuidInt32>\r\n    <KeyValuePairOfGuidInt32>\r\n      <Key>{2}<\/Key>\r\n      <Value>3<\/Value>\r\n    <\/KeyValuePairOfGuidInt32>\r\n  <\/SomeDic>\r\n<\/GUIDTest>\", g1.ToString(), g2.ToString(), g3.ToString(), g4.ToString());\r\n            var serializer = new YAXSerializer(typeof(GUIDTest), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(GUIDTest.GetSampleInstance(g1,g2,g3,g4));\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void NullableTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This exmaple shows the usage of nullable fields -->\r\n<NullableClass>\r\n  <Title>Inside C#<\/Title>\r\n  <PublishYear>2002<\/PublishYear>\r\n  <PurchaseYear \/>\r\n<\/NullableClass>\";\r\n            var serializer = new YAXSerializer(typeof(NullableClass), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(NullableClass.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void NullableSample2Test()\r\n        {\r\n            const string result =\r\n@\"<NullableSample2 Number=\"\"10\"\">\r\n  <DateTime>1980-04-11T13:37:01.2345678Z<\/DateTime>\r\n  <Decimal>1234.56789<\/Decimal>\r\n  <Boolean>True<\/Boolean>\r\n  <Enum>Third<\/Enum>\r\n<\/NullableSample2>\";\r\n            var serializer = new YAXSerializer(typeof(NullableSample2), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(NullableSample2.GetSampleInstance());\r\n\r\n            Console.WriteLine(got);\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void NullableSample2WithNullAttributeTest()\r\n        {\r\n            const string result =\r\n@\"<NullableSample2>\r\n  <DateTime>1980-04-11T13:37:01.2345678Z<\/DateTime>\r\n  <Decimal>1234.56789<\/Decimal>\r\n  <Boolean>True<\/Boolean>\r\n  <Enum>Third<\/Enum>\r\n<\/NullableSample2>\";\r\n            var serializer = new YAXSerializer(typeof(NullableSample2), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            NullableSample2 sample = NullableSample2.GetSampleInstance();\r\n            sample.Number = null;\r\n            string got = serializer.Serialize(sample);\r\n\r\n            Console.WriteLine(got);\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void ListHolderClassTest()\r\n        {\r\n            const string result =\r\n@\"<ListHolderClass>\r\n  <ListOfStrings>\r\n    <String>Hi<\/String>\r\n    <String>Hello<\/String>\r\n  <\/ListOfStrings>\r\n<\/ListHolderClass>\";\r\n            var serializer = new YAXSerializer(typeof(ListHolderClass), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(ListHolderClass.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void StandaloneListTest()\r\n        {\r\n            const string result =\r\n@\"<ListOfString>\r\n  <String>Hi<\/String>\r\n  <String>Hello<\/String>\r\n<\/ListOfString>\";\r\n            var serializer = new YAXSerializer(ListHolderClass.GetSampleInstance().ListOfStrings.GetType(), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(ListHolderClass.GetSampleInstance().ListOfStrings);\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void NamesExampleTest()\r\n        {\r\n            const string result =\r\n@\"<NamesExample>\r\n  <FirstName>Li<\/FirstName>\r\n  <Persons>\r\n    <PersonInfo>\r\n      <FirstName>Li<\/FirstName>\r\n      <LastName \/>\r\n    <\/PersonInfo>\r\n    <PersonInfo>\r\n      <FirstName>Hu<\/FirstName>\r\n      <LastName>Hu<\/LastName>\r\n    <\/PersonInfo>\r\n  <\/Persons>\r\n<\/NamesExample>\";\r\n            var serializer = new YAXSerializer(typeof(NamesExample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(NamesExample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void RequestTest()\r\n        {\r\n            const string result =\r\n@\"<Pricing id=\"\"123\"\">\r\n  <version major=\"\"1\"\" minor=\"\"0\"\" \/>\r\n  <input>\r\n    <value_date>2010-10-5<\/value_date>\r\n    <storage_date>2010-10-5<\/storage_date>\r\n    <user>me<\/user>\r\n    <skylab_config>\r\n      <SomeString>someconf<\/SomeString>\r\n      <job>test<\/job>\r\n    <\/skylab_config>\r\n  <\/input>\r\n<\/Pricing>\";\r\n            var serializer = new YAXSerializer(typeof(Request), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(Request.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void AudioSampleTest()\r\n        {\r\n            const string result =\r\n@\"<AudioSample>\r\n  <Audio FileName=\"\"filesname.jpg\"\">base64<\/Audio>\r\n  <Image FileName=\"\"filesname.jpg\"\">base64<\/Image>\r\n<\/AudioSample>\";\r\n            var serializer = new YAXSerializer(typeof(AudioSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(AudioSample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void TimeSpanTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example shows serialization and deserialization of TimeSpan obejcts -->\r\n<TimeSpanSample>\r\n  <TheTimeSpan>2.03:45:02.3000000<\/TheTimeSpan>\r\n  <AnotherTimeSpan>2.03:45:02.3000000<\/AnotherTimeSpan>\r\n  <DicTimeSpans>\r\n    <KeyValuePairOfTimeSpanInt32>\r\n      <Key>2.03:45:02.3000000<\/Key>\r\n      <Value>1<\/Value>\r\n    <\/KeyValuePairOfTimeSpanInt32>\r\n    <KeyValuePairOfTimeSpanInt32>\r\n      <Key>3.01:40:01.2000000<\/Key>\r\n      <Value>2<\/Value>\r\n    <\/KeyValuePairOfTimeSpanInt32>\r\n  <\/DicTimeSpans>\r\n<\/TimeSpanSample>\";\r\n            var serializer = new YAXSerializer(typeof(TimeSpanSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(TimeSpanSample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n\r\n        [Test]\r\n        public void FieldSerializationSampleTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example shows how to choose the fields to be serialized -->\r\n<FieldSerializationExample>\r\n  <SomePrivateStringProperty>Hi<\/SomePrivateStringProperty>\r\n  <m_someInt>8<\/m_someInt>\r\n  <m_someDouble>3.14<\/m_someDouble>\r\n<\/FieldSerializationExample>\";\r\n            var serializer = new YAXSerializer(typeof(FieldSerializationExample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(FieldSerializationExample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void MoreComplexBookTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example shows how to provide serialization address -->\r\n<!-- for elements and attributes. Theses addresses resemble those used -->\r\n<!-- in known file-systems -->\r\n<MoreComplexBook>\r\n  <SomeTag>\r\n    <SomeOtherTag>\r\n      <AndSo Title=\"\"Inside C#\"\">\r\n        <Author>Tom Archer &amp; Andrew Whitechapel<\/Author>\r\n      <\/AndSo>\r\n    <\/SomeOtherTag>\r\n  <\/SomeTag>\r\n  <PublishYear>2002<\/PublishYear>\r\n  <Price>30.5<\/Price>\r\n<\/MoreComplexBook>\";\r\n            var serializer = new YAXSerializer(typeof(MoreComplexBook), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(MoreComplexBook.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void MoreComplexBookTwoTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This class shows how members of nested objects -->\r\n<!-- can be serialized in their parents using serialization -->\r\n<!-- addresses including \"\"..\"\" -->\r\n<MoreComplexBook2 Author_s_Name=\"\"Tom Archer\"\">\r\n  <Title>Inside C#<\/Title>\r\n  <Something>\r\n    <Or>\r\n      <Another>\r\n        <Author_s_Age>30<\/Author_s_Age>\r\n      <\/Another>\r\n    <\/Or>\r\n  <\/Something>\r\n  <PublishYear>2002<\/PublishYear>\r\n  <Price>30.5<\/Price>\r\n<\/MoreComplexBook2>\";\r\n            var serializer = new YAXSerializer(typeof(MoreComplexBook2), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(MoreComplexBook2.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void MoreComplexBookThreeTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example shows how to serialize collection objects while -->\r\n<!-- not serializing the element for their enclosing collection itself -->\r\n<MoreComplexBook3>\r\n  <Title>Inside C#<\/Title>\r\n  <!-- Comment for author -->\r\n  <PublishYear AuthorName=\"\"Tom Archer\"\">2002<\/PublishYear>\r\n  <AuthorAge>30<\/AuthorAge>\r\n  <Price>30.5<\/Price>\r\n  <Editor>Mark Twain<\/Editor>\r\n  <Editor>Timothy Jones<\/Editor>\r\n  <Editor>Oliver Twist<\/Editor>\r\n<\/MoreComplexBook3>\";\r\n            var serializer = new YAXSerializer(typeof(MoreComplexBook3), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(MoreComplexBook3.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void WarehouseWithDictionaryNoContainerTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example shows how dictionary objects can be serialized without -->\r\n<!-- their enclosing element -->\r\n<WarehouseWithDictionaryNoContainer Name=\"\"Foo Warehousing Ltd.\"\">\r\n  <SiteInfo address=\"\"No. 10, Some Ave., Some City, Some Country\"\">\r\n    <SurfaceArea>120000.5<\/SurfaceArea>\r\n  <\/SiteInfo>\r\n  <StoreableItems>Item3, Item6, Item9, Item12<\/StoreableItems>\r\n  <ItemInfo Item=\"\"Item3\"\" Count=\"\"10\"\" \/>\r\n  <ItemInfo Item=\"\"Item6\"\" Count=\"\"120\"\" \/>\r\n  <ItemInfo Item=\"\"Item9\"\" Count=\"\"600\"\" \/>\r\n  <ItemInfo Item=\"\"Item12\"\" Count=\"\"25\"\" \/>\r\n<\/WarehouseWithDictionaryNoContainer>\";\r\n            var serializer = new YAXSerializer(typeof(WarehouseWithDictionaryNoContainer), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(WarehouseWithDictionaryNoContainer.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void WarehouseWithCommentsTest()\r\n        {\r\n            const string result =\r\n@\"<WarehouseWithComments>\r\n  <foo>\r\n    <bar>\r\n      <one>\r\n        <two>\r\n          <!-- Comment for name -->\r\n          <Name>Foo Warehousing Ltd.<\/Name>\r\n        <\/two>\r\n        <!-- Comment for OwnerName -->\r\n        <OwnerName>John Doe<\/OwnerName>\r\n      <\/one>\r\n    <\/bar>\r\n  <\/foo>\r\n  <SiteInfo address=\"\"No. 10, Some Ave., Some City, Some Country\"\">\r\n    <SurfaceArea>120000.5<\/SurfaceArea>\r\n  <\/SiteInfo>\r\n  <StoreableItems>Item3, Item6, Item9, Item12<\/StoreableItems>\r\n  <!-- This dictionary is serilaized without container -->\r\n  <ItemInfo Item=\"\"Item3\"\" Count=\"\"10\"\" \/>\r\n  <ItemInfo Item=\"\"Item6\"\" Count=\"\"120\"\" \/>\r\n  <ItemInfo Item=\"\"Item9\"\" Count=\"\"600\"\" \/>\r\n  <ItemInfo Item=\"\"Item12\"\" Count=\"\"25\"\" \/>\r\n<\/WarehouseWithComments>\";\r\n            var serializer = new YAXSerializer(typeof(WarehouseWithComments), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(WarehouseWithComments.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void EnumsSampleTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example shows how to define aliases for enum members -->\r\n<EnumsSample OneInstance=\"\"Spring, Summer\"\">\r\n  <TheSeasonSerially>Spring;Summer;Autumn or fall;Winter<\/TheSeasonSerially>\r\n  <TheSeasonRecursive>\r\n    <Seasons>Spring<\/Seasons>\r\n    <Seasons>Summer<\/Seasons>\r\n    <Seasons>Autumn or fall<\/Seasons>\r\n    <Seasons>Winter<\/Seasons>\r\n  <\/TheSeasonRecursive>\r\n  <DicSeasonToInt>\r\n    <KeyValuePairOfSeasonsInt32>\r\n      <Key>Spring<\/Key>\r\n      <Value>1<\/Value>\r\n    <\/KeyValuePairOfSeasonsInt32>\r\n    <KeyValuePairOfSeasonsInt32>\r\n      <Key>Summer<\/Key>\r\n      <Value>2<\/Value>\r\n    <\/KeyValuePairOfSeasonsInt32>\r\n    <KeyValuePairOfSeasonsInt32>\r\n      <Key>Autumn or fall<\/Key>\r\n      <Value>3<\/Value>\r\n    <\/KeyValuePairOfSeasonsInt32>\r\n    <KeyValuePairOfSeasonsInt32>\r\n      <Key>Winter<\/Key>\r\n      <Value>4<\/Value>\r\n    <\/KeyValuePairOfSeasonsInt32>\r\n  <\/DicSeasonToInt>\r\n  <DicIntToSeason>\r\n    <KeyValuePairOfInt32Seasons>\r\n      <Key>1<\/Key>\r\n      <Value>Spring<\/Value>\r\n    <\/KeyValuePairOfInt32Seasons>\r\n    <KeyValuePairOfInt32Seasons>\r\n      <Key>2<\/Key>\r\n      <Value>Spring, Summer<\/Value>\r\n    <\/KeyValuePairOfInt32Seasons>\r\n    <KeyValuePairOfInt32Seasons>\r\n      <Key>3<\/Key>\r\n      <Value>Autumn or fall<\/Value>\r\n    <\/KeyValuePairOfInt32Seasons>\r\n    <KeyValuePairOfInt32Seasons>\r\n      <Key>4<\/Key>\r\n      <Value>Winter<\/Value>\r\n    <\/KeyValuePairOfInt32Seasons>\r\n  <\/DicIntToSeason>\r\n<\/EnumsSample>\";\r\n            var serializer = new YAXSerializer(typeof(EnumsSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(EnumsSample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void MultiDimArraySampleTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example shows serialization of multi-dimensional, -->\r\n<!-- and jagged arrays -->\r\n<MultiDimArraySample xmlns:yaxlib=\"\"http:\/\/www.sinairv.com\/yaxlib\/\"\">\r\n  <IntArray yaxlib:dims=\"\"2,3\"\">\r\n    <Int32>1<\/Int32>\r\n    <Int32>2<\/Int32>\r\n    <Int32>3<\/Int32>\r\n    <Int32>2<\/Int32>\r\n    <Int32>3<\/Int32>\r\n    <Int32>4<\/Int32>\r\n  <\/IntArray>\r\n  <DoubleArray yaxlib:dims=\"\"2,3,3\"\">\r\n    <Double>2<\/Double>\r\n    <Double>0.666666666666667<\/Double>\r\n    <Double>0.4<\/Double>\r\n    <Double>2<\/Double>\r\n    <Double>0.666666666666667<\/Double>\r\n    <Double>0.4<\/Double>\r\n    <Double>2<\/Double>\r\n    <Double>0.666666666666667<\/Double>\r\n    <Double>0.4<\/Double>\r\n    <Double>2<\/Double>\r\n    <Double>0.666666666666667<\/Double>\r\n    <Double>0.4<\/Double>\r\n    <Double>4<\/Double>\r\n    <Double>1.33333333333333<\/Double>\r\n    <Double>0.8<\/Double>\r\n    <Double>6<\/Double>\r\n    <Double>2<\/Double>\r\n    <Double>1.2<\/Double>\r\n  <\/DoubleArray>\r\n  <JaggedArray>\r\n    <Array1OfInt32>\r\n      <Int32>1<\/Int32>\r\n      <Int32>2<\/Int32>\r\n    <\/Array1OfInt32>\r\n    <Array1OfInt32>\r\n      <Int32>1<\/Int32>\r\n      <Int32>2<\/Int32>\r\n      <Int32>3<\/Int32>\r\n      <Int32>4<\/Int32>\r\n    <\/Array1OfInt32>\r\n    <Array1OfInt32>\r\n      <Int32>1<\/Int32>\r\n      <Int32>2<\/Int32>\r\n      <Int32>3<\/Int32>\r\n      <Int32>4<\/Int32>\r\n      <Int32>5<\/Int32>\r\n      <Int32>6<\/Int32>\r\n    <\/Array1OfInt32>\r\n  <\/JaggedArray>\r\n  <!-- The containing element should not disappear because of the dims attribute -->\r\n  <IntArrayNoContainingElems yaxlib:dims=\"\"2,3\"\">\r\n    <Int32>1<\/Int32>\r\n    <Int32>2<\/Int32>\r\n    <Int32>3<\/Int32>\r\n    <Int32>2<\/Int32>\r\n    <Int32>3<\/Int32>\r\n    <Int32>4<\/Int32>\r\n  <\/IntArrayNoContainingElems>\r\n  <!-- This element should not be serialized serially because each element is not of basic type -->\r\n  <JaggedNotSerially>\r\n    <Array1OfInt32>\r\n      <Int32>1<\/Int32>\r\n      <Int32>2<\/Int32>\r\n    <\/Array1OfInt32>\r\n    <Array1OfInt32>\r\n      <Int32>1<\/Int32>\r\n      <Int32>2<\/Int32>\r\n      <Int32>3<\/Int32>\r\n      <Int32>4<\/Int32>\r\n    <\/Array1OfInt32>\r\n    <Array1OfInt32>\r\n      <Int32>1<\/Int32>\r\n      <Int32>2<\/Int32>\r\n      <Int32>3<\/Int32>\r\n      <Int32>4<\/Int32>\r\n      <Int32>5<\/Int32>\r\n      <Int32>6<\/Int32>\r\n    <\/Array1OfInt32>\r\n  <\/JaggedNotSerially>\r\n<\/MultiDimArraySample>\";\r\n            var serializer = new YAXSerializer(typeof(MultiDimArraySample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(MultiDimArraySample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void AnotherArraySampleTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example shows usage of jagged multi-dimensional arrays -->\r\n<AnotherArraySample xmlns:yaxlib=\"\"http:\/\/www.sinairv.com\/yaxlib\/\"\">\r\n  <Array1>\r\n    <Array2OfInt32 yaxlib:dims=\"\"2,3\"\">\r\n      <Int32>1<\/Int32>\r\n      <Int32>1<\/Int32>\r\n      <Int32>1<\/Int32>\r\n      <Int32>1<\/Int32>\r\n      <Int32>2<\/Int32>\r\n      <Int32>3<\/Int32>\r\n    <\/Array2OfInt32>\r\n    <Array2OfInt32 yaxlib:dims=\"\"3,2\"\">\r\n      <Int32>3<\/Int32>\r\n      <Int32>3<\/Int32>\r\n      <Int32>3<\/Int32>\r\n      <Int32>4<\/Int32>\r\n      <Int32>3<\/Int32>\r\n      <Int32>5<\/Int32>\r\n    <\/Array2OfInt32>\r\n  <\/Array1>\r\n<\/AnotherArraySample>\";\r\n            var serializer = new YAXSerializer(typeof(AnotherArraySample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(AnotherArraySample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n\r\n        [Test]\r\n        public void CollectionOfInterfacesSampleTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example shows serialization and deserialization of -->\r\n<!-- objects through a reference to their base class or interface -->\r\n<CollectionOfInterfacesSample xmlns:yaxlib=\"\"http:\/\/www.sinairv.com\/yaxlib\/\"\">\r\n  <SingleRef yaxlib:realtype=\"\"YAXLibTests.SampleClasses.Class2\"\">\r\n    <IntInInterface>22<\/IntInInterface>\r\n    <StringInClass2>SingleRef<\/StringInClass2>\r\n  <\/SingleRef>\r\n  <ListOfSamples>\r\n    <Class1 yaxlib:realtype=\"\"YAXLibTests.SampleClasses.Class1\"\">\r\n      <IntInInterface>1<\/IntInInterface>\r\n      <DoubleInClass1>1<\/DoubleInClass1>\r\n    <\/Class1>\r\n    <Class2 yaxlib:realtype=\"\"YAXLibTests.SampleClasses.Class2\"\">\r\n      <IntInInterface>2<\/IntInInterface>\r\n      <StringInClass2>Class2<\/StringInClass2>\r\n    <\/Class2>\r\n    <Class3_1 yaxlib:realtype=\"\"YAXLibTests.SampleClasses.Class3_1\"\">\r\n      <StringInClass3_1>Class3_1<\/StringInClass3_1>\r\n      <IntInInterface>3<\/IntInInterface>\r\n      <DoubleInClass1>3<\/DoubleInClass1>\r\n    <\/Class3_1>\r\n  <\/ListOfSamples>\r\n  <DictSample2Int>\r\n    <KeyValuePairOfISampleInt32>\r\n      <Key yaxlib:realtype=\"\"YAXLibTests.SampleClasses.Class1\"\">\r\n        <IntInInterface>1<\/IntInInterface>\r\n        <DoubleInClass1>1<\/DoubleInClass1>\r\n      <\/Key>\r\n      <Value>1<\/Value>\r\n    <\/KeyValuePairOfISampleInt32>\r\n    <KeyValuePairOfISampleInt32>\r\n      <Key yaxlib:realtype=\"\"YAXLibTests.SampleClasses.Class2\"\">\r\n        <IntInInterface>2<\/IntInInterface>\r\n        <StringInClass2>Class2<\/StringInClass2>\r\n      <\/Key>\r\n      <Value>2<\/Value>\r\n    <\/KeyValuePairOfISampleInt32>\r\n    <KeyValuePairOfISampleInt32>\r\n      <Key yaxlib:realtype=\"\"YAXLibTests.SampleClasses.Class3_1\"\">\r\n        <StringInClass3_1>Class3_1<\/StringInClass3_1>\r\n        <IntInInterface>3<\/IntInInterface>\r\n        <DoubleInClass1>3<\/DoubleInClass1>\r\n      <\/Key>\r\n      <Value>3<\/Value>\r\n    <\/KeyValuePairOfISampleInt32>\r\n  <\/DictSample2Int>\r\n  <DictInt2Sample>\r\n    <KeyValuePairOfInt32ISample>\r\n      <Key>1<\/Key>\r\n      <Value yaxlib:realtype=\"\"YAXLibTests.SampleClasses.Class1\"\">\r\n        <IntInInterface>1<\/IntInInterface>\r\n        <DoubleInClass1>1<\/DoubleInClass1>\r\n      <\/Value>\r\n    <\/KeyValuePairOfInt32ISample>\r\n    <KeyValuePairOfInt32ISample>\r\n      <Key>2<\/Key>\r\n      <Value yaxlib:realtype=\"\"YAXLibTests.SampleClasses.Class2\"\">\r\n        <IntInInterface>2<\/IntInInterface>\r\n        <StringInClass2>Class2<\/StringInClass2>\r\n      <\/Value>\r\n    <\/KeyValuePairOfInt32ISample>\r\n    <KeyValuePairOfInt32ISample>\r\n      <Key>3<\/Key>\r\n      <Value yaxlib:realtype=\"\"YAXLibTests.SampleClasses.Class3_1\"\">\r\n        <StringInClass3_1>Class3_1<\/StringInClass3_1>\r\n        <IntInInterface>3<\/IntInInterface>\r\n        <DoubleInClass1>3<\/DoubleInClass1>\r\n      <\/Value>\r\n    <\/KeyValuePairOfInt32ISample>\r\n  <\/DictInt2Sample>\r\n<\/CollectionOfInterfacesSample>\";\r\n            var serializer = new YAXSerializer(typeof(CollectionOfInterfacesSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(CollectionOfInterfacesSample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void MultipleCommentsTestTest()\r\n        {\r\n            const string result =\r\n@\"<!-- How multi-line comments are serialized as multiple XML comments -->\r\n<MultipleCommentsTest>\r\n  <!-- Using @ quoted style -->\r\n  <!-- comments for multiline comments -->\r\n  <Dummy>0<\/Dummy>\r\n  <!-- Comment 1 for member -->\r\n  <!-- Comment 2 for member -->\r\n  <SomeInt>10<\/SomeInt>\r\n<\/MultipleCommentsTest>\";\r\n            var serializer = new YAXSerializer(typeof(MultipleCommentsTest), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(MultipleCommentsTest.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void InterfaceMatchingSampleTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example shows serialization and deserialization of objects -->\r\n<!-- through a reference to their base class or interface while used in -->\r\n<!-- collection classes -->\r\n<InterfaceMatchingSample SomeNumber=\"\"10\"\">\r\n  <ListOfSamples>2 4 8<\/ListOfSamples>\r\n  <DictNullable2Int>\r\n    <KeyValuePairOfNullableOfDoubleInt32 Key=\"\"1\"\" Value=\"\"1\"\" \/>\r\n    <KeyValuePairOfNullableOfDoubleInt32 Key=\"\"2\"\" Value=\"\"2\"\" \/>\r\n    <KeyValuePairOfNullableOfDoubleInt32 Key=\"\"3\"\" Value=\"\"3\"\" \/>\r\n  <\/DictNullable2Int>\r\n  <DictInt2Nullable>\r\n    <KeyValuePairOfInt32NullableOfDouble Key=\"\"1\"\" Value=\"\"1\"\" \/>\r\n    <KeyValuePairOfInt32NullableOfDouble Key=\"\"2\"\" Value=\"\"2\"\" \/>\r\n    <KeyValuePairOfInt32NullableOfDouble Key=\"\"3\"\" Value=\"\"\"\" \/>\r\n  <\/DictInt2Nullable>\r\n<\/InterfaceMatchingSample>\";\r\n            var serializer = new YAXSerializer(typeof(InterfaceMatchingSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(InterfaceMatchingSample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void NonGenericCollectionsSampleTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This sample demonstrates serialization of non-generic collection classes -->\r\n<NonGenericCollectionsSample xmlns:yaxlib=\"\"http:\/\/www.sinairv.com\/yaxlib\/\"\">\r\n  <ObjList Author_s_Name=\"\"Charles\"\">\r\n    <Int32 yaxlib:realtype=\"\"System.Int32\"\">1<\/Int32>\r\n    <Double yaxlib:realtype=\"\"System.Double\"\">3<\/Double>\r\n    <String yaxlib:realtype=\"\"System.String\"\">Hello<\/String>\r\n    <DateTime yaxlib:realtype=\"\"System.DateTime\"\">03\/04\/2010 00:00:00<\/DateTime>\r\n    <Something>\r\n      <Or>\r\n        <Another>\r\n          <Author_s_Age>50<\/Author_s_Age>\r\n        <\/Another>\r\n      <\/Or>\r\n    <\/Something>\r\n    <Author yaxlib:realtype=\"\"YAXLibTests.SampleClasses.Author\"\" \/>\r\n  <\/ObjList>\r\n  <TheArrayList Author_s_Name=\"\"Steve\"\">\r\n    <Int32 yaxlib:realtype=\"\"System.Int32\"\">2<\/Int32>\r\n    <Double yaxlib:realtype=\"\"System.Double\"\">8.5<\/Double>\r\n    <String yaxlib:realtype=\"\"System.String\"\">Hi<\/String>\r\n    <Something>\r\n      <Or>\r\n        <Another>\r\n          <Author_s_Age>30<\/Author_s_Age>\r\n        <\/Another>\r\n      <\/Or>\r\n    <\/Something>\r\n    <Author yaxlib:realtype=\"\"YAXLibTests.SampleClasses.Author\"\" \/>\r\n  <\/TheArrayList>\r\n  <TheHashtable>\r\n{0}\r\n{1}\r\n  <\/TheHashtable>\r\n  <TheQueue>\r\n    <Int32 yaxlib:realtype=\"\"System.Int32\"\">10<\/Int32>\r\n    <Int32 yaxlib:realtype=\"\"System.Int32\"\">20<\/Int32>\r\n    <Int32 yaxlib:realtype=\"\"System.Int32\"\">30<\/Int32>\r\n  <\/TheQueue>\r\n  <TheStack>\r\n    <Int32 yaxlib:realtype=\"\"System.Int32\"\">300<\/Int32>\r\n    <Int32 yaxlib:realtype=\"\"System.Int32\"\">200<\/Int32>\r\n    <Int32 yaxlib:realtype=\"\"System.Int32\"\">100<\/Int32>\r\n  <\/TheStack>\r\n  <TheSortedList>\r\n    <DictionaryEntry yaxlib:realtype=\"\"System.Collections.DictionaryEntry\"\">\r\n      <Key yaxlib:realtype=\"\"System.Int32\"\">1<\/Key>\r\n      <Value yaxlib:realtype=\"\"System.Int32\"\">2<\/Value>\r\n    <\/DictionaryEntry>\r\n    <DictionaryEntry yaxlib:realtype=\"\"System.Collections.DictionaryEntry\"\">\r\n      <Key yaxlib:realtype=\"\"System.Int32\"\">5<\/Key>\r\n      <Value yaxlib:realtype=\"\"System.Int32\"\">7<\/Value>\r\n    <\/DictionaryEntry>\r\n    <DictionaryEntry yaxlib:realtype=\"\"System.Collections.DictionaryEntry\"\">\r\n      <Key yaxlib:realtype=\"\"System.Int32\"\">8<\/Key>\r\n      <Value yaxlib:realtype=\"\"System.Int32\"\">2<\/Value>\r\n    <\/DictionaryEntry>\r\n  <\/TheSortedList>\r\n  <TheBitArray>\r\n    <Boolean yaxlib:realtype=\"\"System.Boolean\"\">False<\/Boolean>\r\n    <Boolean yaxlib:realtype=\"\"System.Boolean\"\">True<\/Boolean>\r\n    <Boolean yaxlib:realtype=\"\"System.Boolean\"\">False<\/Boolean>\r\n    <Boolean yaxlib:realtype=\"\"System.Boolean\"\">False<\/Boolean>\r\n    <Boolean yaxlib:realtype=\"\"System.Boolean\"\">False<\/Boolean>\r\n    <Boolean yaxlib:realtype=\"\"System.Boolean\"\">False<\/Boolean>\r\n    <Boolean yaxlib:realtype=\"\"System.Boolean\"\">True<\/Boolean>\r\n    <Boolean yaxlib:realtype=\"\"System.Boolean\"\">False<\/Boolean>\r\n    <Boolean yaxlib:realtype=\"\"System.Boolean\"\">False<\/Boolean>\r\n    <Boolean yaxlib:realtype=\"\"System.Boolean\"\">False<\/Boolean>\r\n  <\/TheBitArray>\r\n<\/NonGenericCollectionsSample>\";\r\n\r\n            string part1 = @\"    <DictionaryEntry yaxlib:realtype=\"\"System.Collections.DictionaryEntry\"\">\r\n      <Key yaxlib:realtype=\"\"System.DateTime\"\">02\/01\/2009 00:00:00<\/Key>\r\n      <Value yaxlib:realtype=\"\"System.Int32\"\">7<\/Value>\r\n    <\/DictionaryEntry>\";\r\n\r\n            string part2 = @\"    <DictionaryEntry yaxlib:realtype=\"\"System.Collections.DictionaryEntry\"\">\r\n      <Key yaxlib:realtype=\"\"System.String\"\">Tom<\/Key>\r\n      <Value yaxlib:realtype=\"\"System.String\"\">Sam<\/Value>\r\n    <\/DictionaryEntry>\r\n    <DictionaryEntry yaxlib:realtype=\"\"System.Collections.DictionaryEntry\"\">\r\n      <Key yaxlib:realtype=\"\"System.Double\"\">1<\/Key>\r\n      <Value yaxlib:realtype=\"\"System.String\"\">Tim<\/Value>\r\n    <\/DictionaryEntry>\";\r\n\r\n            string possibleResult1 = String.Format(result, part1, part2);\r\n            string possibleResult2 = String.Format(result, part2, part1);\r\n\r\n\r\n            var serializer = new YAXSerializer(typeof(NonGenericCollectionsSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(NonGenericCollectionsSample.GetSampleInstance());\r\n            \/\/result.ShouldEqualWithDiff(got, DiffStyle.Minimal);\r\n            bool result1Match = String.Equals(got, possibleResult1, StringComparison.Ordinal);\r\n            bool result2Match = String.Equals(got, possibleResult2, StringComparison.Ordinal);\r\n            Assert.That(result1Match || result2Match, Is.True);\r\n        }\r\n\r\n\r\n        [Test]\r\n        public void GenericCollectionsSampleTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This class provides an example of successful serialization\/deserialization -->\r\n<!-- of collection objects in \"\"System.Collections.Generic\"\" namespaces -->\r\n<GenericCollectionsSample>\r\n  <TheStack>\r\n    <Int32>79<\/Int32>\r\n    <Int32>1<\/Int32>\r\n    <Int32>7<\/Int32>\r\n  <\/TheStack>\r\n  <TheSortedList>\r\n    <Item Key=\"\"0.5\"\" Value=\"\"Hello\"\" \/>\r\n    <Item Key=\"\"1\"\" Value=\"\"Hi\"\" \/>\r\n    <Item Key=\"\"5\"\" Value=\"\"How are you?\"\" \/>\r\n  <\/TheSortedList>\r\n  <TheSortedDictionary>\r\n    <Item Key=\"\"1\"\" Value=\"\"30\"\" \/>\r\n    <Item Key=\"\"5\"\" Value=\"\"2\"\" \/>\r\n    <Item Key=\"\"10\"\" Value=\"\"1\"\" \/>\r\n  <\/TheSortedDictionary>\r\n  <TheQueue>\r\n    <String>Hi<\/String>\r\n    <String>Hello<\/String>\r\n    <String>How are you?<\/String>\r\n  <\/TheQueue>\r\n  <TheHashSet>\r\n    <Int32>1<\/Int32>\r\n    <Int32>2<\/Int32>\r\n    <Int32>4<\/Int32>\r\n    <Int32>6<\/Int32>\r\n  <\/TheHashSet>\r\n  <TheLinkedList>\r\n    <Double>1<\/Double>\r\n    <Double>5<\/Double>\r\n    <Double>61<\/Double>\r\n  <\/TheLinkedList>\r\n<\/GenericCollectionsSample>\";\r\n\r\n            var serializer = new YAXSerializer(typeof(GenericCollectionsSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(GenericCollectionsSample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test] \r\n        public void SerializingPathAndAliasTogetherTest()\r\n        {\r\n            const string result = \r\n@\"<PathAndAliasAssignmentSample>\r\n  <Title value=\"\"Inside C#\"\" \/>\r\n  <Price value=\"\"30.5\"\" \/>\r\n  <Publish year=\"\"2002\"\" \/>\r\n  <Notes>\r\n    <Comments value=\"\"SomeComment\"\" \/>\r\n  <\/Notes>\r\n  <Author name=\"\"Tom Archer &amp; Andrew Whitechapel\"\" \/>\r\n<\/PathAndAliasAssignmentSample>\";\r\n            var serializer = new YAXSerializer(typeof(PathAndAliasAssignmentSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(PathAndAliasAssignmentSample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void CollectionSeriallyAsAttributeTest()\r\n        {\r\n            const string result =\r\n@\"<CollectionSeriallyAsAttribute>\r\n  <Info names=\"\"John Doe,Jane,Sina,Mike,Rich\"\" \/>\r\n  <TheCities>Tehran,Melbourne,New York,Paris<\/TheCities>\r\n  <Location>\r\n    <Countries>Iran,Australia,United States of America,France<\/Countries>\r\n  <\/Location>\r\n<\/CollectionSeriallyAsAttribute>\";\r\n            var serializer = new YAXSerializer(typeof(CollectionSeriallyAsAttribute), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(CollectionSeriallyAsAttribute.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n\r\n        [Test]\r\n        public void SerializationOptionsSampleTest()\r\n        {\r\n            const string resultWithSerializeNullRefs =\r\n@\"<SerializationOptionsSample>\r\n  <!-- Str2Null must NOT be serialized when it is null, even -->\r\n  <!-- if the serialization options of the serializer is changed -->\r\n  <ObjectWithOptionsSet>\r\n    <StrNotNull>SomeString<\/StrNotNull>\r\n    <SomeValueType>0<\/SomeValueType>\r\n  <\/ObjectWithOptionsSet>\r\n  <!-- Str2Null must be serialized when it is null, even -->\r\n  <!-- if the serialization options of the serializer is changed -->\r\n  <AnotherObjectWithOptionsSet>\r\n    <StrNotNull>Some other string<\/StrNotNull>\r\n    <StrNull \/>\r\n  <\/AnotherObjectWithOptionsSet>\r\n  <!-- serialization of Str2Null must obey the options set -->\r\n  <!-- in the serializer itself -->\r\n  <ObjectWithoutOptionsSet>\r\n    <StrNotNull>Another string<\/StrNotNull>\r\n    <StrNull \/>\r\n  <\/ObjectWithoutOptionsSet>\r\n<\/SerializationOptionsSample>\";\r\n\r\n            var serializer = new YAXSerializer(typeof(SerializationOptionsSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(SerializationOptionsSample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(resultWithSerializeNullRefs));\r\n\r\n            const string resultWithDontSerializeNullRefs =\r\n@\"<SerializationOptionsSample>\r\n  <!-- Str2Null must NOT be serialized when it is null, even -->\r\n  <!-- if the serialization options of the serializer is changed -->\r\n  <ObjectWithOptionsSet>\r\n    <StrNotNull>SomeString<\/StrNotNull>\r\n    <SomeValueType>0<\/SomeValueType>\r\n  <\/ObjectWithOptionsSet>\r\n  <!-- Str2Null must be serialized when it is null, even -->\r\n  <!-- if the serialization options of the serializer is changed -->\r\n  <AnotherObjectWithOptionsSet>\r\n    <StrNotNull>Some other string<\/StrNotNull>\r\n    <StrNull \/>\r\n  <\/AnotherObjectWithOptionsSet>\r\n  <!-- serialization of Str2Null must obey the options set -->\r\n  <!-- in the serializer itself -->\r\n  <ObjectWithoutOptionsSet>\r\n    <StrNotNull>Another string<\/StrNotNull>\r\n  <\/ObjectWithoutOptionsSet>\r\n<\/SerializationOptionsSample>\";\r\n\r\n            serializer = new YAXSerializer(typeof(SerializationOptionsSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.DontSerializeNullObjects);\r\n            got = serializer.Serialize(SerializationOptionsSample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(resultWithDontSerializeNullRefs));\r\n        }\r\n\r\n        [Test]\r\n        public void SerializeAClassContainingXElementItself()\r\n        {\r\n            var initialInstance = ClassContainingXElement.GetSampleInstance();\r\n            string initialInstanceString = initialInstance.ToString();\r\n\r\n            var ser = new YAXSerializer(typeof (ClassContainingXElement), YAXExceptionHandlingPolicies.DoNotThrow,\r\n                                        YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n\r\n            var initialXmlSer = ser.Serialize(initialInstance);\r\n\r\n            var initialInstDes = ser.Deserialize(initialXmlSer) as ClassContainingXElement;\r\n            Assert.That(initialInstDes, Is.Not.Null);\r\n            var initialInstDesString = initialInstDes.ToString();\r\n\r\n            Assert.That(initialInstDesString, Is.EqualTo(initialInstanceString));\r\n\r\n            initialInstance.TheElement = null;\r\n            string nulledElementString = initialInstance.ToString();\r\n\r\n            string nulledElemXmlSer = ser.Serialize(initialInstance);\r\n\r\n            var nulledInstanceDeser = ser.Deserialize(nulledElemXmlSer);\r\n            Assert.That(nulledInstanceDeser.ToString(), Is.EqualTo(nulledElementString));\r\n        }\r\n\r\n        [Test]\r\n        public void SerializaitonOfPropertylessClasses()\r\n        {\r\n            const string result =\r\n@\"<PropertylessClassesSample xmlns:yaxlib=\"\"http:\/\/www.sinairv.com\/yaxlib\/\"\">\r\n  <ValuedDbNull>DBNull<\/ValuedDbNull>\r\n  <NullDbNull \/>\r\n  <ObjValuedDbNull yaxlib:realtype=\"\"System.DBNull\"\">DBNull<\/ObjValuedDbNull>\r\n  <ObjNullDbNull \/>\r\n  <ValuedRandom \/>\r\n  <NullRandom \/>\r\n  <ObjValuedRandom yaxlib:realtype=\"\"System.Random\"\" \/>\r\n  <ObjNullRandom \/>\r\n<\/PropertylessClassesSample>\";\r\n            var serializer = new YAXSerializer(typeof(PropertylessClassesSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(PropertylessClassesSample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void GuidsAsBasicTypeTest()\r\n        {\r\n            const string result =\r\n@\"<GuidAsBasicType GuidAsAttr=\"\"fed92f33-e351-47bd-9018-69c89928329e\"\">\r\n  <GuidAsElem>042ba99c-b679-4975-ac4d-2fe563a5dc3e<\/GuidAsElem>\r\n  <GuidArray>\r\n    <Guid>fed92f33-e351-47bd-9018-69c89928329e<\/Guid>\r\n    <Guid>042ba99c-b679-4975-ac4d-2fe563a5dc3e<\/Guid>\r\n    <Guid>82071c51-ea20-473b-a541-1ebdf8f158d3<\/Guid>\r\n    <Guid>81a3478b-5779-451a-b2aa-fbf69bb11424<\/Guid>\r\n    <Guid>d626ba2b-a095-4a34-a376-997e5628dfb9<\/Guid>\r\n  <\/GuidArray>\r\n  <GuidArraySerially>fed92f33-e351-47bd-9018-69c89928329e 042ba99c-b679-4975-ac4d-2fe563a5dc3e 82071c51-ea20-473b-a541-1ebdf8f158d3 81a3478b-5779-451a-b2aa-fbf69bb11424 d626ba2b-a095-4a34-a376-997e5628dfb9<\/GuidArraySerially>\r\n  <GuidsList>\r\n    <Guid>fed92f33-e351-47bd-9018-69c89928329e<\/Guid>\r\n    <Guid>042ba99c-b679-4975-ac4d-2fe563a5dc3e<\/Guid>\r\n    <Guid>82071c51-ea20-473b-a541-1ebdf8f158d3<\/Guid>\r\n    <Guid>81a3478b-5779-451a-b2aa-fbf69bb11424<\/Guid>\r\n    <Guid>d626ba2b-a095-4a34-a376-997e5628dfb9<\/Guid>\r\n  <\/GuidsList>\r\n  <DicKeyGuid>\r\n    <KeyValuePairOfGuidInt32>\r\n      <Key>fed92f33-e351-47bd-9018-69c89928329e<\/Key>\r\n      <Value>1<\/Value>\r\n    <\/KeyValuePairOfGuidInt32>\r\n    <KeyValuePairOfGuidInt32>\r\n      <Key>042ba99c-b679-4975-ac4d-2fe563a5dc3e<\/Key>\r\n      <Value>2<\/Value>\r\n    <\/KeyValuePairOfGuidInt32>\r\n    <KeyValuePairOfGuidInt32>\r\n      <Key>82071c51-ea20-473b-a541-1ebdf8f158d3<\/Key>\r\n      <Value>3<\/Value>\r\n    <\/KeyValuePairOfGuidInt32>\r\n  <\/DicKeyGuid>\r\n  <DicKeyAttrGuid>\r\n    <Pair TheGuid=\"\"fed92f33-e351-47bd-9018-69c89928329e\"\">\r\n      <Value>1<\/Value>\r\n    <\/Pair>\r\n    <Pair TheGuid=\"\"042ba99c-b679-4975-ac4d-2fe563a5dc3e\"\">\r\n      <Value>2<\/Value>\r\n    <\/Pair>\r\n    <Pair TheGuid=\"\"82071c51-ea20-473b-a541-1ebdf8f158d3\"\">\r\n      <Value>3<\/Value>\r\n    <\/Pair>\r\n  <\/DicKeyAttrGuid>\r\n  <DicValueGuid>\r\n    <KeyValuePairOfInt32Guid>\r\n      <Key>1<\/Key>\r\n      <Value>fed92f33-e351-47bd-9018-69c89928329e<\/Value>\r\n    <\/KeyValuePairOfInt32Guid>\r\n    <KeyValuePairOfInt32Guid>\r\n      <Key>2<\/Key>\r\n      <Value>82071c51-ea20-473b-a541-1ebdf8f158d3<\/Value>\r\n    <\/KeyValuePairOfInt32Guid>\r\n    <KeyValuePairOfInt32Guid>\r\n      <Key>3<\/Key>\r\n      <Value>d626ba2b-a095-4a34-a376-997e5628dfb9<\/Value>\r\n    <\/KeyValuePairOfInt32Guid>\r\n  <\/DicValueGuid>\r\n  <DicValueAttrGuid>\r\n    <Pair TheGuid=\"\"fed92f33-e351-47bd-9018-69c89928329e\"\">\r\n      <Key>1<\/Key>\r\n    <\/Pair>\r\n    <Pair TheGuid=\"\"82071c51-ea20-473b-a541-1ebdf8f158d3\"\">\r\n      <Key>2<\/Key>\r\n    <\/Pair>\r\n    <Pair TheGuid=\"\"d626ba2b-a095-4a34-a376-997e5628dfb9\"\">\r\n      <Key>3<\/Key>\r\n    <\/Pair>\r\n  <\/DicValueAttrGuid>\r\n<\/GuidAsBasicType>\";\r\n            var serializer = new YAXSerializer(typeof(GuidAsBasicType), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(GuidAsBasicType.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void PolymorphicSerializationThroughObjectTest()\r\n        {\r\n            object content = \"this is just a simple test\";\r\n            var ser = new YAXSerializer(typeof(object));\r\n            string xmlResult = ser.Serialize(content);\r\n\r\n            string expectedResult = \r\n@\"<Object yaxlib:realtype=\"\"System.String\"\" xmlns:yaxlib=\"\"http:\/\/www.sinairv.com\/yaxlib\/\"\">this is just a simple test<\/Object>\";\r\n\r\n            Assert.That(xmlResult, Is.EqualTo(expectedResult));\r\n            var desObj = ser.Deserialize(xmlResult);\r\n            string objStr = desObj.ToString();\r\n            Assert.That(desObj.ToString(), Is.EqualTo(content.ToString()));\r\n        }\r\n\r\n        [Test]\r\n        public void PolymorphicSerializationThroughListTest()\r\n        {\r\n            var lst = new List<int> {1, 2, 3};\r\n            var ser = new YAXSerializer(typeof(object));\r\n            string xmlResult = ser.Serialize(lst);\r\n\r\n            string expectedResult = \r\n@\"<Object yaxlib:realtype=\"\"System.Collections.Generic.List`1[[System.Int32, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]\"\" xmlns:yaxlib=\"\"http:\/\/www.sinairv.com\/yaxlib\/\"\">\r\n  <Int32>1<\/Int32>\r\n  <Int32>2<\/Int32>\r\n  <Int32>3<\/Int32>\r\n<\/Object>\";\r\n\r\n            Assert.That(xmlResult, Is.EqualTo(expectedResult));\r\n            var desObj = ser.Deserialize(xmlResult);\r\n            Assert.That(desObj.GetType(), Is.EqualTo(lst.GetType()));\r\n            var desLst = desObj as List<int>;\r\n            Assert.That(lst, Has.Count.EqualTo(desLst.Count));\r\n            Assert.That(lst, Is.EquivalentTo(desLst));\r\n        }\r\n\r\n        [Test]\r\n        public void PolymorphicSerializationThroughListWhichMayContainYaxlibNamespaceTest()\r\n        {\r\n            var lst = new List<object> { 1, 2, 3 };\r\n            var ser = new YAXSerializer(typeof(object));\r\n            string xmlResult = ser.Serialize(lst);\r\n\r\n            string expectedResult =\r\n@\"<Object yaxlib:realtype=\"\"System.Collections.Generic.List`1[[System.Object, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]\"\" xmlns:yaxlib=\"\"http:\/\/www.sinairv.com\/yaxlib\/\"\">\r\n  <Int32 yaxlib:realtype=\"\"System.Int32\"\">1<\/Int32>\r\n  <Int32 yaxlib:realtype=\"\"System.Int32\"\">2<\/Int32>\r\n  <Int32 yaxlib:realtype=\"\"System.Int32\"\">3<\/Int32>\r\n<\/Object>\";\r\n\r\n            Assert.That(xmlResult, Is.EqualTo(expectedResult));\r\n            var desObj = ser.Deserialize(xmlResult);\r\n            Assert.That(desObj.GetType(), Is.EqualTo(lst.GetType()));\r\n            var desLst = desObj as List<object>;\r\n            Assert.That(lst, Has.Count.EqualTo(desLst.Count));\r\n            Assert.That(lst, Is.EquivalentTo(desLst));\r\n        }\r\n\r\n        [Test]\r\n        public void DashPreservationTest()\r\n        {\r\n            const string expectedResult = @\"<dashed-sample dashed-name=\"\"Name\"\" \/>\";\r\n\r\n            DashedSample sample = new DashedSample\r\n            {\r\n                DashedName = \"Name\"\r\n            };\r\n\r\n            YAXSerializer ser = new YAXSerializer(typeof(DashedSample));\r\n            string got = ser.Serialize(sample);\r\n            Assert.That(got, Is.EqualTo(expectedResult));\r\n        }\r\n\r\n        [Test]\r\n        public void AttributeForClassTest()\r\n        {\r\n            var ser = new YAXSerializer(typeof(AttributeContainerSample));\r\n            string result = ser.Serialize(AttributeContainerSample.GetSampleInstance());\r\n\r\n            const string expectedResult =\r\n@\"<container>\r\n  <range from=\"\"1\"\" to=\"\"3\"\" \/>\r\n<\/container>\";\r\n\r\n            Assert.That(expectedResult, Is.EqualTo(result));\r\n        }\r\n\r\n\r\n        [Test]\r\n        public void DictionaryKeyValueAsContentTest()\r\n        {\r\n            var ser = new YAXSerializer(typeof(DictionaryKeyValueAsContent));\r\n            string result = ser.Serialize(DictionaryKeyValueAsContent.GetSampleInstance());\r\n\r\n            const string expectedResult =\r\n@\"<DictionaryKeyValueAsContent>\r\n  <DicValueAsContent>\r\n    <Pair Digits=\"\"1\"\">one<\/Pair>\r\n    <Pair Digits=\"\"2\"\">two<\/Pair>\r\n    <Pair Digits=\"\"3\"\">three<\/Pair>\r\n  <\/DicValueAsContent>\r\n  <DicKeyAsContnet>\r\n    <Pair Letters=\"\"one\"\">1<\/Pair>\r\n    <Pair Letters=\"\"two\"\">2<\/Pair>\r\n    <Pair Letters=\"\"three\"\">3<\/Pair>\r\n  <\/DicKeyAsContnet>\r\n  <DicKeyAsContentValueAsElement>\r\n    <Pair>1<Letters>one<\/Letters><\/Pair>\r\n    <Pair>2<Letters>two<\/Letters><\/Pair>\r\n    <Pair>3<Letters>three<\/Letters><\/Pair>\r\n  <\/DicKeyAsContentValueAsElement>\r\n  <DicValueAsContentKeyAsElement>\r\n    <Pair>\r\n      <Digits>1<\/Digits>one<\/Pair>\r\n    <Pair>\r\n      <Digits>2<\/Digits>two<\/Pair>\r\n    <Pair>\r\n      <Digits>3<\/Digits>three<\/Pair>\r\n  <\/DicValueAsContentKeyAsElement>\r\n<\/DictionaryKeyValueAsContent>\";\r\n            Assert.That(expectedResult, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void AttributeForKeyInDictionaryTest()\r\n        {\r\n            var dictionary = DictionarySample.GetSampleInstance();\r\n            var ser = new YAXSerializer(typeof(DictionarySample));\r\n            string result = ser.Serialize(dictionary);\r\n            \r\n            const string expectedResult =\r\n@\"<TheItems xmlns=\"\"http:\/\/example.com\/\"\">\r\n  <TheItem TheKey=\"\"key1\"\">00000001-0002-0003-0405-060708090a0b<\/TheItem>\r\n  <TheItem TheKey=\"\"key2\"\">1234<\/TheItem>\r\n<\/TheItems>\";\r\n\r\n            Assert.AreEqual(expectedResult, result);\r\n        }\r\n\r\n        [Test]\r\n        public void AttributeForKeyInDictionaryPropertyTest()\r\n        {\r\n            var container = DictionaryContainerSample.GetSampleInstance();\r\n            var ser = new YAXSerializer(typeof(DictionaryContainerSample));\r\n            string result = ser.Serialize(container);\r\n\r\n            const string expectedResult =\r\n@\"<container xmlns=\"\"http:\/\/example.com\/\"\">\r\n  <items>\r\n    <item key=\"\"key1\"\">00000001-0002-0003-0405-060708090a0b<\/item>\r\n    <item key=\"\"key2\"\">1234<\/item>\r\n  <\/items>\r\n<\/container>\";\r\n\r\n            Assert.AreEqual(expectedResult, result);\r\n        }\r\n\r\n\r\n    }\r\n}\r\n","old_contents":"\ufeff\/\/ Copyright 2009 - 2010 Sina Iravanian - <sina@sinairv.com>\r\n\/\/\r\n\/\/ This source file(s) may be redistributed, altered and customized\r\n\/\/ by any means PROVIDING the authors name and all copyright\r\n\/\/ notices remain intact.\r\n\/\/ THIS SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n\/\/ EXPRESS OR IMPLIED. USE IT AT YOUR OWN RISK. THE AUTHOR ACCEPTS NO\r\n\/\/ LIABILITY FOR ANY DATA DAMAGE\/LOSS THAT THIS PRODUCT MAY CAUSE.\r\n\/\/-----------------------------------------------------------------------\r\n\r\nusing System;\r\nusing System.Collections.Generic;\r\n\r\nusing NUnit.Framework;\r\n\r\nusing YAXLib;\r\nusing System.Threading;\r\nusing System.Globalization;\r\nusing YAXLibTests.SampleClasses;\r\n\r\nnamespace YAXLibTests\r\n{\r\n    [TestFixture]\r\n    public class SerializationTest\r\n    {\r\n        [TestFixtureSetUp]\r\n        public void TestFixtureSetUp()\r\n        {\r\n            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;\r\n        }\r\n\r\n        [Test]\r\n        public void BasicTypeSerializationTest()\r\n        {\r\n            var objs = new object[] {123, 654.321, \"SomeString\", 24234L};\r\n            var types = new [] {typeof (int), typeof (double), typeof (string), typeof (long)};\r\n            var serializedResults = new[] { \"<Int32>123<\/Int32>\", \"<Double>654.321<\/Double>\", \"<String>SomeString<\/String>\", \"<Int64>24234<\/Int64>\" };\r\n\r\n            for (int i = 0; i < objs.Length; i++)\r\n            {\r\n                var serializer = new YAXSerializer(objs[i].GetType());\r\n                var got = serializer.Serialize(objs[i]);\r\n                Assert.That(got, Is.EqualTo(serializedResults[i]));\r\n\r\n                var deser = new YAXSerializer(types[i]);\r\n                var obj = deser.Deserialize(got);\r\n                Assert.That(objs[i], Is.EqualTo(obj));\r\n            }\r\n\r\n        }\r\n\r\n        [Test]\r\n        public void BookTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example demonstrates serailizing a very simple class -->\r\n<Book>\r\n  <Title>Inside C#<\/Title>\r\n  <Author>Tom Archer &amp; Andrew Whitechapel<\/Author>\r\n  <PublishYear>2002<\/PublishYear>\r\n  <Price>30.5<\/Price>\r\n<\/Book>\";\r\n            var serializer = new YAXSerializer(typeof(Book), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(Book.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void ThreadingTest()\r\n        {\r\n            try\r\n            {\r\n                for (int i = 0; i < 100; i++)\r\n                {\r\n                    var th = new Thread(() =>\r\n                        {\r\n                            var serializer = new YAXSerializer(typeof(Book), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n                            string got = serializer.Serialize(Book.GetSampleInstance());\r\n                            var deserializer = new YAXSerializer(typeof(Book), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n                            var book = deserializer.Deserialize(got) as Book;\r\n                            Assert.That(book, Is.Not.Null);\r\n                        }\r\n                    );\r\n\r\n                    th.Start();\r\n                }\r\n            }\r\n            catch\r\n            {\r\n                Assert.Fail(\"Exception fired in threading method\");\r\n            }\r\n\r\n        }\r\n\r\n        [Test]\r\n        public void BookWithDecimalPriceTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example demonstrates serailizing a very simple class -->\r\n<SimpleBookClassWithDecimalPrice>\r\n  <Title>Inside C#<\/Title>\r\n  <Author>Tom Archer &amp; Andrew Whitechapel<\/Author>\r\n  <PublishYear>2002<\/PublishYear>\r\n  <Price>32.20<\/Price>\r\n<\/SimpleBookClassWithDecimalPrice>\";\r\n            var serializer = new YAXSerializer(typeof(SimpleBookClassWithDecimalPrice), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(SimpleBookClassWithDecimalPrice.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void CultureChangeTest()\r\n        {\r\n            var curCulture = CultureInfo.CurrentCulture;\r\n\r\n            Thread.CurrentThread.CurrentCulture = CultureInfo.GetCultureInfo(\"fr-FR\");\r\n            var serializer = new YAXSerializer(typeof(CultureSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string frResult = serializer.Serialize(CultureSample.GetSampleInstance());\r\n\r\n            Thread.CurrentThread.CurrentCulture = CultureInfo.GetCultureInfo(\"fa-IR\");\r\n            serializer = new YAXSerializer(typeof(CultureSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string faResult = serializer.Serialize(CultureSample.GetSampleInstance());\r\n\r\n            Thread.CurrentThread.CurrentCulture = CultureInfo.GetCultureInfo(\"de-DE\");\r\n            serializer = new YAXSerializer(typeof(CultureSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string deResult = serializer.Serialize(CultureSample.GetSampleInstance());\r\n\r\n            Thread.CurrentThread.CurrentCulture = CultureInfo.GetCultureInfo(\"en-US\");\r\n            serializer = new YAXSerializer(typeof(CultureSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string usResult = serializer.Serialize(CultureSample.GetSampleInstance());\r\n\r\n            Thread.CurrentThread.CurrentCulture = curCulture;\r\n\r\n            Assert.That(faResult, Is.EqualTo(frResult), \"Comparing FR and FA\");\r\n            Assert.That(deResult, Is.EqualTo(faResult), \"Comparing FA and DE\");\r\n            Assert.That(usResult, Is.EqualTo(deResult), \"Comparing DE and US\");\r\n\r\n            const string expected =\r\n@\"<!-- This class contains fields that are vulnerable to culture changes! -->\r\n<CultureSample Number2=\"\"32243.67676\"\" Dec2=\"\"19232389.18391912318232131\"\" Date2=\"\"09\/20\/2011 04:10:30\"\">\r\n  <Number1>123123.1233<\/Number1>\r\n  <Number3>21313.123123<\/Number3>\r\n  <Numbers>\r\n    <Double>23213.2132<\/Double>\r\n    <Double>123.213<\/Double>\r\n    <Double>1.2323E+34<\/Double>\r\n  <\/Numbers>\r\n  <Dec1>192389183919123.18232131<\/Dec1>\r\n  <Date1>10\/11\/2010 18:20:30<\/Date1>\r\n<\/CultureSample>\";\r\n\r\n            Assert.That(expected, Is.EqualTo(usResult), \"Checking US is as expected!\");\r\n        }\r\n\r\n        [Test]\r\n        public void BookStructTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example demonstrates serailizing a very simple struct -->\r\n<BookStruct>\r\n  <Title>Reinforcement Learning an Introduction<\/Title>\r\n  <Author>R. S. Sutton &amp; A. G. Barto<\/Author>\r\n  <PublishYear>1998<\/PublishYear>\r\n  <Price>38.75<\/Price>\r\n<\/BookStruct>\";\r\n            var serializer = new YAXSerializer(typeof(BookStruct), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(BookStruct.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void WarehouseSimpleTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example is our basic hypothetical warehouse -->\r\n<WarehouseSimple>\r\n  <Name>Foo Warehousing Ltd.<\/Name>\r\n  <Address>No. 10, Some Ave., Some City, Some Country<\/Address>\r\n  <Area>120000.5<\/Area>\r\n<\/WarehouseSimple>\";\r\n            var serializer = new YAXSerializer(typeof(WarehouseSimple), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(WarehouseSimple.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void WarehouseStructuredTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example shows our hypothetical warehouse, a little bit structured -->\r\n<WarehouseStructured Name=\"\"Foo Warehousing Ltd.\"\">\r\n  <SiteInfo address=\"\"No. 10, Some Ave., Some City, Some Country\"\">\r\n    <SurfaceArea>120000.5<\/SurfaceArea>\r\n  <\/SiteInfo>\r\n<\/WarehouseStructured>\";\r\n            var serializer = new YAXSerializer(typeof(WarehouseStructured), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(WarehouseStructured.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void WarehouseWithArrayTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example shows the serialization of arrays -->\r\n<WarehouseWithArray Name=\"\"Foo Warehousing Ltd.\"\">\r\n  <SiteInfo address=\"\"No. 10, Some Ave., Some City, Some Country\"\">\r\n    <SurfaceArea>120000.5<\/SurfaceArea>\r\n  <\/SiteInfo>\r\n  <StoreableItems>Item3, Item6, Item9, Item12<\/StoreableItems>\r\n<\/WarehouseWithArray>\";\r\n            var serializer = new YAXSerializer(typeof(WarehouseWithArray), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(WarehouseWithArray.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void WarehouseWithDictionaryTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example shows the serialization of Dictionary -->\r\n<WarehouseWithDictionary Name=\"\"Foo Warehousing Ltd.\"\">\r\n  <SiteInfo address=\"\"No. 10, Some Ave., Some City, Some Country\"\">\r\n    <SurfaceArea>120000.5<\/SurfaceArea>\r\n  <\/SiteInfo>\r\n  <StoreableItems>Item3, Item6, Item9, Item12<\/StoreableItems>\r\n  <ItemQuantities>\r\n    <ItemInfo Item=\"\"Item3\"\" Count=\"\"10\"\" \/>\r\n    <ItemInfo Item=\"\"Item6\"\" Count=\"\"120\"\" \/>\r\n    <ItemInfo Item=\"\"Item9\"\" Count=\"\"600\"\" \/>\r\n    <ItemInfo Item=\"\"Item12\"\" Count=\"\"25\"\" \/>\r\n  <\/ItemQuantities>\r\n<\/WarehouseWithDictionary>\";\r\n            var serializer = new YAXSerializer(typeof(WarehouseWithDictionary), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(WarehouseWithDictionary.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void WarehouseNestedObjectTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example demonstrates serializing nested objects -->\r\n<WarehouseNestedObjectExample Name=\"\"Foo Warehousing Ltd.\"\">\r\n  <SiteInfo address=\"\"No. 10, Some Ave., Some City, Some Country\"\">\r\n    <SurfaceArea>120000.5<\/SurfaceArea>\r\n  <\/SiteInfo>\r\n  <StoreableItems>Item3, Item6, Item9, Item12<\/StoreableItems>\r\n  <ItemQuantities>\r\n    <ItemInfo Item=\"\"Item3\"\" Count=\"\"10\"\" \/>\r\n    <ItemInfo Item=\"\"Item6\"\" Count=\"\"120\"\" \/>\r\n    <ItemInfo Item=\"\"Item9\"\" Count=\"\"600\"\" \/>\r\n    <ItemInfo Item=\"\"Item12\"\" Count=\"\"25\"\" \/>\r\n  <\/ItemQuantities>\r\n  <Owner SSN=\"\"123456789\"\">\r\n    <Identification Name=\"\"John\"\" Family=\"\"Doe\"\" \/>\r\n    <Age>50<\/Age>\r\n  <\/Owner>\r\n<\/WarehouseNestedObjectExample>\";\r\n            var serializer = new YAXSerializer(typeof(WarehouseNestedObjectExample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(WarehouseNestedObjectExample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void ProgrammingLanguageTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example is used in the article to show YAXLib exception handling policies -->\r\n<ProgrammingLanguage>\r\n  <LanguageName>C#<\/LanguageName>\r\n  <IsCaseSensitive>True<\/IsCaseSensitive>\r\n<\/ProgrammingLanguage>\";\r\n            var serializer = new YAXSerializer(typeof(ProgrammingLanguage), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(ProgrammingLanguage.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void ColorExampleTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example shows a technique for serializing classes without a default constructor -->\r\n<ColorExample>\r\n  <TheColor>#FF0000FF<\/TheColor>\r\n<\/ColorExample>\";\r\n            var serializer = new YAXSerializer(typeof(ColorExample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(ColorExample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void MultiLevelClassTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example shows a multi-level class, which helps to test -->\r\n<!-- the null references identity problem. -->\r\n<!-- Thanks go to Anton Levshunov for proposing this example, -->\r\n<!-- and a disussion on this matter. -->\r\n<MultilevelClass>\r\n  <items>\r\n    <FirstLevelClass>\r\n      <ID>1<\/ID>\r\n      <Second>\r\n        <SecondID>1-2<\/SecondID>\r\n      <\/Second>\r\n    <\/FirstLevelClass>\r\n    <FirstLevelClass>\r\n      <ID>2<\/ID>\r\n      <Second \/>\r\n    <\/FirstLevelClass>\r\n  <\/items>\r\n<\/MultilevelClass>\";\r\n            var serializer = new YAXSerializer(typeof(MultilevelClass), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(MultilevelClass.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void FormattingTest()\r\n        {\r\n            string result =\r\n@\"<!-- This example shows how to apply format strings to a class properties -->\r\n<FormattingExample>\r\n  <CreationDate>{0}<\/CreationDate>\r\n  <ModificationDate>{1}<\/ModificationDate>\r\n  <PI>3.14159<\/PI>\r\n  <NaturalExp>\r\n    <Double>2.718<\/Double>\r\n    <Double>7.389<\/Double>\r\n    <Double>20.086<\/Double>\r\n    <Double>54.598<\/Double>\r\n  <\/NaturalExp>\r\n  <SomeLogarithmExample>\r\n    <KeyValuePairOfDoubleDouble>\r\n      <Key>1.50<\/Key>\r\n      <Value>0.40547<\/Value>\r\n    <\/KeyValuePairOfDoubleDouble>\r\n    <KeyValuePairOfDoubleDouble>\r\n      <Key>3.00<\/Key>\r\n      <Value>1.09861<\/Value>\r\n    <\/KeyValuePairOfDoubleDouble>\r\n    <KeyValuePairOfDoubleDouble>\r\n      <Key>6.00<\/Key>\r\n      <Value>1.79176<\/Value>\r\n    <\/KeyValuePairOfDoubleDouble>\r\n  <\/SomeLogarithmExample>\r\n<\/FormattingExample>\";\r\n\r\n            result = String.Format(result,\r\n                FormattingExample.GetSampleInstance().CreationDate.ToLongDateString(),\r\n                FormattingExample.GetSampleInstance().ModificationDate.ToShortDateString()\r\n                );\r\n\r\n            var serializer = new YAXSerializer(typeof(FormattingExample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(FormattingExample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void PathsExampleTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example demonstrates how not to use -->\r\n<!-- white spaces as separators while serializing -->\r\n<!-- collection classes serially -->\r\n<PathsExample>\r\n  <Paths>C:\\SomeFile.txt;C:\\SomeFolder\\SomeFile.txt;C:\\Some Folder With Space Such As\\Program Files<\/Paths>\r\n<\/PathsExample>\";\r\n            var serializer = new YAXSerializer(typeof(PathsExample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(PathsExample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void MoreComplexExampleTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example tries to show almost all features of YAXLib which were not shown before. -->\r\n<!-- FamousPoints - shows a dictionary with a non-primitive value member. -->\r\n<!-- IntEnumerable - shows serializing properties of type IEnumerable<> -->\r\n<!-- Students - shows the usage of YAXNotCollection attribute -->\r\n<MoreComplexExample xmlns:yaxlib=\"\"http:\/\/www.sinairv.com\/yaxlib\/\"\">\r\n  <FamousPoints>\r\n    <PointInfo PName=\"\"Center\"\">\r\n      <ThePoint X=\"\"0\"\" Y=\"\"0\"\" \/>\r\n    <\/PointInfo>\r\n    <PointInfo PName=\"\"Q1\"\">\r\n      <ThePoint X=\"\"1\"\" Y=\"\"1\"\" \/>\r\n    <\/PointInfo>\r\n    <PointInfo PName=\"\"Q2\"\">\r\n      <ThePoint X=\"\"-1\"\" Y=\"\"1\"\" \/>\r\n    <\/PointInfo>\r\n  <\/FamousPoints>\r\n  <IntEnumerable yaxlib:realtype=\"\"System.Collections.Generic.List`1[[System.Int32, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]\"\">\r\n    <Int32>1<\/Int32>\r\n    <Int32>3<\/Int32>\r\n    <Int32>5<\/Int32>\r\n    <Int32>7<\/Int32>\r\n  <\/IntEnumerable>\r\n  <Students>\r\n    <Count>3<\/Count>\r\n    <Names>\r\n      <String>Ali<\/String>\r\n      <String>Dave<\/String>\r\n      <String>John<\/String>\r\n    <\/Names>\r\n    <Families>\r\n      <String>Alavi<\/String>\r\n      <String>Black<\/String>\r\n      <String>Doe<\/String>\r\n    <\/Families>\r\n  <\/Students>\r\n<\/MoreComplexExample>\";\r\n            var serializer = new YAXSerializer(typeof(MoreComplexExample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(MoreComplexExample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void NestedDicSampleTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example demonstrates usage of recursive collection serialization -->\r\n<!-- and deserialization. In this case a Dictionary whose Key, or Value is -->\r\n<!-- another dictionary or collection has been used. -->\r\n<NestedDicSample>\r\n  <SomeDic>\r\n    <KeyValuePairOfDictionaryOfDoubleDictionaryOfInt32Int32DictionaryOfDictionaryOfStringStringListOfDouble>\r\n      <Key>\r\n        <KeyValuePairOfDoubleDictionaryOfInt32Int32>\r\n          <Key>0.99999<\/Key>\r\n          <Value>\r\n            <KeyValuePairOfInt32Int32>\r\n              <Key>1<\/Key>\r\n              <Value>1<\/Value>\r\n            <\/KeyValuePairOfInt32Int32>\r\n            <KeyValuePairOfInt32Int32>\r\n              <Key>2<\/Key>\r\n              <Value>2<\/Value>\r\n            <\/KeyValuePairOfInt32Int32>\r\n            <KeyValuePairOfInt32Int32>\r\n              <Key>3<\/Key>\r\n              <Value>3<\/Value>\r\n            <\/KeyValuePairOfInt32Int32>\r\n            <KeyValuePairOfInt32Int32>\r\n              <Key>4<\/Key>\r\n              <Value>4<\/Value>\r\n            <\/KeyValuePairOfInt32Int32>\r\n          <\/Value>\r\n        <\/KeyValuePairOfDoubleDictionaryOfInt32Int32>\r\n        <KeyValuePairOfDoubleDictionaryOfInt32Int32>\r\n          <Key>3.14<\/Key>\r\n          <Value>\r\n            <KeyValuePairOfInt32Int32>\r\n              <Key>9<\/Key>\r\n              <Value>1<\/Value>\r\n            <\/KeyValuePairOfInt32Int32>\r\n            <KeyValuePairOfInt32Int32>\r\n              <Key>8<\/Key>\r\n              <Value>2<\/Value>\r\n            <\/KeyValuePairOfInt32Int32>\r\n          <\/Value>\r\n        <\/KeyValuePairOfDoubleDictionaryOfInt32Int32>\r\n      <\/Key>\r\n      <Value>\r\n        <KeyValuePairOfDictionaryOfStringStringListOfDouble>\r\n          <Key>\r\n            <KeyValuePairOfStringString>\r\n              <Key>Test<\/Key>\r\n              <Value>123<\/Value>\r\n            <\/KeyValuePairOfStringString>\r\n            <KeyValuePairOfStringString>\r\n              <Key>Test2<\/Key>\r\n              <Value>456<\/Value>\r\n            <\/KeyValuePairOfStringString>\r\n          <\/Key>\r\n          <Value>\r\n            <Double>0.98767<\/Double>\r\n            <Double>232<\/Double>\r\n            <Double>13.124<\/Double>\r\n          <\/Value>\r\n        <\/KeyValuePairOfDictionaryOfStringStringListOfDouble>\r\n        <KeyValuePairOfDictionaryOfStringStringListOfDouble>\r\n          <Key>\r\n            <KeyValuePairOfStringString>\r\n              <Key>Num1<\/Key>\r\n              <Value>123<\/Value>\r\n            <\/KeyValuePairOfStringString>\r\n            <KeyValuePairOfStringString>\r\n              <Key>Num2<\/Key>\r\n              <Value>456<\/Value>\r\n            <\/KeyValuePairOfStringString>\r\n          <\/Key>\r\n          <Value>\r\n            <Double>9.8767<\/Double>\r\n            <Double>23.2<\/Double>\r\n            <Double>1.34<\/Double>\r\n          <\/Value>\r\n        <\/KeyValuePairOfDictionaryOfStringStringListOfDouble>\r\n      <\/Value>\r\n    <\/KeyValuePairOfDictionaryOfDoubleDictionaryOfInt32Int32DictionaryOfDictionaryOfStringStringListOfDouble>\r\n  <\/SomeDic>\r\n<\/NestedDicSample>\";\r\n            var serializer = new YAXSerializer(typeof(NestedDicSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(NestedDicSample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void GuidDemoTest()\r\n        {\r\n            Guid g1 = Guid.NewGuid();\r\n            Guid g2 = Guid.NewGuid();\r\n            Guid g3 = Guid.NewGuid();\r\n            Guid g4 = Guid.NewGuid();\r\n\r\n            string result = String.Format(\r\n@\"<!-- This example shows serialization and deserialization of GUID obejcts -->\r\n<GUIDTest>\r\n  <StandaloneGuid>{3}<\/StandaloneGuid>\r\n  <SomeDic>\r\n    <KeyValuePairOfGuidInt32>\r\n      <Key>{0}<\/Key>\r\n      <Value>1<\/Value>\r\n    <\/KeyValuePairOfGuidInt32>\r\n    <KeyValuePairOfGuidInt32>\r\n      <Key>{1}<\/Key>\r\n      <Value>2<\/Value>\r\n    <\/KeyValuePairOfGuidInt32>\r\n    <KeyValuePairOfGuidInt32>\r\n      <Key>{2}<\/Key>\r\n      <Value>3<\/Value>\r\n    <\/KeyValuePairOfGuidInt32>\r\n  <\/SomeDic>\r\n<\/GUIDTest>\", g1.ToString(), g2.ToString(), g3.ToString(), g4.ToString());\r\n            var serializer = new YAXSerializer(typeof(GUIDTest), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(GUIDTest.GetSampleInstance(g1,g2,g3,g4));\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void NullableTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This exmaple shows the usage of nullable fields -->\r\n<NullableClass>\r\n  <Title>Inside C#<\/Title>\r\n  <PublishYear>2002<\/PublishYear>\r\n  <PurchaseYear \/>\r\n<\/NullableClass>\";\r\n            var serializer = new YAXSerializer(typeof(NullableClass), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(NullableClass.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void NullableSample2Test()\r\n        {\r\n            const string result =\r\n@\"<NullableSample2 Number=\"\"10\"\">\r\n  <DateTime>1980-04-11T13:37:01.2345678Z<\/DateTime>\r\n  <Decimal>1234.56789<\/Decimal>\r\n  <Boolean>True<\/Boolean>\r\n  <Enum>Third<\/Enum>\r\n<\/NullableSample2>\";\r\n            var serializer = new YAXSerializer(typeof(NullableSample2), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(NullableSample2.GetSampleInstance());\r\n\r\n            Console.WriteLine(got);\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n\r\n        [Test]\r\n        public void ListHolderClassTest()\r\n        {\r\n            const string result =\r\n@\"<ListHolderClass>\r\n  <ListOfStrings>\r\n    <String>Hi<\/String>\r\n    <String>Hello<\/String>\r\n  <\/ListOfStrings>\r\n<\/ListHolderClass>\";\r\n            var serializer = new YAXSerializer(typeof(ListHolderClass), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(ListHolderClass.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void StandaloneListTest()\r\n        {\r\n            const string result =\r\n@\"<ListOfString>\r\n  <String>Hi<\/String>\r\n  <String>Hello<\/String>\r\n<\/ListOfString>\";\r\n            var serializer = new YAXSerializer(ListHolderClass.GetSampleInstance().ListOfStrings.GetType(), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(ListHolderClass.GetSampleInstance().ListOfStrings);\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void NamesExampleTest()\r\n        {\r\n            const string result =\r\n@\"<NamesExample>\r\n  <FirstName>Li<\/FirstName>\r\n  <Persons>\r\n    <PersonInfo>\r\n      <FirstName>Li<\/FirstName>\r\n      <LastName \/>\r\n    <\/PersonInfo>\r\n    <PersonInfo>\r\n      <FirstName>Hu<\/FirstName>\r\n      <LastName>Hu<\/LastName>\r\n    <\/PersonInfo>\r\n  <\/Persons>\r\n<\/NamesExample>\";\r\n            var serializer = new YAXSerializer(typeof(NamesExample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(NamesExample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void RequestTest()\r\n        {\r\n            const string result =\r\n@\"<Pricing id=\"\"123\"\">\r\n  <version major=\"\"1\"\" minor=\"\"0\"\" \/>\r\n  <input>\r\n    <value_date>2010-10-5<\/value_date>\r\n    <storage_date>2010-10-5<\/storage_date>\r\n    <user>me<\/user>\r\n    <skylab_config>\r\n      <SomeString>someconf<\/SomeString>\r\n      <job>test<\/job>\r\n    <\/skylab_config>\r\n  <\/input>\r\n<\/Pricing>\";\r\n            var serializer = new YAXSerializer(typeof(Request), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(Request.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void AudioSampleTest()\r\n        {\r\n            const string result =\r\n@\"<AudioSample>\r\n  <Audio FileName=\"\"filesname.jpg\"\">base64<\/Audio>\r\n  <Image FileName=\"\"filesname.jpg\"\">base64<\/Image>\r\n<\/AudioSample>\";\r\n            var serializer = new YAXSerializer(typeof(AudioSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(AudioSample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void TimeSpanTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example shows serialization and deserialization of TimeSpan obejcts -->\r\n<TimeSpanSample>\r\n  <TheTimeSpan>2.03:45:02.3000000<\/TheTimeSpan>\r\n  <AnotherTimeSpan>2.03:45:02.3000000<\/AnotherTimeSpan>\r\n  <DicTimeSpans>\r\n    <KeyValuePairOfTimeSpanInt32>\r\n      <Key>2.03:45:02.3000000<\/Key>\r\n      <Value>1<\/Value>\r\n    <\/KeyValuePairOfTimeSpanInt32>\r\n    <KeyValuePairOfTimeSpanInt32>\r\n      <Key>3.01:40:01.2000000<\/Key>\r\n      <Value>2<\/Value>\r\n    <\/KeyValuePairOfTimeSpanInt32>\r\n  <\/DicTimeSpans>\r\n<\/TimeSpanSample>\";\r\n            var serializer = new YAXSerializer(typeof(TimeSpanSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(TimeSpanSample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n\r\n        [Test]\r\n        public void FieldSerializationSampleTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example shows how to choose the fields to be serialized -->\r\n<FieldSerializationExample>\r\n  <SomePrivateStringProperty>Hi<\/SomePrivateStringProperty>\r\n  <m_someInt>8<\/m_someInt>\r\n  <m_someDouble>3.14<\/m_someDouble>\r\n<\/FieldSerializationExample>\";\r\n            var serializer = new YAXSerializer(typeof(FieldSerializationExample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(FieldSerializationExample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void MoreComplexBookTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example shows how to provide serialization address -->\r\n<!-- for elements and attributes. Theses addresses resemble those used -->\r\n<!-- in known file-systems -->\r\n<MoreComplexBook>\r\n  <SomeTag>\r\n    <SomeOtherTag>\r\n      <AndSo Title=\"\"Inside C#\"\">\r\n        <Author>Tom Archer &amp; Andrew Whitechapel<\/Author>\r\n      <\/AndSo>\r\n    <\/SomeOtherTag>\r\n  <\/SomeTag>\r\n  <PublishYear>2002<\/PublishYear>\r\n  <Price>30.5<\/Price>\r\n<\/MoreComplexBook>\";\r\n            var serializer = new YAXSerializer(typeof(MoreComplexBook), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(MoreComplexBook.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void MoreComplexBookTwoTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This class shows how members of nested objects -->\r\n<!-- can be serialized in their parents using serialization -->\r\n<!-- addresses including \"\"..\"\" -->\r\n<MoreComplexBook2 Author_s_Name=\"\"Tom Archer\"\">\r\n  <Title>Inside C#<\/Title>\r\n  <Something>\r\n    <Or>\r\n      <Another>\r\n        <Author_s_Age>30<\/Author_s_Age>\r\n      <\/Another>\r\n    <\/Or>\r\n  <\/Something>\r\n  <PublishYear>2002<\/PublishYear>\r\n  <Price>30.5<\/Price>\r\n<\/MoreComplexBook2>\";\r\n            var serializer = new YAXSerializer(typeof(MoreComplexBook2), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(MoreComplexBook2.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void MoreComplexBookThreeTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example shows how to serialize collection objects while -->\r\n<!-- not serializing the element for their enclosing collection itself -->\r\n<MoreComplexBook3>\r\n  <Title>Inside C#<\/Title>\r\n  <!-- Comment for author -->\r\n  <PublishYear AuthorName=\"\"Tom Archer\"\">2002<\/PublishYear>\r\n  <AuthorAge>30<\/AuthorAge>\r\n  <Price>30.5<\/Price>\r\n  <Editor>Mark Twain<\/Editor>\r\n  <Editor>Timothy Jones<\/Editor>\r\n  <Editor>Oliver Twist<\/Editor>\r\n<\/MoreComplexBook3>\";\r\n            var serializer = new YAXSerializer(typeof(MoreComplexBook3), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(MoreComplexBook3.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void WarehouseWithDictionaryNoContainerTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example shows how dictionary objects can be serialized without -->\r\n<!-- their enclosing element -->\r\n<WarehouseWithDictionaryNoContainer Name=\"\"Foo Warehousing Ltd.\"\">\r\n  <SiteInfo address=\"\"No. 10, Some Ave., Some City, Some Country\"\">\r\n    <SurfaceArea>120000.5<\/SurfaceArea>\r\n  <\/SiteInfo>\r\n  <StoreableItems>Item3, Item6, Item9, Item12<\/StoreableItems>\r\n  <ItemInfo Item=\"\"Item3\"\" Count=\"\"10\"\" \/>\r\n  <ItemInfo Item=\"\"Item6\"\" Count=\"\"120\"\" \/>\r\n  <ItemInfo Item=\"\"Item9\"\" Count=\"\"600\"\" \/>\r\n  <ItemInfo Item=\"\"Item12\"\" Count=\"\"25\"\" \/>\r\n<\/WarehouseWithDictionaryNoContainer>\";\r\n            var serializer = new YAXSerializer(typeof(WarehouseWithDictionaryNoContainer), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(WarehouseWithDictionaryNoContainer.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void WarehouseWithCommentsTest()\r\n        {\r\n            const string result =\r\n@\"<WarehouseWithComments>\r\n  <foo>\r\n    <bar>\r\n      <one>\r\n        <two>\r\n          <!-- Comment for name -->\r\n          <Name>Foo Warehousing Ltd.<\/Name>\r\n        <\/two>\r\n        <!-- Comment for OwnerName -->\r\n        <OwnerName>John Doe<\/OwnerName>\r\n      <\/one>\r\n    <\/bar>\r\n  <\/foo>\r\n  <SiteInfo address=\"\"No. 10, Some Ave., Some City, Some Country\"\">\r\n    <SurfaceArea>120000.5<\/SurfaceArea>\r\n  <\/SiteInfo>\r\n  <StoreableItems>Item3, Item6, Item9, Item12<\/StoreableItems>\r\n  <!-- This dictionary is serilaized without container -->\r\n  <ItemInfo Item=\"\"Item3\"\" Count=\"\"10\"\" \/>\r\n  <ItemInfo Item=\"\"Item6\"\" Count=\"\"120\"\" \/>\r\n  <ItemInfo Item=\"\"Item9\"\" Count=\"\"600\"\" \/>\r\n  <ItemInfo Item=\"\"Item12\"\" Count=\"\"25\"\" \/>\r\n<\/WarehouseWithComments>\";\r\n            var serializer = new YAXSerializer(typeof(WarehouseWithComments), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(WarehouseWithComments.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void EnumsSampleTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example shows how to define aliases for enum members -->\r\n<EnumsSample OneInstance=\"\"Spring, Summer\"\">\r\n  <TheSeasonSerially>Spring;Summer;Autumn or fall;Winter<\/TheSeasonSerially>\r\n  <TheSeasonRecursive>\r\n    <Seasons>Spring<\/Seasons>\r\n    <Seasons>Summer<\/Seasons>\r\n    <Seasons>Autumn or fall<\/Seasons>\r\n    <Seasons>Winter<\/Seasons>\r\n  <\/TheSeasonRecursive>\r\n  <DicSeasonToInt>\r\n    <KeyValuePairOfSeasonsInt32>\r\n      <Key>Spring<\/Key>\r\n      <Value>1<\/Value>\r\n    <\/KeyValuePairOfSeasonsInt32>\r\n    <KeyValuePairOfSeasonsInt32>\r\n      <Key>Summer<\/Key>\r\n      <Value>2<\/Value>\r\n    <\/KeyValuePairOfSeasonsInt32>\r\n    <KeyValuePairOfSeasonsInt32>\r\n      <Key>Autumn or fall<\/Key>\r\n      <Value>3<\/Value>\r\n    <\/KeyValuePairOfSeasonsInt32>\r\n    <KeyValuePairOfSeasonsInt32>\r\n      <Key>Winter<\/Key>\r\n      <Value>4<\/Value>\r\n    <\/KeyValuePairOfSeasonsInt32>\r\n  <\/DicSeasonToInt>\r\n  <DicIntToSeason>\r\n    <KeyValuePairOfInt32Seasons>\r\n      <Key>1<\/Key>\r\n      <Value>Spring<\/Value>\r\n    <\/KeyValuePairOfInt32Seasons>\r\n    <KeyValuePairOfInt32Seasons>\r\n      <Key>2<\/Key>\r\n      <Value>Spring, Summer<\/Value>\r\n    <\/KeyValuePairOfInt32Seasons>\r\n    <KeyValuePairOfInt32Seasons>\r\n      <Key>3<\/Key>\r\n      <Value>Autumn or fall<\/Value>\r\n    <\/KeyValuePairOfInt32Seasons>\r\n    <KeyValuePairOfInt32Seasons>\r\n      <Key>4<\/Key>\r\n      <Value>Winter<\/Value>\r\n    <\/KeyValuePairOfInt32Seasons>\r\n  <\/DicIntToSeason>\r\n<\/EnumsSample>\";\r\n            var serializer = new YAXSerializer(typeof(EnumsSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(EnumsSample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void MultiDimArraySampleTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example shows serialization of multi-dimensional, -->\r\n<!-- and jagged arrays -->\r\n<MultiDimArraySample xmlns:yaxlib=\"\"http:\/\/www.sinairv.com\/yaxlib\/\"\">\r\n  <IntArray yaxlib:dims=\"\"2,3\"\">\r\n    <Int32>1<\/Int32>\r\n    <Int32>2<\/Int32>\r\n    <Int32>3<\/Int32>\r\n    <Int32>2<\/Int32>\r\n    <Int32>3<\/Int32>\r\n    <Int32>4<\/Int32>\r\n  <\/IntArray>\r\n  <DoubleArray yaxlib:dims=\"\"2,3,3\"\">\r\n    <Double>2<\/Double>\r\n    <Double>0.666666666666667<\/Double>\r\n    <Double>0.4<\/Double>\r\n    <Double>2<\/Double>\r\n    <Double>0.666666666666667<\/Double>\r\n    <Double>0.4<\/Double>\r\n    <Double>2<\/Double>\r\n    <Double>0.666666666666667<\/Double>\r\n    <Double>0.4<\/Double>\r\n    <Double>2<\/Double>\r\n    <Double>0.666666666666667<\/Double>\r\n    <Double>0.4<\/Double>\r\n    <Double>4<\/Double>\r\n    <Double>1.33333333333333<\/Double>\r\n    <Double>0.8<\/Double>\r\n    <Double>6<\/Double>\r\n    <Double>2<\/Double>\r\n    <Double>1.2<\/Double>\r\n  <\/DoubleArray>\r\n  <JaggedArray>\r\n    <Array1OfInt32>\r\n      <Int32>1<\/Int32>\r\n      <Int32>2<\/Int32>\r\n    <\/Array1OfInt32>\r\n    <Array1OfInt32>\r\n      <Int32>1<\/Int32>\r\n      <Int32>2<\/Int32>\r\n      <Int32>3<\/Int32>\r\n      <Int32>4<\/Int32>\r\n    <\/Array1OfInt32>\r\n    <Array1OfInt32>\r\n      <Int32>1<\/Int32>\r\n      <Int32>2<\/Int32>\r\n      <Int32>3<\/Int32>\r\n      <Int32>4<\/Int32>\r\n      <Int32>5<\/Int32>\r\n      <Int32>6<\/Int32>\r\n    <\/Array1OfInt32>\r\n  <\/JaggedArray>\r\n  <!-- The containing element should not disappear because of the dims attribute -->\r\n  <IntArrayNoContainingElems yaxlib:dims=\"\"2,3\"\">\r\n    <Int32>1<\/Int32>\r\n    <Int32>2<\/Int32>\r\n    <Int32>3<\/Int32>\r\n    <Int32>2<\/Int32>\r\n    <Int32>3<\/Int32>\r\n    <Int32>4<\/Int32>\r\n  <\/IntArrayNoContainingElems>\r\n  <!-- This element should not be serialized serially because each element is not of basic type -->\r\n  <JaggedNotSerially>\r\n    <Array1OfInt32>\r\n      <Int32>1<\/Int32>\r\n      <Int32>2<\/Int32>\r\n    <\/Array1OfInt32>\r\n    <Array1OfInt32>\r\n      <Int32>1<\/Int32>\r\n      <Int32>2<\/Int32>\r\n      <Int32>3<\/Int32>\r\n      <Int32>4<\/Int32>\r\n    <\/Array1OfInt32>\r\n    <Array1OfInt32>\r\n      <Int32>1<\/Int32>\r\n      <Int32>2<\/Int32>\r\n      <Int32>3<\/Int32>\r\n      <Int32>4<\/Int32>\r\n      <Int32>5<\/Int32>\r\n      <Int32>6<\/Int32>\r\n    <\/Array1OfInt32>\r\n  <\/JaggedNotSerially>\r\n<\/MultiDimArraySample>\";\r\n            var serializer = new YAXSerializer(typeof(MultiDimArraySample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(MultiDimArraySample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void AnotherArraySampleTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example shows usage of jagged multi-dimensional arrays -->\r\n<AnotherArraySample xmlns:yaxlib=\"\"http:\/\/www.sinairv.com\/yaxlib\/\"\">\r\n  <Array1>\r\n    <Array2OfInt32 yaxlib:dims=\"\"2,3\"\">\r\n      <Int32>1<\/Int32>\r\n      <Int32>1<\/Int32>\r\n      <Int32>1<\/Int32>\r\n      <Int32>1<\/Int32>\r\n      <Int32>2<\/Int32>\r\n      <Int32>3<\/Int32>\r\n    <\/Array2OfInt32>\r\n    <Array2OfInt32 yaxlib:dims=\"\"3,2\"\">\r\n      <Int32>3<\/Int32>\r\n      <Int32>3<\/Int32>\r\n      <Int32>3<\/Int32>\r\n      <Int32>4<\/Int32>\r\n      <Int32>3<\/Int32>\r\n      <Int32>5<\/Int32>\r\n    <\/Array2OfInt32>\r\n  <\/Array1>\r\n<\/AnotherArraySample>\";\r\n            var serializer = new YAXSerializer(typeof(AnotherArraySample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(AnotherArraySample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n\r\n        [Test]\r\n        public void CollectionOfInterfacesSampleTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example shows serialization and deserialization of -->\r\n<!-- objects through a reference to their base class or interface -->\r\n<CollectionOfInterfacesSample xmlns:yaxlib=\"\"http:\/\/www.sinairv.com\/yaxlib\/\"\">\r\n  <SingleRef yaxlib:realtype=\"\"YAXLibTests.SampleClasses.Class2\"\">\r\n    <IntInInterface>22<\/IntInInterface>\r\n    <StringInClass2>SingleRef<\/StringInClass2>\r\n  <\/SingleRef>\r\n  <ListOfSamples>\r\n    <Class1 yaxlib:realtype=\"\"YAXLibTests.SampleClasses.Class1\"\">\r\n      <IntInInterface>1<\/IntInInterface>\r\n      <DoubleInClass1>1<\/DoubleInClass1>\r\n    <\/Class1>\r\n    <Class2 yaxlib:realtype=\"\"YAXLibTests.SampleClasses.Class2\"\">\r\n      <IntInInterface>2<\/IntInInterface>\r\n      <StringInClass2>Class2<\/StringInClass2>\r\n    <\/Class2>\r\n    <Class3_1 yaxlib:realtype=\"\"YAXLibTests.SampleClasses.Class3_1\"\">\r\n      <StringInClass3_1>Class3_1<\/StringInClass3_1>\r\n      <IntInInterface>3<\/IntInInterface>\r\n      <DoubleInClass1>3<\/DoubleInClass1>\r\n    <\/Class3_1>\r\n  <\/ListOfSamples>\r\n  <DictSample2Int>\r\n    <KeyValuePairOfISampleInt32>\r\n      <Key yaxlib:realtype=\"\"YAXLibTests.SampleClasses.Class1\"\">\r\n        <IntInInterface>1<\/IntInInterface>\r\n        <DoubleInClass1>1<\/DoubleInClass1>\r\n      <\/Key>\r\n      <Value>1<\/Value>\r\n    <\/KeyValuePairOfISampleInt32>\r\n    <KeyValuePairOfISampleInt32>\r\n      <Key yaxlib:realtype=\"\"YAXLibTests.SampleClasses.Class2\"\">\r\n        <IntInInterface>2<\/IntInInterface>\r\n        <StringInClass2>Class2<\/StringInClass2>\r\n      <\/Key>\r\n      <Value>2<\/Value>\r\n    <\/KeyValuePairOfISampleInt32>\r\n    <KeyValuePairOfISampleInt32>\r\n      <Key yaxlib:realtype=\"\"YAXLibTests.SampleClasses.Class3_1\"\">\r\n        <StringInClass3_1>Class3_1<\/StringInClass3_1>\r\n        <IntInInterface>3<\/IntInInterface>\r\n        <DoubleInClass1>3<\/DoubleInClass1>\r\n      <\/Key>\r\n      <Value>3<\/Value>\r\n    <\/KeyValuePairOfISampleInt32>\r\n  <\/DictSample2Int>\r\n  <DictInt2Sample>\r\n    <KeyValuePairOfInt32ISample>\r\n      <Key>1<\/Key>\r\n      <Value yaxlib:realtype=\"\"YAXLibTests.SampleClasses.Class1\"\">\r\n        <IntInInterface>1<\/IntInInterface>\r\n        <DoubleInClass1>1<\/DoubleInClass1>\r\n      <\/Value>\r\n    <\/KeyValuePairOfInt32ISample>\r\n    <KeyValuePairOfInt32ISample>\r\n      <Key>2<\/Key>\r\n      <Value yaxlib:realtype=\"\"YAXLibTests.SampleClasses.Class2\"\">\r\n        <IntInInterface>2<\/IntInInterface>\r\n        <StringInClass2>Class2<\/StringInClass2>\r\n      <\/Value>\r\n    <\/KeyValuePairOfInt32ISample>\r\n    <KeyValuePairOfInt32ISample>\r\n      <Key>3<\/Key>\r\n      <Value yaxlib:realtype=\"\"YAXLibTests.SampleClasses.Class3_1\"\">\r\n        <StringInClass3_1>Class3_1<\/StringInClass3_1>\r\n        <IntInInterface>3<\/IntInInterface>\r\n        <DoubleInClass1>3<\/DoubleInClass1>\r\n      <\/Value>\r\n    <\/KeyValuePairOfInt32ISample>\r\n  <\/DictInt2Sample>\r\n<\/CollectionOfInterfacesSample>\";\r\n            var serializer = new YAXSerializer(typeof(CollectionOfInterfacesSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(CollectionOfInterfacesSample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void MultipleCommentsTestTest()\r\n        {\r\n            const string result =\r\n@\"<!-- How multi-line comments are serialized as multiple XML comments -->\r\n<MultipleCommentsTest>\r\n  <!-- Using @ quoted style -->\r\n  <!-- comments for multiline comments -->\r\n  <Dummy>0<\/Dummy>\r\n  <!-- Comment 1 for member -->\r\n  <!-- Comment 2 for member -->\r\n  <SomeInt>10<\/SomeInt>\r\n<\/MultipleCommentsTest>\";\r\n            var serializer = new YAXSerializer(typeof(MultipleCommentsTest), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(MultipleCommentsTest.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void InterfaceMatchingSampleTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This example shows serialization and deserialization of objects -->\r\n<!-- through a reference to their base class or interface while used in -->\r\n<!-- collection classes -->\r\n<InterfaceMatchingSample SomeNumber=\"\"10\"\">\r\n  <ListOfSamples>2 4 8<\/ListOfSamples>\r\n  <DictNullable2Int>\r\n    <KeyValuePairOfNullableOfDoubleInt32 Key=\"\"1\"\" Value=\"\"1\"\" \/>\r\n    <KeyValuePairOfNullableOfDoubleInt32 Key=\"\"2\"\" Value=\"\"2\"\" \/>\r\n    <KeyValuePairOfNullableOfDoubleInt32 Key=\"\"3\"\" Value=\"\"3\"\" \/>\r\n  <\/DictNullable2Int>\r\n  <DictInt2Nullable>\r\n    <KeyValuePairOfInt32NullableOfDouble Key=\"\"1\"\" Value=\"\"1\"\" \/>\r\n    <KeyValuePairOfInt32NullableOfDouble Key=\"\"2\"\" Value=\"\"2\"\" \/>\r\n    <KeyValuePairOfInt32NullableOfDouble Key=\"\"3\"\" Value=\"\"\"\" \/>\r\n  <\/DictInt2Nullable>\r\n<\/InterfaceMatchingSample>\";\r\n            var serializer = new YAXSerializer(typeof(InterfaceMatchingSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(InterfaceMatchingSample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void NonGenericCollectionsSampleTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This sample demonstrates serialization of non-generic collection classes -->\r\n<NonGenericCollectionsSample xmlns:yaxlib=\"\"http:\/\/www.sinairv.com\/yaxlib\/\"\">\r\n  <ObjList Author_s_Name=\"\"Charles\"\">\r\n    <Int32 yaxlib:realtype=\"\"System.Int32\"\">1<\/Int32>\r\n    <Double yaxlib:realtype=\"\"System.Double\"\">3<\/Double>\r\n    <String yaxlib:realtype=\"\"System.String\"\">Hello<\/String>\r\n    <DateTime yaxlib:realtype=\"\"System.DateTime\"\">03\/04\/2010 00:00:00<\/DateTime>\r\n    <Something>\r\n      <Or>\r\n        <Another>\r\n          <Author_s_Age>50<\/Author_s_Age>\r\n        <\/Another>\r\n      <\/Or>\r\n    <\/Something>\r\n    <Author yaxlib:realtype=\"\"YAXLibTests.SampleClasses.Author\"\" \/>\r\n  <\/ObjList>\r\n  <TheArrayList Author_s_Name=\"\"Steve\"\">\r\n    <Int32 yaxlib:realtype=\"\"System.Int32\"\">2<\/Int32>\r\n    <Double yaxlib:realtype=\"\"System.Double\"\">8.5<\/Double>\r\n    <String yaxlib:realtype=\"\"System.String\"\">Hi<\/String>\r\n    <Something>\r\n      <Or>\r\n        <Another>\r\n          <Author_s_Age>30<\/Author_s_Age>\r\n        <\/Another>\r\n      <\/Or>\r\n    <\/Something>\r\n    <Author yaxlib:realtype=\"\"YAXLibTests.SampleClasses.Author\"\" \/>\r\n  <\/TheArrayList>\r\n  <TheHashtable>\r\n{0}\r\n{1}\r\n  <\/TheHashtable>\r\n  <TheQueue>\r\n    <Int32 yaxlib:realtype=\"\"System.Int32\"\">10<\/Int32>\r\n    <Int32 yaxlib:realtype=\"\"System.Int32\"\">20<\/Int32>\r\n    <Int32 yaxlib:realtype=\"\"System.Int32\"\">30<\/Int32>\r\n  <\/TheQueue>\r\n  <TheStack>\r\n    <Int32 yaxlib:realtype=\"\"System.Int32\"\">300<\/Int32>\r\n    <Int32 yaxlib:realtype=\"\"System.Int32\"\">200<\/Int32>\r\n    <Int32 yaxlib:realtype=\"\"System.Int32\"\">100<\/Int32>\r\n  <\/TheStack>\r\n  <TheSortedList>\r\n    <DictionaryEntry yaxlib:realtype=\"\"System.Collections.DictionaryEntry\"\">\r\n      <Key yaxlib:realtype=\"\"System.Int32\"\">1<\/Key>\r\n      <Value yaxlib:realtype=\"\"System.Int32\"\">2<\/Value>\r\n    <\/DictionaryEntry>\r\n    <DictionaryEntry yaxlib:realtype=\"\"System.Collections.DictionaryEntry\"\">\r\n      <Key yaxlib:realtype=\"\"System.Int32\"\">5<\/Key>\r\n      <Value yaxlib:realtype=\"\"System.Int32\"\">7<\/Value>\r\n    <\/DictionaryEntry>\r\n    <DictionaryEntry yaxlib:realtype=\"\"System.Collections.DictionaryEntry\"\">\r\n      <Key yaxlib:realtype=\"\"System.Int32\"\">8<\/Key>\r\n      <Value yaxlib:realtype=\"\"System.Int32\"\">2<\/Value>\r\n    <\/DictionaryEntry>\r\n  <\/TheSortedList>\r\n  <TheBitArray>\r\n    <Boolean yaxlib:realtype=\"\"System.Boolean\"\">False<\/Boolean>\r\n    <Boolean yaxlib:realtype=\"\"System.Boolean\"\">True<\/Boolean>\r\n    <Boolean yaxlib:realtype=\"\"System.Boolean\"\">False<\/Boolean>\r\n    <Boolean yaxlib:realtype=\"\"System.Boolean\"\">False<\/Boolean>\r\n    <Boolean yaxlib:realtype=\"\"System.Boolean\"\">False<\/Boolean>\r\n    <Boolean yaxlib:realtype=\"\"System.Boolean\"\">False<\/Boolean>\r\n    <Boolean yaxlib:realtype=\"\"System.Boolean\"\">True<\/Boolean>\r\n    <Boolean yaxlib:realtype=\"\"System.Boolean\"\">False<\/Boolean>\r\n    <Boolean yaxlib:realtype=\"\"System.Boolean\"\">False<\/Boolean>\r\n    <Boolean yaxlib:realtype=\"\"System.Boolean\"\">False<\/Boolean>\r\n  <\/TheBitArray>\r\n<\/NonGenericCollectionsSample>\";\r\n\r\n            string part1 = @\"    <DictionaryEntry yaxlib:realtype=\"\"System.Collections.DictionaryEntry\"\">\r\n      <Key yaxlib:realtype=\"\"System.DateTime\"\">02\/01\/2009 00:00:00<\/Key>\r\n      <Value yaxlib:realtype=\"\"System.Int32\"\">7<\/Value>\r\n    <\/DictionaryEntry>\";\r\n\r\n            string part2 = @\"    <DictionaryEntry yaxlib:realtype=\"\"System.Collections.DictionaryEntry\"\">\r\n      <Key yaxlib:realtype=\"\"System.String\"\">Tom<\/Key>\r\n      <Value yaxlib:realtype=\"\"System.String\"\">Sam<\/Value>\r\n    <\/DictionaryEntry>\r\n    <DictionaryEntry yaxlib:realtype=\"\"System.Collections.DictionaryEntry\"\">\r\n      <Key yaxlib:realtype=\"\"System.Double\"\">1<\/Key>\r\n      <Value yaxlib:realtype=\"\"System.String\"\">Tim<\/Value>\r\n    <\/DictionaryEntry>\";\r\n\r\n            string possibleResult1 = String.Format(result, part1, part2);\r\n            string possibleResult2 = String.Format(result, part2, part1);\r\n\r\n\r\n            var serializer = new YAXSerializer(typeof(NonGenericCollectionsSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(NonGenericCollectionsSample.GetSampleInstance());\r\n            \/\/result.ShouldEqualWithDiff(got, DiffStyle.Minimal);\r\n            bool result1Match = String.Equals(got, possibleResult1, StringComparison.Ordinal);\r\n            bool result2Match = String.Equals(got, possibleResult2, StringComparison.Ordinal);\r\n            Assert.That(result1Match || result2Match, Is.True);\r\n        }\r\n\r\n\r\n        [Test]\r\n        public void GenericCollectionsSampleTest()\r\n        {\r\n            const string result =\r\n@\"<!-- This class provides an example of successful serialization\/deserialization -->\r\n<!-- of collection objects in \"\"System.Collections.Generic\"\" namespaces -->\r\n<GenericCollectionsSample>\r\n  <TheStack>\r\n    <Int32>79<\/Int32>\r\n    <Int32>1<\/Int32>\r\n    <Int32>7<\/Int32>\r\n  <\/TheStack>\r\n  <TheSortedList>\r\n    <Item Key=\"\"0.5\"\" Value=\"\"Hello\"\" \/>\r\n    <Item Key=\"\"1\"\" Value=\"\"Hi\"\" \/>\r\n    <Item Key=\"\"5\"\" Value=\"\"How are you?\"\" \/>\r\n  <\/TheSortedList>\r\n  <TheSortedDictionary>\r\n    <Item Key=\"\"1\"\" Value=\"\"30\"\" \/>\r\n    <Item Key=\"\"5\"\" Value=\"\"2\"\" \/>\r\n    <Item Key=\"\"10\"\" Value=\"\"1\"\" \/>\r\n  <\/TheSortedDictionary>\r\n  <TheQueue>\r\n    <String>Hi<\/String>\r\n    <String>Hello<\/String>\r\n    <String>How are you?<\/String>\r\n  <\/TheQueue>\r\n  <TheHashSet>\r\n    <Int32>1<\/Int32>\r\n    <Int32>2<\/Int32>\r\n    <Int32>4<\/Int32>\r\n    <Int32>6<\/Int32>\r\n  <\/TheHashSet>\r\n  <TheLinkedList>\r\n    <Double>1<\/Double>\r\n    <Double>5<\/Double>\r\n    <Double>61<\/Double>\r\n  <\/TheLinkedList>\r\n<\/GenericCollectionsSample>\";\r\n\r\n            var serializer = new YAXSerializer(typeof(GenericCollectionsSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(GenericCollectionsSample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test] \r\n        public void SerializingPathAndAliasTogetherTest()\r\n        {\r\n            const string result = \r\n@\"<PathAndAliasAssignmentSample>\r\n  <Title value=\"\"Inside C#\"\" \/>\r\n  <Price value=\"\"30.5\"\" \/>\r\n  <Publish year=\"\"2002\"\" \/>\r\n  <Notes>\r\n    <Comments value=\"\"SomeComment\"\" \/>\r\n  <\/Notes>\r\n  <Author name=\"\"Tom Archer &amp; Andrew Whitechapel\"\" \/>\r\n<\/PathAndAliasAssignmentSample>\";\r\n            var serializer = new YAXSerializer(typeof(PathAndAliasAssignmentSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(PathAndAliasAssignmentSample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void CollectionSeriallyAsAttributeTest()\r\n        {\r\n            const string result =\r\n@\"<CollectionSeriallyAsAttribute>\r\n  <Info names=\"\"John Doe,Jane,Sina,Mike,Rich\"\" \/>\r\n  <TheCities>Tehran,Melbourne,New York,Paris<\/TheCities>\r\n  <Location>\r\n    <Countries>Iran,Australia,United States of America,France<\/Countries>\r\n  <\/Location>\r\n<\/CollectionSeriallyAsAttribute>\";\r\n            var serializer = new YAXSerializer(typeof(CollectionSeriallyAsAttribute), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(CollectionSeriallyAsAttribute.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n\r\n        [Test]\r\n        public void SerializationOptionsSampleTest()\r\n        {\r\n            const string resultWithSerializeNullRefs =\r\n@\"<SerializationOptionsSample>\r\n  <!-- Str2Null must NOT be serialized when it is null, even -->\r\n  <!-- if the serialization options of the serializer is changed -->\r\n  <ObjectWithOptionsSet>\r\n    <StrNotNull>SomeString<\/StrNotNull>\r\n    <SomeValueType>0<\/SomeValueType>\r\n  <\/ObjectWithOptionsSet>\r\n  <!-- Str2Null must be serialized when it is null, even -->\r\n  <!-- if the serialization options of the serializer is changed -->\r\n  <AnotherObjectWithOptionsSet>\r\n    <StrNotNull>Some other string<\/StrNotNull>\r\n    <StrNull \/>\r\n  <\/AnotherObjectWithOptionsSet>\r\n  <!-- serialization of Str2Null must obey the options set -->\r\n  <!-- in the serializer itself -->\r\n  <ObjectWithoutOptionsSet>\r\n    <StrNotNull>Another string<\/StrNotNull>\r\n    <StrNull \/>\r\n  <\/ObjectWithoutOptionsSet>\r\n<\/SerializationOptionsSample>\";\r\n\r\n            var serializer = new YAXSerializer(typeof(SerializationOptionsSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(SerializationOptionsSample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(resultWithSerializeNullRefs));\r\n\r\n            const string resultWithDontSerializeNullRefs =\r\n@\"<SerializationOptionsSample>\r\n  <!-- Str2Null must NOT be serialized when it is null, even -->\r\n  <!-- if the serialization options of the serializer is changed -->\r\n  <ObjectWithOptionsSet>\r\n    <StrNotNull>SomeString<\/StrNotNull>\r\n    <SomeValueType>0<\/SomeValueType>\r\n  <\/ObjectWithOptionsSet>\r\n  <!-- Str2Null must be serialized when it is null, even -->\r\n  <!-- if the serialization options of the serializer is changed -->\r\n  <AnotherObjectWithOptionsSet>\r\n    <StrNotNull>Some other string<\/StrNotNull>\r\n    <StrNull \/>\r\n  <\/AnotherObjectWithOptionsSet>\r\n  <!-- serialization of Str2Null must obey the options set -->\r\n  <!-- in the serializer itself -->\r\n  <ObjectWithoutOptionsSet>\r\n    <StrNotNull>Another string<\/StrNotNull>\r\n  <\/ObjectWithoutOptionsSet>\r\n<\/SerializationOptionsSample>\";\r\n\r\n            serializer = new YAXSerializer(typeof(SerializationOptionsSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.DontSerializeNullObjects);\r\n            got = serializer.Serialize(SerializationOptionsSample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(resultWithDontSerializeNullRefs));\r\n        }\r\n\r\n        [Test]\r\n        public void SerializeAClassContainingXElementItself()\r\n        {\r\n            var initialInstance = ClassContainingXElement.GetSampleInstance();\r\n            string initialInstanceString = initialInstance.ToString();\r\n\r\n            var ser = new YAXSerializer(typeof (ClassContainingXElement), YAXExceptionHandlingPolicies.DoNotThrow,\r\n                                        YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n\r\n            var initialXmlSer = ser.Serialize(initialInstance);\r\n\r\n            var initialInstDes = ser.Deserialize(initialXmlSer) as ClassContainingXElement;\r\n            Assert.That(initialInstDes, Is.Not.Null);\r\n            var initialInstDesString = initialInstDes.ToString();\r\n\r\n            Assert.That(initialInstDesString, Is.EqualTo(initialInstanceString));\r\n\r\n            initialInstance.TheElement = null;\r\n            string nulledElementString = initialInstance.ToString();\r\n\r\n            string nulledElemXmlSer = ser.Serialize(initialInstance);\r\n\r\n            var nulledInstanceDeser = ser.Deserialize(nulledElemXmlSer);\r\n            Assert.That(nulledInstanceDeser.ToString(), Is.EqualTo(nulledElementString));\r\n        }\r\n\r\n        [Test]\r\n        public void SerializaitonOfPropertylessClasses()\r\n        {\r\n            const string result =\r\n@\"<PropertylessClassesSample xmlns:yaxlib=\"\"http:\/\/www.sinairv.com\/yaxlib\/\"\">\r\n  <ValuedDbNull>DBNull<\/ValuedDbNull>\r\n  <NullDbNull \/>\r\n  <ObjValuedDbNull yaxlib:realtype=\"\"System.DBNull\"\">DBNull<\/ObjValuedDbNull>\r\n  <ObjNullDbNull \/>\r\n  <ValuedRandom \/>\r\n  <NullRandom \/>\r\n  <ObjValuedRandom yaxlib:realtype=\"\"System.Random\"\" \/>\r\n  <ObjNullRandom \/>\r\n<\/PropertylessClassesSample>\";\r\n            var serializer = new YAXSerializer(typeof(PropertylessClassesSample), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(PropertylessClassesSample.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void GuidsAsBasicTypeTest()\r\n        {\r\n            const string result =\r\n@\"<GuidAsBasicType GuidAsAttr=\"\"fed92f33-e351-47bd-9018-69c89928329e\"\">\r\n  <GuidAsElem>042ba99c-b679-4975-ac4d-2fe563a5dc3e<\/GuidAsElem>\r\n  <GuidArray>\r\n    <Guid>fed92f33-e351-47bd-9018-69c89928329e<\/Guid>\r\n    <Guid>042ba99c-b679-4975-ac4d-2fe563a5dc3e<\/Guid>\r\n    <Guid>82071c51-ea20-473b-a541-1ebdf8f158d3<\/Guid>\r\n    <Guid>81a3478b-5779-451a-b2aa-fbf69bb11424<\/Guid>\r\n    <Guid>d626ba2b-a095-4a34-a376-997e5628dfb9<\/Guid>\r\n  <\/GuidArray>\r\n  <GuidArraySerially>fed92f33-e351-47bd-9018-69c89928329e 042ba99c-b679-4975-ac4d-2fe563a5dc3e 82071c51-ea20-473b-a541-1ebdf8f158d3 81a3478b-5779-451a-b2aa-fbf69bb11424 d626ba2b-a095-4a34-a376-997e5628dfb9<\/GuidArraySerially>\r\n  <GuidsList>\r\n    <Guid>fed92f33-e351-47bd-9018-69c89928329e<\/Guid>\r\n    <Guid>042ba99c-b679-4975-ac4d-2fe563a5dc3e<\/Guid>\r\n    <Guid>82071c51-ea20-473b-a541-1ebdf8f158d3<\/Guid>\r\n    <Guid>81a3478b-5779-451a-b2aa-fbf69bb11424<\/Guid>\r\n    <Guid>d626ba2b-a095-4a34-a376-997e5628dfb9<\/Guid>\r\n  <\/GuidsList>\r\n  <DicKeyGuid>\r\n    <KeyValuePairOfGuidInt32>\r\n      <Key>fed92f33-e351-47bd-9018-69c89928329e<\/Key>\r\n      <Value>1<\/Value>\r\n    <\/KeyValuePairOfGuidInt32>\r\n    <KeyValuePairOfGuidInt32>\r\n      <Key>042ba99c-b679-4975-ac4d-2fe563a5dc3e<\/Key>\r\n      <Value>2<\/Value>\r\n    <\/KeyValuePairOfGuidInt32>\r\n    <KeyValuePairOfGuidInt32>\r\n      <Key>82071c51-ea20-473b-a541-1ebdf8f158d3<\/Key>\r\n      <Value>3<\/Value>\r\n    <\/KeyValuePairOfGuidInt32>\r\n  <\/DicKeyGuid>\r\n  <DicKeyAttrGuid>\r\n    <Pair TheGuid=\"\"fed92f33-e351-47bd-9018-69c89928329e\"\">\r\n      <Value>1<\/Value>\r\n    <\/Pair>\r\n    <Pair TheGuid=\"\"042ba99c-b679-4975-ac4d-2fe563a5dc3e\"\">\r\n      <Value>2<\/Value>\r\n    <\/Pair>\r\n    <Pair TheGuid=\"\"82071c51-ea20-473b-a541-1ebdf8f158d3\"\">\r\n      <Value>3<\/Value>\r\n    <\/Pair>\r\n  <\/DicKeyAttrGuid>\r\n  <DicValueGuid>\r\n    <KeyValuePairOfInt32Guid>\r\n      <Key>1<\/Key>\r\n      <Value>fed92f33-e351-47bd-9018-69c89928329e<\/Value>\r\n    <\/KeyValuePairOfInt32Guid>\r\n    <KeyValuePairOfInt32Guid>\r\n      <Key>2<\/Key>\r\n      <Value>82071c51-ea20-473b-a541-1ebdf8f158d3<\/Value>\r\n    <\/KeyValuePairOfInt32Guid>\r\n    <KeyValuePairOfInt32Guid>\r\n      <Key>3<\/Key>\r\n      <Value>d626ba2b-a095-4a34-a376-997e5628dfb9<\/Value>\r\n    <\/KeyValuePairOfInt32Guid>\r\n  <\/DicValueGuid>\r\n  <DicValueAttrGuid>\r\n    <Pair TheGuid=\"\"fed92f33-e351-47bd-9018-69c89928329e\"\">\r\n      <Key>1<\/Key>\r\n    <\/Pair>\r\n    <Pair TheGuid=\"\"82071c51-ea20-473b-a541-1ebdf8f158d3\"\">\r\n      <Key>2<\/Key>\r\n    <\/Pair>\r\n    <Pair TheGuid=\"\"d626ba2b-a095-4a34-a376-997e5628dfb9\"\">\r\n      <Key>3<\/Key>\r\n    <\/Pair>\r\n  <\/DicValueAttrGuid>\r\n<\/GuidAsBasicType>\";\r\n            var serializer = new YAXSerializer(typeof(GuidAsBasicType), YAXExceptionHandlingPolicies.DoNotThrow, YAXExceptionTypes.Warning, YAXSerializationOptions.SerializeNullObjects);\r\n            string got = serializer.Serialize(GuidAsBasicType.GetSampleInstance());\r\n            Assert.That(got, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void PolymorphicSerializationThroughObjectTest()\r\n        {\r\n            object content = \"this is just a simple test\";\r\n            var ser = new YAXSerializer(typeof(object));\r\n            string xmlResult = ser.Serialize(content);\r\n\r\n            string expectedResult = \r\n@\"<Object yaxlib:realtype=\"\"System.String\"\" xmlns:yaxlib=\"\"http:\/\/www.sinairv.com\/yaxlib\/\"\">this is just a simple test<\/Object>\";\r\n\r\n            Assert.That(xmlResult, Is.EqualTo(expectedResult));\r\n            var desObj = ser.Deserialize(xmlResult);\r\n            string objStr = desObj.ToString();\r\n            Assert.That(desObj.ToString(), Is.EqualTo(content.ToString()));\r\n        }\r\n\r\n        [Test]\r\n        public void PolymorphicSerializationThroughListTest()\r\n        {\r\n            var lst = new List<int> {1, 2, 3};\r\n            var ser = new YAXSerializer(typeof(object));\r\n            string xmlResult = ser.Serialize(lst);\r\n\r\n            string expectedResult = \r\n@\"<Object yaxlib:realtype=\"\"System.Collections.Generic.List`1[[System.Int32, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]\"\" xmlns:yaxlib=\"\"http:\/\/www.sinairv.com\/yaxlib\/\"\">\r\n  <Int32>1<\/Int32>\r\n  <Int32>2<\/Int32>\r\n  <Int32>3<\/Int32>\r\n<\/Object>\";\r\n\r\n            Assert.That(xmlResult, Is.EqualTo(expectedResult));\r\n            var desObj = ser.Deserialize(xmlResult);\r\n            Assert.That(desObj.GetType(), Is.EqualTo(lst.GetType()));\r\n            var desLst = desObj as List<int>;\r\n            Assert.That(lst, Has.Count.EqualTo(desLst.Count));\r\n            Assert.That(lst, Is.EquivalentTo(desLst));\r\n        }\r\n\r\n        [Test]\r\n        public void PolymorphicSerializationThroughListWhichMayContainYaxlibNamespaceTest()\r\n        {\r\n            var lst = new List<object> { 1, 2, 3 };\r\n            var ser = new YAXSerializer(typeof(object));\r\n            string xmlResult = ser.Serialize(lst);\r\n\r\n            string expectedResult =\r\n@\"<Object yaxlib:realtype=\"\"System.Collections.Generic.List`1[[System.Object, mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]\"\" xmlns:yaxlib=\"\"http:\/\/www.sinairv.com\/yaxlib\/\"\">\r\n  <Int32 yaxlib:realtype=\"\"System.Int32\"\">1<\/Int32>\r\n  <Int32 yaxlib:realtype=\"\"System.Int32\"\">2<\/Int32>\r\n  <Int32 yaxlib:realtype=\"\"System.Int32\"\">3<\/Int32>\r\n<\/Object>\";\r\n\r\n            Assert.That(xmlResult, Is.EqualTo(expectedResult));\r\n            var desObj = ser.Deserialize(xmlResult);\r\n            Assert.That(desObj.GetType(), Is.EqualTo(lst.GetType()));\r\n            var desLst = desObj as List<object>;\r\n            Assert.That(lst, Has.Count.EqualTo(desLst.Count));\r\n            Assert.That(lst, Is.EquivalentTo(desLst));\r\n        }\r\n\r\n        [Test]\r\n        public void DashPreservationTest()\r\n        {\r\n            const string expectedResult = @\"<dashed-sample dashed-name=\"\"Name\"\" \/>\";\r\n\r\n            DashedSample sample = new DashedSample\r\n            {\r\n                DashedName = \"Name\"\r\n            };\r\n\r\n            YAXSerializer ser = new YAXSerializer(typeof(DashedSample));\r\n            string got = ser.Serialize(sample);\r\n            Assert.That(got, Is.EqualTo(expectedResult));\r\n        }\r\n\r\n        [Test]\r\n        public void AttributeForClassTest()\r\n        {\r\n            var ser = new YAXSerializer(typeof(AttributeContainerSample));\r\n            string result = ser.Serialize(AttributeContainerSample.GetSampleInstance());\r\n\r\n            const string expectedResult =\r\n@\"<container>\r\n  <range from=\"\"1\"\" to=\"\"3\"\" \/>\r\n<\/container>\";\r\n\r\n            Assert.That(expectedResult, Is.EqualTo(result));\r\n        }\r\n\r\n\r\n        [Test]\r\n        public void DictionaryKeyValueAsContentTest()\r\n        {\r\n            var ser = new YAXSerializer(typeof(DictionaryKeyValueAsContent));\r\n            string result = ser.Serialize(DictionaryKeyValueAsContent.GetSampleInstance());\r\n\r\n            const string expectedResult =\r\n@\"<DictionaryKeyValueAsContent>\r\n  <DicValueAsContent>\r\n    <Pair Digits=\"\"1\"\">one<\/Pair>\r\n    <Pair Digits=\"\"2\"\">two<\/Pair>\r\n    <Pair Digits=\"\"3\"\">three<\/Pair>\r\n  <\/DicValueAsContent>\r\n  <DicKeyAsContnet>\r\n    <Pair Letters=\"\"one\"\">1<\/Pair>\r\n    <Pair Letters=\"\"two\"\">2<\/Pair>\r\n    <Pair Letters=\"\"three\"\">3<\/Pair>\r\n  <\/DicKeyAsContnet>\r\n  <DicKeyAsContentValueAsElement>\r\n    <Pair>1<Letters>one<\/Letters><\/Pair>\r\n    <Pair>2<Letters>two<\/Letters><\/Pair>\r\n    <Pair>3<Letters>three<\/Letters><\/Pair>\r\n  <\/DicKeyAsContentValueAsElement>\r\n  <DicValueAsContentKeyAsElement>\r\n    <Pair>\r\n      <Digits>1<\/Digits>one<\/Pair>\r\n    <Pair>\r\n      <Digits>2<\/Digits>two<\/Pair>\r\n    <Pair>\r\n      <Digits>3<\/Digits>three<\/Pair>\r\n  <\/DicValueAsContentKeyAsElement>\r\n<\/DictionaryKeyValueAsContent>\";\r\n            Assert.That(expectedResult, Is.EqualTo(result));\r\n        }\r\n\r\n        [Test]\r\n        public void AttributeForKeyInDictionaryTest()\r\n        {\r\n            var dictionary = DictionarySample.GetSampleInstance();\r\n            var ser = new YAXSerializer(typeof(DictionarySample));\r\n            string result = ser.Serialize(dictionary);\r\n            \r\n            const string expectedResult =\r\n@\"<TheItems xmlns=\"\"http:\/\/example.com\/\"\">\r\n  <TheItem TheKey=\"\"key1\"\">00000001-0002-0003-0405-060708090a0b<\/TheItem>\r\n  <TheItem TheKey=\"\"key2\"\">1234<\/TheItem>\r\n<\/TheItems>\";\r\n\r\n            Assert.AreEqual(expectedResult, result);\r\n        }\r\n\r\n        [Test]\r\n        public void AttributeForKeyInDictionaryPropertyTest()\r\n        {\r\n            var container = DictionaryContainerSample.GetSampleInstance();\r\n            var ser = new YAXSerializer(typeof(DictionaryContainerSample));\r\n            string result = ser.Serialize(container);\r\n\r\n            const string expectedResult =\r\n@\"<container xmlns=\"\"http:\/\/example.com\/\"\">\r\n  <items>\r\n    <item key=\"\"key1\"\">00000001-0002-0003-0405-060708090a0b<\/item>\r\n    <item key=\"\"key2\"\">1234<\/item>\r\n  <\/items>\r\n<\/container>\";\r\n\r\n            Assert.AreEqual(expectedResult, result);\r\n        }\r\n\r\n\r\n    }\r\n}\r\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"824a4c7a98289aedd3474893ab17d0566988229d","subject":"Remove signupbox id from register bx since then it can be hidden by the zk.showLoginBox function","message":"Remove signupbox id from register bx since then it can be hidden by the zk.showLoginBox function\n","repos":"erooijak\/oogstplanner,erooijak\/oogstplanner,erooijak\/oogstplanner,erooijak\/oogstplanner","old_file":"Zk\/Views\/Account\/Register.cshtml","new_file":"Zk\/Views\/Account\/Register.cshtml","new_contents":"\ufeff@{\n    ViewBag.Title = \"Registreer je vandaag bij de Oogstplanner\";\n}\n\n<div class=\"flowtype-area\">\n\n<!-- START RESPONSIVE RECTANGLE LAYOUT -->\n\n<!-- Top bar -->\n<div id=\"top\">\n<\/div>\n\n<!-- Fixed main screen -->\n<div id=\"login\" class=\"bg imglogin\">\n\t<div class=\"row\">\n \t\t<div class=\"mainbox col-md-12 col-sm-12 col-xs-12\">\n            <div class=\"panel panel-info\">\n                <div class=\"panel-heading\">\n                    <div class=\"panel-title\">Registreer je vandaag bij de Oogstplanner<\/div>\n                    <div class=\"panel-side-link\">\n                        <a id=\"signin-link\" href=\"#\">Inloggen<\/a>\n                    <\/div>\n                <\/div>  \n                <div class=\"panel-body\">\n                    @{ Html.RenderPartial(\"_RegisterForm\"); }\n\n                 <\/div><!-- End panel body -->\n            <\/div><!-- End panel -->\n        <\/div><!-- End signup box -->\n    <\/div><!-- End row -->\n<\/div><!-- End main login div -->\n\n<!-- END RESPONSIVE RECTANGLES LAYOUT -->\n\n<\/div><!-- End flowtype-area -->","old_contents":"\ufeff@{\n    ViewBag.Title = \"Registreer je vandaag bij de Oogstplanner\";\n}\n\n<div class=\"flowtype-area\">\n\n<!-- START RESPONSIVE RECTANGLE LAYOUT -->\n\n<!-- Top bar -->\n<div id=\"top\">\n    <h1>Registreer je vandaag bij de Oogstplanner<\/h1>\n<\/div>\n\n<!-- Fixed main screen -->\n<div id=\"login\" class=\"bg imglogin\">\n   \n    <!-- Signup box inspired by http:\/\/bootsnipp.com\/snippets\/featured\/login-amp-signup-forms-in-panel -->\n    <div id=\"signupbox\" class=\"mainbox span12\">\n        <div class=\"panel panel-info\">\n            <div class=\"panel-heading\">\n                <div class=\"panel-side-link\">\n                    <a id=\"signin-link form-text\" href=\"Login\">Inloggen<\/a>\n                <\/div>\n            <\/div>  \n            <div class=\"panel-body\">\n\n                @{ Html.RenderPartial(\"_RegisterForm\"); }\n\n             <\/div><!-- End panel body -->\n        <\/div><!-- End panel -->\n    <\/div><!-- End signup box -->\n\n<\/div><!-- End main login div -->\n\n<!-- END RESPONSIVE RECTANGLES LAYOUT -->\n\n<\/div><!-- End flowtype-area -->","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"b7f9209f44163aff278746ecda6c5e99acc964af","subject":"Updated InstancePerHttpRequest and InstancePerApiRequest in the Web, MVC and Web API integrations to accept additional lifetime scope tags.","message":"Updated InstancePerHttpRequest and InstancePerApiRequest in the Web, MVC and Web API integrations to accept additional lifetime scope tags.\n","repos":"dparra0007\/Autofac.Mvc,jango2015\/Autofac.Mvc,autofac\/Autofac.Mvc","old_file":"RegistrationExtensionsFixture.cs","new_file":"RegistrationExtensionsFixture.cs","new_contents":"\ufeffusing System;\r\nusing System.Linq;\r\nusing System.Reflection;\r\nusing System.Web.Mvc;\r\nusing Autofac.Builder;\r\nusing Autofac.Features.Metadata;\r\nusing Autofac.Integration.Mvc;\r\nusing NUnit.Framework;\r\n\r\nnamespace Autofac.Tests.Integration.Mvc\r\n{\r\n    [TestFixture]\r\n    public class RegistrationExtensionsFixture\r\n    {\r\n        [Test]\r\n        public void AdditionalLifetimeScopeTagsCanBeProvidedToInstancePerHttpRequest()\r\n        {\r\n            var builder = new ContainerBuilder();\r\n            const string tag1 = \"Tag1\";\r\n            const string tag2 = \"Tag2\";\r\n            builder.Register(c => new object()).InstancePerHttpRequest(tag1, tag2);\r\n\r\n            var container = builder.Build();\r\n\r\n            var scope1 = container.BeginLifetimeScope(tag1);\r\n            Assert.That(scope1.Resolve<object>(), Is.Not.Null);\r\n\r\n            var scope2 = container.BeginLifetimeScope(tag2);\r\n            Assert.That(scope2.Resolve<object>(), Is.Not.Null);\r\n\r\n            var requestScope = container.BeginLifetimeScope(RequestLifetimeScopeProvider.HttpRequestTag);\r\n            Assert.That(requestScope.Resolve<object>(), Is.Not.Null);\r\n        }\r\n\r\n        [Test]\r\n        public void RegisterModelBinderProviderThrowsExceptionForNullBuilder()\r\n        {\r\n            var exception = Assert.Throws<ArgumentNullException>(\r\n                () => Autofac.Integration.Mvc.RegistrationExtensions.RegisterModelBinderProvider(null));\r\n            Assert.That(exception.ParamName, Is.EqualTo(\"builder\"));\r\n        }\r\n\r\n        [Test]\r\n        public void RegisterModelBindersThrowsExceptionForNullBuilder()\r\n        {\r\n            var exception = Assert.Throws<ArgumentNullException>(\r\n                () => Autofac.Integration.Mvc.RegistrationExtensions.RegisterModelBinders(null, Assembly.GetExecutingAssembly()));\r\n            Assert.That(exception.ParamName, Is.EqualTo(\"builder\"));\r\n        }\r\n\r\n        [Test]\r\n        public void RegisterModelBindersThrowsExceptionForNullAssemblies()\r\n        {\r\n            var exception = Assert.Throws<ArgumentNullException>(\r\n                () => new ContainerBuilder().RegisterModelBinders(null));\r\n            Assert.That(exception.ParamName, Is.EqualTo(\"modelBinderAssemblies\"));\r\n        }\r\n\r\n        [Test]\r\n        public void AsModelBinderForTypesThrowsExceptionWhenAllTypesNullInList()\r\n        {\r\n            var builder = new ContainerBuilder();\r\n            var registration = builder.RegisterType<TestModelBinder>();\r\n            Assert.Throws<ArgumentException>(() => registration.AsModelBinderForTypes(null, null, null));\r\n        }\r\n\r\n        [Test]\r\n        public void AsModelBinderForTypesThrowsExceptionForEmptyTypeList()\r\n        {\r\n            var types = new Type[0];\r\n            var builder = new ContainerBuilder();\r\n            var registration = builder.RegisterType<TestModelBinder>();\r\n            Assert.Throws<ArgumentException>(() => registration.AsModelBinderForTypes(types));\r\n        }\r\n\r\n        [Test]\r\n        public void AsModelBinderForTypesRegistersInstanceModelBinder()\r\n        {\r\n            IDependencyResolver originalResolver = null;\r\n            try\r\n            {\r\n                originalResolver = DependencyResolver.Current;\r\n                var builder = new ContainerBuilder();\r\n                var binder = new TestModelBinder();\r\n                builder.RegisterInstance(binder).AsModelBinderForTypes(typeof(TestModel1));\r\n                var container = builder.Build();\r\n                DependencyResolver.SetResolver(new AutofacDependencyResolver(container, new StubLifetimeScopeProvider(container)));\r\n                var provider = new AutofacModelBinderProvider();\r\n                Assert.AreSame(binder, provider.GetBinder(typeof(TestModel1)));\r\n            }\r\n            finally\r\n            {\r\n                DependencyResolver.SetResolver(originalResolver);\r\n            }\r\n        }\r\n\r\n        [Test]\r\n        public void AsModelBinderForTypesRegistersTypeModelBinder()\r\n        {\r\n            IDependencyResolver originalResolver = null;\r\n            try\r\n            {\r\n                originalResolver = DependencyResolver.Current;\r\n                var builder = new ContainerBuilder();\r\n                builder.RegisterType<TestModelBinder>().AsModelBinderForTypes(typeof(TestModel1), typeof(TestModel2));\r\n                var container = builder.Build();\r\n                DependencyResolver.SetResolver(new AutofacDependencyResolver(container, new StubLifetimeScopeProvider(container)));\r\n                var provider = new AutofacModelBinderProvider();\r\n                Assert.IsInstanceOf<TestModelBinder>(provider.GetBinder(typeof(TestModel1)), \"The model binder was not registered for TestModel1\");\r\n                Assert.IsInstanceOf<TestModelBinder>(provider.GetBinder(typeof(TestModel2)), \"The model binder was not registered for TestModel2\");\r\n            }\r\n            finally\r\n            {\r\n                DependencyResolver.SetResolver(originalResolver);\r\n            }\r\n        }\r\n\r\n        [Test]\r\n        public void AsModelBinderForTypesThrowsExceptionForNullRegistration()\r\n        {\r\n            IRegistrationBuilder<RegistrationExtensionsFixture, ConcreteReflectionActivatorData, SingleRegistrationStyle> registration = null;\r\n            Assert.Throws<ArgumentNullException>(() => registration.AsModelBinderForTypes(typeof(TestModel1)));\r\n        }\r\n\r\n        [Test]\r\n        public void AsModelBinderForTypesThrowsExceptionForNullTypeList()\r\n        {\r\n            Type[] types = null;\r\n            var builder = new ContainerBuilder();\r\n            var registration = builder.RegisterType<TestModelBinder>();\r\n            Assert.Throws<ArgumentNullException>(() => registration.AsModelBinderForTypes(types));\r\n        }\r\n\r\n        [Test]\r\n        public void RegisterFilterProviderThrowsExceptionForNullBuilder()\r\n        {\r\n            var exception = Assert.Throws<ArgumentNullException>(\r\n                () => Autofac.Integration.Mvc.RegistrationExtensions.RegisterFilterProvider(null));\r\n            Assert.That(exception.ParamName, Is.EqualTo(\"builder\"));\r\n        }\r\n\r\n        [Test]\r\n        public void RegisterFilterProviderRemovesExistingProvider()\r\n        {\r\n            var builder = new ContainerBuilder();\r\n            builder.RegisterFilterProvider();\r\n            Assert.That(FilterProviders.Providers.OfType<FilterAttributeFilterProvider>().Any(), Is.False);\r\n        }\r\n\r\n        [Test]\r\n        public void RegisterFilterProviderCanSafelyBeCalledTwice()\r\n        {\r\n            var builder = new ContainerBuilder();\r\n            builder.RegisterFilterProvider();\r\n            builder.RegisterFilterProvider();\r\n        }\r\n\r\n        [Test]\r\n        public void CacheInSessionThrowsExceptionForNullRegistration()\r\n        {\r\n            var exception = Assert.Throws<ArgumentNullException>(\r\n                () => Autofac.Integration.Mvc.RegistrationExtensions.CacheInSession<object, SimpleActivatorData, SingleRegistrationStyle>(null));\r\n            Assert.That(exception.ParamName, Is.EqualTo(\"registration\"));\r\n        }\r\n\r\n        [Test]\r\n        public void InvokesCustomActivating()\r\n        {\r\n            var builder = new ContainerBuilder();\r\n            builder.RegisterControllers(GetType().Assembly)\r\n                .OnActivating(e => ((TestController)e.Instance).Dependency = new object());\r\n\r\n            var container = builder.Build();\r\n\r\n            var controller = container.Resolve<TestController>();\r\n            Assert.IsNotNull(controller.Dependency);\r\n        }\r\n\r\n        [Test]\r\n        public void InjectsInvoker()\r\n        {\r\n            var builder = new ContainerBuilder();\r\n            builder.RegisterControllers(GetType().Assembly)\r\n                .InjectActionInvoker();\r\n            builder.RegisterType<TestActionInvoker>().As<IActionInvoker>();\r\n            var container = builder.Build();\r\n\r\n            var controller = container.Resolve<TestController>();\r\n            Assert.IsInstanceOf<TestActionInvoker>(controller.ActionInvoker);\r\n        }\r\n\r\n\r\n        [Test]\r\n        public void DoesNotRegisterControllerTypesThatDoNotEndWithControllerString()\r\n        {\r\n            var builder = new ContainerBuilder();\r\n            builder.RegisterControllers(GetType().Assembly);\r\n\r\n            var container = builder.Build();\r\n\r\n            Assert.IsFalse(container.IsRegistered<IsAControllerNot>());\r\n        }\r\n\r\n        [Test]\r\n        public void AsActionFilterForControllerScopedFilterThrowsExceptionForNullRegistration()\r\n        {\r\n            var exception = Assert.Throws<ArgumentNullException>(\r\n                () => Autofac.Integration.Mvc.RegistrationExtensions.AsActionFilterFor<TestController>(null));\r\n\r\n            Assert.That(exception.ParamName, Is.EqualTo(\"registration\"));\r\n        }\r\n\r\n        [Test]\r\n        public void AsActionFilterForActionScopedFilterThrowsExceptionForNullRegistration()\r\n        {\r\n            var exception = Assert.Throws<ArgumentNullException>(\r\n                () => Autofac.Integration.Mvc.RegistrationExtensions.AsActionFilterFor<TestController>\r\n                    (null, c => c.Action1(default(string))));\r\n\r\n            Assert.That(exception.ParamName, Is.EqualTo(\"registration\"));\r\n        }\r\n\r\n        [Test]\r\n        public void AsActionFilterForControllerScopedFilterAddsCorrectMetadata()\r\n        {\r\n            AssertFilterRegistration<TestActionFilter, IActionFilter>(\r\n                FilterScope.Controller, \r\n                null,\r\n                r => r.AsActionFilterFor<TestController>(20),\r\n                AutofacFilterProvider.ActionFilterMetadataKey);\r\n        }\r\n\r\n        [Test]\r\n        public void AsActionFilterForActionScopedFilterAddsCorrectMetadata()\r\n        {\r\n            AssertFilterRegistration<TestActionFilter, IActionFilter>(\r\n                FilterScope.Action,\r\n                TestController.GetAction1MethodInfo<TestController>(),\r\n                r => r.AsActionFilterFor<TestController>(c => c.Action1(default(string)), 20),\r\n                AutofacFilterProvider.ActionFilterMetadataKey);\r\n        }\r\n\r\n        [Test]\r\n        public void AsAuthorizationFilterForControllerScopedFilterThrowsExceptionForNullRegistration()\r\n        {\r\n            var exception = Assert.Throws<ArgumentNullException>(\r\n                () => Autofac.Integration.Mvc.RegistrationExtensions.AsAuthorizationFilterFor<TestController>(null));\r\n\r\n            Assert.That(exception.ParamName, Is.EqualTo(\"registration\"));\r\n        }\r\n\r\n        [Test]\r\n        public void AsAuthorizationFilterForActionScopedFilterThrowsExceptionForNullRegistration()\r\n        {\r\n            var exception = Assert.Throws<ArgumentNullException>(\r\n                () => Autofac.Integration.Mvc.RegistrationExtensions.AsAuthorizationFilterFor<TestController>\r\n                    (null, c => c.Action1(default(string))));\r\n\r\n            Assert.That(exception.ParamName, Is.EqualTo(\"registration\"));\r\n        }\r\n\r\n        [Test]\r\n        public void AsAuthorizationFilterForControllerScopedFilterAddsCorrectMetadata()\r\n        {\r\n            AssertFilterRegistration<TestAuthorizationFilter, IAuthorizationFilter>(\r\n                FilterScope.Controller,\r\n                null,\r\n                r => r.AsAuthorizationFilterFor<TestController>(20),\r\n                AutofacFilterProvider.AuthorizationFilterMetadataKey);\r\n        }\r\n\r\n        [Test]\r\n        public void AsAuthorizationFilterForActionScopedFilterAddsCorrectMetadata()\r\n        {\r\n            AssertFilterRegistration<TestAuthorizationFilter, IAuthorizationFilter>(\r\n                FilterScope.Action,\r\n                TestController.GetAction1MethodInfo<TestController>(),\r\n                r => r.AsAuthorizationFilterFor<TestController>(c => c.Action1(default(string)), 20),\r\n                AutofacFilterProvider.AuthorizationFilterMetadataKey);\r\n        }\r\n\r\n        [Test]\r\n        public void AsExceptionFilterForControllerScopedFilterThrowsExceptionForNullRegistration()\r\n        {\r\n            var exception = Assert.Throws<ArgumentNullException>(\r\n                () => Autofac.Integration.Mvc.RegistrationExtensions.AsExceptionFilterFor<TestController>(null));\r\n\r\n            Assert.That(exception.ParamName, Is.EqualTo(\"registration\"));\r\n        }\r\n\r\n        [Test]\r\n        public void AsExceptionFilterForActionScopedFilterThrowsExceptionForNullRegistration()\r\n        {\r\n            var exception = Assert.Throws<ArgumentNullException>(\r\n                () => Autofac.Integration.Mvc.RegistrationExtensions.AsExceptionFilterFor<TestController>\r\n                    (null, c => c.Action1(default(string))));\r\n\r\n            Assert.That(exception.ParamName, Is.EqualTo(\"registration\"));\r\n        }\r\n\r\n        [Test]\r\n        public void AsExceptionFilterForControllerScopedFilterAddsCorrectMetadata()\r\n        {\r\n            AssertFilterRegistration<TestExceptionFilter, IExceptionFilter>(\r\n                FilterScope.Controller,\r\n                null,\r\n                r => r.AsExceptionFilterFor<TestController>(20),\r\n                AutofacFilterProvider.ExceptionFilterMetadataKey);\r\n        }\r\n\r\n        [Test]\r\n        public void AsExceptionFilterForActionScopedFilterAddsCorrectMetadata()\r\n        {\r\n            AssertFilterRegistration<TestExceptionFilter, IExceptionFilter>(\r\n                FilterScope.Action,\r\n                TestController.GetAction1MethodInfo<TestController>(),\r\n                r => r.AsExceptionFilterFor<TestController>(c => c.Action1(default(string)), 20),\r\n                AutofacFilterProvider.ExceptionFilterMetadataKey);\r\n        }\r\n\r\n        [Test]\r\n        public void AsResultFilterForControllerScopedFilterThrowsExceptionForNullRegistration()\r\n        {\r\n            var exception = Assert.Throws<ArgumentNullException>(\r\n                () => Autofac.Integration.Mvc.RegistrationExtensions.AsResultFilterFor<TestController>(null));\r\n\r\n            Assert.That(exception.ParamName, Is.EqualTo(\"registration\"));\r\n        }\r\n\r\n        [Test]\r\n        public void AsResultFilterForActionScopedFilterThrowsExceptionForNullRegistration()\r\n        {\r\n            var exception = Assert.Throws<ArgumentNullException>(\r\n                () => Autofac.Integration.Mvc.RegistrationExtensions.AsResultFilterFor<TestController>\r\n                    (null, c => c.Action1(default(string))));\r\n\r\n            Assert.That(exception.ParamName, Is.EqualTo(\"registration\"));\r\n        }\r\n\r\n        [Test]\r\n        public void AsResultFilterForControllerScopedFilterAddsCorrectMetadata()\r\n        {\r\n            AssertFilterRegistration<TestResultFilter, IResultFilter>(\r\n                FilterScope.Controller,\r\n                null,\r\n                r => r.AsResultFilterFor<TestController>(20),\r\n                AutofacFilterProvider.ResultFilterMetadataKey);\r\n        }\r\n\r\n        [Test]\r\n        public void AsResultFilterForActionScopedFilterAddsCorrectMetadata()\r\n        {\r\n            AssertFilterRegistration<TestResultFilter, IResultFilter>(\r\n                FilterScope.Action,\r\n                TestController.GetAction1MethodInfo<TestController>(),\r\n                r => r.AsResultFilterFor<TestController>(c => c.Action1(default(string)), 20),\r\n                AutofacFilterProvider.ResultFilterMetadataKey);\r\n        }\r\n\r\n        static void AssertFilterRegistration<TFilter, TService>(FilterScope filterScope, MethodInfo methodInfo,\r\n            Action<IRegistrationBuilder<TFilter, SimpleActivatorData, SingleRegistrationStyle>> configure, string metadataKey)\r\n                where TFilter : new()\r\n        {\r\n            var builder = new ContainerBuilder();\r\n            configure(builder.Register(c => new TFilter()));\r\n            var container = builder.Build();\r\n\r\n            var service = container.Resolve<Meta<TService>>();\r\n\r\n            var metadata = (FilterMetadata)service.Metadata[metadataKey];\r\n\r\n            Assert.That(metadata.ControllerType, Is.EqualTo(typeof(TestController)));\r\n            Assert.That(metadata.FilterScope, Is.EqualTo(filterScope));\r\n            Assert.That(metadata.MethodInfo, Is.EqualTo(methodInfo));\r\n            Assert.That(metadata.Order, Is.EqualTo(20));\r\n            Assert.That(service.Value, Is.InstanceOf<TService>());\r\n        }\r\n    }\r\n}","old_contents":"\ufeffusing System;\r\nusing System.Linq;\r\nusing System.Reflection;\r\nusing System.Web.Mvc;\r\nusing Autofac.Builder;\r\nusing Autofac.Features.Metadata;\r\nusing Autofac.Integration.Mvc;\r\nusing NUnit.Framework;\r\n\r\nnamespace Autofac.Tests.Integration.Mvc\r\n{\r\n    [TestFixture]\r\n    public class RegistrationExtensionsFixture\r\n    {\r\n        [Test]\r\n        public void RegisterModelBinderProviderThrowsExceptionForNullBuilder()\r\n        {\r\n            var exception = Assert.Throws<ArgumentNullException>(\r\n                () => Autofac.Integration.Mvc.RegistrationExtensions.RegisterModelBinderProvider(null));\r\n            Assert.That(exception.ParamName, Is.EqualTo(\"builder\"));\r\n        }\r\n\r\n        [Test]\r\n        public void RegisterModelBindersThrowsExceptionForNullBuilder()\r\n        {\r\n            var exception = Assert.Throws<ArgumentNullException>(\r\n                () => Autofac.Integration.Mvc.RegistrationExtensions.RegisterModelBinders(null, Assembly.GetExecutingAssembly()));\r\n            Assert.That(exception.ParamName, Is.EqualTo(\"builder\"));\r\n        }\r\n\r\n        [Test]\r\n        public void RegisterModelBindersThrowsExceptionForNullAssemblies()\r\n        {\r\n            var exception = Assert.Throws<ArgumentNullException>(\r\n                () => new ContainerBuilder().RegisterModelBinders(null));\r\n            Assert.That(exception.ParamName, Is.EqualTo(\"modelBinderAssemblies\"));\r\n        }\r\n\r\n        [Test]\r\n        public void AsModelBinderForTypesThrowsExceptionWhenAllTypesNullInList()\r\n        {\r\n            var builder = new ContainerBuilder();\r\n            var registration = builder.RegisterType<TestModelBinder>();\r\n            Assert.Throws<ArgumentException>(() => registration.AsModelBinderForTypes(null, null, null));\r\n        }\r\n\r\n        [Test]\r\n        public void AsModelBinderForTypesThrowsExceptionForEmptyTypeList()\r\n        {\r\n            var types = new Type[0];\r\n            var builder = new ContainerBuilder();\r\n            var registration = builder.RegisterType<TestModelBinder>();\r\n            Assert.Throws<ArgumentException>(() => registration.AsModelBinderForTypes(types));\r\n        }\r\n\r\n        [Test]\r\n        public void AsModelBinderForTypesRegistersInstanceModelBinder()\r\n        {\r\n            IDependencyResolver originalResolver = null;\r\n            try\r\n            {\r\n                originalResolver = DependencyResolver.Current;\r\n                var builder = new ContainerBuilder();\r\n                var binder = new TestModelBinder();\r\n                builder.RegisterInstance(binder).AsModelBinderForTypes(typeof(TestModel1));\r\n                var container = builder.Build();\r\n                DependencyResolver.SetResolver(new AutofacDependencyResolver(container, new StubLifetimeScopeProvider(container)));\r\n                var provider = new AutofacModelBinderProvider();\r\n                Assert.AreSame(binder, provider.GetBinder(typeof(TestModel1)));\r\n            }\r\n            finally\r\n            {\r\n                DependencyResolver.SetResolver(originalResolver);\r\n            }\r\n        }\r\n\r\n        [Test]\r\n        public void AsModelBinderForTypesRegistersTypeModelBinder()\r\n        {\r\n            IDependencyResolver originalResolver = null;\r\n            try\r\n            {\r\n                originalResolver = DependencyResolver.Current;\r\n                var builder = new ContainerBuilder();\r\n                builder.RegisterType<TestModelBinder>().AsModelBinderForTypes(typeof(TestModel1), typeof(TestModel2));\r\n                var container = builder.Build();\r\n                DependencyResolver.SetResolver(new AutofacDependencyResolver(container, new StubLifetimeScopeProvider(container)));\r\n                var provider = new AutofacModelBinderProvider();\r\n                Assert.IsInstanceOf<TestModelBinder>(provider.GetBinder(typeof(TestModel1)), \"The model binder was not registered for TestModel1\");\r\n                Assert.IsInstanceOf<TestModelBinder>(provider.GetBinder(typeof(TestModel2)), \"The model binder was not registered for TestModel2\");\r\n            }\r\n            finally\r\n            {\r\n                DependencyResolver.SetResolver(originalResolver);\r\n            }\r\n        }\r\n\r\n        [Test]\r\n        public void AsModelBinderForTypesThrowsExceptionForNullRegistration()\r\n        {\r\n            IRegistrationBuilder<RegistrationExtensionsFixture, ConcreteReflectionActivatorData, SingleRegistrationStyle> registration = null;\r\n            Assert.Throws<ArgumentNullException>(() => registration.AsModelBinderForTypes(typeof(TestModel1)));\r\n        }\r\n\r\n        [Test]\r\n        public void AsModelBinderForTypesThrowsExceptionForNullTypeList()\r\n        {\r\n            Type[] types = null;\r\n            var builder = new ContainerBuilder();\r\n            var registration = builder.RegisterType<TestModelBinder>();\r\n            Assert.Throws<ArgumentNullException>(() => registration.AsModelBinderForTypes(types));\r\n        }\r\n\r\n        [Test]\r\n        public void RegisterFilterProviderThrowsExceptionForNullBuilder()\r\n        {\r\n            var exception = Assert.Throws<ArgumentNullException>(\r\n                () => Autofac.Integration.Mvc.RegistrationExtensions.RegisterFilterProvider(null));\r\n            Assert.That(exception.ParamName, Is.EqualTo(\"builder\"));\r\n        }\r\n\r\n        [Test]\r\n        public void RegisterFilterProviderRemovesExistingProvider()\r\n        {\r\n            var builder = new ContainerBuilder();\r\n            builder.RegisterFilterProvider();\r\n            Assert.That(FilterProviders.Providers.OfType<FilterAttributeFilterProvider>().Any(), Is.False);\r\n        }\r\n\r\n        [Test]\r\n        public void RegisterFilterProviderCanSafelyBeCalledTwice()\r\n        {\r\n            var builder = new ContainerBuilder();\r\n            builder.RegisterFilterProvider();\r\n            builder.RegisterFilterProvider();\r\n        }\r\n\r\n        [Test]\r\n        public void CacheInSessionThrowsExceptionForNullRegistration()\r\n        {\r\n            var exception = Assert.Throws<ArgumentNullException>(\r\n                () => Autofac.Integration.Mvc.RegistrationExtensions.CacheInSession<object, SimpleActivatorData, SingleRegistrationStyle>(null));\r\n            Assert.That(exception.ParamName, Is.EqualTo(\"registration\"));\r\n        }\r\n\r\n        [Test]\r\n        public void InvokesCustomActivating()\r\n        {\r\n            var builder = new ContainerBuilder();\r\n            builder.RegisterControllers(GetType().Assembly)\r\n                .OnActivating(e => ((TestController)e.Instance).Dependency = new object());\r\n\r\n            var container = builder.Build();\r\n\r\n            var controller = container.Resolve<TestController>();\r\n            Assert.IsNotNull(controller.Dependency);\r\n        }\r\n\r\n        [Test]\r\n        public void InjectsInvoker()\r\n        {\r\n            var builder = new ContainerBuilder();\r\n            builder.RegisterControllers(GetType().Assembly)\r\n                .InjectActionInvoker();\r\n            builder.RegisterType<TestActionInvoker>().As<IActionInvoker>();\r\n            var container = builder.Build();\r\n\r\n            var controller = container.Resolve<TestController>();\r\n            Assert.IsInstanceOf<TestActionInvoker>(controller.ActionInvoker);\r\n        }\r\n\r\n\r\n        [Test]\r\n        public void DoesNotRegisterControllerTypesThatDoNotEndWithControllerString()\r\n        {\r\n            var builder = new ContainerBuilder();\r\n            builder.RegisterControllers(GetType().Assembly);\r\n\r\n            var container = builder.Build();\r\n\r\n            Assert.IsFalse(container.IsRegistered<IsAControllerNot>());\r\n        }\r\n\r\n        [Test]\r\n        public void AsActionFilterForControllerScopedFilterThrowsExceptionForNullRegistration()\r\n        {\r\n            var exception = Assert.Throws<ArgumentNullException>(\r\n                () => Autofac.Integration.Mvc.RegistrationExtensions.AsActionFilterFor<TestController>(null));\r\n\r\n            Assert.That(exception.ParamName, Is.EqualTo(\"registration\"));\r\n        }\r\n\r\n        [Test]\r\n        public void AsActionFilterForActionScopedFilterThrowsExceptionForNullRegistration()\r\n        {\r\n            var exception = Assert.Throws<ArgumentNullException>(\r\n                () => Autofac.Integration.Mvc.RegistrationExtensions.AsActionFilterFor<TestController>\r\n                    (null, c => c.Action1(default(string))));\r\n\r\n            Assert.That(exception.ParamName, Is.EqualTo(\"registration\"));\r\n        }\r\n\r\n        [Test]\r\n        public void AsActionFilterForControllerScopedFilterAddsCorrectMetadata()\r\n        {\r\n            AssertFilterRegistration<TestActionFilter, IActionFilter>(\r\n                FilterScope.Controller, \r\n                null,\r\n                r => r.AsActionFilterFor<TestController>(20),\r\n                AutofacFilterProvider.ActionFilterMetadataKey);\r\n        }\r\n\r\n        [Test]\r\n        public void AsActionFilterForActionScopedFilterAddsCorrectMetadata()\r\n        {\r\n            AssertFilterRegistration<TestActionFilter, IActionFilter>(\r\n                FilterScope.Action,\r\n                TestController.GetAction1MethodInfo<TestController>(),\r\n                r => r.AsActionFilterFor<TestController>(c => c.Action1(default(string)), 20),\r\n                AutofacFilterProvider.ActionFilterMetadataKey);\r\n        }\r\n\r\n        [Test]\r\n        public void AsAuthorizationFilterForControllerScopedFilterThrowsExceptionForNullRegistration()\r\n        {\r\n            var exception = Assert.Throws<ArgumentNullException>(\r\n                () => Autofac.Integration.Mvc.RegistrationExtensions.AsAuthorizationFilterFor<TestController>(null));\r\n\r\n            Assert.That(exception.ParamName, Is.EqualTo(\"registration\"));\r\n        }\r\n\r\n        [Test]\r\n        public void AsAuthorizationFilterForActionScopedFilterThrowsExceptionForNullRegistration()\r\n        {\r\n            var exception = Assert.Throws<ArgumentNullException>(\r\n                () => Autofac.Integration.Mvc.RegistrationExtensions.AsAuthorizationFilterFor<TestController>\r\n                    (null, c => c.Action1(default(string))));\r\n\r\n            Assert.That(exception.ParamName, Is.EqualTo(\"registration\"));\r\n        }\r\n\r\n        [Test]\r\n        public void AsAuthorizationFilterForControllerScopedFilterAddsCorrectMetadata()\r\n        {\r\n            AssertFilterRegistration<TestAuthorizationFilter, IAuthorizationFilter>(\r\n                FilterScope.Controller,\r\n                null,\r\n                r => r.AsAuthorizationFilterFor<TestController>(20),\r\n                AutofacFilterProvider.AuthorizationFilterMetadataKey);\r\n        }\r\n\r\n        [Test]\r\n        public void AsAuthorizationFilterForActionScopedFilterAddsCorrectMetadata()\r\n        {\r\n            AssertFilterRegistration<TestAuthorizationFilter, IAuthorizationFilter>(\r\n                FilterScope.Action,\r\n                TestController.GetAction1MethodInfo<TestController>(),\r\n                r => r.AsAuthorizationFilterFor<TestController>(c => c.Action1(default(string)), 20),\r\n                AutofacFilterProvider.AuthorizationFilterMetadataKey);\r\n        }\r\n\r\n        [Test]\r\n        public void AsExceptionFilterForControllerScopedFilterThrowsExceptionForNullRegistration()\r\n        {\r\n            var exception = Assert.Throws<ArgumentNullException>(\r\n                () => Autofac.Integration.Mvc.RegistrationExtensions.AsExceptionFilterFor<TestController>(null));\r\n\r\n            Assert.That(exception.ParamName, Is.EqualTo(\"registration\"));\r\n        }\r\n\r\n        [Test]\r\n        public void AsExceptionFilterForActionScopedFilterThrowsExceptionForNullRegistration()\r\n        {\r\n            var exception = Assert.Throws<ArgumentNullException>(\r\n                () => Autofac.Integration.Mvc.RegistrationExtensions.AsExceptionFilterFor<TestController>\r\n                    (null, c => c.Action1(default(string))));\r\n\r\n            Assert.That(exception.ParamName, Is.EqualTo(\"registration\"));\r\n        }\r\n\r\n        [Test]\r\n        public void AsExceptionFilterForControllerScopedFilterAddsCorrectMetadata()\r\n        {\r\n            AssertFilterRegistration<TestExceptionFilter, IExceptionFilter>(\r\n                FilterScope.Controller,\r\n                null,\r\n                r => r.AsExceptionFilterFor<TestController>(20),\r\n                AutofacFilterProvider.ExceptionFilterMetadataKey);\r\n        }\r\n\r\n        [Test]\r\n        public void AsExceptionFilterForActionScopedFilterAddsCorrectMetadata()\r\n        {\r\n            AssertFilterRegistration<TestExceptionFilter, IExceptionFilter>(\r\n                FilterScope.Action,\r\n                TestController.GetAction1MethodInfo<TestController>(),\r\n                r => r.AsExceptionFilterFor<TestController>(c => c.Action1(default(string)), 20),\r\n                AutofacFilterProvider.ExceptionFilterMetadataKey);\r\n        }\r\n\r\n        [Test]\r\n        public void AsResultFilterForControllerScopedFilterThrowsExceptionForNullRegistration()\r\n        {\r\n            var exception = Assert.Throws<ArgumentNullException>(\r\n                () => Autofac.Integration.Mvc.RegistrationExtensions.AsResultFilterFor<TestController>(null));\r\n\r\n            Assert.That(exception.ParamName, Is.EqualTo(\"registration\"));\r\n        }\r\n\r\n        [Test]\r\n        public void AsResultFilterForActionScopedFilterThrowsExceptionForNullRegistration()\r\n        {\r\n            var exception = Assert.Throws<ArgumentNullException>(\r\n                () => Autofac.Integration.Mvc.RegistrationExtensions.AsResultFilterFor<TestController>\r\n                    (null, c => c.Action1(default(string))));\r\n\r\n            Assert.That(exception.ParamName, Is.EqualTo(\"registration\"));\r\n        }\r\n\r\n        [Test]\r\n        public void AsResultFilterForControllerScopedFilterAddsCorrectMetadata()\r\n        {\r\n            AssertFilterRegistration<TestResultFilter, IResultFilter>(\r\n                FilterScope.Controller,\r\n                null,\r\n                r => r.AsResultFilterFor<TestController>(20),\r\n                AutofacFilterProvider.ResultFilterMetadataKey);\r\n        }\r\n\r\n        [Test]\r\n        public void AsResultFilterForActionScopedFilterAddsCorrectMetadata()\r\n        {\r\n            AssertFilterRegistration<TestResultFilter, IResultFilter>(\r\n                FilterScope.Action,\r\n                TestController.GetAction1MethodInfo<TestController>(),\r\n                r => r.AsResultFilterFor<TestController>(c => c.Action1(default(string)), 20),\r\n                AutofacFilterProvider.ResultFilterMetadataKey);\r\n        }\r\n\r\n        static void AssertFilterRegistration<TFilter, TService>(FilterScope filterScope, MethodInfo methodInfo,\r\n            Action<IRegistrationBuilder<TFilter, SimpleActivatorData, SingleRegistrationStyle>> configure, string metadataKey)\r\n                where TFilter : new()\r\n        {\r\n            var builder = new ContainerBuilder();\r\n            configure(builder.Register(c => new TFilter()));\r\n            var container = builder.Build();\r\n\r\n            var service = container.Resolve<Meta<TService>>();\r\n\r\n            var metadata = (FilterMetadata)service.Metadata[metadataKey];\r\n\r\n            Assert.That(metadata.ControllerType, Is.EqualTo(typeof(TestController)));\r\n            Assert.That(metadata.FilterScope, Is.EqualTo(filterScope));\r\n            Assert.That(metadata.MethodInfo, Is.EqualTo(methodInfo));\r\n            Assert.That(metadata.Order, Is.EqualTo(20));\r\n            Assert.That(service.Value, Is.InstanceOf<TService>());\r\n        }\r\n    }\r\n}","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"8f8aff201fa934ec0083046267de3f623aac7886","subject":"Change unity scene type to struct","message":"Change unity scene type to struct\n","repos":"insthync\/LiteNetLibManager,insthync\/LiteNetLibManager","old_file":"Scripts\/Utils\/LiteNetLibScene.cs","new_file":"Scripts\/Utils\/LiteNetLibScene.cs","new_contents":"\ufeffusing UnityEngine;\n\nnamespace LiteNetLibManager\n{\n    [System.Serializable]\n    public struct LiteNetLibScene\n    {\n        [SerializeField]\n        private Object sceneAsset;\n        [SerializeField]\n        private string sceneName;\n\n        public string SceneName\n        {\n            get { return sceneName; }\n            set { sceneName = value; }\n        }\n\n        public static implicit operator string(LiteNetLibScene unityScene)\n        {\n            return unityScene.SceneName;\n        }\n\n        public bool IsSet()\n        {\n            return !string.IsNullOrEmpty(sceneName);\n        }\n    }\n}\n","old_contents":"\ufeffusing UnityEngine;\n\nnamespace LiteNetLibManager\n{\n    [System.Serializable]\n    public class LiteNetLibScene\n    {\n        [SerializeField]\n        private Object sceneAsset;\n        [SerializeField]\n        private string sceneName = string.Empty;\n\n        public string SceneName\n        {\n            get { return sceneName; }\n            set { sceneName = value; }\n        }\n\n        public static implicit operator string(LiteNetLibScene unityScene)\n        {\n            return unityScene.SceneName;\n        }\n\n        public bool IsSet()\n        {\n            return !string.IsNullOrEmpty(sceneName);\n        }\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"fa3d5c57a76aa1c01100686bffc7c7fcf1baf460","subject":"Move WinApi call into NativeMethods","message":"Move WinApi call into NativeMethods\n","repos":"CindyB\/sloth","old_file":"Sloth\/Sloth\/Core\/WinUtilities.cs","new_file":"Sloth\/Sloth\/Core\/WinUtilities.cs","new_contents":"\ufeffusing Sloth.Interfaces.Core;\nusing System;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Windows.Forms;\n\nnamespace Sloth.Core\n{\n    public class WinUtilities : IWinUtilities\n    {\n\n        private List<IntPtr> m_ChildHandles;\n\n        public IntPtr FindControlHandle(IntPtr windowsHandle, string controlName)\n        {\n            m_ChildHandles = new List<IntPtr>();\n            NativeMethods.EnumChildWindows(windowsHandle, EnumChildProc, 0);\n            foreach (IntPtr childHandle in m_ChildHandles) if (Control.FromHandle(childHandle)?.Name == controlName) return childHandle;\n            return IntPtr.Zero;\n        }\n\n        public IntPtr FindWindowsHandle(string className,string windowsName)\n        {\n            return NativeMethods.FindWindow(className, windowsName);\n        }\n\n        public string GetWindowText(IntPtr windowsHandle)\n        {\n            StringBuilder builder = new StringBuilder(256);\n            NativeMethods.GetWindowText(windowsHandle, builder, builder.Capacity);\n            return builder.ToString();\n        }\n\n        public void SendMessage(IntPtr windowsHandle, IntPtr controlHandle, ISlothEvent slothEvent)\n        {\n            NativeMethods.SendMessage(controlHandle, slothEvent.Message,IntPtr.Zero,IntPtr.Zero);\n        }\n\n\n        public delegate bool EnumChildCallback(IntPtr hwnd, ref IntPtr lParam);\n\n        public bool EnumChildProc(IntPtr hwndChild, ref IntPtr lParam)\n        {\n            m_ChildHandles.Add(hwndChild);\n            return true;\n        }\n\n        internal static class NativeMethods\n        {\n            [DllImport(\"user32.dll\")]\n            internal static extern int EnumChildWindows(IntPtr hwnd, EnumChildCallback Proc, int lParam);\n\n            [DllImport(\"user32.dll\", SetLastError = true)]\n            internal static extern IntPtr FindWindow(string lpClassName, string lpWindowName);\n\n            [DllImport(\"user32.dll\")]\n            internal static extern IntPtr GetDlgItem(IntPtr hDlg, int nIDDlgItem);\n\n            [DllImport(\"user32.dll\", CharSet = CharSet.Auto, SetLastError = true)]\n            internal static extern int GetWindowText(IntPtr hWnd, StringBuilder lpString, int nMaxCount);\n\n            [DllImport(\"user32.dll\")]\n            internal static extern IntPtr SendMessage(IntPtr hWnd, UInt32 msg, IntPtr wParam, IntPtr lParam);\n        }\n    }\n\n}\n","old_contents":"\ufeffusing Sloth.Interfaces.Core;\nusing System;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing System.Windows.Forms;\n\nnamespace Sloth.Core\n{\n    public class WinUtilities : IWinUtilities\n    {\n\n        private List<IntPtr> m_ChildHandles;\n\n        public IntPtr FindControlHandle(IntPtr windowsHandle, string controlName)\n        {\n            m_ChildHandles = new List<IntPtr>();\n            EnumChildWindows(windowsHandle, EnumChildProc, 0);\n            foreach (IntPtr childHandle in m_ChildHandles) if (Control.FromHandle(childHandle)?.Name == controlName) return childHandle;\n            return IntPtr.Zero;\n        }\n\n        public IntPtr FindWindowsHandle(string className,string windowsName)\n        {\n            return FindWindow(className, windowsName);\n        }\n\n        public string GetWindowText(IntPtr windowsHandle)\n        {\n            StringBuilder builder = new StringBuilder(256);\n            GetWindowText(windowsHandle, builder, builder.Capacity);\n            return builder.ToString();\n        }\n\n        public void SendMessage(IntPtr windowsHandle, IntPtr controlHandle, ISlothEvent slothEvent)\n        {\n            SendMessage(controlHandle, slothEvent.Message,IntPtr.Zero,IntPtr.Zero);\n        }\n\n\n        public delegate bool EnumChildCallback(IntPtr hwnd, ref IntPtr lParam);\n\n        public bool EnumChildProc(IntPtr hwndChild, ref IntPtr lParam)\n        {\n            m_ChildHandles.Add(hwndChild);\n            return true;\n        }\n\n        [DllImport(\"user32.dll\")]\n        public static extern int EnumChildWindows(IntPtr hwnd, EnumChildCallback Proc, int lParam);\n\n        [DllImport(\"user32.dll\", SetLastError = true)]\n        static extern IntPtr FindWindow(string lpClassName, string lpWindowName);\n\n        [DllImport(\"user32.dll\")]\n        static extern IntPtr GetDlgItem(IntPtr hDlg, int nIDDlgItem);\n\n        [DllImport(\"user32.dll\", CharSet = CharSet.Auto, SetLastError = true)]\n        static extern int GetWindowText(IntPtr hWnd, StringBuilder lpString, int nMaxCount);\n\n        [DllImport(\"user32.dll\")]\n        static extern IntPtr SendMessage(IntPtr hWnd, UInt32 msg, IntPtr wParam, IntPtr lParam);\n\n    }\n\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"dcd9da0942a4a54f8a5eda5272d1b4cb5ab47b43","subject":"modified cardview to support the new field (days since last update)","message":"modified cardview to support the new field (days since last update)\n","repos":"netxph\/cards","old_file":"src\/Cards.Core\/CardView.cs","new_file":"src\/Cards.Core\/CardView.cs","new_contents":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Cards.Core\n{\n    public class CardView\n    {\n        public int ID { get; set; }\n\n        public int AreaID { get; set; }\n\n        public string Name { get; set; }\n\n        public bool IsActive { get; set; }\n\n        public long Age { get; set; }\n\n        public string AgeText { get; set; }\n\n        public int DaysSinceLastUpdate { get; set; }\n\n        public string DaysSinceLastUpdateText { get; set; }\n\n    }\n}\n","old_contents":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Cards.Core\n{\n    public class CardView\n    {\n        public int ID { get; set; }\n\n        public int AreaID { get; set; }\n\n        public string Name { get; set; }\n\n        public bool IsActive { get; set; }\n\n        public long Age { get; set; }\n\n        public string AgeText { get; set; }\n\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"0786a357a832c528380997465418de15faf84873","subject":"CLI refinements for service comms","message":"CLI refinements for service comms\n\n","repos":"ndouthit\/Certify,webprofusion\/Certify,Prerequisite\/Certify","old_file":"src\/Certify.CLI\/Program.cs","new_file":"src\/Certify.CLI\/Program.cs","new_contents":"\ufeffusing Certify.Client;\r\nusing Certify.Models;\r\nusing Microsoft.ApplicationInsights;\r\nusing System;\r\nusing System.Globalization;\r\nusing System.Linq;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace Certify.CLI\r\n{\r\n    internal class Program\r\n    {\r\n        private static int Main(string[] args)\r\n        {\r\n            var p = new CertifyCLI();\r\n\r\n            p.ShowVersion();\r\n\r\n            if (!p.IsServiceAvailable().Result)\r\n            {\r\n                Console.ForegroundColor = ConsoleColor.Red;\r\n                System.Console.WriteLine(\"Certify SSL Manager service not started.\");\r\n                Console.ForegroundColor = ConsoleColor.White;\r\n                return -1;\r\n            }\r\n\r\n            Task.Run(async () =>\r\n            {\r\n                await p.LoadPreferences();\r\n            });\r\n\r\n            if (args.Length == 0)\r\n            {\r\n                p.ShowHelp();\r\n                p.ShowACMEInfo();\r\n            }\r\n            else\r\n            {\r\n                p.ShowACMEInfo();\r\n\r\n                if (args.Contains(\"renew\", StringComparer.InvariantCultureIgnoreCase))\r\n                {\r\n                    \/\/ perform auto renew all\r\n                    var renewalTask = p.PerformAutoRenew();\r\n                    renewalTask.ConfigureAwait(true);\r\n                    renewalTask.Wait();\r\n                }\r\n\r\n                if (args.Contains(\"list\", StringComparer.InvariantCultureIgnoreCase))\r\n                {\r\n                    \/\/list managed sites and status\r\n                    p.ListManagedSites();\r\n                }\r\n            }\r\n\r\n#if DEBUG\r\n            p.ListManagedSites();\r\n            Console.ReadKey();\r\n#endif\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    internal class CertifyCLI\r\n    {\r\n        private readonly IdnMapping _idnMapping = new IdnMapping();\r\n        private TelemetryClient _tc = null;\r\n        private ICertifyClient _certifyClient = null;\r\n        private Preferences _prefs = new Preferences();\r\n\r\n        public CertifyCLI()\r\n        {\r\n            _certifyClient = new CertifyServiceClient();\r\n        }\r\n\r\n        public async Task<bool> IsServiceAvailable()\r\n        {\r\n            bool isAvailable = false;\r\n\r\n            try\r\n            {\r\n                await _certifyClient.GetAppVersion();\r\n                isAvailable = true;\r\n            }\r\n            catch (Exception)\r\n            {\r\n                isAvailable = false;\r\n            }\r\n            return isAvailable;\r\n        }\r\n\r\n        public async Task LoadPreferences()\r\n        {\r\n            _prefs = await _certifyClient.GetPreferences();\r\n        }\r\n\r\n        private bool IsTelematicsEnabled()\r\n        {\r\n            return _prefs.EnableAppTelematics;\r\n        }\r\n\r\n        private string GetInstrumentationKey()\r\n        {\r\n            return Certify.Locales.ConfigResources.AIInstrumentationKey;\r\n        }\r\n\r\n        private async Task<string> GetAppVersion()\r\n        {\r\n            try\r\n            {\r\n                return await _certifyClient.GetAppVersion();\r\n            }\r\n            catch (Exception)\r\n            {\r\n                return await Task.FromResult(\"--- (Service Not Started)\");\r\n            }\r\n        }\r\n\r\n        private string GetAppWebsiteURL()\r\n        {\r\n            return Certify.Locales.ConfigResources.AppWebsiteURL;\r\n        }\r\n\r\n        private void InitTelematics()\r\n        {\r\n            if (IsTelematicsEnabled())\r\n            {\r\n                _tc = new TelemetryClient();\r\n                _tc.Context.InstrumentationKey = GetInstrumentationKey();\r\n                _tc.InstrumentationKey = GetInstrumentationKey();\r\n\r\n                \/\/ Set session data:\r\n\r\n                _tc.Context.Session.Id = Guid.NewGuid().ToString();\r\n                _tc.Context.Component.Version = GetAppVersion().Result;\r\n                _tc.Context.Device.OperatingSystem = Environment.OSVersion.ToString();\r\n                _tc.TrackEvent(\"StartCLI\");\r\n            }\r\n        }\r\n\r\n        internal void ShowVersion()\r\n        {\r\n            Console.ForegroundColor = ConsoleColor.Yellow;\r\n            System.Console.WriteLine(\"Certify SSL Manager - CLI v3.0.0. Certify.Core v\" + GetAppVersion().Result);\r\n            Console.ForegroundColor = ConsoleColor.White;\r\n            System.Console.WriteLine(\"For more information see \" + GetAppWebsiteURL());\r\n            System.Console.WriteLine(\"\");\r\n        }\r\n\r\n        internal void ShowACMEInfo()\r\n        {\r\n            \/*\r\n                        var certifyManager = new CertifyManager();\r\n                        string vaultInfo = certifyManager.GetVaultSummary();\r\n                        string acmeInfo = certifyManager.GetAcmeSummary();\r\n\r\n                        Console.ForegroundColor = ConsoleColor.DarkYellow;\r\n                        System.Console.WriteLine(\"Let's Encrypt ACME API: \" + acmeInfo);\r\n                        System.Console.WriteLine(\"ACMESharp Vault: \" + vaultInfo);\r\n            *\/\r\n            System.Console.WriteLine(\"\");\r\n            Console.ForegroundColor = ConsoleColor.White;\r\n        }\r\n\r\n        internal void ShowHelp()\r\n        {\r\n            Console.ForegroundColor = ConsoleColor.White;\r\n            System.Console.WriteLine(\"Usage: certify <command> \\n\");\r\n            System.Console.WriteLine(\"certify renew : renew certificates for all auto renewed managed sites\");\r\n            System.Console.WriteLine(\"certify list : list managed sites and current running\/not running status in IIS\");\r\n\r\n            System.Console.WriteLine(\"\\n\");\r\n        }\r\n\r\n        internal async Task PerformAutoRenew()\r\n        {\r\n            if (_tc == null) InitTelematics();\r\n            if (_tc != null)\r\n            {\r\n                _tc.TrackEvent(\"CLI_BeginAutoRenew\");\r\n            }\r\n\r\n            Console.ForegroundColor = ConsoleColor.White;\r\n            System.Console.WriteLine(\"\\nPerforming Auto Renewals..\\n\");\r\n\r\n            \/\/go through list of items configured for auto renew, perform renewal and report the result\r\n            var results = await _certifyClient.BeginAutoRenewal();\r\n            Console.ForegroundColor = ConsoleColor.White;\r\n\r\n            foreach (var r in results)\r\n            {\r\n                if (r.ManagedItem != null)\r\n                {\r\n                    System.Console.WriteLine(\"--------------------------------------\");\r\n                    if (r.IsSuccess)\r\n                    {\r\n                        Console.ForegroundColor = ConsoleColor.Green;\r\n                        System.Console.WriteLine(r.ManagedItem.Name);\r\n                    }\r\n                    else\r\n                    {\r\n                        Console.ForegroundColor = ConsoleColor.DarkYellow;\r\n                        System.Console.WriteLine(r.ManagedItem.Name);\r\n\r\n                        if (r.Message != null)\r\n                        {\r\n                            Console.ForegroundColor = ConsoleColor.Red;\r\n                            System.Console.WriteLine(r.Message);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            Console.ForegroundColor = ConsoleColor.White;\r\n\r\n            System.Console.WriteLine(\"Completed:\" + results.Where(r => r.IsSuccess == true).Count());\r\n            if (results.Any(r => r.IsSuccess == false))\r\n            {\r\n                Console.ForegroundColor = ConsoleColor.Red;\r\n                System.Console.WriteLine(\"Failed:\" + results.Where(r => r.IsSuccess == false).Count());\r\n                Console.ForegroundColor = ConsoleColor.White;\r\n            }\r\n        }\r\n\r\n        internal void ListManagedSites()\r\n        {\r\n            var managedSites = _certifyClient.GetManagedSites(new ManagedSiteFilter()).Result;\r\n\r\n            foreach (var site in managedSites)\r\n            {\r\n                Console.ForegroundColor = ConsoleColor.White;\r\n\r\n                Console.WriteLine($\"{site.Name},{site.DateExpiry}\");\r\n            }\r\n        }\r\n\r\n        \/*\r\n       private bool PerformCertRequestAndIISBinding(string certDomain, string[] alternativeNames)\r\n       {\r\n           \/\/ ACME service requires international domain names in ascii mode\r\n           certDomain = _idnMapping.GetAscii(certDomain);\r\n\r\n            \/\/create cert and binding it\r\n\r\n            \/\/Typical command sequence for a new certificate\r\n\r\n            \/\/Initialize-ACMEVault -BaseURI https:\/\/acme-staging.api.letsencrypt.org\/\r\n\r\n            \/\/ Get-Module -ListAvailable ACMESharp New-ACMEIdentifier -Dns test7.examplesite.co.uk\r\n            \/\/ -Alias test7_examplesite_co_uk636213616564101276 -Label Identifier:test7.examplesite.co.uk\r\n            \/\/ Complete-ACMEChallenge -Ref test7_examplesite_co_uk636213616564101276 -ChallengeType\r\n            \/\/ http-01 -Handler manual\r\n            \/\/ -Regenerate Submit-ACMEChallenge -Ref test7_examplesite_co_uk636213616564101276\r\n            \/\/ -Challenge http-01 Update-ACMEIdentifier -Ref test7_examplesite_co_uk636213616564101276\r\n            \/\/ Update-ACMEIdentifier -Ref test7_examplesite_co_uk636213616564101276 New-ACMECertificate\r\n            \/\/ -Identifier test7_examplesite_co_uk636213616564101276 -Alias\r\n            \/\/ cert_test7_examplesite_co_uk636213616564101276 -Generate Update-ACMEIdentifier -Ref\r\n            \/\/ test7_examplesite_co_uk636213616564101276 Update-ACMEIdentifier -Ref\r\n            \/\/ test7_examplesite_co_uk636213616564101276 Get-ACMECertificate -Ref = ac22dbfe - b75f\r\n            \/\/ - 4cac-9247-b40c1d9bf9eb -ExportPkcs12\r\n            \/\/ C:\\ProgramData\\ACMESharp\\sysVault\\99-ASSET\\ac22dbfe-b75f-4cac-9247-b40c1d9bf9eb-all.pfx -Overwrite\r\n\r\n            \/\/get info on existing IIS site we want to create\/update SSL binding for\r\n            IISManager iisManager = new IISManager();\r\n            var iisSite = iisManager.GetSiteBindingByDomain(certDomain);\r\n            var certConfig = new CertRequestConfig()\r\n            {\r\n                PrimaryDomain = certDomain,\r\n                PerformChallengeFileCopy = true,\r\n                WebsiteRootPath = Environment.ExpandEnvironmentVariables(iisSite.PhysicalPath)\r\n            };\r\n\r\n            var certifyManager = new VaultManager(Properties.Settings.Default.VaultPath, LocalDiskVault.VAULT);\r\n\r\n            \/\/init vault if not already created\r\n            certifyManager.InitVault(staging: true);\r\n\r\n            \/\/domain alias is used as an ID in both the vault and the LE server, it's specific to one authorization attempt and cannot be reused for renewal\r\n            var domainIdentifierAlias = certifyManager.ComputeIdentifierAlias(certDomain);\r\n\r\n            \/\/NOTE: to support a SAN certificate (multiple alternative domains on one site) the domain validation steps need to be repeat for each name:\r\n\r\n            \/\/register identifier with LE, get http challenge spec back\r\n            \/\/create challenge response answer file under site .well-known, auto configure web.config for extenstionless content, mark challenge prep completed\r\n            var authState = certifyManager.BeginRegistrationAndValidation(certConfig, domainIdentifierAlias);\r\n\r\n            \/\/ask LE to check our answer to their authorization challenge (http), LE will then attempt to fetch our answer, if all accessible and correct (authorized) LE will then allow us to request a certificate\r\n            if (authState.Identifier.Authorization.IsPending())\r\n            {\r\n                \/\/prepare IIS with answer for the LE challenege\r\n                certifyManager.PerformIISAutomatedChallengeResponse(certConfig, authState);\r\n\r\n                \/\/ask LE to validate our challenge response\r\n                certifyManager.SubmitChallenge(domainIdentifierAlias, \"http-01\");\r\n            }\r\n\r\n            \/\/now check if LE has validated our challenge answer\r\n            bool validated = certifyManager.CompleteIdentifierValidationProcess(domainIdentifierAlias);\r\n\r\n            if (validated)\r\n            {\r\n                var certRequestResult = certifyManager.PerformCertificateRequestProcess(domainIdentifierAlias, alternativeIdentifierRefs: null);\r\n                if (certRequestResult.IsSuccess)\r\n                {\r\n                    string pfxPath = certRequestResult.Result.ToString();\r\n                    \/\/Install certificate into certificate store and bind to IIS site\r\n                    \/\/TODO, match by site id?\r\n                    if (iisManager.InstallCertForDomain(certDomain, pfxPath, cleanupCertStore: true, skipBindings: false))\r\n                    {\r\n                        \/\/all done\r\n                        System.Diagnostics.Debug.WriteLine(\"Certificate installed and SSL bindings updated for \" + certDomain);\r\n                        return true;\r\n                    }\r\n                    else\r\n                    {\r\n                        System.Diagnostics.Debug.WriteLine(\"Failed to install PFX file for Certificate.\");\r\n                        return false;\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    System.Diagnostics.Debug.WriteLine(\"LE did not issue a valid certificate in the time allowed.\");\r\n                    return false;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                System.Diagnostics.Debug.WriteLine(\"Validation of the required challenges did not complete successfully.\");\r\n                return false;\r\n            }\r\n\r\n           return false;\r\n       }\r\n       *\/\r\n    }\r\n}","old_contents":"\ufeffusing System;\r\nusing System.Collections.Generic;\r\nusing System.Globalization;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nusing Newtonsoft.Json;\r\nusing Microsoft.ApplicationInsights;\r\nusing Certify.Client;\r\nusing Certify.Models;\r\n\r\nnamespace Certify.CLI\r\n{\r\n    internal class Program\r\n    {\r\n        private static int Main(string[] args)\r\n        {\r\n            \/\/ upgrade assembly version of saved settings (if required)\r\n#if DIRECTCLIENT\r\n            Certify.Properties.Settings.Default.UpgradeSettingsVersion(); \/\/ deprecated\r\n            Certify.Management.SettingsManager.LoadAppSettings();\r\n#endif\r\n\r\n            var p = new CertifyCLI();\r\n            Task.Run(async () =>\r\n            {\r\n                await p.LoadPreferences();\r\n            });\r\n\r\n            p.ShowVersion();\r\n\r\n            if (args.Length == 0)\r\n            {\r\n                p.ShowHelp();\r\n                p.ShowACMEInfo();\r\n            }\r\n            else\r\n            {\r\n                p.ShowACMEInfo();\r\n\r\n                if (args.Contains(\"cleanup\", StringComparer.InvariantCultureIgnoreCase))\r\n                {\r\n                    \/\/ cleanup vault\r\n                    p.PerformVaultCleanup();\r\n                }\r\n\r\n                if (args.Contains(\"renew\", StringComparer.InvariantCultureIgnoreCase))\r\n                {\r\n                    \/\/ perform auto renew all\r\n                    var renewalTask = p.PerformAutoRenew();\r\n                    renewalTask.ConfigureAwait(true);\r\n                    renewalTask.Wait();\r\n\r\n                    \/\/ now perform vault cleanup\r\n                    p.PerformVaultCleanup();\r\n                }\r\n\r\n                if (args.Contains(\"list\", StringComparer.InvariantCultureIgnoreCase))\r\n                {\r\n                    \/\/list managed sites and status\r\n                    p.ListManagedSites();\r\n                }\r\n            }\r\n\r\n#if DEBUG\r\n            p.ListManagedSites();\r\n            Console.ReadKey();\r\n#endif\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    internal class CertifyCLI\r\n    {\r\n        private readonly IdnMapping _idnMapping = new IdnMapping();\r\n        private TelemetryClient _tc = null;\r\n        private ICertifyClient _certifyClient = null;\r\n        private Preferences _prefs = new Preferences();\r\n\r\n        public CertifyCLI()\r\n        {\r\n#if DIRECTCLIENT\r\n            _certifyClient = new CertifyDirectClient();\r\n#else\r\n            _certifyClient = new CertifyServiceClient();\r\n\r\n#endif\r\n        }\r\n\r\n        public async Task LoadPreferences()\r\n        {\r\n            _prefs = await _certifyClient.GetPreferences();\r\n        }\r\n\r\n        private bool IsTelematicsEnabled()\r\n        {\r\n            return _prefs.EnableAppTelematics;\r\n        }\r\n\r\n        private string GetInstrumentationKey()\r\n        {\r\n            return Certify.Locales.ConfigResources.AIInstrumentationKey;\r\n        }\r\n\r\n        private async Task<string> GetAppVersion()\r\n        {\r\n            return await _certifyClient.GetAppVersion();\r\n        }\r\n\r\n        private string GetAppWebsiteURL()\r\n        {\r\n            return \"https:\/\/certifytheweb.com\";\r\n            \/\/ return Certify.Locales.CoreSR.Ap\r\n            \/\/return Certify.Properties.Resources.AppWebsiteURL;\r\n        }\r\n\r\n        private void InitTelematics()\r\n        {\r\n            if (IsTelematicsEnabled())\r\n            {\r\n                _tc = new TelemetryClient();\r\n                _tc.Context.InstrumentationKey = GetInstrumentationKey();\r\n                _tc.InstrumentationKey = GetInstrumentationKey();\r\n\r\n                \/\/ Set session data:\r\n\r\n                _tc.Context.Session.Id = Guid.NewGuid().ToString();\r\n                _tc.Context.Component.Version = GetAppVersion().Result;\r\n                _tc.Context.Device.OperatingSystem = Environment.OSVersion.ToString();\r\n                _tc.TrackEvent(\"StartCLI\");\r\n            }\r\n        }\r\n\r\n        internal void ShowVersion()\r\n        {\r\n            Console.ForegroundColor = ConsoleColor.Yellow;\r\n            System.Console.WriteLine(\"Certify SSL Manager - CLI v1.1.0. Certify.Core v\" + GetAppVersion());\r\n            Console.ForegroundColor = ConsoleColor.White;\r\n            System.Console.WriteLine(\"For more information see \" + GetAppWebsiteURL());\r\n            System.Console.WriteLine(\"\");\r\n        }\r\n\r\n        internal void PerformVaultCleanup()\r\n        {\r\n            System.Console.WriteLine(\"Beginning Vault Cleanup..\");\r\n#if DIRECTCLIENT\r\n            \/\/var certifyManager = new CertifyManager();\r\n            certifyManager.PerformVaultCleanup();\r\n#endif\r\n\r\n            System.Console.WriteLine(\"Completed Vault Cleanup..\");\r\n        }\r\n\r\n        internal void ShowACMEInfo()\r\n        {\r\n#if DIRECTCLIENT\r\n            var certifyManager = new CertifyManager();\r\n            string vaultInfo = certifyManager.GetVaultSummary();\r\n            string acmeInfo = certifyManager.GetAcmeSummary();\r\n\r\n            Console.ForegroundColor = ConsoleColor.DarkYellow;\r\n            System.Console.WriteLine(\"Let's Encrypt ACME API: \" + acmeInfo);\r\n            System.Console.WriteLine(\"ACMESharp Vault: \" + vaultInfo);\r\n#endif\r\n            System.Console.WriteLine(\"\");\r\n            Console.ForegroundColor = ConsoleColor.White;\r\n        }\r\n\r\n        internal void ShowHelp()\r\n        {\r\n            Console.ForegroundColor = ConsoleColor.White;\r\n            System.Console.WriteLine(\"Usage: certify <command> \\n\");\r\n            System.Console.WriteLine(\"certify renew : renew certificates for all auto renewed managed sites\");\r\n            System.Console.WriteLine(\"certify list : list managed sites and current running\/not running status in IIS\");\r\n            System.Console.WriteLine(\"certify cleanup : cleanup vault entries\");\r\n\r\n            System.Console.WriteLine(\"\\n\");\r\n        }\r\n\r\n        internal async Task PerformAutoRenew()\r\n        {\r\n            if (_tc == null) InitTelematics();\r\n            if (_tc != null)\r\n            {\r\n                _tc.TrackEvent(\"CLI_BeginAutoRenew\");\r\n            }\r\n\r\n            Console.ForegroundColor = ConsoleColor.White;\r\n            System.Console.WriteLine(\"\\nPerforming Auto Renewals..\\n\");\r\n\r\n            \/\/go through list of items configured for auto renew, perform renewal and report the result\r\n            var results = await _certifyClient.BeginAutoRenewal();\r\n            Console.ForegroundColor = ConsoleColor.White;\r\n\r\n            foreach (var r in results)\r\n            {\r\n                if (r.ManagedItem != null)\r\n                {\r\n                    System.Console.WriteLine(\"--------------------------------------\");\r\n                    if (r.IsSuccess)\r\n                    {\r\n                        Console.ForegroundColor = ConsoleColor.Green;\r\n                        System.Console.WriteLine(r.ManagedItem.Name);\r\n                    }\r\n                    else\r\n                    {\r\n                        Console.ForegroundColor = ConsoleColor.DarkYellow;\r\n                        System.Console.WriteLine(r.ManagedItem.Name);\r\n\r\n                        if (r.Message != null)\r\n                        {\r\n                            Console.ForegroundColor = ConsoleColor.Red;\r\n                            System.Console.WriteLine(r.Message);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            Console.ForegroundColor = ConsoleColor.White;\r\n\r\n            System.Console.WriteLine(\"Completed:\" + results.Where(r => r.IsSuccess == true).Count());\r\n            if (results.Any(r => r.IsSuccess == false))\r\n            {\r\n                Console.ForegroundColor = ConsoleColor.Red;\r\n                System.Console.WriteLine(\"Failed:\" + results.Where(r => r.IsSuccess == false).Count());\r\n                Console.ForegroundColor = ConsoleColor.White;\r\n            }\r\n        }\r\n\r\n        internal void ListManagedSites()\r\n        {\r\n            var managedSites = _certifyClient.GetManagedSites(new ManagedSiteFilter()).Result;\r\n\r\n            foreach (var site in managedSites)\r\n            {\r\n                Console.ForegroundColor = ConsoleColor.White;\r\n\r\n                Console.WriteLine($\"{site.Name},{site.DateExpiry}\");\r\n            }\r\n        }\r\n\r\n        \/*\r\n       private bool PerformCertRequestAndIISBinding(string certDomain, string[] alternativeNames)\r\n       {\r\n           \/\/ ACME service requires international domain names in ascii mode\r\n           certDomain = _idnMapping.GetAscii(certDomain);\r\n\r\n            \/\/create cert and binding it\r\n\r\n            \/\/Typical command sequence for a new certificate\r\n\r\n            \/\/Initialize-ACMEVault -BaseURI https:\/\/acme-staging.api.letsencrypt.org\/\r\n\r\n            \/\/ Get-Module -ListAvailable ACMESharp New-ACMEIdentifier -Dns test7.examplesite.co.uk\r\n            \/\/ -Alias test7_examplesite_co_uk636213616564101276 -Label\r\n            \/\/ Identifier:test7.examplesite.co.uk Complete-ACMEChallenge -Ref\r\n            \/\/ test7_examplesite_co_uk636213616564101276 -ChallengeType http-01 -Handler manual\r\n            \/\/ -Regenerate Submit-ACMEChallenge -Ref test7_examplesite_co_uk636213616564101276\r\n            \/\/ -Challenge http-01 Update-ACMEIdentifier -Ref\r\n            \/\/ test7_examplesite_co_uk636213616564101276 Update-ACMEIdentifier -Ref\r\n            \/\/ test7_examplesite_co_uk636213616564101276 New-ACMECertificate -Identifier\r\n            \/\/ test7_examplesite_co_uk636213616564101276 -Alias\r\n            \/\/ cert_test7_examplesite_co_uk636213616564101276 -Generate Update-ACMEIdentifier -Ref\r\n            \/\/ test7_examplesite_co_uk636213616564101276 Update-ACMEIdentifier -Ref\r\n            \/\/ test7_examplesite_co_uk636213616564101276 Get-ACMECertificate -Ref = ac22dbfe - b75f\r\n            \/\/ - 4cac-9247-b40c1d9bf9eb -ExportPkcs12\r\n            \/\/ C:\\ProgramData\\ACMESharp\\sysVault\\99-ASSET\\ac22dbfe-b75f-4cac-9247-b40c1d9bf9eb-all.pfx -Overwrite\r\n\r\n            \/\/get info on existing IIS site we want to create\/update SSL binding for\r\n            IISManager iisManager = new IISManager();\r\n            var iisSite = iisManager.GetSiteBindingByDomain(certDomain);\r\n            var certConfig = new CertRequestConfig()\r\n            {\r\n                PrimaryDomain = certDomain,\r\n                PerformChallengeFileCopy = true,\r\n                WebsiteRootPath = Environment.ExpandEnvironmentVariables(iisSite.PhysicalPath)\r\n            };\r\n\r\n            var certifyManager = new VaultManager(Properties.Settings.Default.VaultPath, LocalDiskVault.VAULT);\r\n\r\n            \/\/init vault if not already created\r\n            certifyManager.InitVault(staging: true);\r\n\r\n            \/\/domain alias is used as an ID in both the vault and the LE server, it's specific to one authorization attempt and cannot be reused for renewal\r\n            var domainIdentifierAlias = certifyManager.ComputeIdentifierAlias(certDomain);\r\n\r\n            \/\/NOTE: to support a SAN certificate (multiple alternative domains on one site) the domain validation steps need to be repeat for each name:\r\n\r\n            \/\/register identifier with LE, get http challenge spec back\r\n            \/\/create challenge response answer file under site .well-known, auto configure web.config for extenstionless content, mark challenge prep completed\r\n            var authState = certifyManager.BeginRegistrationAndValidation(certConfig, domainIdentifierAlias);\r\n\r\n            \/\/ask LE to check our answer to their authorization challenge (http), LE will then attempt to fetch our answer, if all accessible and correct (authorized) LE will then allow us to request a certificate\r\n            if (authState.Identifier.Authorization.IsPending())\r\n            {\r\n                \/\/prepare IIS with answer for the LE challenege\r\n                certifyManager.PerformIISAutomatedChallengeResponse(certConfig, authState);\r\n\r\n                \/\/ask LE to validate our challenge response\r\n                certifyManager.SubmitChallenge(domainIdentifierAlias, \"http-01\");\r\n            }\r\n\r\n            \/\/now check if LE has validated our challenge answer\r\n            bool validated = certifyManager.CompleteIdentifierValidationProcess(domainIdentifierAlias);\r\n\r\n            if (validated)\r\n            {\r\n                var certRequestResult = certifyManager.PerformCertificateRequestProcess(domainIdentifierAlias, alternativeIdentifierRefs: null);\r\n                if (certRequestResult.IsSuccess)\r\n                {\r\n                    string pfxPath = certRequestResult.Result.ToString();\r\n                    \/\/Install certificate into certificate store and bind to IIS site\r\n                    \/\/TODO, match by site id?\r\n                    if (iisManager.InstallCertForDomain(certDomain, pfxPath, cleanupCertStore: true, skipBindings: false))\r\n                    {\r\n                        \/\/all done\r\n                        System.Diagnostics.Debug.WriteLine(\"Certificate installed and SSL bindings updated for \" + certDomain);\r\n                        return true;\r\n                    }\r\n                    else\r\n                    {\r\n                        System.Diagnostics.Debug.WriteLine(\"Failed to install PFX file for Certificate.\");\r\n                        return false;\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    System.Diagnostics.Debug.WriteLine(\"LE did not issue a valid certificate in the time allowed.\");\r\n                    return false;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                System.Diagnostics.Debug.WriteLine(\"Validation of the required challenges did not complete successfully.\");\r\n                return false;\r\n            }\r\n\r\n           return false;\r\n       }\r\n       *\/\r\n    }\r\n}","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"3c10ed73ef43af8ac2d0e9f7ec2c316d08c80abc","subject":"all methods now returns Config so tha API can be fluent","message":"all methods now returns Config so tha API can be fluent\n","repos":"inputfalken\/Sharpy","old_file":"DataGen\/Config.cs","new_file":"DataGen\/Config.cs","new_contents":"using System;\nusing System.Linq;\nusing DataGen.Types.CountryCode;\nusing DataGen.Types.Mail;\nusing DataGen.Types.Name;\nusing DataGen.Types.String;\n\nnamespace DataGen {\n    public class Config {\n        internal PhoneNumberGenerator PhoneNumberGenerator { get; private set; }\n        internal NameFilter NameFilter { get; private set; }\n        internal StringFilter Usernames { get; private set; }\n        internal MailGenerator MailGenerator { get; private set; }\n\n        public Config FilterNamesByCountry(string country) {\n            NameFilter = NameFilter.ByCountry(country);\n            return this;\n        }\n\n        public Config FilterNamesByRegion(string region) {\n            NameFilter = NameFilter.ByRegion(region);\n            return this;\n        }\n\n        public Config ChangeMailProviders(string provider, params string[] providers) {\n            MailGenerator = new MailGenerator(provider, providers);\n            return this;\n        }\n\n        public Config ChangePhoneCode(string country) {\n            PhoneNumberGenerator = DataCollections.CountryCodes.Value.First(generator => generator.Name == country);\n            return this;\n        }\n\n\n        public Config ChangeUserNameFiltering(Func<StringFilter, StringFilter> func) {\n            Usernames = func(Usernames);\n            return this;\n        }\n\n        public Config(NameFilter nameFilter = null, StringFilter usernames = null,\n            MailGenerator mailGenerator = null,\n            PhoneNumberGenerator phoneNumberGenerator = null) {\n            PhoneNumberGenerator = phoneNumberGenerator ?? DataCollections.CountryCodes.Value.RandomItem;\n            NameFilter = nameFilter ?? DataCollections.Names.Value;\n            Usernames = usernames ?? DataCollections.UserNames.Value;\n            MailGenerator = mailGenerator ?? new MailGenerator(\"gmail.com\", \"hotmail.com\", \"yahoo.com\");\n        }\n    }\n}","old_contents":"using System;\nusing System.Linq;\nusing DataGen.Types.CountryCode;\nusing DataGen.Types.Mail;\nusing DataGen.Types.Name;\nusing DataGen.Types.String;\n\nnamespace DataGen {\n    public class Config {\n        internal PhoneNumberGenerator PhoneNumberGenerator { get; private set; }\n        internal NameFilter NameFilter { get; private set; }\n        internal StringFilter Usernames { get; private set; }\n        internal MailGenerator MailGenerator { get; private set; }\n\n        public void FilterNamesByCountry(string country) => NameFilter = NameFilter.ByCountry(country);\n        public void FilterNamesByRegion(string region) => NameFilter = NameFilter.ByRegion(region);\n        public void ChangeMailProviders(params string[] providers) => MailGenerator = new MailGenerator(null, providers);\n\n        public void ChangePhoneCode(string country) =>\n            PhoneNumberGenerator = DataCollections.CountryCodes.Value.First(generator => generator.Name == country);\n\n        public void ChangeUserNameFiltering(Func<StringFilter, StringFilter> func) => Usernames = func(Usernames);\n\n        public Config(NameFilter nameFilter = null, StringFilter usernames = null,\n            MailGenerator mailGenerator = null,\n            PhoneNumberGenerator phoneNumberGenerator = null) {\n            PhoneNumberGenerator = phoneNumberGenerator ?? DataCollections.CountryCodes.Value.RandomItem;\n            NameFilter = nameFilter ?? DataCollections.Names.Value;\n            Usernames = usernames ?? DataCollections.UserNames.Value;\n            MailGenerator = mailGenerator ?? new MailGenerator(\"gmail.com\", \"hotmail.com\", \"yahoo.com\");\n        }\n    }\n}","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"e54e8c86d655fcd5b445ef6636df3400568c44b3","subject":"optimized json serializer to use ContractResolver","message":"optimized json serializer to use ContractResolver\n","repos":"Soluto\/tweek,Soluto\/tweek,Soluto\/tweek,Soluto\/tweek,Soluto\/tweek,Soluto\/tweek","old_file":"Tweek.ApiService\/Bootstrapper.cs","new_file":"Tweek.ApiService\/Bootstrapper.cs","new_contents":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Configuration;\nusing System.Threading.Tasks;\nusing Couchbase;\nusing Couchbase.Configuration.Client;\nusing Couchbase.Core.Serialization;\nusing Engine;\nusing Engine.Core.Rules;\nusing Engine.Drivers.Context;\nusing Engine.Drivers.Rules;\nusing FSharp.Data;\nusing Nancy;\nusing Nancy.Bootstrapper;\nusing Nancy.TinyIoc;\nusing Newtonsoft.Json;\nusing Newtonsoft.Json.Converters;\nusing Newtonsoft.Json.Serialization;\nusing NLog;\nusing NLog.Config;\nusing NLog.Targets;\nusing Tweek.ApiService.Interfaces;\nusing Tweek.ApiService.Modules;\nusing Tweek.ApiService.Services;\nusing Tweek.ApiService.Utils;\nusing Tweek.Drivers.Blob;\nusing Tweek.Drivers.CouchbaseDriver;\nusing Tweek.JPad;\nusing Tweek.JPad.Utils;\nusing Tweek.Drivers.Blob.WebClient;\nusing Tweek.Utils;\n\nnamespace Tweek.ApiService\n{\n    class TweekContractResolver : DefaultContractResolver\n    {\n        protected override JsonContract CreateContract(Type objectType)\n         {\n            JsonContract contract = base.CreateContract(objectType);\n \n            if (typeof(JsonValue).IsAssignableFrom(objectType))\n            {\n                contract.Converter = new JsonValueConverter();\n            }\n\n            return contract;\n        }\n    }\n    public class Bootstrapper : DefaultNancyBootstrapper\n    {\n        protected override void ApplicationStartup(TinyIoCContainer container, IPipelines pipelines)\n        {\n            InitLogging();\n            \n            var contextBucketName = ConfigurationManager.AppSettings[\"Couchbase.BucketName\"];\n            var contextBucketPassword = ConfigurationManager.AppSettings[\"Couchbase.Password\"];\n\n            InitCouchbaseCluster(contextBucketName, contextBucketPassword);\n            var contextDriver = new CouchBaseDriver(ClusterHelper.GetBucket, contextBucketName);\n\n            var rulesDriver = GetRulesDriver();\n            StaticConfiguration.DisableErrorTraces = false;\n\n            var parser = GetRulesParser();\n\n            var tweek = Task.Run(async () => await Engine.Tweek.Create(contextDriver, rulesDriver, parser)).Result;\n\n            var bucketConnectionIsAlive = new BucketConnectionIsAlive(ClusterHelper.GetBucket, contextBucketName);\n            var rulesDriverStatusService = new RulesDriverStatusService(rulesDriver);\n\n            container.Register<ITweek>(tweek);\n            container.Register<IContextDriver>(contextDriver);\n            container.Register<IRuleParser>(parser);\n            container.Register<IEnumerable<IDiagnosticsProvider>>((ctx, no) => new List<IDiagnosticsProvider> {  bucketConnectionIsAlive, rulesDriverStatusService});\n\n            var jsonSerializer = new JsonSerializer() {ContractResolver = new TweekContractResolver()};\n            container.Register<JsonSerializer>(jsonSerializer);\n                \n            base.ApplicationStartup(container, pipelines);\n        }\n\n        IRuleParser GetRulesParser()\n        {\n            return JPadRulesParserAdapter.Convert(new JPadParser(new ParserSettings(\n                comparers: new Dictionary<string, ComparerDelegate>()\n                {\n                    [\"version\"] = Version.Parse\n                })));\n        }\n\n        private void InitCouchbaseCluster(string bucketName, string bucketPassword)\n        {\n            var url = ConfigurationManager.AppSettings[\"Couchbase.Url\"];\n\n            ClusterHelper.Initialize(new ClientConfiguration\n            {\n                Servers = new List<Uri> { new Uri(url) },\n                BucketConfigs = new Dictionary<string, BucketConfiguration>\n                {\n                    [bucketName] = new BucketConfiguration\n                    {\n                        BucketName = bucketName,\n                        Password = bucketPassword,\n                        PoolConfiguration = new PoolConfiguration()\n                        {\n                            MaxSize = 30,\n                            MinSize = 5\n                        }\n                    }\n                },\n                Serializer = () => new DefaultSerializer(\n                   new JsonSerializerSettings()\n                   {\n                       ContractResolver = new TweekContractResolver()\n                   },\n                   new JsonSerializerSettings()\n                   {\n                       ContractResolver = new TweekContractResolver()\n                   })\n            });\n        }\n\n        private BlobRulesDriver GetRulesDriver()\n        {\n            return new BlobRulesDriver(new Uri(ConfigurationManager.AppSettings[\"RulesBlob.Url\"]), new SystemWebClientFactory());\n        }\n\n        private static void InitLogging()\n        {\n            var configuration = new LoggingConfiguration();\n\n            var fileTarget = new FileTarget\n            {\n                FileName = \"${basedir}\/tweek-\" + DateTime.UtcNow.ToString(\"yyyyMMdd\") + \".log\",\n                Layout = @\"${date:format=HH\\:mm\\:ss} | ${message}\"\n            };\n\n            configuration.AddTarget(\"file\", fileTarget);\n\n            var rule = new LoggingRule(\"*\", LogLevel.Debug, fileTarget);\n            configuration.LoggingRules.Add(rule);\n\n            LogManager.Configuration = configuration;\n        }\n    }\n}","old_contents":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Configuration;\nusing System.Threading.Tasks;\nusing Couchbase;\nusing Couchbase.Configuration.Client;\nusing Couchbase.Core.Serialization;\nusing Engine;\nusing Engine.Core.Rules;\nusing Engine.Drivers.Context;\nusing Engine.Drivers.Rules;\nusing Nancy;\nusing Nancy.Bootstrapper;\nusing Nancy.TinyIoc;\nusing Newtonsoft.Json;\nusing Newtonsoft.Json.Serialization;\nusing NLog;\nusing NLog.Config;\nusing NLog.Targets;\nusing Tweek.ApiService.Interfaces;\nusing Tweek.ApiService.Modules;\nusing Tweek.ApiService.Services;\nusing Tweek.ApiService.Utils;\nusing Tweek.Drivers.Blob;\nusing Tweek.Drivers.CouchbaseDriver;\nusing Tweek.JPad;\nusing Tweek.JPad.Utils;\nusing Tweek.Drivers.Blob.WebClient;\nusing Tweek.Utils;\n\nnamespace Tweek.ApiService\n{\n    public class Bootstrapper : DefaultNancyBootstrapper\n    {\n        protected override void ApplicationStartup(TinyIoCContainer container, IPipelines pipelines)\n        {\n            InitLogging();\n            \n            var contextBucketName = ConfigurationManager.AppSettings[\"Couchbase.BucketName\"];\n            var contextBucketPassword = ConfigurationManager.AppSettings[\"Couchbase.Password\"];\n\n            InitCouchbaseCluster(contextBucketName, contextBucketPassword);\n            var contextDriver = new CouchBaseDriver(ClusterHelper.GetBucket, contextBucketName);\n\n            var rulesDriver = GetRulesDriver();\n            StaticConfiguration.DisableErrorTraces = false;\n\n            var parser = GetRulesParser();\n\n            var tweek = Task.Run(async () => await Engine.Tweek.Create(contextDriver, rulesDriver, parser)).Result;\n\n            var bucketConnectionIsAlive = new BucketConnectionIsAlive(ClusterHelper.GetBucket, contextBucketName);\n            var rulesDriverStatusService = new RulesDriverStatusService(rulesDriver);\n\n            container.Register<ITweek>(tweek);\n            container.Register<IContextDriver>(contextDriver);\n            container.Register<IRuleParser>(parser);\n            container.Register<IEnumerable<IDiagnosticsProvider>>((ctx, no) => new List<IDiagnosticsProvider> {  bucketConnectionIsAlive, rulesDriverStatusService});\n\n            var jsonSerializer = new JsonSerializer() {Converters = { JsonValueConverter.Instance } };\n            container.Register<JsonSerializer>(jsonSerializer);\n                \n            base.ApplicationStartup(container, pipelines);\n        }\n\n        IRuleParser GetRulesParser()\n        {\n            return JPadRulesParserAdapter.Convert(new JPadParser(new ParserSettings(\n                comparers: new Dictionary<string, ComparerDelegate>()\n                {\n                    [\"version\"] = Version.Parse\n                })));\n        }\n\n        private void InitCouchbaseCluster(string bucketName, string bucketPassword)\n        {\n            var url = ConfigurationManager.AppSettings[\"Couchbase.Url\"];\n\n            ClusterHelper.Initialize(new ClientConfiguration\n            {\n                Servers = new List<Uri> { new Uri(url) },\n                BucketConfigs = new Dictionary<string, BucketConfiguration>\n                {\n                    [bucketName] = new BucketConfiguration\n                    {\n                        BucketName = bucketName,\n                        Password = bucketPassword,\n                        PoolConfiguration = new PoolConfiguration()\n                        {\n                            MaxSize = 30,\n                            MinSize = 5\n                        }\n                    }\n                },\n                Serializer = () => new DefaultSerializer(\n                   new JsonSerializerSettings()\n                   {\n                       ContractResolver = new DefaultContractResolver(),\n                       Converters =\n                       {\n                           JsonValueConverter.Instance\n                       }\n                   },\n                   new JsonSerializerSettings()\n                   {\n                       ContractResolver = new DefaultContractResolver(),\n                       Converters =\n                       {\n                           JsonValueConverter.Instance\n                       }\n                   })\n            });\n        }\n\n        private BlobRulesDriver GetRulesDriver()\n        {\n            return new BlobRulesDriver(new Uri(ConfigurationManager.AppSettings[\"RulesBlob.Url\"]), new SystemWebClientFactory());\n        }\n\n        private static void InitLogging()\n        {\n            var configuration = new LoggingConfiguration();\n\n            var fileTarget = new FileTarget\n            {\n                FileName = \"${basedir}\/tweek-\" + DateTime.UtcNow.ToString(\"yyyyMMdd\") + \".log\",\n                Layout = @\"${date:format=HH\\:mm\\:ss} | ${message}\"\n            };\n\n            configuration.AddTarget(\"file\", fileTarget);\n\n            var rule = new LoggingRule(\"*\", LogLevel.Debug, fileTarget);\n            configuration.LoggingRules.Add(rule);\n\n            LogManager.Configuration = configuration;\n        }\n    }\n}","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"c92566f8e0ee21de88d3a1e79dec41e78bf62a96","subject":"[versions] Add individual facebook android version","message":"[versions] Add individual facebook android version\n","repos":"xamarin\/XamarinComponents,xamarin\/XamarinComponents,xamarin\/XamarinComponents,xamarin\/XamarinComponents,xamarin\/XamarinComponents,xamarin\/XamarinComponents","old_file":"Util\/VersionChecker\/versions.csx","new_file":"Util\/VersionChecker\/versions.csx","new_contents":"#load \".\/common\/CocoaPods.csx\"\n#load \".\/common\/Maven.csx\"\n#load \".\/common\/GitHubReleases.csx\"\n#load \".\/common\/XPath.csx\"\n#load \".\/common\/SlackNotifier.csx\"\n\nvar OWNER_US1 = System.Environment.GetEnvironmentVariable (\"OWNER_US1\");\nvar OWNER_CA1 = System.Environment.GetEnvironmentVariable (\"OWNER_CA1\");\nvar OWNER_MX1 = System.Environment.GetEnvironmentVariable (\"OWNER_MX1\");\nvar OWNER_SA1 = System.Environment.GetEnvironmentVariable (\"OWNER_SA1\");\n\nvar fetchers = new VersionFetcher[] {\n    \/\/ Android\n    new MavenCentral (\"Android Easing Functions\", \"1.0.2\", \"com\/daimajia\/easing\/library\", OWNER_SA1),\n    new MavenCentral (\"Android Swipe Layout\", \"1.2.0\", \"com\/daimajia\/swipelayout\/library\", OWNER_SA1),\n    new Maven (\"Android Things\", \"1.0\", \"https:\/\/google.bintray.com\/androidthings\/com\/google\/android\/things\/androidthings\/maven-metadata.xml\", OWNER_CA1),\n    new MavenCentral (\"Android View Animations\", \"1.1.3\", \"com\/daimajia\/androidanimations\/library\", OWNER_SA1),\n    new MavenCentral (\"Android Volley\", \"1.0.19\", \"com\/mcxiaoke\/volley\/library\", OWNER_SA1),\n    new BinTray (\"Animated Circle Loading View\", \"1.1.5\", \"jlmd\", \"maven\/com\/github\/jlmd\/AnimatedCircleLoadingView\", OWNER_SA1),\n    new MavenCentral (\"Auto Fit Text View\", \"0.2.1\", \"me\/grantland\/autofittextview\", OWNER_SA1),\n    new BinTray (\"Azure Messaging Android\", \"0.4.0\", \"microsoftazuremobile\", \"SDK\/com\/microsoft\/azure\/notification-hubs-android-sdk\", OWNER_CA1),\n    new MavenCentral (\"Better Pickers\", \"1.6.0\", \"com\/doomonafireball\/betterpickers\/library\", OWNER_CA1),\n    new BinTray (\"Elastic Progress Bar\", \"1.0.5\", \"michelelacorte\", \"maven\/it\/michelelacorte\/elasticprogressbar\/library\", OWNER_SA1),\n    new MavenCentral (\"Floating SearchView\", \"2.1.1\", \"com\/github\/arimorty\/floatingsearchview\", OWNER_SA1),\n    new MavenCentral (\"GoogleGson\", \"2.8.1\", \"com\/google\/code\/gson\/gson\", OWNER_SA1),\n    new MavenCentral (\"KenBurnsView\", \"1.0.7\", \"com\/flaviofaria\/kenburnsview\", OWNER_SA1),\n    new MavenCentral (\"Minimal Json\", \"0.9.4\", \"com\/eclipsesource\/minimal-json\/minimal-json\", OWNER_SA1),\n    new MavenCentral (\"Nine Old Androids\", \"2.4.0\", \"com\/nineoldandroids\/library\", OWNER_SA1),\n    new MavenCentral (\"Number Progress Bar\", \"1.2\", \"com\/daimajia\/numberprogressbar\/library\", OWNER_SA1),\n    new MavenCentral (\"PhotoView\", \"2.1.3\", \"com\/github\/chrisbanes\/photoview\/library\", OWNER_SA1),\n    \/\/new BinTray (\"RecyclerView Animators\", \"2.1.0\", \"wasabeef\", \"maven\/jp\/wasabeef\/recyclerview-animators\", OWNER_SA1),\n    new MavenCentral (\"RoundedImageView\", \"2.3.0\", \"com\/makeramen\/roundedimageview\", OWNER_SA1),\n    new MavenCentral (\"Scissors\", \"1.1.1\", \"com\/lyft\/scissors\", OWNER_SA1),\n    \/\/new BinTray (\"Sortable TableView\", \"2.2.0\", \"ischwarz\", \"maven\/de\/codecrafters\/tableview\/tableview\", OWNER_SA1),\n    new MavenCentral (\"Sticky List Headers\", \"2.7.0\", \"se\/emilsjolander\/stickylistheaders\", OWNER_SA1),\n    new MavenCentral (\"Timber\", \"4.6.0\", \"com\/jakewharton\/timber\/timber\", OWNER_US1),\n    new MavenCentral (\"Universal Image Loader\", \"1.9.5\", \"com\/nostra13\/universalimageloader\/universal-image-loader\", OWNER_SA1),\n    new MavenCentral (\"VectorCompat\", \"1.0.5\", \"com\/wnafee\/vector-compat\", OWNER_SA1),\n    new MavenCentral (\"ViewPropertyObjectAnimator\", \"1.4.5\", \"com\/bartoszlipinski\/viewpropertyobjectanimator\", OWNER_SA1),\n    new MavenCentral (\"Kotlin\", \"1.1.4-3\", \"org\/jetbrains\/kotlin\/kotlin-stdlib\", OWNER_SA1),        \n    new Maven (\"Blurring\", \"1.0.0\", \"https:\/\/github.com\/500px\/500px-android-blur\/blob\/master\/releases\/com\/fivehundredpx\/blurringview\/maven-metadata.xml\", OWNER_CA1),\n    new MavenCentral (\"DeviceYearClass\", \"1.0.0\", \"com.facebook.device.yearclass\", OWNER_SA1),\n    new MavenCentral (\"Glide\", \"4.0.0\", \"com.github.bumptech.glide\", OWNER_SA1),\n    new MavenCentral (\"GoogleZXing\", \"3.3.0\", \"com.google.zxing\", OWNER_SA1),\n    new MavenCentral (\"Guava\", \"23.2-android\", \"com.google.guava\", OWNER_SA1),\n    new MavenCentral (\"Jackson.Core\", \"2.7.4\", \"com.fasterxml.jackson.core\", OWNER_SA1),\n    new MavenCentral (\"MinimalJson\", \"0.9.4\", \"com.eclipsesource.minimal-json\", OWNER_SA1),\n    new MavenCentral (\"RecyclerViewAnimators\", \"2.1.0\", \"jp.wasabeef\", OWNER_SA1),\n    new MavenCentral (\"ShimmerLayout\", \"0.5.0\", \"io.supercharge\", OWNER_SA1),\n    new MavenCentral (\"UrlImageViewHelper\", \"1.0.4\", \"com.koushikdutta.urlimageviewhelper\", OWNER_SA1),\n    new MavenCentral (\"Bolts\", \"1.4.0\", \"com.parse.bolts\", OWNER_SA1),\n\n    \/\/ iOS\n    new CocoaPods (\"AMViralSwitch\", \"1.0.0\", \"AMViralSwitch\", OWNER_SA1),\n    new CocoaPods (\"Chameleon\", \"2.1\", \"ChameleonFramework\", OWNER_SA1),\n    new GitHubReleases (\"CorePlot\", \"1.5.1\", \"core-plot\", \"core-plot\", OWNER_SA1),\n    new CocoaPods (\"DACircularProgress\", \"2.3.1\", \"DACircularProgress\", OWNER_SA1),\n    new CocoaPods (\"DZNEmptyDataSet\", \"1.7.3\", \"DZNEmptyDataSet\", OWNER_SA1),\n    new CocoaPods (\"FXBlurView\", \"1.6.4\", \"FXBlurView\", OWNER_SA1),\n    new CocoaPods (\"GPUImage\", \"0.1.7\", \"GPUImage\", OWNER_SA1),\n    new CocoaPods (\"InAppSettingsKit\", \"2.6\", \"InAppSettingsKit\", OWNER_SA1),\n    new CocoaPods (\"JDStatusBarNotification\", \"1.5.3\", \"JDStatusBarNotification\", OWNER_SA1),\n    new GitHubReleases (\"JSQMessagesViewController\", \"7.3.5\", \"jessesquires\", \"JSQMessagesViewController\", OWNER_US1),\n    new CocoaPods (\"Progress HUD\", \"0.9.2.0\", \"MBProgressHUD\", OWNER_SA1),\n    new CocoaPods (\"MWPhotoBrowser\", \"2.1.1\", \"MWPhotoBrowser\", OWNER_SA1),\n    new CocoaPods (\"Masonry\", \"1.0.2\", \"Masonry\", OWNER_SA1),\n    new CocoaPods (\"RZTransitions\", \"1.2.1\", \"RZTransitions\", OWNER_SA1),\n    new CocoaPods (\"SCCatWaitingHUD\", \"0.1.6\", \"SCCatWaitingHUD\", OWNER_SA1),\n    new CocoaPods (\"SDWebImage\", \"3.7.5\", \"SDWebImage\", OWNER_SA1),\n    new CocoaPods (\"SlackTextViewController\", \"1.9.6\", \"SlackTextViewController\", OWNER_SA1),\n    new CocoaPods (\"TPKeyboardAvoiding\", \"1.3.2\", \"TPKeyboardAvoiding\", OWNER_SA1),\n    new CocoaPods (\"ZipArchive\", \"1.4.0\", \"ZipArchive\", OWNER_SA1),\n    new CocoaPods (\"iCarousel\", \"1.8.3\", \"iCarousel\", OWNER_SA1),\n    new GitHubReleases (\"iRate\", \"1.11.7\", \"nicklockwood\", \"iRate\", OWNER_SA1),\n    new CocoaPods (\"AMScrollingNavbar\", \"4.1.0\", \"AMScrollingNavbar\", OWNER_SA1),\n    new CocoaPods (\"IQAudioRecorderController\", \"1.1\", \"IQAudioRecorderController\", OWNER_SA1),\n    new CocoaPods (\"REFrostedViewController\", \"1.1\", \"REFrostedViewController\", OWNER_SA1),\n    new CocoaPods (\"TwitterImagePipeline\", \"2.2.2\", \"TwitterImagePipeline\", OWNER_SA1),\n    new CocoaPods (\"LiquidFloatingActionButton\", \"2.0.0\", \"LiquidFloatingActionButton\", OWNER_SA1),\n    new CocoaPods (\"JVMenuPopover\", \"1.7\", \"JVMenuPopover\", OWNER_SA1),\n    new CocoaPods (\"JZMultiChoicesCircleButton\", \"1.1\", \"JZMultiChoicesCircleButton\", OWNER_SA1),\n    new CocoaPods (\"PickerCells\", \"1.2\", \"PickerCells\", OWNER_SA1),\n    new CocoaPods (\"SDSegmentedControl\", \"2.1.5\", \"SDSegmentedControl\", OWNER_SA1),\n\n    \/\/ Card.IO\n    new GitHubReleases (\"Card.IO Android\", \"5.5.1\", \"card-io\", \"card.io-Android-SDK\", OWNER_CA1),\n    new GitHubReleases (\"Card.IO iOS\", \"5.4.1\", \"card-io\", \"card.io-iOS-SDK\", OWNER_CA1),\n\n\n    \/\/ Facebook\n    new XPath (\"Facebook Android - SDK\", \"4.33.0\", \"https:\/\/repo1.maven.org\/maven2\/com\/facebook\/android\/facebook-android-sdk\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Facebook Android - AppLinks\", \"4.33.0\", \"https:\/\/repo1.maven.org\/maven2\/com\/facebook\/android\/facebook-applinks\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Facebook Android - Common\", \"4.33.0\", \"https:\/\/repo1.maven.org\/maven2\/com\/facebook\/android\/facebook-common\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Facebook Android - Core\", \"4.33.0\", \"https:\/\/repo1.maven.org\/maven2\/com\/facebook\/android\/facebook-core\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Facebook Android - Login\", \"4.33.0\", \"https:\/\/repo1.maven.org\/maven2\/com\/facebook\/android\/facebook-login\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Facebook Android - Messenger\", \"4.33.0\", \"https:\/\/repo1.maven.org\/maven2\/com\/facebook\/android\/facebook-messenger\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Facebook Android - Places\", \"4.33.0\", \"https:\/\/repo1.maven.org\/maven2\/com\/facebook\/android\/facebook-places\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Facebook Android - Share\", \"4.33.0\", \"https:\/\/repo1.maven.org\/maven2\/com\/facebook\/android\/facebook-share\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Facebook Android - Account Kit SDK\", \"4.28.0\", \"https:\/\/repo1.maven.org\/maven2\/com\/facebook\/android\/facebook-common\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Facebook Android - Audience Network SDK\", \"4.28.1\", \"https:\/\/repo1.maven.org\/maven2\/com\/facebook\/android\/facebook-common\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Facebook Android - Notifications\", \"1.0.2\", \"https:\/\/repo1.maven.org\/maven2\/com\/facebook\/android\/facebook-common\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    \n\n    new CocoaPods (\"Facebook Pop\", \"1.0.9\", \"pop\", OWNER_CA1),\n    new CocoaPods (\"Facebook iOS - CoreKit\", \"4.33.0\", \"FBSDKCoreKit\", OWNER_MX1),\n\n    \/\/ Google - Android\n    new XPath (\"Android Support Libraries\", \"27.0.2\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/android\/support\/appcompat-v7\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Google Glass SDK\", \"11\", \"https:\/\/dl.google.com\/android\/repository\/glass\/addon2-1.xml\", \"\/\/*[local-name() = 'remotePackage' and @path='add-ons;addon-google_gdk-google-19']\/*[local-name() = 'revision']\", OWNER_CA1),\n    new XPath (\"Google Android ARCore\", \"1.0.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/ar\/core\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Android Wearable\/Wearable\", \"2.2.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/android\/wearable\/wearable\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Android Support\/Wearable\", \"2.2.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/android\/support\/wearable\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Android Support Constraint Layout\", \"1.1.0-beta5\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/android\/support\/constraint\/constraint-layout\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n\n    \/\/ Google - iOS\n    new CocoaPods (\"Google.Analytics iOS\", \"3.17.0\", \"GoogleAnalytics\", OWNER_MX1),\n    new CocoaPods (\"Google.AppIndexing iOS\", \"2.0.3\", \"GoogleAppIndexing\", OWNER_MX1),\n    \/\/ new CocoaPods (\"Google.AppInvites iOS\", \"1.0.2\", \"AppInvites\", OWNER_MX1), \/\/ Deprecated\n    new CocoaPods (\"Google.Cast iOS\", \"4.1.0\", \"google-cast-sdk\", OWNER_MX1),\n    new CocoaPods (\"Google.Core iOS\", \"3.1.0\", \"Google\", OWNER_MX1),\n    \/\/ new CocoaPods (\"Google.GoogleCloudMessaging iOS\", \"1.2.0\", \"GoogleCloudMessaging\", OWNER_MX1), \/\/ Deprecated\n    new CocoaPods (\"Google.InstanceID iOS\", \"1.2.1\", \"GGLInstanceID\", OWNER_MX1),\n    new CocoaPods (\"Google.Maps iOS\", \"2.5.0\", \"GoogleMaps\", OWNER_MX1),\n    \/\/ new CocoaPods (\"Google.MobileAds iOS\", \"7.27.0\", \"GoogleMobileAds\", OWNER_MX1), \/\/ Renamed as Firebase.AdMob\n    new CocoaPods (\"Google.PlayGames iOS\", \"5.1.1\", \"GooglePlayGames\", OWNER_MX1),\n    \/\/ new CocoaPods (\"Google.Plus iOS\", \"1.7.1\", \"GooglePlusOpenSource\", OWNER_MX1), \/\/ Deprecated\n    new CocoaPods (\"Google.SignIn iOS\", \"4.8.0\", \"GoogleSignIn\", OWNER_MX1),\n    new CocoaPods (\"Google.TagManager iOS\", \"6.0.0\", \"GoogleTagManager\", OWNER_MX1),\n\n    \/\/Firebase - Android\n    new XPath (\"Firebase - Ads\", \"15.0.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-ads\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Analytics\", \"16.0.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-analytics\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Analytics Impl\", \"16.1.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-analytics-impl\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Appindexing\", \"16.0.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-appindexing\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Auth\", \"16.0.2\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-auth\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Common\", \"16.0.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-common\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Config\", \"16.0.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-config\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Core\", \"16.0.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-core\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Crash\", \"16.0.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-crash\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Database\", \"16.0.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-database\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Database Connection\", \"16.0.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-database-connection\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Dynamic Links\", \"16.0.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-dynamic-links\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Firestore\", \"17.0.2\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-firestore\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Iid\", \"16.2.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-iid\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Invites\", \"16.0.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-invites\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Messaging\", \"17.1.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-messaging\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Perf\", \"16.0.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-perf\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Storage\", \"16.0.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-storage\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Storage Common\", \"16.0.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-storage-common\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    \n    new XPath (\"Firebase - Abt\", \"16.0.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-abt\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Ads Lite\", \"15.0.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-ads-lite\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Auth Interop\", \"16.0.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-auth-interop\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Database Collection\", \"15.0.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-database-collection\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Functions\", \"16.0.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-functions\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Iid Interop\", \"16.0.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-iid-interop\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Measurement Connector\", \"17.0.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-measurement-connector\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Measurement Connector Impl\", \"16.0.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-measurement-connector-impl\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Ml Common\", \"16.0.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-ml-common\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Ml Model Interpreter\", \"16.0.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-ml-model-interpreter\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Ml Vision\", \"16.0.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-ml-vision\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Ml Vision Image Label Model\", \"15.0.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-ml-vision-image-label-model\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n\n\n    \/\/ Firebase - iOS\n    new CocoaPods (\"Firebase iOS\", \"4.0.3\", \"Firebase\", OWNER_MX1),\n    new CocoaPods (\"Firebase.AdMob iOS\", \"7.27.0\", \"Google-Mobile-Ads-SDK\", OWNER_MX1),\n    new CocoaPods (\"Firebase.Analytics iOS\", \"4.0.5\", \"FirebaseAnalytics\", OWNER_MX1),\n    new CocoaPods (\"Firebase.Auth iOS\", \"4.0.0\", \"FirebaseAuth\", OWNER_MX1),\n    new CocoaPods (\"Firebase.CloudMessaging iOS\", \"4.8.0\", \"FirebaseMessaging\", OWNER_MX1),\n    new CocoaPods (\"Firebase.Core iOS\", \"4.0.13\", \"FirebaseCore\", OWNER_MX1),\n    new CocoaPods (\"Firebase.CrashReporting iOS\", \"2.0.0\", \"FirebaseCrash\", OWNER_MX1),\n    new CocoaPods (\"Firebase.Database iOS\", \"4.1.3\", \"FirebaseDatabase\", OWNER_MX1),\n    new CocoaPods (\"Firebase.DynamicLinks iOS\", \"4.8.0\", \"FirebaseDynamicLinks\", OWNER_MX1),\n    new CocoaPods (\"Firebase.InstanceID iOS\", \"2.0.8\", \"FirebaseInstanceID\", OWNER_MX1),\n    new CocoaPods (\"Firebase.Invites iOS\", \"4.8.0\", \"FirebaseInvites\", OWNER_MX1),\n    new CocoaPods (\"Firebase.PerformanceMonitoring iOS\", \"1.1.0\", \"FirebasePerformance\", OWNER_MX1),\n    new CocoaPods (\"Firebase.RemoteConfig iOS\", \"2.0.3\", \"FirebaseRemoteConfig\", OWNER_MX1),\n    new CocoaPods (\"Firebase.Storage iOS\", \"2.0.2\", \"FirebaseStorage\", OWNER_MX1),\n\n    \/\/ Mapbox\n    new MavenCentral (\"Mapbox Android\", \"4.2.2\", \"com\/mapbox\/mapboxsdk\/mapbox-android-sdk\", OWNER_CA1),\n    new CocoaPods (\"Mapbox iOS\", \"3.5.0\", \"Mapbox-iOS-SDK\", OWNER_CA1),\n\n    \/\/ Socket.IO\n    new MavenCentral (\"Socket.IO Client\", \"1.0.0\", \"io\/socket\/socket.io-client\", OWNER_SA1),\n    new MavenCentral (\"Engine.IO Client\", \"1.0.0\", \"io\/socket\/engine.io-client\", OWNER_SA1),\n\n    \/\/ Square\n    new MavenCentral (\"OkIO\", \"1.13.0\", \"com\/squareup\/okio\/okio\", OWNER_SA1),\n    new MavenCentral (\"OkHttp\", \"2.7.5\", \"com\/squareup\/okhttp\/okhttp\", OWNER_SA1),\n    new MavenCentral (\"OkHttp3\", \"3.8.1\", \"com\/squareup\/okhttp3\/okhttp\", OWNER_SA1),\n    new MavenCentral (\"OkHttp Web Sockets\", \"2.7.5\", \"com\/squareup\/okhttp\/okhttp-ws\", OWNER_SA1),\n    new MavenCentral (\"OkHttp3 Web Sockets\", \"3.4.2\", \"com\/squareup\/okhttp3\/okhttp-ws\", OWNER_SA1),\n    new MavenCentral (\"Picasso\", \"2.5.2\", \"com\/squareup\/picasso\/picasso\", OWNER_SA1),\n    new MavenCentral (\"AndroidTimesSquare\", \"1.7.3\", \"com\/squareup\/android-times-square\", OWNER_SA1),\n    new MavenCentral (\"Seismic\", \"1.0.2\", \"com\/squareup\/seismic\", OWNER_SA1),\n    new MavenCentral (\"Pollexor\", \"2.0.4\", \"com\/squareup\/pollexor\", OWNER_SA1),\n    new MavenCentral (\"OkHttp UrlConection\", \"2.7.5\", \"com\/squareup\/okhttp\/okhttp-urlconnection\", OWNER_SA1),\n    new MavenCentral (\"Retrofit\", \"1.9.0\", \"com\/squareup\/retrofit\", OWNER_SA1),\n    new MavenCentral (\"Retrofit2\", \"2.3.0\", \"com\/squareup\/retrofit2\", OWNER_SA1),\n    new GitHubReleases (\"SocketRocket\", \"0.5.1\", \"square\", \"SocketRocket\", OWNER_SA1),\n    new GitHubReleases (\"Valet\", \"2.4.1\", \"square\", \"Valet\", OWNER_SA1),\n    new GitHubReleases (\"Aardvark\", \"1.5.0\", \"square\", \"Aardvark\", OWNER_SA1),\n};\n\nvar updates = new List<UpdateInfo> ();\nvar failures = new List<string> ();\n\nforeach (var v in fetchers) {\n    try {\n        var updateInfo = v.Run ();\n        if (updateInfo != null)\n            updates.Add (updateInfo);\n    } catch (Exception ex) {\n        failures.Add (v.ComponentName);\n    }\n}\n\nforeach (var grp in updates.GroupBy (up => up.Owner)) {\n    var owner = string.IsNullOrEmpty (grp.Key) ? \"here\" : grp.Key;\n    SlackNotifier.Notify (owner, grp);\n}\n\nif (failures.Any ())\n    SlackNotifier.Notify (failures);\n","old_contents":"#load \".\/common\/CocoaPods.csx\"\n#load \".\/common\/Maven.csx\"\n#load \".\/common\/GitHubReleases.csx\"\n#load \".\/common\/XPath.csx\"\n#load \".\/common\/SlackNotifier.csx\"\n\nvar OWNER_US1 = System.Environment.GetEnvironmentVariable (\"OWNER_US1\");\nvar OWNER_CA1 = System.Environment.GetEnvironmentVariable (\"OWNER_CA1\");\nvar OWNER_MX1 = System.Environment.GetEnvironmentVariable (\"OWNER_MX1\");\nvar OWNER_SA1 = System.Environment.GetEnvironmentVariable (\"OWNER_SA1\");\n\nvar fetchers = new VersionFetcher[] {\n    \/\/ Android\n    new MavenCentral (\"Android Easing Functions\", \"1.0.2\", \"com\/daimajia\/easing\/library\", OWNER_SA1),\n    new MavenCentral (\"Android Swipe Layout\", \"1.2.0\", \"com\/daimajia\/swipelayout\/library\", OWNER_SA1),\n    new Maven (\"Android Things\", \"1.0\", \"https:\/\/google.bintray.com\/androidthings\/com\/google\/android\/things\/androidthings\/maven-metadata.xml\", OWNER_CA1),\n    new MavenCentral (\"Android View Animations\", \"1.1.3\", \"com\/daimajia\/androidanimations\/library\", OWNER_SA1),\n    new MavenCentral (\"Android Volley\", \"1.0.19\", \"com\/mcxiaoke\/volley\/library\", OWNER_SA1),\n    new BinTray (\"Animated Circle Loading View\", \"1.1.5\", \"jlmd\", \"maven\/com\/github\/jlmd\/AnimatedCircleLoadingView\", OWNER_SA1),\n    new MavenCentral (\"Auto Fit Text View\", \"0.2.1\", \"me\/grantland\/autofittextview\", OWNER_SA1),\n    new BinTray (\"Azure Messaging Android\", \"0.4.0\", \"microsoftazuremobile\", \"SDK\/com\/microsoft\/azure\/notification-hubs-android-sdk\", OWNER_CA1),\n    new MavenCentral (\"Better Pickers\", \"1.6.0\", \"com\/doomonafireball\/betterpickers\/library\", OWNER_CA1),\n    new BinTray (\"Elastic Progress Bar\", \"1.0.5\", \"michelelacorte\", \"maven\/it\/michelelacorte\/elasticprogressbar\/library\", OWNER_SA1),\n    new MavenCentral (\"Floating SearchView\", \"2.1.1\", \"com\/github\/arimorty\/floatingsearchview\", OWNER_SA1),\n    new MavenCentral (\"GoogleGson\", \"2.8.1\", \"com\/google\/code\/gson\/gson\", OWNER_SA1),\n    new MavenCentral (\"KenBurnsView\", \"1.0.7\", \"com\/flaviofaria\/kenburnsview\", OWNER_SA1),\n    new MavenCentral (\"Minimal Json\", \"0.9.4\", \"com\/eclipsesource\/minimal-json\/minimal-json\", OWNER_SA1),\n    new MavenCentral (\"Nine Old Androids\", \"2.4.0\", \"com\/nineoldandroids\/library\", OWNER_SA1),\n    new MavenCentral (\"Number Progress Bar\", \"1.2\", \"com\/daimajia\/numberprogressbar\/library\", OWNER_SA1),\n    new MavenCentral (\"PhotoView\", \"2.1.3\", \"com\/github\/chrisbanes\/photoview\/library\", OWNER_SA1),\n    \/\/new BinTray (\"RecyclerView Animators\", \"2.1.0\", \"wasabeef\", \"maven\/jp\/wasabeef\/recyclerview-animators\", OWNER_SA1),\n    new MavenCentral (\"RoundedImageView\", \"2.3.0\", \"com\/makeramen\/roundedimageview\", OWNER_SA1),\n    new MavenCentral (\"Scissors\", \"1.1.1\", \"com\/lyft\/scissors\", OWNER_SA1),\n    \/\/new BinTray (\"Sortable TableView\", \"2.2.0\", \"ischwarz\", \"maven\/de\/codecrafters\/tableview\/tableview\", OWNER_SA1),\n    new MavenCentral (\"Sticky List Headers\", \"2.7.0\", \"se\/emilsjolander\/stickylistheaders\", OWNER_SA1),\n    new MavenCentral (\"Timber\", \"4.6.0\", \"com\/jakewharton\/timber\/timber\", OWNER_US1),\n    new MavenCentral (\"Universal Image Loader\", \"1.9.5\", \"com\/nostra13\/universalimageloader\/universal-image-loader\", OWNER_SA1),\n    new MavenCentral (\"VectorCompat\", \"1.0.5\", \"com\/wnafee\/vector-compat\", OWNER_SA1),\n    new MavenCentral (\"ViewPropertyObjectAnimator\", \"1.4.5\", \"com\/bartoszlipinski\/viewpropertyobjectanimator\", OWNER_SA1),\n    new MavenCentral (\"Kotlin\", \"1.1.4-3\", \"org\/jetbrains\/kotlin\/kotlin-stdlib\", OWNER_SA1),        \n    new Maven (\"Blurring\", \"1.0.0\", \"https:\/\/github.com\/500px\/500px-android-blur\/blob\/master\/releases\/com\/fivehundredpx\/blurringview\/maven-metadata.xml\", OWNER_CA1),\n    new MavenCentral (\"DeviceYearClass\", \"1.0.0\", \"com.facebook.device.yearclass\", OWNER_SA1),\n    new MavenCentral (\"Glide\", \"4.0.0\", \"com.github.bumptech.glide\", OWNER_SA1),\n    new MavenCentral (\"GoogleZXing\", \"3.3.0\", \"com.google.zxing\", OWNER_SA1),\n    new MavenCentral (\"Guava\", \"23.2-android\", \"com.google.guava\", OWNER_SA1),\n    new MavenCentral (\"Jackson.Core\", \"2.7.4\", \"com.fasterxml.jackson.core\", OWNER_SA1),\n    new MavenCentral (\"MinimalJson\", \"0.9.4\", \"com.eclipsesource.minimal-json\", OWNER_SA1),\n    new MavenCentral (\"RecyclerViewAnimators\", \"2.1.0\", \"jp.wasabeef\", OWNER_SA1),\n    new MavenCentral (\"ShimmerLayout\", \"0.5.0\", \"io.supercharge\", OWNER_SA1),\n    new MavenCentral (\"UrlImageViewHelper\", \"1.0.4\", \"com.koushikdutta.urlimageviewhelper\", OWNER_SA1),\n    new MavenCentral (\"Bolts\", \"1.4.0\", \"com.parse.bolts\", OWNER_SA1),\n\n    \/\/ iOS\n    new CocoaPods (\"AMViralSwitch\", \"1.0.0\", \"AMViralSwitch\", OWNER_SA1),\n    new CocoaPods (\"Chameleon\", \"2.1\", \"ChameleonFramework\", OWNER_SA1),\n    new GitHubReleases (\"CorePlot\", \"1.5.1\", \"core-plot\", \"core-plot\", OWNER_SA1),\n    new CocoaPods (\"DACircularProgress\", \"2.3.1\", \"DACircularProgress\", OWNER_SA1),\n    new CocoaPods (\"DZNEmptyDataSet\", \"1.7.3\", \"DZNEmptyDataSet\", OWNER_SA1),\n    new CocoaPods (\"FXBlurView\", \"1.6.4\", \"FXBlurView\", OWNER_SA1),\n    new CocoaPods (\"GPUImage\", \"0.1.7\", \"GPUImage\", OWNER_SA1),\n    new CocoaPods (\"InAppSettingsKit\", \"2.6\", \"InAppSettingsKit\", OWNER_SA1),\n    new CocoaPods (\"JDStatusBarNotification\", \"1.5.3\", \"JDStatusBarNotification\", OWNER_SA1),\n    new GitHubReleases (\"JSQMessagesViewController\", \"7.3.5\", \"jessesquires\", \"JSQMessagesViewController\", OWNER_US1),\n    new CocoaPods (\"Progress HUD\", \"0.9.2.0\", \"MBProgressHUD\", OWNER_SA1),\n    new CocoaPods (\"MWPhotoBrowser\", \"2.1.1\", \"MWPhotoBrowser\", OWNER_SA1),\n    new CocoaPods (\"Masonry\", \"1.0.2\", \"Masonry\", OWNER_SA1),\n    new CocoaPods (\"RZTransitions\", \"1.2.1\", \"RZTransitions\", OWNER_SA1),\n    new CocoaPods (\"SCCatWaitingHUD\", \"0.1.6\", \"SCCatWaitingHUD\", OWNER_SA1),\n    new CocoaPods (\"SDWebImage\", \"3.7.5\", \"SDWebImage\", OWNER_SA1),\n    new CocoaPods (\"SlackTextViewController\", \"1.9.6\", \"SlackTextViewController\", OWNER_SA1),\n    new CocoaPods (\"TPKeyboardAvoiding\", \"1.3.2\", \"TPKeyboardAvoiding\", OWNER_SA1),\n    new CocoaPods (\"ZipArchive\", \"1.4.0\", \"ZipArchive\", OWNER_SA1),\n    new CocoaPods (\"iCarousel\", \"1.8.3\", \"iCarousel\", OWNER_SA1),\n    new GitHubReleases (\"iRate\", \"1.11.7\", \"nicklockwood\", \"iRate\", OWNER_SA1),\n    new CocoaPods (\"AMScrollingNavbar\", \"4.1.0\", \"AMScrollingNavbar\", OWNER_SA1),\n    new CocoaPods (\"IQAudioRecorderController\", \"1.1\", \"IQAudioRecorderController\", OWNER_SA1),\n    new CocoaPods (\"REFrostedViewController\", \"1.1\", \"REFrostedViewController\", OWNER_SA1),\n    new CocoaPods (\"TwitterImagePipeline\", \"2.2.2\", \"TwitterImagePipeline\", OWNER_SA1),\n    new CocoaPods (\"LiquidFloatingActionButton\", \"2.0.0\", \"LiquidFloatingActionButton\", OWNER_SA1),\n    new CocoaPods (\"JVMenuPopover\", \"1.7\", \"JVMenuPopover\", OWNER_SA1),\n    new CocoaPods (\"JZMultiChoicesCircleButton\", \"1.1\", \"JZMultiChoicesCircleButton\", OWNER_SA1),\n    new CocoaPods (\"PickerCells\", \"1.2\", \"PickerCells\", OWNER_SA1),\n    new CocoaPods (\"SDSegmentedControl\", \"2.1.5\", \"SDSegmentedControl\", OWNER_SA1),\n\n    \/\/ Card.IO\n    new GitHubReleases (\"Card.IO Android\", \"5.5.1\", \"card-io\", \"card.io-Android-SDK\", OWNER_CA1),\n    new GitHubReleases (\"Card.IO iOS\", \"5.4.1\", \"card-io\", \"card.io-iOS-SDK\", OWNER_CA1),\n\n\n    \/\/ Facebook\n    new XPath (\"Facebook Android\", \"4.33.0\", \"https:\/\/repo1.maven.org\/maven2\/com\/facebook\/android\/facebook-android-sdk\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new CocoaPods (\"Facebook Pop\", \"1.0.9\", \"pop\", OWNER_CA1),\n    new CocoaPods (\"Facebook iOS CoreKit\", \"4.33.0\", \"FBSDKCoreKit\", OWNER_MX1),\n\n    \/\/ Google - Android\n    new XPath (\"Android Support Libraries\", \"27.0.2\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/android\/support\/appcompat-v7\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Google Glass SDK\", \"11\", \"https:\/\/dl.google.com\/android\/repository\/glass\/addon2-1.xml\", \"\/\/*[local-name() = 'remotePackage' and @path='add-ons;addon-google_gdk-google-19']\/*[local-name() = 'revision']\", OWNER_CA1),\n    new XPath (\"Google Android ARCore\", \"1.0.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/ar\/core\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Android Wearable\/Wearable\", \"2.2.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/android\/wearable\/wearable\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Android Support\/Wearable\", \"2.2.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/android\/support\/wearable\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Android Support Constraint Layout\", \"1.1.0-beta5\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/android\/support\/constraint\/constraint-layout\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n\n    \/\/ Google - iOS\n    new CocoaPods (\"Google.Analytics iOS\", \"3.17.0\", \"GoogleAnalytics\", OWNER_MX1),\n    new CocoaPods (\"Google.AppIndexing iOS\", \"2.0.3\", \"GoogleAppIndexing\", OWNER_MX1),\n    \/\/ new CocoaPods (\"Google.AppInvites iOS\", \"1.0.2\", \"AppInvites\", OWNER_MX1), \/\/ Deprecated\n    new CocoaPods (\"Google.Cast iOS\", \"4.1.0\", \"google-cast-sdk\", OWNER_MX1),\n    new CocoaPods (\"Google.Core iOS\", \"3.1.0\", \"Google\", OWNER_MX1),\n    \/\/ new CocoaPods (\"Google.GoogleCloudMessaging iOS\", \"1.2.0\", \"GoogleCloudMessaging\", OWNER_MX1), \/\/ Deprecated\n    new CocoaPods (\"Google.InstanceID iOS\", \"1.2.1\", \"GGLInstanceID\", OWNER_MX1),\n    new CocoaPods (\"Google.Maps iOS\", \"2.5.0\", \"GoogleMaps\", OWNER_MX1),\n    \/\/ new CocoaPods (\"Google.MobileAds iOS\", \"7.27.0\", \"GoogleMobileAds\", OWNER_MX1), \/\/ Renamed as Firebase.AdMob\n    new CocoaPods (\"Google.PlayGames iOS\", \"5.1.1\", \"GooglePlayGames\", OWNER_MX1),\n    \/\/ new CocoaPods (\"Google.Plus iOS\", \"1.7.1\", \"GooglePlusOpenSource\", OWNER_MX1), \/\/ Deprecated\n    new CocoaPods (\"Google.SignIn iOS\", \"4.8.0\", \"GoogleSignIn\", OWNER_MX1),\n    new CocoaPods (\"Google.TagManager iOS\", \"6.0.0\", \"GoogleTagManager\", OWNER_MX1),\n\n    \/\/Firebase - Android\n    new XPath (\"Firebase - Ads\", \"15.0.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-ads\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Analytics\", \"16.0.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-analytics\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Analytics Impl\", \"16.1.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-analytics-impl\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Appindexing\", \"16.0.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-appindexing\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Auth\", \"16.0.2\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-auth\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Common\", \"16.0.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-common\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Config\", \"16.0.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-config\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Core\", \"16.0.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-core\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Crash\", \"16.0.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-crash\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Database\", \"16.0.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-database\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Database Connection\", \"16.0.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-database-connection\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Dynamic Links\", \"16.0.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-dynamic-links\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Firestore\", \"17.0.2\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-firestore\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Iid\", \"16.2.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-iid\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Invites\", \"16.0.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-invites\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Messaging\", \"17.1.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-messaging\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Perf\", \"16.0.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-perf\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Storage\", \"16.0.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-storage\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Storage Common\", \"16.0.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-storage-common\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    \n    new XPath (\"Firebase - Abt\", \"16.0.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-abt\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Ads Lite\", \"15.0.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-ads-lite\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Auth Interop\", \"16.0.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-auth-interop\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Database Collection\", \"15.0.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-database-collection\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Functions\", \"16.0.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-functions\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Iid Interop\", \"16.0.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-iid-interop\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Measurement Connector\", \"17.0.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-measurement-connector\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Measurement Connector Impl\", \"16.0.1\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-measurement-connector-impl\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Ml Common\", \"16.0.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-ml-common\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Ml Model Interpreter\", \"16.0.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-ml-model-interpreter\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Ml Vision\", \"16.0.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-ml-vision\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n    new XPath (\"Firebase - Ml Vision Image Label Model\", \"15.0.0\", \"https:\/\/dl.google.com\/dl\/android\/maven2\/com\/google\/firebase\/firebase-ml-vision-image-label-model\/maven-metadata.xml\", \"\/metadata\/versioning\/release\", OWNER_CA1),\n\n\n    \/\/ Firebase - iOS\n    new CocoaPods (\"Firebase iOS\", \"4.0.3\", \"Firebase\", OWNER_MX1),\n    new CocoaPods (\"Firebase.AdMob iOS\", \"7.27.0\", \"Google-Mobile-Ads-SDK\", OWNER_MX1),\n    new CocoaPods (\"Firebase.Analytics iOS\", \"4.0.5\", \"FirebaseAnalytics\", OWNER_MX1),\n    new CocoaPods (\"Firebase.Auth iOS\", \"4.0.0\", \"FirebaseAuth\", OWNER_MX1),\n    new CocoaPods (\"Firebase.CloudMessaging iOS\", \"4.8.0\", \"FirebaseMessaging\", OWNER_MX1),\n    new CocoaPods (\"Firebase.Core iOS\", \"4.0.13\", \"FirebaseCore\", OWNER_MX1),\n    new CocoaPods (\"Firebase.CrashReporting iOS\", \"2.0.0\", \"FirebaseCrash\", OWNER_MX1),\n    new CocoaPods (\"Firebase.Database iOS\", \"4.1.3\", \"FirebaseDatabase\", OWNER_MX1),\n    new CocoaPods (\"Firebase.DynamicLinks iOS\", \"4.8.0\", \"FirebaseDynamicLinks\", OWNER_MX1),\n    new CocoaPods (\"Firebase.InstanceID iOS\", \"2.0.8\", \"FirebaseInstanceID\", OWNER_MX1),\n    new CocoaPods (\"Firebase.Invites iOS\", \"4.8.0\", \"FirebaseInvites\", OWNER_MX1),\n    new CocoaPods (\"Firebase.PerformanceMonitoring iOS\", \"1.1.0\", \"FirebasePerformance\", OWNER_MX1),\n    new CocoaPods (\"Firebase.RemoteConfig iOS\", \"2.0.3\", \"FirebaseRemoteConfig\", OWNER_MX1),\n    new CocoaPods (\"Firebase.Storage iOS\", \"2.0.2\", \"FirebaseStorage\", OWNER_MX1),\n\n    \/\/ Mapbox\n    new MavenCentral (\"Mapbox Android\", \"4.2.2\", \"com\/mapbox\/mapboxsdk\/mapbox-android-sdk\", OWNER_CA1),\n    new CocoaPods (\"Mapbox iOS\", \"3.5.0\", \"Mapbox-iOS-SDK\", OWNER_CA1),\n\n    \/\/ Socket.IO\n    new MavenCentral (\"Socket.IO Client\", \"1.0.0\", \"io\/socket\/socket.io-client\", OWNER_SA1),\n    new MavenCentral (\"Engine.IO Client\", \"1.0.0\", \"io\/socket\/engine.io-client\", OWNER_SA1),\n\n    \/\/ Square\n    new MavenCentral (\"OkIO\", \"1.13.0\", \"com\/squareup\/okio\/okio\", OWNER_SA1),\n    new MavenCentral (\"OkHttp\", \"2.7.5\", \"com\/squareup\/okhttp\/okhttp\", OWNER_SA1),\n    new MavenCentral (\"OkHttp3\", \"3.8.1\", \"com\/squareup\/okhttp3\/okhttp\", OWNER_SA1),\n    new MavenCentral (\"OkHttp Web Sockets\", \"2.7.5\", \"com\/squareup\/okhttp\/okhttp-ws\", OWNER_SA1),\n    new MavenCentral (\"OkHttp3 Web Sockets\", \"3.4.2\", \"com\/squareup\/okhttp3\/okhttp-ws\", OWNER_SA1),\n    new MavenCentral (\"Picasso\", \"2.5.2\", \"com\/squareup\/picasso\/picasso\", OWNER_SA1),\n    new MavenCentral (\"AndroidTimesSquare\", \"1.7.3\", \"com\/squareup\/android-times-square\", OWNER_SA1),\n    new MavenCentral (\"Seismic\", \"1.0.2\", \"com\/squareup\/seismic\", OWNER_SA1),\n    new MavenCentral (\"Pollexor\", \"2.0.4\", \"com\/squareup\/pollexor\", OWNER_SA1),\n    new MavenCentral (\"OkHttp UrlConection\", \"2.7.5\", \"com\/squareup\/okhttp\/okhttp-urlconnection\", OWNER_SA1),\n    new MavenCentral (\"Retrofit\", \"1.9.0\", \"com\/squareup\/retrofit\", OWNER_SA1),\n    new MavenCentral (\"Retrofit2\", \"2.3.0\", \"com\/squareup\/retrofit2\", OWNER_SA1),\n    new GitHubReleases (\"SocketRocket\", \"0.5.1\", \"square\", \"SocketRocket\", OWNER_SA1),\n    new GitHubReleases (\"Valet\", \"2.4.1\", \"square\", \"Valet\", OWNER_SA1),\n    new GitHubReleases (\"Aardvark\", \"1.5.0\", \"square\", \"Aardvark\", OWNER_SA1),\n};\n\nvar updates = new List<UpdateInfo> ();\nvar failures = new List<string> ();\n\nforeach (var v in fetchers) {\n    try {\n        var updateInfo = v.Run ();\n        if (updateInfo != null)\n            updates.Add (updateInfo);\n    } catch (Exception ex) {\n        failures.Add (v.ComponentName);\n    }\n}\n\nforeach (var grp in updates.GroupBy (up => up.Owner)) {\n    var owner = string.IsNullOrEmpty (grp.Key) ? \"here\" : grp.Key;\n    SlackNotifier.Notify (owner, grp);\n}\n\nif (failures.Any ())\n    SlackNotifier.Notify (failures);\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"0a196d621c382ec252e7ff99249d70cae17d80d5","subject":"Width\/Height should set client size not window size","message":"Width\/Height should set client size not window size\n","repos":"tigrouind\/LifeDISA,tigrouind\/LifeDISA","old_file":"VarsViewer\/VarsViewer\/Program.cs","new_file":"VarsViewer\/VarsViewer\/Program.cs","new_contents":"\ufeffusing System;\nusing System.Drawing;\nusing System.Windows.Forms;\nusing Shared;\n\nnamespace VarsViewer\n{\n\tsealed class Program\n\t{\n\t\t[STAThread]\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tApplication.EnableVisualStyles();\n\t\t\tApplication.SetCompatibleTextRenderingDefault(false);\n\n\t\t\tvar form = new MainForm();\n\t\t\tvar width = Tools.GetArgument(args, \"-screen-width\") ?? 1024;\n\t\t\tvar height = Tools.GetArgument(args, \"-screen-height\") ?? 576;\n\t\t\tform.ClientSize = new Size(width, height);\n\n\t\t\tApplication.Run(form);\n\t\t}\n\t}\n}\n","old_contents":"\ufeffusing System;\nusing System.Drawing;\nusing System.Windows.Forms;\nusing Shared;\n\nnamespace VarsViewer\n{\n\tsealed class Program\n\t{\n\t\t[STAThread]\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tApplication.EnableVisualStyles();\n\t\t\tApplication.SetCompatibleTextRenderingDefault(false);\n\n\t\t\tvar form = new MainForm();\n\t\t\tvar width = Tools.GetArgument(args, \"-screen-width\") ?? 1024;\n\t\t\tvar height = Tools.GetArgument(args, \"-screen-height\") ?? 576;\n\t\t\tform.Size = new Size(width, height);\n\n\t\t\tApplication.Run(form);\n\t\t}\n\t}\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"6baad7a9fa56736d341defadf3e86ae4ff57af9d","subject":"Returned default angle for map","message":"Returned default angle for map\n","repos":"aleksandrpak\/vision","old_file":"Vision\/Processing\/Static2DMap.cs","new_file":"Vision\/Processing\/Static2DMap.cs","new_contents":"\ufeffusing System;\r\nusing System.Collections.Generic;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\nusing System.Windows;\r\nusing System.Windows.Media;\r\nusing System.Windows.Media.Imaging;\r\n\r\nnamespace Vision.Processing\r\n{\r\n    public sealed class Static2DMap\r\n    {\r\n        private readonly Dictionary<DepthAngle, List<DepthData>> _map;\r\n\r\n        private WriteableBitmap _obstaclesBitmap;\r\n        private WriteableBitmap _otherBitmap;\r\n\r\n        private double _currentAngle;\r\n\r\n        private ManualResetEventSlim _servoEvent;\r\n\r\n        private readonly Dictionary<int, int[]> _markers;\r\n        private ushort _maxDepth;\r\n\r\n        public Static2DMap(int width, int height, double horizontalAngle, double verticalAngle, ushort maxDepth, ushort hostHeight)\r\n        {\r\n            Width = width;\r\n            Height = height;\r\n            HorizontalAngle = horizontalAngle;\r\n            VerticalAngle = verticalAngle;\r\n            MaxDepth = maxDepth;\r\n            HostHeight = hostHeight;\r\n\r\n            _obstaclesBitmap = BitmapFactory.New(MaxDepth \/ 5, MaxDepth \/ 5 \/ 2);\r\n            _otherBitmap = BitmapFactory.New(MaxDepth \/ 5, MaxDepth \/ 5 \/ 2);\r\n            LastDepthData = new ushort[Width * Height];\r\n\r\n            _map = new Dictionary<DepthAngle, List<DepthData>>();\r\n            _markers = new Dictionary<int, int[]>();\r\n\r\n            _currentAngle = 90;\r\n        }\r\n\r\n        public ImageSource ObstaclesImage => _obstaclesBitmap;\r\n\r\n        public ImageSource OtherImage => _otherBitmap;\r\n\r\n        public ushort[] LastDepthData { get; }\r\n\r\n        public int Width { get; }\r\n\r\n        public int Height { get; }\r\n\r\n        public double HorizontalAngle { get; }\r\n\r\n        public double VerticalAngle { get; }\r\n\r\n        public ushort MaxDepth\r\n        {\r\n            get { return _maxDepth; }\r\n            set\r\n            {\r\n                _maxDepth = value;\r\n\r\n                if (_obstaclesBitmap == null)\r\n                    return;\r\n\r\n                var oldBitmap = _obstaclesBitmap;\r\n                lock (oldBitmap)\r\n                {\r\n                    _obstaclesBitmap = BitmapFactory.New(MaxDepth \/ 5, MaxDepth \/ 5 \/ 2);\r\n                    _otherBitmap = BitmapFactory.New(MaxDepth \/ 5, MaxDepth \/ 5 \/ 2);\r\n                }\r\n            }\r\n        }\r\n\r\n        public ushort HostHeight { get; set; }\r\n\r\n        public void SetAngle(double angle)\r\n        {\r\n            _currentAngle = angle;\r\n        }\r\n\r\n        public void ConnectServo(ManualResetEventSlim servoEvent)\r\n        {\r\n            _servoEvent = servoEvent;\r\n        }\r\n\r\n        public void DisconnectServo()\r\n        {\r\n            _servoEvent = null;\r\n        }\r\n\r\n        public void Clear()\r\n        {\r\n            lock (_obstaclesBitmap)\r\n            {\r\n                _obstaclesBitmap.Clear();\r\n                _otherBitmap.Clear();\r\n            }\r\n        }\r\n\r\n        public void AddMarker(int id, Point topLeft, Point topRight, Point bottomLeft, Point bottomRight, int width, int depth, double yAngle)\r\n        {\r\n            lock (LastDepthData)\r\n            {\r\n                const double shift = Math.PI \/ 2.0;\r\n                var maxDepth = MaxDepth;\r\n                var mapWidth = (double)maxDepth \/ 10;\r\n\r\n                var centerDepth = FindAverageDepth(Math.Max(topLeft.X, bottomLeft.X), Math.Max(topLeft.Y, topRight.Y), Math.Min(topRight.X, bottomRight.X), Math.Min(bottomLeft.Y, bottomRight.Y));\r\n                if (centerDepth == 0)\r\n                    return;\r\n\r\n                var maxDiff = width \/ 2;\r\n\r\n                var leftPoint = topLeft.X > bottomLeft.X ? topLeft : bottomLeft;\r\n                var leftDepth = FindDepth(leftPoint.X, leftPoint.Y, 5, centerDepth - maxDiff, centerDepth + maxDiff);\r\n                if (leftDepth == 0)\r\n                    return;\r\n\r\n                var rightPoint = topRight.X > bottomRight.X ? topRight : bottomRight;\r\n                var rightDepth = FindDepth(rightPoint.X, rightPoint.Y, 5, centerDepth - maxDiff, centerDepth + maxDiff);\r\n                if (rightDepth == 0)\r\n                    return;\r\n\r\n                \/\/var multiplier = (markerData.Width \/ markerData.MarkerSize);\r\n                \/\/topRightX = (topLeftX + (topRightX - topLeftX) * multiplier);\r\n\r\n                var currentRadians = _currentAngle * Math.PI \/ 180.0;\r\n\r\n                var bottomLeftAngle = ((leftPoint.X - Width \/ 2.0) \/ Width * HorizontalAngle * Math.PI \/ 180.0) - currentRadians + shift;\r\n                var bottomLeftX = mapWidth + Math.Sin(bottomLeftAngle) * leftDepth;\r\n                var bottomLeftY = mapWidth - Math.Cos(bottomLeftAngle) * leftDepth;\r\n\r\n                var bottomRightAngle = ((rightPoint.X - Width \/ 2.0) \/ Width * HorizontalAngle * Math.PI \/ 180.0) - currentRadians + shift;\r\n                var bottomRightX = mapWidth + Math.Sin(bottomRightAngle) * rightDepth;\r\n                var bottomRightY = mapWidth - Math.Cos(bottomRightAngle) * rightDepth;\r\n\r\n                var bottomLeftPoint = new Point(bottomLeftX, bottomLeftY);\r\n                var angle = Math.Atan((bottomRightY - bottomLeftY) \/ (bottomRightX - bottomLeftX));\r\n                var bottomRightPoint = ExtendLine(bottomLeftPoint, width, angle);\r\n                var topLeftPoint = ExtendLine(bottomLeftPoint, depth, angle + shift);\r\n                var topRightPoint = ExtendLine(bottomRightPoint, depth, angle + shift);\r\n\r\n                _markers[id] = new[]\r\n                {\r\n                    (int)bottomLeftPoint.X, (int)bottomLeftPoint.Y,\r\n                    (int)bottomRightPoint.X, (int)bottomRightPoint.Y,\r\n                    (int)topRightPoint.X, (int)topRightPoint.Y,\r\n                    (int)topLeftPoint.X, (int)topLeftPoint.Y,\r\n                    (int)bottomLeftPoint.X, (int)bottomLeftPoint.Y\r\n                };\r\n            }\r\n        }\r\n\r\n        private static Point ExtendLine(Point first, double width, double angle)\r\n        {\r\n            var x3 = width * Math.Cos(angle);\r\n            var y3 = width * Math.Sin(angle);\r\n\r\n            return new Point(first.X + x3, first.Y + y3);\r\n        }\r\n\r\n        public void RemoveMarker(int id)\r\n        {\r\n            lock (LastDepthData)\r\n                _markers.Remove(id);\r\n        }\r\n\r\n        private ushort FindAverageDepth(double x1, double y1, double x2, double y2)\r\n        {\r\n            double sum = 0;\r\n            double count = 0;\r\n\r\n            for (var i = y1; i <= y2; ++i)\r\n            {\r\n                for (var j = x1; j <= x2; ++j)\r\n                {\r\n                    var depth = LastDepthData[(int)i * Width + (Width - (int)j)];\r\n                    if (depth == 0)\r\n                        continue;\r\n\r\n                    sum += depth;\r\n                    ++count;\r\n                }\r\n            }\r\n\r\n            return (ushort)(sum \/ count \/ 10.0);\r\n        }\r\n\r\n        private ushort FindDepth(double x, double y, int steps, int min, int max)\r\n        {\r\n            for (var step = 0; step < steps; ++step)\r\n            {\r\n                for (var xStep = -step; xStep <= step; ++xStep)\r\n                {\r\n                    for (var yStep = -step; yStep <= step; ++yStep)\r\n                    {\r\n                        var newX = x + xStep;\r\n                        var newY = y + yStep;\r\n\r\n                        if (newX < 0 || newX > Width || newY < 0 || newY > Height)\r\n                            continue;\r\n\r\n                        var depth = LastDepthData[(int)newY * Width + (Width - (int)newX)] \/ 10;\r\n                        if (depth == 0)\r\n                            continue;\r\n\r\n                        if (depth < min || depth > max)\r\n                            continue;\r\n\r\n                        return (ushort)depth;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return 0;\r\n        }\r\n\r\n        public async Task Update(ushort[] data)\r\n        {\r\n            if (_servoEvent != null && _servoEvent.IsSet)\r\n                return;\r\n\r\n            await Task.Run(() => BuildMap(data));\r\n\r\n            var width = (double)MaxDepth \/ 10;\r\n            const double shift = Math.PI \/ 2.0;\r\n\r\n            lock (_obstaclesBitmap)\r\n            {\r\n                using (var obstaclesContext = _obstaclesBitmap.GetBitmapContext(ReadWriteMode.ReadWrite))\r\n                using (var otherContext = _otherBitmap.GetBitmapContext(ReadWriteMode.ReadWrite))\r\n                {\r\n                    obstaclesContext.Clear();\r\n                    otherContext.Clear();\r\n\r\n                    var pixelWidth = obstaclesContext.Width;\r\n\r\n                    foreach (var depthPair in _map)\r\n                    {\r\n                        var depthData = depthPair.Value;\r\n                        if (depthData == null)\r\n                            continue;\r\n\r\n                        var depthAngle = depthPair.Key;\r\n                        foreach (var depthItem in depthData)\r\n                        {\r\n                            var depth = depthItem.Depth \/ 10;\r\n                            if (depth == 0)\r\n                                continue;\r\n\r\n                            var angle = depthAngle.ScreenAngle - depthAngle.ViewAngle + shift;\r\n                            var x = width + Math.Sin(angle) * depth;\r\n                            var y = width - Math.Cos(angle) * depth;\r\n\r\n                            if (x < 0 || x > pixelWidth || y < 0 || y > pixelWidth)\r\n                                continue;\r\n\r\n                            unsafe\r\n                            {\r\n                                if (depthItem.IsObstacle)\r\n                                    obstaclesContext.Pixels[(int)y * pixelWidth + (int)x] = -16777216 | 255 << 16;\r\n                                else\r\n                                    otherContext.Pixels[(int)y * pixelWidth + (int)x] = -16777216 | 255 << 8;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                foreach (var marker in _markers.Values)\r\n                    _obstaclesBitmap.FillPolygon(marker, Colors.Blue);\r\n            }\r\n\r\n            _servoEvent?.Set();\r\n        }\r\n\r\n        private void BuildMap(ushort[] data)\r\n        {\r\n            lock (LastDepthData)\r\n                Array.Copy(data, LastDepthData, Width * Height);\r\n\r\n            var currentRadians = _currentAngle * Math.PI \/ 180.0;\r\n            var maxDepth = MaxDepth;\r\n            _map.Clear();\r\n\r\n            for (var j = 0; j < Width; ++j)\r\n            {\r\n                var horizontalScreenAngle = (j - Width \/ 2) \/ (double)Width * HorizontalAngle;\r\n                var depthAngle = new DepthAngle(currentRadians, horizontalScreenAngle * Math.PI \/ 180.0);\r\n\r\n                List<DepthData> depthData;\r\n                if (!_map.TryGetValue(depthAngle, out depthData))\r\n                    _map[depthAngle] = depthData = new List<DepthData>();\r\n\r\n                depthData.Clear();\r\n\r\n                for (var i = 0; i < Height; ++i)\r\n                {\r\n                    var depth = Math.Min(maxDepth, data[i * Width + (Width - j - 1)]);\r\n                    if (depth == 0)\r\n                        continue;\r\n\r\n                    var isObstacle = false;\r\n\r\n                    if (i >= Height \/ 2)\r\n                    {\r\n                        var verticalScreenAngle = Math.Abs((i - Height \/ 2) \/ (double)Height * VerticalAngle);\r\n                        var height = (ushort)(Math.Sin(verticalScreenAngle * Math.PI \/ 180.0) * depth \/ Math.Sin((90 - verticalScreenAngle) * Math.PI \/ 180.0));\r\n\r\n                        if (height <= HostHeight * 10)\r\n                            isObstacle = true;\r\n                    }\r\n\r\n                    depth = (ushort)(depth \/ Math.Sin((90 - horizontalScreenAngle) * Math.PI \/ 180.0));\r\n\r\n                    depthData.Add(new DepthData(depth, isObstacle));\r\n                }\r\n            }\r\n        }\r\n\r\n        private struct DepthAngle : IEquatable<DepthAngle>\r\n        {\r\n            public DepthAngle(double viewAngle, double screenAngle)\r\n            {\r\n                ViewAngle = viewAngle;\r\n                ScreenAngle = screenAngle;\r\n            }\r\n\r\n            public double ViewAngle { get; }\r\n            public double ScreenAngle { get; }\r\n\r\n            public override bool Equals(object obj)\r\n            {\r\n                if (ReferenceEquals(null, obj))\r\n                    return false;\r\n\r\n                return obj is DepthAngle && Equals((DepthAngle)obj);\r\n            }\r\n\r\n            public override int GetHashCode()\r\n            {\r\n                unchecked\r\n                {\r\n                    return (ViewAngle.GetHashCode() * 397) ^ ScreenAngle.GetHashCode();\r\n                }\r\n            }\r\n\r\n            public bool Equals(DepthAngle other)\r\n            {\r\n                return ViewAngle.Equals(other.ViewAngle) && ScreenAngle.Equals(other.ScreenAngle);\r\n            }\r\n        }\r\n\r\n        private struct DepthData\r\n        {\r\n            public DepthData(ushort depth, bool isObstacle)\r\n            {\r\n                Depth = depth;\r\n                IsObstacle = isObstacle;\r\n            }\r\n\r\n            public ushort Depth { get; }\r\n            public bool IsObstacle { get; }\r\n        }\r\n    }\r\n}\r\n","old_contents":"\ufeffusing System;\r\nusing System.Collections.Generic;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\nusing System.Windows;\r\nusing System.Windows.Media;\r\nusing System.Windows.Media.Imaging;\r\n\r\nnamespace Vision.Processing\r\n{\r\n    public sealed class Static2DMap\r\n    {\r\n        private readonly Dictionary<DepthAngle, List<DepthData>> _map;\r\n\r\n        private WriteableBitmap _obstaclesBitmap;\r\n        private WriteableBitmap _otherBitmap;\r\n\r\n        private double _currentAngle;\r\n\r\n        private ManualResetEventSlim _servoEvent;\r\n\r\n        private readonly Dictionary<int, int[]> _markers;\r\n        private ushort _maxDepth;\r\n\r\n        public Static2DMap(int width, int height, double horizontalAngle, double verticalAngle, ushort maxDepth, ushort hostHeight)\r\n        {\r\n            Width = width;\r\n            Height = height;\r\n            HorizontalAngle = horizontalAngle;\r\n            VerticalAngle = verticalAngle;\r\n            MaxDepth = maxDepth;\r\n            HostHeight = hostHeight;\r\n\r\n            _obstaclesBitmap = BitmapFactory.New(MaxDepth \/ 5, MaxDepth \/ 5 \/ 2);\r\n            _otherBitmap = BitmapFactory.New(MaxDepth \/ 5, MaxDepth \/ 5 \/ 2);\r\n            LastDepthData = new ushort[Width * Height];\r\n\r\n            _map = new Dictionary<DepthAngle, List<DepthData>>();\r\n            _markers = new Dictionary<int, int[]>();\r\n\r\n            _currentAngle = 120;\r\n        }\r\n\r\n        public ImageSource ObstaclesImage => _obstaclesBitmap;\r\n\r\n        public ImageSource OtherImage => _otherBitmap;\r\n\r\n        public ushort[] LastDepthData { get; }\r\n\r\n        public int Width { get; }\r\n\r\n        public int Height { get; }\r\n\r\n        public double HorizontalAngle { get; }\r\n\r\n        public double VerticalAngle { get; }\r\n\r\n        public ushort MaxDepth\r\n        {\r\n            get { return _maxDepth; }\r\n            set\r\n            {\r\n                _maxDepth = value;\r\n\r\n                if (_obstaclesBitmap == null)\r\n                    return;\r\n\r\n                var oldBitmap = _obstaclesBitmap;\r\n                lock (oldBitmap)\r\n                {\r\n                    _obstaclesBitmap = BitmapFactory.New(MaxDepth \/ 5, MaxDepth \/ 5 \/ 2);\r\n                    _otherBitmap = BitmapFactory.New(MaxDepth \/ 5, MaxDepth \/ 5 \/ 2);\r\n                }\r\n            }\r\n        }\r\n\r\n        public ushort HostHeight { get; set; }\r\n\r\n        public void SetAngle(double angle)\r\n        {\r\n            _currentAngle = angle;\r\n        }\r\n\r\n        public void ConnectServo(ManualResetEventSlim servoEvent)\r\n        {\r\n            _servoEvent = servoEvent;\r\n        }\r\n\r\n        public void DisconnectServo()\r\n        {\r\n            _servoEvent = null;\r\n        }\r\n\r\n        public void Clear()\r\n        {\r\n            lock (_obstaclesBitmap)\r\n            {\r\n                _obstaclesBitmap.Clear();\r\n                _otherBitmap.Clear();\r\n            }\r\n        }\r\n\r\n        public void AddMarker(int id, Point topLeft, Point topRight, Point bottomLeft, Point bottomRight, int width, int depth, double yAngle)\r\n        {\r\n            lock (LastDepthData)\r\n            {\r\n                const double shift = Math.PI \/ 2.0;\r\n                var maxDepth = MaxDepth;\r\n                var mapWidth = (double)maxDepth \/ 10;\r\n\r\n                var centerDepth = FindAverageDepth(Math.Max(topLeft.X, bottomLeft.X), Math.Max(topLeft.Y, topRight.Y), Math.Min(topRight.X, bottomRight.X), Math.Min(bottomLeft.Y, bottomRight.Y));\r\n                if (centerDepth == 0)\r\n                    return;\r\n\r\n                var maxDiff = width \/ 2;\r\n\r\n                var leftPoint = topLeft.X > bottomLeft.X ? topLeft : bottomLeft;\r\n                var leftDepth = FindDepth(leftPoint.X, leftPoint.Y, 5, centerDepth - maxDiff, centerDepth + maxDiff);\r\n                if (leftDepth == 0)\r\n                    return;\r\n\r\n                var rightPoint = topRight.X > bottomRight.X ? topRight : bottomRight;\r\n                var rightDepth = FindDepth(rightPoint.X, rightPoint.Y, 5, centerDepth - maxDiff, centerDepth + maxDiff);\r\n                if (rightDepth == 0)\r\n                    return;\r\n\r\n                \/\/var multiplier = (markerData.Width \/ markerData.MarkerSize);\r\n                \/\/topRightX = (topLeftX + (topRightX - topLeftX) * multiplier);\r\n\r\n                var currentRadians = _currentAngle * Math.PI \/ 180.0;\r\n\r\n                var bottomLeftAngle = ((leftPoint.X - Width \/ 2.0) \/ Width * HorizontalAngle * Math.PI \/ 180.0) - currentRadians + shift;\r\n                var bottomLeftX = mapWidth + Math.Sin(bottomLeftAngle) * leftDepth;\r\n                var bottomLeftY = mapWidth - Math.Cos(bottomLeftAngle) * leftDepth;\r\n\r\n                var bottomRightAngle = ((rightPoint.X - Width \/ 2.0) \/ Width * HorizontalAngle * Math.PI \/ 180.0) - currentRadians + shift;\r\n                var bottomRightX = mapWidth + Math.Sin(bottomRightAngle) * rightDepth;\r\n                var bottomRightY = mapWidth - Math.Cos(bottomRightAngle) * rightDepth;\r\n\r\n                var bottomLeftPoint = new Point(bottomLeftX, bottomLeftY);\r\n                var angle = Math.Atan((bottomRightY - bottomLeftY) \/ (bottomRightX - bottomLeftX));\r\n                var bottomRightPoint = ExtendLine(bottomLeftPoint, width, angle);\r\n                var topLeftPoint = ExtendLine(bottomLeftPoint, depth, angle + shift);\r\n                var topRightPoint = ExtendLine(bottomRightPoint, depth, angle + shift);\r\n\r\n                _markers[id] = new[]\r\n                {\r\n                    (int)bottomLeftPoint.X, (int)bottomLeftPoint.Y,\r\n                    (int)bottomRightPoint.X, (int)bottomRightPoint.Y,\r\n                    (int)topRightPoint.X, (int)topRightPoint.Y,\r\n                    (int)topLeftPoint.X, (int)topLeftPoint.Y,\r\n                    (int)bottomLeftPoint.X, (int)bottomLeftPoint.Y\r\n                };\r\n            }\r\n        }\r\n\r\n        private static Point ExtendLine(Point first, double width, double angle)\r\n        {\r\n            var x3 = width * Math.Cos(angle);\r\n            var y3 = width * Math.Sin(angle);\r\n\r\n            return new Point(first.X + x3, first.Y + y3);\r\n        }\r\n\r\n        public void RemoveMarker(int id)\r\n        {\r\n            lock (LastDepthData)\r\n                _markers.Remove(id);\r\n        }\r\n\r\n        private ushort FindAverageDepth(double x1, double y1, double x2, double y2)\r\n        {\r\n            double sum = 0;\r\n            double count = 0;\r\n\r\n            for (var i = y1; i <= y2; ++i)\r\n            {\r\n                for (var j = x1; j <= x2; ++j)\r\n                {\r\n                    var depth = LastDepthData[(int)i * Width + (Width - (int)j)];\r\n                    if (depth == 0)\r\n                        continue;\r\n\r\n                    sum += depth;\r\n                    ++count;\r\n                }\r\n            }\r\n\r\n            return (ushort)(sum \/ count \/ 10.0);\r\n        }\r\n\r\n        private ushort FindDepth(double x, double y, int steps, int min, int max)\r\n        {\r\n            for (var step = 0; step < steps; ++step)\r\n            {\r\n                for (var xStep = -step; xStep <= step; ++xStep)\r\n                {\r\n                    for (var yStep = -step; yStep <= step; ++yStep)\r\n                    {\r\n                        var newX = x + xStep;\r\n                        var newY = y + yStep;\r\n\r\n                        if (newX < 0 || newX > Width || newY < 0 || newY > Height)\r\n                            continue;\r\n\r\n                        var depth = LastDepthData[(int)newY * Width + (Width - (int)newX)] \/ 10;\r\n                        if (depth == 0)\r\n                            continue;\r\n\r\n                        if (depth < min || depth > max)\r\n                            continue;\r\n\r\n                        return (ushort)depth;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return 0;\r\n        }\r\n\r\n        public async Task Update(ushort[] data)\r\n        {\r\n            if (_servoEvent != null && _servoEvent.IsSet)\r\n                return;\r\n\r\n            await Task.Run(() => BuildMap(data));\r\n\r\n            var width = (double)MaxDepth \/ 10;\r\n            const double shift = Math.PI \/ 2.0;\r\n\r\n            lock (_obstaclesBitmap)\r\n            {\r\n                using (var obstaclesContext = _obstaclesBitmap.GetBitmapContext(ReadWriteMode.ReadWrite))\r\n                using (var otherContext = _otherBitmap.GetBitmapContext(ReadWriteMode.ReadWrite))\r\n                {\r\n                    obstaclesContext.Clear();\r\n                    otherContext.Clear();\r\n\r\n                    var pixelWidth = obstaclesContext.Width;\r\n\r\n                    foreach (var depthPair in _map)\r\n                    {\r\n                        var depthData = depthPair.Value;\r\n                        if (depthData == null)\r\n                            continue;\r\n\r\n                        var depthAngle = depthPair.Key;\r\n                        foreach (var depthItem in depthData)\r\n                        {\r\n                            var depth = depthItem.Depth \/ 10;\r\n                            if (depth == 0)\r\n                                continue;\r\n\r\n                            var angle = depthAngle.ScreenAngle - depthAngle.ViewAngle + shift;\r\n                            var x = width + Math.Sin(angle) * depth;\r\n                            var y = width - Math.Cos(angle) * depth;\r\n\r\n                            if (x < 0 || x > pixelWidth || y < 0 || y > pixelWidth)\r\n                                continue;\r\n\r\n                            unsafe\r\n                            {\r\n                                if (depthItem.IsObstacle)\r\n                                    obstaclesContext.Pixels[(int)y * pixelWidth + (int)x] = -16777216 | 255 << 16;\r\n                                else\r\n                                    otherContext.Pixels[(int)y * pixelWidth + (int)x] = -16777216 | 255 << 8;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                foreach (var marker in _markers.Values)\r\n                    _obstaclesBitmap.FillPolygon(marker, Colors.Blue);\r\n            }\r\n\r\n            _servoEvent?.Set();\r\n        }\r\n\r\n        private void BuildMap(ushort[] data)\r\n        {\r\n            lock (LastDepthData)\r\n                Array.Copy(data, LastDepthData, Width * Height);\r\n\r\n            var currentRadians = _currentAngle * Math.PI \/ 180.0;\r\n            var maxDepth = MaxDepth;\r\n            _map.Clear();\r\n\r\n            for (var j = 0; j < Width; ++j)\r\n            {\r\n                var horizontalScreenAngle = (j - Width \/ 2) \/ (double)Width * HorizontalAngle;\r\n                var depthAngle = new DepthAngle(currentRadians, horizontalScreenAngle * Math.PI \/ 180.0);\r\n\r\n                List<DepthData> depthData;\r\n                if (!_map.TryGetValue(depthAngle, out depthData))\r\n                    _map[depthAngle] = depthData = new List<DepthData>();\r\n\r\n                depthData.Clear();\r\n\r\n                for (var i = 0; i < Height; ++i)\r\n                {\r\n                    var depth = Math.Min(maxDepth, data[i * Width + (Width - j - 1)]);\r\n                    if (depth == 0)\r\n                        continue;\r\n\r\n                    var isObstacle = false;\r\n\r\n                    if (i >= Height \/ 2)\r\n                    {\r\n                        var verticalScreenAngle = Math.Abs((i - Height \/ 2) \/ (double)Height * VerticalAngle);\r\n                        var height = (ushort)(Math.Sin(verticalScreenAngle * Math.PI \/ 180.0) * depth \/ Math.Sin((90 - verticalScreenAngle) * Math.PI \/ 180.0));\r\n\r\n                        if (height <= HostHeight * 10)\r\n                            isObstacle = true;\r\n                    }\r\n\r\n                    depth = (ushort)(depth \/ Math.Sin((90 - horizontalScreenAngle) * Math.PI \/ 180.0));\r\n\r\n                    depthData.Add(new DepthData(depth, isObstacle));\r\n                }\r\n            }\r\n        }\r\n\r\n        private struct DepthAngle : IEquatable<DepthAngle>\r\n        {\r\n            public DepthAngle(double viewAngle, double screenAngle)\r\n            {\r\n                ViewAngle = viewAngle;\r\n                ScreenAngle = screenAngle;\r\n            }\r\n\r\n            public double ViewAngle { get; }\r\n            public double ScreenAngle { get; }\r\n\r\n            public override bool Equals(object obj)\r\n            {\r\n                if (ReferenceEquals(null, obj))\r\n                    return false;\r\n\r\n                return obj is DepthAngle && Equals((DepthAngle)obj);\r\n            }\r\n\r\n            public override int GetHashCode()\r\n            {\r\n                unchecked\r\n                {\r\n                    return (ViewAngle.GetHashCode() * 397) ^ ScreenAngle.GetHashCode();\r\n                }\r\n            }\r\n\r\n            public bool Equals(DepthAngle other)\r\n            {\r\n                return ViewAngle.Equals(other.ViewAngle) && ScreenAngle.Equals(other.ScreenAngle);\r\n            }\r\n        }\r\n\r\n        private struct DepthData\r\n        {\r\n            public DepthData(ushort depth, bool isObstacle)\r\n            {\r\n                Depth = depth;\r\n                IsObstacle = isObstacle;\r\n            }\r\n\r\n            public ushort Depth { get; }\r\n            public bool IsObstacle { get; }\r\n        }\r\n    }\r\n}\r\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"0ebfa35381aca838fac68c7666b8e84c5784560e","subject":"increase threads count","message":"increase threads count\n","repos":"LykkeCity\/bitcoinservice,LykkeCity\/bitcoinservice","old_file":"src\/ApiRunner\/Program.cs","new_file":"src\/ApiRunner\/Program.cs","new_contents":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing AzureRepositories;\nusing BitcoinApi;\nusing Core.Settings;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.DependencyInjection;\nusing Newtonsoft.Json;\n\nnamespace ApiRunner\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            var arguments = args.Select(t => t.Split('=')).ToDictionary(spl => spl[0].Trim('-'), spl => spl[1]);\n\n            Console.Clear();\n            Console.Title = \"Bitcoin self-hosted API - Ver. \" + Microsoft.Extensions.PlatformAbstractions.PlatformServices.Default.Application.ApplicationVersion;\n\n            var builder = new WebHostBuilder()\n                .UseKestrel(o => o.ThreadCount = 4)\n                .UseContentRoot(Directory.GetCurrentDirectory())\n                .UseIISIntegration()\n                .UseStartup<Startup>();\n\n            if (arguments.ContainsKey(\"port\"))\n                builder.UseUrls($\"http:\/\/*:{arguments[\"port\"]}\");\n\n            Console.WriteLine($\"Web Server is running\");\n            Console.WriteLine(\"Utc time: \" + DateTime.UtcNow.ToString(\"yyyy-MM-dd HH:mm:ss\"));\n\n            var host = builder.Build();\n\n            host.Run();\n        }\n\n        static void Exit()\n        {\n            Console.WriteLine(\"Press any key to exit...\");\n            Console.ReadKey();\n        }\n\n        static BaseSettings GetSettings()\n        {\n            var settingsData = ReadSettingsFile();\n\n            if (string.IsNullOrWhiteSpace(settingsData))\n            {\n                Console.WriteLine(\"Please, provide generalsettings.json file\");\n                return null;\n            }\n\n            var settings = JsonConvert.DeserializeObject<BaseSettings>(settingsData);\n\n            return settings;\n        }\n\n\n        static string ReadSettingsFile()\n        {\n#if DEBUG\n            return File.ReadAllText(@\"..\\..\\settings\\settings.json\");\n#else\n\t\t\treturn File.ReadAllText(\"settings.json\");\n#endif\n        }\n\n    }\n}\n","old_contents":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing AzureRepositories;\nusing BitcoinApi;\nusing Core.Settings;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.DependencyInjection;\nusing Newtonsoft.Json;\n\nnamespace ApiRunner\n{\n    public class Program\n    {\n        public static void Main(string[] args)\n        {\n            var arguments = args.Select(t => t.Split('=')).ToDictionary(spl => spl[0].Trim('-'), spl => spl[1]);\n\n            Console.Clear();\n            Console.Title = \"Bitcoin self-hosted API - Ver. \" + Microsoft.Extensions.PlatformAbstractions.PlatformServices.Default.Application.ApplicationVersion;\n            \n            var builder = new WebHostBuilder()\n                .UseKestrel()\n                .UseContentRoot(Directory.GetCurrentDirectory())\n                .UseIISIntegration()\n                .UseStartup<Startup>();\n\n            if (arguments.ContainsKey(\"port\"))\n                builder.UseUrls($\"http:\/\/*:{arguments[\"port\"]}\");\n\n            Console.WriteLine($\"Web Server is running\");\n            Console.WriteLine(\"Utc time: \" + DateTime.UtcNow.ToString(\"yyyy-MM-dd HH:mm:ss\"));\n\n            var host = builder.Build();\n\n            host.Run();            \n        }\n\n        static void Exit()\n        {\n            Console.WriteLine(\"Press any key to exit...\");\n            Console.ReadKey();\n        }\n\n        static BaseSettings GetSettings()\n        {\n            var settingsData = ReadSettingsFile();\n\n            if (string.IsNullOrWhiteSpace(settingsData))\n            {\n                Console.WriteLine(\"Please, provide generalsettings.json file\");\n                return null;\n            }\n            \n            var settings = JsonConvert.DeserializeObject<BaseSettings>(settingsData);\n\n            return settings;\n        }\n\n\n        static string ReadSettingsFile()\n        {\n#if DEBUG\n            return File.ReadAllText(@\"..\\..\\settings\\settings.json\");\n#else\n\t\t\treturn File.ReadAllText(\"settings.json\");\n#endif\n        }\n\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"c3903397d225554244c1f6d6504b2206d2918f30","subject":"Fix AppsCategory","message":"Fix AppsCategory\n","repos":"Soniclev\/vk,vknet\/vk,rassvet85\/vk,kadkin\/vk,vknet\/vk,mainefremov\/vk,kkohno\/vk","old_file":"VkNet\/Categories\/AppsCategory.cs","new_file":"VkNet\/Categories\/AppsCategory.cs","new_contents":"\ufeffusing System;\nusing VkNet.Enums.Filters;\nusing VkNet.Enums.SafetyEnums;\nusing VkNet.Model;\nusing VkNet.Model.RequestParams;\nusing VkNet.Utils;\n\nnamespace VkNet.Categories\n{\n\t\/\/\/ <summary>\n\t\/\/\/ \u041c\u0435\u0442\u043e\u0434\u044b \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f\u043c\u0438.\n\t\/\/\/ <\/summary>\n\tpublic partial class AppsCategory\n\t{\n\t\t\/\/\/ <summary>\n\t\t\/\/\/ API.\n\t\t\/\/\/ <\/summary>\n\t\tprivate readonly VkApi _vk;\n\n\t\t\/\/\/ <summary>\n\t\t\/\/\/ \u041c\u0435\u0442\u043e\u0434\u044b \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f\u043c\u0438.\n\t\t\/\/\/ <\/summary>\n\t\t\/\/\/ <param name=\"vk\">API.<\/param>\n\t\tinternal AppsCategory(VkApi vk)\n\t\t{\n\t\t\t_vk = vk;\n\t\t}\n\n\t\t\/\/\/ <summary>\n\t\t\/\/\/ \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0441\u043f\u0438\u0441\u043e\u043a \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0439, \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u044b\u0445 \u0434\u043b\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u0439 \u0441\u0430\u0439\u0442\u0430 \u0447\u0435\u0440\u0435\u0437 \u043a\u0430\u0442\u0430\u043b\u043e\u0433 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0439.\n\t\t\/\/\/ <\/summary>\n\t\t\/\/\/ <param name=\"params\">\u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0437\u0430\u043f\u0440\u043e\u0441\u0430.<\/param>\n\t\t\/\/\/ <returns>\n\t\t\/\/\/ \u041f\u043e\u0441\u043b\u0435 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0433\u043e \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u043e\u0431\u0449\u0435\u0435 \u0447\u0438\u0441\u043b\u043e \u043d\u0430\u0439\u0434\u0435\u043d\u043d\u044b\u0445 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0439 \u0438 \u043c\u0430\u0441\u0441\u0438\u0432 \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0439.\n\t\t\/\/\/ <\/returns>\n\t\t\/\/\/ <remarks>\n\t\t\/\/\/ \u041a \u043c\u0435\u0442\u043e\u0434\u0443 \u043c\u043e\u0436\u043d\u043e \u0434\u0435\u043b\u0430\u0442\u044c \u043d\u0435 \u0431\u043e\u043b\u0435\u0435 60 \u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432 \u0432 \u043c\u0438\u043d\u0443\u0442\u0443 \u0441 \u043e\u0434\u043d\u043e\u0433\u043e IP \u0438\u043b\u0438 id.\n\t\t\/\/\/ \u0421\u0442\u0440\u0430\u043d\u0438\u0446\u0430 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0438 \u0412\u041a\u043e\u043d\u0442\u0430\u043a\u0442\u0435 <seealso cref=\"http:\/\/vk.com\/dev\/apps.getCatalog\" \/>.\n\t\t\/\/\/ <\/remarks>\n\t\tpublic VkCollection<App> GetCatalog(AppGetCatalogParams @params)\n\t\t{\n\t\t\treturn _vk.Call(\"apps.getCatalog\", @params, !@params.ReturnFriends).ToVkCollectionOf<App>(x => x);\n\t\t}\n\n\t\t\/\/\/ <summary>\n\t\t\/\/\/ \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0434\u0430\u043d\u043d\u044b\u0435 \u043e \u0437\u0430\u043f\u0440\u043e\u0448\u0435\u043d\u043d\u043e\u043c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0438 \u043d\u0430 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0435 \u0412\u041a\u043e\u043d\u0442\u0430\u043a\u0442\u0435\n\t\t\/\/\/ <\/summary>\n\t\t\/\/\/ <param name=\"params\">\u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0437\u0430\u043f\u0440\u043e\u0441\u0430.<\/param>\n\t\t\/\/\/ <returns>\n\t\t\/\/\/ \u041f\u043e\u0441\u043b\u0435 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0433\u043e \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u043e\u0431\u044a\u0435\u043a\u0442 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f.\n\t\t\/\/\/ <\/returns>\n\t\t\/\/\/ <remarks>\n\t\t\/\/\/ \u0421\u0442\u0440\u0430\u043d\u0438\u0446\u0430 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0438 \u0412\u041a\u043e\u043d\u0442\u0430\u043a\u0442\u0435 <see href=\"http:\/\/vk.com\/dev\/apps.get\" \/>.\n\t\t\/\/\/ <\/remarks>\n\t\tpublic VkCollection<App> Get(AppGetParams @params)\n\t\t{\n\t\t\treturn _vk.Call(\"apps.get\", @params).ToVkCollectionOf<App>(x => x);\n\t\t}\n\n\t\t\/\/\/ <summary>\n\t\t\/\/\/ \u041f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u043e\u0442\u043f\u0440\u0430\u0432\u0438\u0442\u044c \u0437\u0430\u043f\u0440\u043e\u0441 \u0434\u0440\u0443\u0433\u043e\u043c\u0443 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e \u0432 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0438, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0449\u0435\u043c \u0430\u0432\u0442\u043e\u0440\u0438\u0437\u0430\u0446\u0438\u044e \u0412\u041a\u043e\u043d\u0442\u0430\u043a\u0442\u0435.\n\t\t\/\/\/ <\/summary>\n\t\t\/\/\/ <param name=\"params\">\u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0437\u0430\u043f\u0440\u043e\u0441\u0430.<\/param>\n\t\t\/\/\/ <returns>\n\t\t\/\/\/ \u0412 \u0441\u043b\u0443\u0447\u0430\u0435 \u0443\u0434\u0430\u0447\u043d\u043e\u0433\u043e \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u043c\u0435\u0442\u043e\u0434 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0441\u043e\u0437\u0434\u0430\u043d\u043d\u043e\u0433\u043e \u0437\u0430\u043f\u0440\u043e\u0441\u0430, \u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440:\n\t\t\/\/\/ 10013.\n\t\t\/\/\/ <\/returns>\n\t\t\/\/\/ <remarks>\n\t\t\/\/\/ \u0421\u0442\u0440\u0430\u043d\u0438\u0446\u0430 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0438 \u0412\u041a\u043e\u043d\u0442\u0430\u043a\u0442\u0435 <see href=\"http:\/\/vk.com\/dev\/apps.sendRequest\" \/>.\n\t\t\/\/\/ <\/remarks>\n\t\t[ApiVersion(\"5.44\")]\n\t\tpublic long SendRequest(AppSendRequestParams @params)\n\t\t{\n\t\t\treturn _vk.Call(\"apps.sendRequest\", @params);\n\t\t}\n\n\t\t\/\/\/ <summary>\n\t\t\/\/\/ \u0423\u0434\u0430\u043b\u044f\u0435\u0442 \u0432\u0441\u0435 \u0443\u0432\u0435\u0434\u043e\u043c\u043b\u0435\u043d\u0438\u044f \u043e \u0437\u0430\u043f\u0440\u043e\u0441\u0430\u0445, \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u043d\u044b\u0445 \u0438\u0437 \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f.\n\t\t\/\/\/ <\/summary>\n\t\t\/\/\/ <returns>\n\t\t\/\/\/ \u0412 \u0441\u043b\u0443\u0447\u0430\u0435 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0433\u043e \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 <c>true<\/c>.\n\t\t\/\/\/ <\/returns>\n\t\t\/\/\/ <remarks>\n\t\t\/\/\/ \u0421\u0442\u0440\u0430\u043d\u0438\u0446\u0430 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0438 \u0412\u041a\u043e\u043d\u0442\u0430\u043a\u0442\u0435 <see href=\"http:\/\/vk.com\/dev\/apps.deleteAppRequests\" \/>.\n\t\t\/\/\/ <\/remarks>\n\t\t[ApiVersion(\"5.44\")]\n\t\tpublic bool DeleteAppRequests()\n\t\t{\n\t\t\treturn _vk.Call(\"apps.deleteAppRequests\", VkParameters.Empty);\n\t\t}\n\n\t\t\/\/\/ <summary>\n\t\t\/\/\/ \u0421\u043e\u0437\u0434\u0430\u0435\u0442 \u0441\u043f\u0438\u0441\u043e\u043a \u0434\u0440\u0443\u0437\u0435\u0439, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0431\u0443\u0434\u0435\u0442 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c\u0441\u044f \u043f\u0440\u0438 \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0435 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u043c \u043f\u0440\u0438\u0433\u043b\u0430\u0448\u0435\u043d\u0438\u0439 \u0432 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435.\n\t\t\/\/\/ <\/summary>\n\t\t\/\/\/ <param name=\"type\">T\u0438\u043f \u0441\u043e\u0437\u0434\u0430\u0432\u0430\u0435\u043c\u043e\u0433\u043e \u0441\u043f\u0438\u0441\u043a\u0430 \u0434\u0440\u0443\u0437\u0435\u0439.<\/param>\n\t\t\/\/\/ <param name=\"extended\">\u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440, \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u044e\u0449\u0438\u0439 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e\u0441\u0442\u044c \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0442\u044c \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\u0445.\n\t\t\/\/\/ 0 \u2014 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u044e\u0442\u0441\u044f \u0442\u043e\u043b\u044c\u043a\u043e \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440\u044b;\n\t\t\/\/\/ 1 \u2014 \u0431\u0443\u0434\u0443\u0442 \u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u043e \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0435\u043d\u044b \u0438\u043c\u044f \u0438 \u0444\u0430\u043c\u0438\u043b\u0438\u044f. \u0444\u043b\u0430\u0433, \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0442\u044c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f 1 \u0438\u043b\u0438 0, \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e 0 (\u0424\u043b\u0430\u0433, \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0442\u044c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f 1 \u0438\u043b\u0438 0, \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e 0).<\/param>\n\t\t\/\/\/ <param name=\"count\">\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u0439 \u0432 \u0441\u043e\u0437\u0434\u0430\u0432\u0430\u0435\u043c\u043e\u043c \u0441\u043f\u0438\u0441\u043a\u0435.<\/param>\n\t\t\/\/\/ <param name=\"offset\">\u0421\u043c\u0435\u0449\u0435\u043d\u0438\u0435 \u043e\u0442\u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c\u043d\u043e \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0434\u043b\u044f \u0432\u044b\u0431\u043e\u0440\u043a\u0438 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u043e\u0433\u043e \u043f\u043e\u0434\u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u0430.<\/param>\n\t\t\/\/\/ <param name=\"fields\">\u0421\u043f\u0438\u0441\u043e\u043a \u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0445 \u043f\u043e\u043b\u0435\u0439 \u043f\u0440\u043e\u0444\u0438\u043b\u0435\u0439, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0432\u0435\u0440\u043d\u0443\u0442\u044c. \u0421\u043c. \u043f\u043e\u0434\u0440\u043e\u0431\u043d\u043e\u0435 \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435.<\/param>\n\t\t\/\/\/ <returns>\n\t\t\/\/\/ \u041f\u043e\u0441\u043b\u0435 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0433\u043e \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0441\u043f\u0438\u0441\u043e\u043a \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u0439.\n\t\t\/\/\/ <\/returns>\n\t\t\/\/\/ <remarks>\n\t\t\/\/\/ \u0421\u0442\u0440\u0430\u043d\u0438\u0446\u0430 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0438 \u0412\u041a\u043e\u043d\u0442\u0430\u043a\u0442\u0435 <see href=\"http:\/\/vk.com\/dev\/apps.getFriendsList\" \/>.\n\t\t\/\/\/ <\/remarks>\n\t\t[ApiVersion(\"5.44\")]\n\t\tpublic VkCollection<User> GetFriendsList(AppRequestType type, bool? extended = null, long? count = null, long? offset = null, UsersFields fields = null)\n\t\t{\n\t\t\tvar parameters = new VkParameters\n\t\t\t{\n\t\t\t\t{ \"extended\", extended },\n\t\t\t\t{ \"offset\", offset },\n\t\t\t\t{ \"type\", type },\n\t\t\t\t{ \"fields\", fields }\n\t\t\t};\n\n\t\t\tif (count <= 5000)\n\t\t\t{\n\t\t\t\tparameters.Add(\"count\", count);\n\t\t\t}\n\n\t\t\treturn _vk.Call(\"apps.getFriendsList\", parameters).ToVkCollectionOf<User>(x => x);\n\t\t}\n\n\t\t\/\/\/ <summary>\n\t\t\/\/\/ \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0440\u0435\u0439\u0442\u0438\u043d\u0433 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u0439 \u0432 \u0438\u0433\u0440\u0435.\n\t\t\/\/\/ <\/summary>\n\t\t\/\/\/ <param name=\"type\">Level \u2014 \u0440\u0435\u0439\u0442\u0438\u043d\u0433 \u043f\u043e \u0443\u0440\u043e\u0432\u043d\u044f\u043c,\n\t\t\/\/\/ points \u2014 \u0440\u0435\u0439\u0442\u0438\u043d\u0433 \u043f\u043e \u043e\u0447\u043a\u0430\u043c, \u043d\u0430\u0447\u0438\u0441\u043b\u0435\u043d\u043d\u044b\u043c \u0437\u0430 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043c\u0438\u0441\u0441\u0438\u0439.\n\t\t\/\/\/ score \u2014 \u0440\u0435\u0439\u0442\u0438\u043d\u0433 \u043f\u043e \u043e\u0447\u043a\u0430\u043c, \u043d\u0430\u0447\u0438\u0441\u043b\u0435\u043d\u043d\u044b\u043c \u043d\u0430\u043f\u0440\u044f\u043c\u0443\u044e (apps.getScore). \u0441\u0442\u0440\u043e\u043a\u0430, \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440 (\u0421\u0442\u0440\u043e\u043a\u0430, \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440).<\/param>\n\t\t\/\/\/ <param name=\"global\">1 \u2014 \u0433\u043b\u043e\u0431\u0430\u043b\u044c\u043d\u044b\u0439 \u0440\u0435\u0439\u0442\u0438\u043d\u0433 \u043f\u043e \u0432\u0441\u0435\u043c \u0438\u0433\u0440\u043e\u043a\u0430\u043c,\n\t\t\/\/\/ 0 \u2014 \u0440\u0435\u0439\u0442\u0438\u043d\u0433 \u043f\u043e \u0434\u0440\u0443\u0437\u044c\u044f\u043c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0444\u043b\u0430\u0433, \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0442\u044c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f 1 \u0438\u043b\u0438 0, \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e 1 (\u0424\u043b\u0430\u0433, \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0442\u044c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f 1 \u0438\u043b\u0438 0, \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e 1).<\/param>\n\t\t\/\/\/ <param name=\"extended\">1 \u2014 \u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u043e \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435. \u0444\u043b\u0430\u0433, \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0442\u044c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f 1 \u0438\u043b\u0438 0, \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e 0 (\u0424\u043b\u0430\u0433, \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0442\u044c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f 1 \u0438\u043b\u0438 0, \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e 0).<\/param>\n\t\t\/\/\/ <returns>\n\t\t\/\/\/ \u041f\u043e\u0441\u043b\u0435 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0433\u043e \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0441\u043f\u0438\u0441\u043e\u043a \u0434\u0440\u0443\u0437\u0435\u0439 \u0441 \u0442\u0435\u043a\u0443\u0449\u0438\u043c \u0443\u0440\u043e\u0432\u043d\u0435\u043c \u0438 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e\u043c \u043e\u0447\u043a\u043e\u0432 \u0432 \u0438\u0433\u0440\u0435, \u043e\u0442\u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0439 \u043f\u043e \u0443\u0431\u044b\u0432\u0430\u043d\u0438\u044e \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u0443\u0440\u043e\u0432\u043d\u044f \u0438\u043b\u0438 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430 \u043e\u0447\u043a\u043e\u0432.\n\t\t\/\/\/ <\/returns>\n\t\t\/\/\/ <remarks>\n\t\t\/\/\/ \u0421\u0442\u0440\u0430\u043d\u0438\u0446\u0430 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0438 \u0412\u041a\u043e\u043d\u0442\u0430\u043a\u0442\u0435 <see href=\"http:\/\/vk.com\/dev\/apps.getLeaderboard\" \/>.\n\t\t\/\/\/ <\/remarks>\n\t\t[ApiVersion(\"5.44\")]\n\t\tpublic bool GetLeaderboard(AppRatingType type, bool? global = null, bool? extended = null)\n\t\t{\n\t\t\t\/\/var parameters = new VkParameters\n\t\t\t\/\/{\n\t\t\t\/\/\t{ \"type\", type },\n\t\t\t\/\/\t{ \"global\", global },\n\t\t\t\/\/\t{ \"extended\", extended }\n\t\t\t\/\/};\n\t\t\t\/\/return _vk.Call(\"apps.getLeaderboard\", parameters, true);\n\t\t\tthrow new NotImplementedException(); \/\/ TODO: \u041c\u0435\u0442\u043e\u0434\u044b \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u044b \u0442\u043e\u043b\u044c\u043a\u043e \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f\u043c, \u0440\u0430\u0437\u043c\u0435\u0449\u0435\u043d\u043d\u044b\u043c \u0432 \u0438\u0433\u0440\u043e\u0432\u043e\u043c \u043a\u0430\u0442\u0430\u043b\u043e\u0433\u0435.\n\t\t}\n\n\t\t\/\/\/ <summary>\n\t\t\/\/\/ \u041c\u0435\u0442\u043e\u0434 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043e\u0447\u043a\u043e\u0432 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0432 \u044d\u0442\u043e\u0439 \u0438\u0433\u0440\u0435.\n\t\t\/\/\/ <\/summary>\n\t\t\/\/\/ <param name=\"userId\">\u0418\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f. \u043f\u043e\u043b\u043e\u0436\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e, \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f, \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440 (\u041f\u043e\u043b\u043e\u0436\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e, \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f, \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440).<\/param>\n\t\t\/\/\/ <returns>\n\t\t\/\/\/ \u041f\u043e\u0441\u043b\u0435 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0433\u043e \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0447\u0438\u0441\u043b\u043e \u043e\u0447\u043a\u043e\u0432 \u0434\u043b\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f.\n\t\t\/\/\/ <\/returns>\n\t\t\/\/\/ <remarks>\n\t\t\/\/\/ \u0421\u0442\u0440\u0430\u043d\u0438\u0446\u0430 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0438 \u0412\u041a\u043e\u043d\u0442\u0430\u043a\u0442\u0435 <see href=\"http:\/\/vk.com\/dev\/apps.getScore\" \/>.\n\t\t\/\/\/ <\/remarks>\n\t\t[ApiVersion(\"5.44\")]\n\t\tpublic long GetScore(long userId)\n\t\t{\n\t\t\tVkErrors.ThrowIfNumberIsNegative(() => userId);\n\t\t\tvar parameters = new VkParameters\n\t\t\t{\n\t\t\t\t{ \"user_id\", userId }\n\t\t\t};\n\t\t\treturn _vk.Call(\"apps.getScore\", parameters, false);\n\t\t}\n\t}\n}\n","old_contents":"\ufeffusing System;\nusing VkNet.Enums.Filters;\nusing VkNet.Enums.SafetyEnums;\nusing VkNet.Model;\nusing VkNet.Model.RequestParams;\nusing VkNet.Utils;\n\nnamespace VkNet.Categories\n{\n\t\/\/\/ <summary>\n\t\/\/\/ \u041c\u0435\u0442\u043e\u0434\u044b \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f\u043c\u0438.\n\t\/\/\/ <\/summary>\n\tpublic partial class AppsCategory\n\t{\n\t\t\/\/\/ <summary>\n\t\t\/\/\/ API.\n\t\t\/\/\/ <\/summary>\n\t\tprivate readonly VkApi _vk;\n\n\t\t\/\/\/ <summary>\n\t\t\/\/\/ \u041c\u0435\u0442\u043e\u0434\u044b \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f\u043c\u0438.\n\t\t\/\/\/ <\/summary>\n\t\t\/\/\/ <param name=\"vk\">API.<\/param>\n\t\tinternal AppsCategory(VkApi vk)\n\t\t{\n\t\t\t_vk = vk;\n\t\t}\n\n\t\t\/\/\/ <summary>\n\t\t\/\/\/ \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0441\u043f\u0438\u0441\u043e\u043a \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0439, \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u044b\u0445 \u0434\u043b\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u0439 \u0441\u0430\u0439\u0442\u0430 \u0447\u0435\u0440\u0435\u0437 \u043a\u0430\u0442\u0430\u043b\u043e\u0433 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0439.\n\t\t\/\/\/ <\/summary>\n\t\t\/\/\/ <param name=\"params\">\u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0437\u0430\u043f\u0440\u043e\u0441\u0430.<\/param>\n\t\t\/\/\/ <returns>\n\t\t\/\/\/ \u041f\u043e\u0441\u043b\u0435 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0433\u043e \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u043e\u0431\u0449\u0435\u0435 \u0447\u0438\u0441\u043b\u043e \u043d\u0430\u0439\u0434\u0435\u043d\u043d\u044b\u0445 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0439 \u0438 \u043c\u0430\u0441\u0441\u0438\u0432 \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0439.\n\t\t\/\/\/ <\/returns>\n\t\t\/\/\/ <remarks>\n\t\t\/\/\/ \u041a \u043c\u0435\u0442\u043e\u0434\u0443 \u043c\u043e\u0436\u043d\u043e \u0434\u0435\u043b\u0430\u0442\u044c \u043d\u0435 \u0431\u043e\u043b\u0435\u0435 60 \u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432 \u0432 \u043c\u0438\u043d\u0443\u0442\u0443 \u0441 \u043e\u0434\u043d\u043e\u0433\u043e IP \u0438\u043b\u0438 id.\n\t\t\/\/\/ \u0421\u0442\u0440\u0430\u043d\u0438\u0446\u0430 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0438 \u0412\u041a\u043e\u043d\u0442\u0430\u043a\u0442\u0435 <seealso cref=\"http:\/\/vk.com\/dev\/apps.getCatalog\" \/>.\n\t\t\/\/\/ <\/remarks>\n\t\tpublic VkCollection<App> GetCatalog(AppGetCatalogParams @params)\n\t\t{\n\t\t\treturn _vk.Call(\"apps.getCatalog\", @params, !@params.ReturnFriends).ToVkCollectionOf<App>(x => x);\n\t\t}\n\n\t\t\/\/\/ <summary>\n\t\t\/\/\/ \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0434\u0430\u043d\u043d\u044b\u0435 \u043e \u0437\u0430\u043f\u0440\u043e\u0448\u0435\u043d\u043d\u043e\u043c \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0438 \u043d\u0430 \u043f\u043b\u0430\u0442\u0444\u043e\u0440\u043c\u0435 \u0412\u041a\u043e\u043d\u0442\u0430\u043a\u0442\u0435\n\t\t\/\/\/ <\/summary>\n\t\t\/\/\/ <param name=\"params\">\u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0437\u0430\u043f\u0440\u043e\u0441\u0430.<\/param>\n\t\t\/\/\/ <returns>\n\t\t\/\/\/ \u041f\u043e\u0441\u043b\u0435 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0433\u043e \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u043e\u0431\u044a\u0435\u043a\u0442 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f.\n\t\t\/\/\/ <\/returns>\n\t\t\/\/\/ <remarks>\n\t\t\/\/\/ \u0421\u0442\u0440\u0430\u043d\u0438\u0446\u0430 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0438 \u0412\u041a\u043e\u043d\u0442\u0430\u043a\u0442\u0435 <see href=\"http:\/\/vk.com\/dev\/apps.get\" \/>.\n\t\t\/\/\/ <\/remarks>\n\t\tpublic VkCollection<App> Get(AppGetParams @params)\n\t\t{\n\t\t\treturn _vk.Call(\"apps.get\", @params).ToVkCollectionOf<App>(x => x);\n\t\t}\n\n\t\t\/\/\/ <summary>\n\t\t\/\/\/ \u041f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u043e\u0442\u043f\u0440\u0430\u0432\u0438\u0442\u044c \u0437\u0430\u043f\u0440\u043e\u0441 \u0434\u0440\u0443\u0433\u043e\u043c\u0443 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044e \u0432 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0438, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0449\u0435\u043c \u0430\u0432\u0442\u043e\u0440\u0438\u0437\u0430\u0446\u0438\u044e \u0412\u041a\u043e\u043d\u0442\u0430\u043a\u0442\u0435.\n\t\t\/\/\/ <\/summary>\n\t\t\/\/\/ <param name=\"params\">\u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0437\u0430\u043f\u0440\u043e\u0441\u0430.<\/param>\n\t\t\/\/\/ <returns>\n\t\t\/\/\/ \u0412 \u0441\u043b\u0443\u0447\u0430\u0435 \u0443\u0434\u0430\u0447\u043d\u043e\u0433\u043e \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u043c\u0435\u0442\u043e\u0434 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0441\u043e\u0437\u0434\u0430\u043d\u043d\u043e\u0433\u043e \u0437\u0430\u043f\u0440\u043e\u0441\u0430, \u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440:\n\t\t\/\/\/ 10013.\n\t\t\/\/\/ <\/returns>\n\t\t\/\/\/ <remarks>\n\t\t\/\/\/ \u0421\u0442\u0440\u0430\u043d\u0438\u0446\u0430 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0438 \u0412\u041a\u043e\u043d\u0442\u0430\u043a\u0442\u0435 <see href=\"http:\/\/vk.com\/dev\/apps.sendRequest\" \/>.\n\t\t\/\/\/ <\/remarks>\n\t\t[ApiVersion(\"5.44\")]\n\t\tpublic long SendRequest(AppSendRequestParams @params)\n\t\t{\n\t\t\treturn _vk.Call(\"apps.sendRequest\", @params);\n\t\t}\n\n\t\t\/\/\/ <summary>\n\t\t\/\/\/ \u0423\u0434\u0430\u043b\u044f\u0435\u0442 \u0432\u0441\u0435 \u0443\u0432\u0435\u0434\u043e\u043c\u043b\u0435\u043d\u0438\u044f \u043e \u0437\u0430\u043f\u0440\u043e\u0441\u0430\u0445, \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u043d\u044b\u0445 \u0438\u0437 \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f.\n\t\t\/\/\/ <\/summary>\n\t\t\/\/\/ <returns>\n\t\t\/\/\/ \u0412 \u0441\u043b\u0443\u0447\u0430\u0435 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0433\u043e \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 <c>true<\/c>.\n\t\t\/\/\/ <\/returns>\n\t\t\/\/\/ <remarks>\n\t\t\/\/\/ \u0421\u0442\u0440\u0430\u043d\u0438\u0446\u0430 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0438 \u0412\u041a\u043e\u043d\u0442\u0430\u043a\u0442\u0435 <see href=\"http:\/\/vk.com\/dev\/apps.deleteAppRequests\" \/>.\n\t\t\/\/\/ <\/remarks>\n\t\t[ApiVersion(\"5.44\")]\n\t\tpublic bool DeleteAppRequests()\n\t\t{\n\t\t\treturn _vk.Call(\"apps.deleteAppRequests\", VkParameters.Empty);\n\t\t}\n\n\t\t\/\/\/ <summary>\n\t\t\/\/\/ \u0421\u043e\u0437\u0434\u0430\u0435\u0442 \u0441\u043f\u0438\u0441\u043e\u043a \u0434\u0440\u0443\u0437\u0435\u0439, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0431\u0443\u0434\u0435\u0442 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c\u0441\u044f \u043f\u0440\u0438 \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0435 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u043c \u043f\u0440\u0438\u0433\u043b\u0430\u0448\u0435\u043d\u0438\u0439 \u0432 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435.\n\t\t\/\/\/ <\/summary>\n\t\t\/\/\/ <param name=\"type\">T\u0438\u043f \u0441\u043e\u0437\u0434\u0430\u0432\u0430\u0435\u043c\u043e\u0433\u043e \u0441\u043f\u0438\u0441\u043a\u0430 \u0434\u0440\u0443\u0437\u0435\u0439.<\/param>\n\t\t\/\/\/ <param name=\"extended\">\u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440, \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u044e\u0449\u0438\u0439 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e\u0441\u0442\u044c \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0442\u044c \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u043d\u0443\u044e \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\u0445.\n\t\t\/\/\/ 0 \u2014 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u044e\u0442\u0441\u044f \u0442\u043e\u043b\u044c\u043a\u043e \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440\u044b;\n\t\t\/\/\/ 1 \u2014 \u0431\u0443\u0434\u0443\u0442 \u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u043e \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0435\u043d\u044b \u0438\u043c\u044f \u0438 \u0444\u0430\u043c\u0438\u043b\u0438\u044f. \u0444\u043b\u0430\u0433, \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0442\u044c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f 1 \u0438\u043b\u0438 0, \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e 0 (\u0424\u043b\u0430\u0433, \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0442\u044c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f 1 \u0438\u043b\u0438 0, \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e 0).<\/param>\n\t\t\/\/\/ <param name=\"count\">\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u0439 \u0432 \u0441\u043e\u0437\u0434\u0430\u0432\u0430\u0435\u043c\u043e\u043c \u0441\u043f\u0438\u0441\u043a\u0435.<\/param>\n\t\t\/\/\/ <param name=\"offset\">\u0421\u043c\u0435\u0449\u0435\u043d\u0438\u0435 \u043e\u0442\u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c\u043d\u043e \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0434\u043b\u044f \u0432\u044b\u0431\u043e\u0440\u043a\u0438 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u043e\u0433\u043e \u043f\u043e\u0434\u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u0430.<\/param>\n\t\t\/\/\/ <param name=\"fields\">\u0421\u043f\u0438\u0441\u043e\u043a \u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0445 \u043f\u043e\u043b\u0435\u0439 \u043f\u0440\u043e\u0444\u0438\u043b\u0435\u0439, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0432\u0435\u0440\u043d\u0443\u0442\u044c. \u0421\u043c. \u043f\u043e\u0434\u0440\u043e\u0431\u043d\u043e\u0435 \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435.<\/param>\n\t\t\/\/\/ <returns>\n\t\t\/\/\/ \u041f\u043e\u0441\u043b\u0435 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0433\u043e \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0441\u043f\u0438\u0441\u043e\u043a \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u0439.\n\t\t\/\/\/ <\/returns>\n\t\t\/\/\/ <remarks>\n\t\t\/\/\/ \u0421\u0442\u0440\u0430\u043d\u0438\u0446\u0430 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0438 \u0412\u041a\u043e\u043d\u0442\u0430\u043a\u0442\u0435 <see href=\"http:\/\/vk.com\/dev\/apps.getFriendsList\" \/>.\n\t\t\/\/\/ <\/remarks>\n\t\t[ApiVersion(\"5.44\")]\n\t\tpublic VkCollection<User> GetFriendsList(AppRequestType type, bool? extended = null, long? count = null, long? offset = null, UsersFields fields = null)\n\t\t{\n\t\t\tvar parameters = new VkParameters\n\t\t\t{\n\t\t\t\t{ \"extended\", extended },\n\t\t\t\t{ \"offset\", offset },\n\t\t\t\t{ \"type\", type },\n\t\t\t\t{ \"fields\", fields }\n\t\t\t};\n\n\t\t\tif (count <= 5000)\n\t\t\t{\n\t\t\t\tparameters.Add(\"count\", count);\n\t\t\t}\n\n\t\t\treturn _vk.Call(\"apps.getFriendsList\", parameters).ToVkCollectionOf<User>(x => x);\n\t\t}\n\n\t\t\/\/\/ <summary>\n\t\t\/\/\/ \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0440\u0435\u0439\u0442\u0438\u043d\u0433 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u0439 \u0432 \u0438\u0433\u0440\u0435.\n\t\t\/\/\/ <\/summary>\n\t\t\/\/\/ <param name=\"type\">Level \u2014 \u0440\u0435\u0439\u0442\u0438\u043d\u0433 \u043f\u043e \u0443\u0440\u043e\u0432\u043d\u044f\u043c,\n\t\t\/\/\/ points \u2014 \u0440\u0435\u0439\u0442\u0438\u043d\u0433 \u043f\u043e \u043e\u0447\u043a\u0430\u043c, \u043d\u0430\u0447\u0438\u0441\u043b\u0435\u043d\u043d\u044b\u043c \u0437\u0430 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043c\u0438\u0441\u0441\u0438\u0439.\n\t\t\/\/\/ score \u2014 \u0440\u0435\u0439\u0442\u0438\u043d\u0433 \u043f\u043e \u043e\u0447\u043a\u0430\u043c, \u043d\u0430\u0447\u0438\u0441\u043b\u0435\u043d\u043d\u044b\u043c \u043d\u0430\u043f\u0440\u044f\u043c\u0443\u044e (apps.getScore). \u0441\u0442\u0440\u043e\u043a\u0430, \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440 (\u0421\u0442\u0440\u043e\u043a\u0430, \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440).<\/param>\n\t\t\/\/\/ <param name=\"global\">1 \u2014 \u0433\u043b\u043e\u0431\u0430\u043b\u044c\u043d\u044b\u0439 \u0440\u0435\u0439\u0442\u0438\u043d\u0433 \u043f\u043e \u0432\u0441\u0435\u043c \u0438\u0433\u0440\u043e\u043a\u0430\u043c,\n\t\t\/\/\/ 0 \u2014 \u0440\u0435\u0439\u0442\u0438\u043d\u0433 \u043f\u043e \u0434\u0440\u0443\u0437\u044c\u044f\u043c \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0444\u043b\u0430\u0433, \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0442\u044c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f 1 \u0438\u043b\u0438 0, \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e 1 (\u0424\u043b\u0430\u0433, \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0442\u044c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f 1 \u0438\u043b\u0438 0, \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e 1).<\/param>\n\t\t\/\/\/ <param name=\"extended\">1 \u2014 \u0434\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u043e \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435. \u0444\u043b\u0430\u0433, \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0442\u044c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f 1 \u0438\u043b\u0438 0, \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e 0 (\u0424\u043b\u0430\u0433, \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0442\u044c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f 1 \u0438\u043b\u0438 0, \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e 0).<\/param>\n\t\t\/\/\/ <returns>\n\t\t\/\/\/ \u041f\u043e\u0441\u043b\u0435 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0433\u043e \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0441\u043f\u0438\u0441\u043e\u043a \u0434\u0440\u0443\u0437\u0435\u0439 \u0441 \u0442\u0435\u043a\u0443\u0449\u0438\u043c \u0443\u0440\u043e\u0432\u043d\u0435\u043c \u0438 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e\u043c \u043e\u0447\u043a\u043e\u0432 \u0432 \u0438\u0433\u0440\u0435, \u043e\u0442\u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0439 \u043f\u043e \u0443\u0431\u044b\u0432\u0430\u043d\u0438\u044e \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u0443\u0440\u043e\u0432\u043d\u044f \u0438\u043b\u0438 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430 \u043e\u0447\u043a\u043e\u0432.\n\t\t\/\/\/ <\/returns>\n\t\t\/\/\/ <remarks>\n\t\t\/\/\/ \u0421\u0442\u0440\u0430\u043d\u0438\u0446\u0430 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0438 \u0412\u041a\u043e\u043d\u0442\u0430\u043a\u0442\u0435 <see href=\"http:\/\/vk.com\/dev\/apps.getLeaderboard\" \/>.\n\t\t\/\/\/ <\/remarks>\n\t\t[ApiVersion(\"5.44\")]\n\t\tpublic bool GetLeaderboard(AppRatingType type, bool? global = null, bool? extended = null)\n\t\t{\n\t\t\t\/\/var parameters = new VkParameters\n\t\t\t\/\/{\n\t\t\t\/\/\t{ \"type\", type },\n\t\t\t\/\/\t{ \"global\", global },\n\t\t\t\/\/\t{ \"extended\", extended }\n\t\t\t\/\/};\n\t\t\t\/\/return _vk.Call(\"apps.getLeaderboard\", parameters, true);\n\t\t\tthrow new NotImplementedException(); \/\/ TODO: \u041c\u0435\u0442\u043e\u0434\u044b \u0434\u043e\u0441\u0442\u0443\u043f\u043d\u044b \u0442\u043e\u043b\u044c\u043a\u043e \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f\u043c, \u0440\u0430\u0437\u043c\u0435\u0449\u0435\u043d\u043d\u044b\u043c \u0432 \u0438\u0433\u0440\u043e\u0432\u043e\u043c \u043a\u0430\u0442\u0430\u043b\u043e\u0433\u0435.\n\t\t}\n\n\t\t\/\/\/ <summary>\n\t\t\/\/\/ \u041c\u0435\u0442\u043e\u0434 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043e\u0447\u043a\u043e\u0432 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0432 \u044d\u0442\u043e\u0439 \u0438\u0433\u0440\u0435.\n\t\t\/\/\/ <\/summary>\n\t\t\/\/\/ <param name=\"userId\">\u0418\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f. \u043f\u043e\u043b\u043e\u0436\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e, \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f, \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440 (\u041f\u043e\u043b\u043e\u0436\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e, \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f, \u043e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440).<\/param>\n\t\t\/\/\/ <returns>\n\t\t\/\/\/ \u041f\u043e\u0441\u043b\u0435 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0433\u043e \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0447\u0438\u0441\u043b\u043e \u043e\u0447\u043a\u043e\u0432 \u0434\u043b\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f.\n\t\t\/\/\/ <\/returns>\n\t\t\/\/\/ <remarks>\n\t\t\/\/\/ \u0421\u0442\u0440\u0430\u043d\u0438\u0446\u0430 \u0434\u043e\u043a\u0443\u043c\u0435\u043d\u0442\u0430\u0446\u0438\u0438 \u0412\u041a\u043e\u043d\u0442\u0430\u043a\u0442\u0435 <see href=\"http:\/\/vk.com\/dev\/apps.getScore\" \/>.\n\t\t\/\/\/ <\/remarks>\n\t\t[ApiVersion(\"5.44\")]\n\t\tpublic long GetScore(long userId)\n\t\t{\n            VkErrors.ThrowIfNumberIsNegative(() => userId);\n            var parameters = new VkParameters\n\t\t\t{\n\t\t\t\t{ \"user_id\", userId }\n\t\t\t};\n\t\t\treturn _vk.Call(\"apps.getScore\", parameters, true);\n\t\t}\n\t}\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"ad0b0873802383b062b57f6a39a895b5b6c54a28","subject":"Use of better variable name","message":"Use of better variable name\n","repos":"greatb\/PartialDeployer","old_file":"src\/PartialDeployer\/Ftp.cs","new_file":"src\/PartialDeployer\/Ftp.cs","new_contents":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nusing System.Net;\nusing System.Security.Cryptography;\nusing System.IO;\n\nnamespace PartialDeployer\n{\n    using System.Text.RegularExpressions;\n    using log4net;\n\n    public class ftp\n    {\n        private static readonly ILog log = LogManager.GetLogger(\"Ftp\");\n\n        private string ftp_server;\n        private string ftp_username;\n        private string ftp_password;\n        private string ftp_folder;\n\n        private List<string> ConfigedRemotePaths;\n\n        \/\/http:\/\/stackoverflow.com\/questions\/1013486\/parsing-ftpwebrequests-listdirectorydetails-line\n        \/\/Regex regex = new Regex(@\"^([d-])([rwxt-]{3}){3}\\s+\\d{1,}\\s+.*?(\\d{1,})\\s+(\\w+\\s+\\d{1,2}\\s+(?:\\d{4})?)(\\d{1,2}:\\d{2})?\\s+(.+?)\\s?$\", RegexOptions.Compiled | RegexOptions.Multiline | RegexOptions.IgnoreCase | RegexOptions.IgnorePatternWhitespace);\n        public static Regex FtpListDirectoryDetailsRegex = new Regex(@\".*(?<month>(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec))\\s*(?<day>[0-9]*)\\s*(?<yearTime>([0-9]|:)*)\\s*(?<fileName>.*)\", RegexOptions.Compiled | RegexOptions.Multiline | RegexOptions.IgnoreCase | RegexOptions.IgnorePatternWhitespace);\n        public static string fileNamesWithoutDot = \"|error_log|\";\n\n\n        public ftp(configMan _configMan)\n        {\n            ftp_username = _configMan.FTP_UserName;\n            ftp_password = _configMan.FTP_PassWord;\n            ftp_server = _configMan.FTP_Server;\n            ftp_folder = _configMan.FTP_Folder;\n\n            ConfigedRemotePaths = new List<string>();\n        }\n\n        #region Privates\n        private NetworkCredential getNewNetworkCredential()\n        {\n            return new NetworkCredential(ftp_username, ftp_password);\n        }\n\n        private FtpWebRequest getRequestObject(string fullpath)\n        {\n            FtpWebRequest request = (FtpWebRequest)WebRequest.Create(fullpath);\n            request.Credentials = getNewNetworkCredential();\n            request.KeepAlive = true;\n            request.UsePassive = true;\n            request.Timeout = 300000;\n            request.ReadWriteTimeout = 1200000;\n            request.ConnectionGroupName = getSecureGroupName();\n            return request;\n        }\n\n        private string getSecureGroupName()\n        {\n            SHA1Managed Sha1 = new SHA1Managed();\n            Byte[] updHash = Sha1.ComputeHash(Encoding.UTF8.GetBytes(ftp_username + ftp_password + ftp_server));\n            return Encoding.Default.GetString(updHash);\n        }\n        #endregion\n\n        public void FTPdownload(string fileToDownload, string savePath, string saveAs)\n        {\n            log.Debug(\"FTPdownload\");\n\n            try\n            {\n                if (!Directory.Exists(savePath))\n                {\n                    Directory.CreateDirectory(savePath);\n                }\n            }\n            catch (Exception ex)\n            {\n                log.InfoFormat(\"Error : {0} - {1}\", savePath, ex.Message);\n            }\n\n\n            try\n            {\n                FtpWebRequest requestFileDownload = getRequestObject(fileToDownload);\n                requestFileDownload.Method = WebRequestMethods.Ftp.DownloadFile;\n                FtpWebResponse responseFileDownload = (FtpWebResponse)requestFileDownload.GetResponse();\n\n\n                Stream responseStream = responseFileDownload.GetResponseStream();\n                FileStream writeStream = new FileStream(saveAs, FileMode.Create);\n\n                int Length = 2048;\n                Byte[] buffer = new Byte[Length];\n                int bytesRead = responseStream.Read(buffer, 0, Length);\n\n                while (bytesRead > 0)\n                {\n                    writeStream.Write(buffer, 0, bytesRead);\n                    bytesRead = responseStream.Read(buffer, 0, Length);\n                }\n\n                responseStream.Close();\n                writeStream.Close();\n\n                requestFileDownload = null;\n                responseFileDownload = null;\n            }\n            catch (Exception ex)\n            {\n                log.InfoFormat(\"Error Server connection : {0} - {1}\", savePath, ex.Message);\n            }\n        }\n\n        \/\/http:\/\/msdn.microsoft.com\/en-us\/library\/ms229715%28v=vs.110%29.aspx\n\n        public bool FTPMakeFolder(string folderToMake)\n        {\n            log.Debug(\"FTPMakeFolder\");\n\n            folderToMake = folderToMake.Substring(0, folderToMake.Length - 1);\n\n            string[] pathToMake = folderToMake.Substring(ftp_server.Length + ftp_folder.Length, folderToMake.Length - ftp_server.Length - ftp_folder.Length).Split('\/');\n\n            for (int i = 1; i <= pathToMake.Length - 1; i++)\n            {\n                pathToMake[i] = string.Format(\"{0}\/{1}\", pathToMake[i - 1], pathToMake[i]);\n            }\n\n            foreach (string path in pathToMake)\n            {\n                string tryPath = String.Format(\"{0}{1}{2}\", ftp_server, ftp_folder, path);\n\n                if (!ConfigedRemotePaths.Any(s => s == tryPath))\n                {\n                    FtpWebRequest request = getRequestObject(tryPath);\n                    request.Method = WebRequestMethods.Ftp.MakeDirectory;\n                    try\n                    {\n                        WebResponse response = request.GetResponse();\n                        ConfigedRemotePaths.Add(tryPath);\n                    }\n                    catch (Exception ex)\n                    {\n                        log.ErrorFormat(ex.Message);\n                    }\n                }\n            }\n\n            return true;\n        }\n\n        public bool FTPUpload(string fromFile, string fileToUpload)\n        {\n            log.Debug(\"FTPUpload\");\n\n            if (!File.Exists(fromFile))\n            {\n                log.InfoFormat(\"FromFile not exists : {0}\", fromFile);\n                return false;\n            }\n\n            FtpWebRequest requestFTPUploader = getRequestObject(fileToUpload);\n            log.InfoFormat(\"Upload file : {0}\", fileToUpload);\n            requestFTPUploader.Method = WebRequestMethods.Ftp.UploadFile;\n\n            FileInfo fileInfo = new FileInfo(fromFile);\n            FileStream fileStream = fileInfo.OpenRead();\n\n            int bufferLength = 2048;\n            byte[] buffer = new byte[bufferLength];\n\n            try\n            {\n                Stream uploadStream = requestFTPUploader.GetRequestStream();\n                int contentLength = fileStream.Read(buffer, 0, bufferLength);\n\n                while (contentLength != 0)\n                {\n                    uploadStream.Write(buffer, 0, contentLength);\n                    contentLength = fileStream.Read(buffer, 0, bufferLength);\n                }\n                uploadStream.Close();\n                fileStream.Close();\n\n            }\n            catch (Exception e)\n            {\n                log.ErrorFormat(e.Message);\n                return false;\n            }\n            finally\n            {\n                requestFTPUploader = null;\n            }\n\n            return true;\n        }\n\n        private DirEntry getFtpEntryFromDataLine(string dataline, string sFolder)\n        {\n            log.Debug(\"getFtpEntryFromDataLine\");\n\n            Match match = FtpListDirectoryDetailsRegex.Match(dataline);\n            DirEntry ftpET = new DirEntry() { EntryName = match.Groups[\"fileName\"].Value, EntryPath = sFolder, EntryType = FtpEntryType.Unknown };\n            log.Info(dataline);\n            if (dataline.EndsWith(\" .\") || dataline.EndsWith(\" ..\"))\n            {\n                ftpET.EntryType = FtpEntryType.Unknown;\n            }\n            else if (dataline.StartsWith(\"d\"))\n            {\n                ftpET.EntryType = FtpEntryType.Folder;\n                ftpET.EntryName = ftpET.EntryName + \"\/\";\n            }\n            else\n            {\n                ftpET.EntryType = FtpEntryType.File;\n            }\n            return ftpET;\n        }\n\n        private List<DirEntry> getDirectoryEntries(string sServer, string sFolder, bool details = true)\n        {\n            log.Debug(\"getDirectoryEntries\");\n\n            List<DirEntry> DirEntries = new List<DirEntry>();\n            FtpWebRequest request = getRequestObject(sServer + sFolder);\n            request.Method = WebRequestMethods.Ftp.ListDirectory;\n            FtpWebResponse responseDetails = (FtpWebResponse)request.GetResponse();\n            Stream responseDetailsStream = responseDetails.GetResponseStream();\n            StreamReader readerDetails = new StreamReader(responseDetailsStream);\n\n            string line = readerDetails.ReadLine();\n            while (line != null)\n            {\n                DirEntries.Add(new DirEntry() { EntryName = line, EntryPath = sFolder, EntryType = FtpEntryType.Unknown });\n                line = readerDetails.ReadLine();\n            }\n            readerDetails.Close();\n            responseDetails.Close();\n\n            FtpWebRequest request1 = getRequestObject(sServer + sFolder);\n            request1.Method = WebRequestMethods.Ftp.ListDirectoryDetails;\n            FtpWebResponse responseDetails1 = (FtpWebResponse)request1.GetResponse();\n            Stream responseDetailsStream1 = responseDetails1.GetResponseStream();\n            StreamReader readerDetails1 = new StreamReader(responseDetailsStream1);\n\n            string line1;\n            foreach (DirEntry dirEntry in DirEntries)\n            {\n                line1 = readerDetails1.ReadLine();\n                if (line1.StartsWith(\"-\"))\n                {\n                    dirEntry.EntryType = FtpEntryType.File;\n                }\n                else\n                {\n                    if (dirEntry.EntryName != \".\" && dirEntry.EntryName != \"..\")\n                    {\n                        dirEntry.EntryType = FtpEntryType.Folder;\n                        dirEntry.EntryName = dirEntry.EntryName + \"\/\";\n                    }\n                }\n            }\n            readerDetails1.Close();\n            responseDetails1.Close();\n\n            return DirEntries;\n        }\n\n        private List<DirEntry> getDirectoryEntries2(string sServer, string sFolder, bool details = true)\n        {\n            log.Debug(\"getDirectoryEntries2\");\n\n            List<DirEntry> DirEntries = new List<DirEntry>();\n            FtpWebRequest request = getRequestObject(sServer + sFolder);\n            request.Method = WebRequestMethods.Ftp.ListDirectoryDetails;\n\n            FtpWebResponse responseDetails = (FtpWebResponse)request.GetResponse();\n            Stream responseDetailsStream = responseDetails.GetResponseStream();\n            StreamReader readerDetails = new StreamReader(responseDetailsStream);\n\n            string line = readerDetails.ReadLine();\n            while (line != null)\n            {\n                if (line.Length > 2)\n                {\n                    DirEntries.Add(getFtpEntryFromDataLine(line, sFolder));\n                }\n                line = readerDetails.ReadLine();\n            }\n\n            readerDetails.Close();\n            responseDetails.Close();\n\n            return DirEntries;\n        }\n\n        \/\/ http:\/\/msdn.microsoft.com\/en-us\/library\/ms229716%28v=vs.110%29.aspx\n        public List<DirEntry> FTPGetFolderContents(string sServer, string sFolder, bool regressive = true)\n        {\n            log.Debug(\"FTPGetFolderContents\"); \n            log.InfoFormat(\"Reading Folder : {0}\", sFolder);\n\n            List<DirEntry> DirEntries = new List<DirEntry>();\n\n            DirEntries = getDirectoryEntries2(sServer, sFolder);\n\n            if (regressive)\n            {\n                List<DirEntry> ftpFolders = DirEntries.Where(x => (x.EntryType == FtpEntryType.Folder)).ToList();\n\n                foreach (DirEntry f in ftpFolders)\n                {\n                    DirEntries.AddRange(FTPGetFolderContents(sServer, sFolder + f.EntryName));\n                }\n            }\n            return DirEntries;\n        }\n    }\n}\n","old_contents":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nusing System.Net;\nusing System.Security.Cryptography;\nusing System.IO;\n\nnamespace PartialDeployer\n{\n    using System.Text.RegularExpressions;\n    using log4net;\n\n    public class ftp\n    {\n        private static readonly ILog log = LogManager.GetLogger(\"Ftp\");\n\n        private string ftp_server;\n        private string ftp_username;\n        private string ftp_password;\n        private string ftp_folder;\n\n        private List<string> ConfigedRemotePaths;\n\n        \/\/http:\/\/stackoverflow.com\/questions\/1013486\/parsing-ftpwebrequests-listdirectorydetails-line\n        \/\/Regex regex = new Regex(@\"^([d-])([rwxt-]{3}){3}\\s+\\d{1,}\\s+.*?(\\d{1,})\\s+(\\w+\\s+\\d{1,2}\\s+(?:\\d{4})?)(\\d{1,2}:\\d{2})?\\s+(.+?)\\s?$\", RegexOptions.Compiled | RegexOptions.Multiline | RegexOptions.IgnoreCase | RegexOptions.IgnorePatternWhitespace);\n        public static Regex FtpListDirectoryDetailsRegex = new Regex(@\".*(?<month>(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec))\\s*(?<day>[0-9]*)\\s*(?<yearTime>([0-9]|:)*)\\s*(?<fileName>.*)\", RegexOptions.Compiled | RegexOptions.Multiline | RegexOptions.IgnoreCase | RegexOptions.IgnorePatternWhitespace);\n        public static string fileNamesWithoutDot = \"|error_log|\";\n\n\n        public ftp(configMan _configMan)\n        {\n            ftp_username = _configMan.FTP_UserName;\n            ftp_password = _configMan.FTP_PassWord;\n            ftp_server = _configMan.FTP_Server;\n            ftp_folder = _configMan.FTP_Folder;\n        }\n\n        #region Privates\n        private NetworkCredential getNewNetworkCredential()\n        {\n            return new NetworkCredential(ftp_username, ftp_password);\n        }\n\n        private FtpWebRequest getRequestObject(string fullpath)\n        {\n            FtpWebRequest request = (FtpWebRequest)WebRequest.Create(fullpath);\n            request.Credentials = getNewNetworkCredential();\n            request.KeepAlive = true;\n            request.UsePassive = true;\n            request.Timeout = 300000;\n            request.ReadWriteTimeout = 1200000;\n            request.ConnectionGroupName = getSecureGroupName();\n            return request;\n        }\n\n        private string getSecureGroupName()\n        {\n            SHA1Managed Sha1 = new SHA1Managed();\n            Byte[] updHash = Sha1.ComputeHash(Encoding.UTF8.GetBytes(ftp_username + ftp_password + ftp_server));\n            return Encoding.Default.GetString(updHash);\n        }\n        #endregion\n\n        public void FTPdownload(string fileToDownload, string savePath, string saveAs)\n        {\n            log.Debug(\"FTPdownload\");\n\n            try\n            {\n                if (!Directory.Exists(savePath))\n                {\n                    Directory.CreateDirectory(savePath);\n                }\n            }\n            catch (Exception ex)\n            {\n                log.InfoFormat(\"Error : {0} - {1}\", savePath, ex.Message);\n            }\n\n\n            try\n            {\n\n                FtpWebRequest requestFileDownload = getRequestObject(fileToDownload);\n                requestFileDownload.Method = WebRequestMethods.Ftp.DownloadFile;\n                FtpWebResponse responseFileDownload = (FtpWebResponse)requestFileDownload.GetResponse();\n\n\n                Stream responseStream = responseFileDownload.GetResponseStream();\n                FileStream writeStream = new FileStream(saveAs, FileMode.Create);\n\n                int Length = 2048;\n                Byte[] buffer = new Byte[Length];\n                int bytesRead = responseStream.Read(buffer, 0, Length);\n\n                while (bytesRead > 0)\n                {\n                    writeStream.Write(buffer, 0, bytesRead);\n                    bytesRead = responseStream.Read(buffer, 0, Length);\n                }\n\n                responseStream.Close();\n                writeStream.Close();\n\n                requestFileDownload = null;\n                responseFileDownload = null;\n\n\n            }\n            catch (Exception ex)\n            {\n                log.InfoFormat(\"Error Server connection : {0} - {1}\", savePath, ex.Message);\n            }\n        }\n\n        \/\/http:\/\/msdn.microsoft.com\/en-us\/library\/ms229715%28v=vs.110%29.aspx\n\n        public bool FTPMakeFolder(string folderToMake)\n        {\n            log.Debug(\"FTPMakeFolder\");\n\n            folderToMake = folderToMake.Substring(0, folderToMake.Length - 1);\n\n            string[] pathToMake = folderToMake.Substring(ftp_server.Length + ftp_folder.Length, folderToMake.Length - ftp_server.Length - ftp_folder.Length).Split('\/');\n\n            for (int i = 1; i <= pathToMake.Length - 1; i++)\n            {\n                pathToMake[i] = string.Format(\"{0}\/{1}\", pathToMake[i - 1], pathToMake[i]);\n            }\n\n            foreach (string path in pathToMake)\n            {\n                string tryPath = String.Format(\"{0}{1}{2}\", ftp_server, ftp_folder, path);\n\n                if (!ConfigedRemotePaths.Any(s => s == tryPath))\n                {\n                    FtpWebRequest request = getRequestObject(tryPath);\n                    request.Method = WebRequestMethods.Ftp.MakeDirectory;\n                    try\n                    {\n                        WebResponse response = request.GetResponse();\n                        ConfigedRemotePaths.Add(tryPath);\n                    }\n                    catch (Exception ex)\n                    {\n                        log.ErrorFormat(ex.Message);\n                    }\n                }\n            }\n\n            return true;\n        }\n\n        public bool FTPUpload(string fromFile, string fileToUpload)\n        {\n            log.Debug(\"FTPUpload\");\n\n            if (!File.Exists(fromFile))\n            {\n                log.InfoFormat(\"FromFile not exists : {0}\", fromFile);\n                return false;\n            }\n\n            FtpWebRequest requestFTPUploader = getRequestObject(fileToUpload);\n            log.InfoFormat(\"Upload file : {0}\", fileToUpload);\n            requestFTPUploader.Method = WebRequestMethods.Ftp.UploadFile;\n\n            FileInfo fileInfo = new FileInfo(fromFile);\n            FileStream fileStream = fileInfo.OpenRead();\n\n            int bufferLength = 2048;\n            byte[] buffer = new byte[bufferLength];\n\n            try\n            {\n                Stream uploadStream = requestFTPUploader.GetRequestStream();\n                int contentLength = fileStream.Read(buffer, 0, bufferLength);\n\n                while (contentLength != 0)\n                {\n                    uploadStream.Write(buffer, 0, contentLength);\n                    contentLength = fileStream.Read(buffer, 0, bufferLength);\n                }\n                uploadStream.Close();\n                fileStream.Close();\n\n            }\n            catch (Exception e)\n            {\n                log.ErrorFormat(e.Message);\n                return false;\n            }\n            finally\n            {\n                requestFTPUploader = null;\n            }\n\n            return true;\n        }\n\n\n        private DirEntry getFtpEntryFromDataLine(string dataline, string sFolder)\n        {\n            log.Debug(\"getFtpEntryFromDataLine\");\n\n            Match match = FtpListDirectoryDetailsRegex.Match(dataline);\n            DirEntry ftpET = new DirEntry() { EntryName = match.Groups[\"fileName\"].Value, EntryPath = sFolder, EntryType = FtpEntryType.Unknown };\n            log.Info(dataline);\n            if (dataline.EndsWith(\" .\") || dataline.EndsWith(\" ..\"))\n            {\n                ftpET.EntryType = FtpEntryType.Unknown;\n            }\n            else if (dataline.StartsWith(\"d\"))\n            {\n                ftpET.EntryType = FtpEntryType.Folder;\n                ftpET.EntryName = ftpET.EntryName + \"\/\";\n            }\n            else\n            {\n                ftpET.EntryType = FtpEntryType.File;\n            }\n            return ftpET;\n        }\n\n        private List<DirEntry> getDirectoryEntries(string sServer, string sFolder, bool details = true)\n        {\n            log.Debug(\"getDirectoryEntries\");\n\n            List<DirEntry> DirEntries = new List<DirEntry>();\n            FtpWebRequest request = getRequestObject(sServer + sFolder);\n            request.Method = WebRequestMethods.Ftp.ListDirectory;\n            FtpWebResponse responseDetails = (FtpWebResponse)request.GetResponse();\n            Stream responseDetailsStream = responseDetails.GetResponseStream();\n            StreamReader readerDetails = new StreamReader(responseDetailsStream);\n\n            string line = readerDetails.ReadLine();\n            while (line != null)\n            {\n                DirEntries.Add(new DirEntry() { EntryName = line, EntryPath = sFolder, EntryType = FtpEntryType.Unknown });\n                line = readerDetails.ReadLine();\n            }\n            readerDetails.Close();\n            responseDetails.Close();\n\n            FtpWebRequest request1 = getRequestObject(sServer + sFolder);\n            request1.Method = WebRequestMethods.Ftp.ListDirectoryDetails;\n            FtpWebResponse responseDetails1 = (FtpWebResponse)request1.GetResponse();\n            Stream responseDetailsStream1 = responseDetails1.GetResponseStream();\n            StreamReader readerDetails1 = new StreamReader(responseDetailsStream1);\n\n            string line1;\n            foreach (DirEntry f in DirEntries)\n            {\n                line1 = readerDetails1.ReadLine();\n                if (line1.StartsWith(\"-\"))\n                {\n                    f.EntryType = FtpEntryType.File;\n                }\n                else\n                {\n                    if (f.EntryName != \".\" && f.EntryName != \"..\")\n                    {\n                        f.EntryType = FtpEntryType.Folder;\n                        f.EntryName = f.EntryName + \"\/\";\n                    }\n                }\n            }\n            readerDetails1.Close();\n            responseDetails1.Close();\n\n            return DirEntries;\n        }\n\n        private List<DirEntry> getDirectoryEntries2(string sServer, string sFolder, bool details = true)\n        {\n            log.Debug(\"getDirectoryEntries2\");\n\n            List<DirEntry> DirEntries = new List<DirEntry>();\n            FtpWebRequest request = getRequestObject(sServer + sFolder);\n            request.Method = WebRequestMethods.Ftp.ListDirectoryDetails;\n\n            FtpWebResponse responseDetails = (FtpWebResponse)request.GetResponse();\n            Stream responseDetailsStream = responseDetails.GetResponseStream();\n            StreamReader readerDetails = new StreamReader(responseDetailsStream);\n\n            string line = readerDetails.ReadLine();\n            while (line != null)\n            {\n                if (line.Length > 2)\n                {\n                    DirEntries.Add(getFtpEntryFromDataLine(line, sFolder));\n                }\n                line = readerDetails.ReadLine();\n            }\n\n            readerDetails.Close();\n            responseDetails.Close();\n\n            return DirEntries;\n        }\n\n        \/\/ http:\/\/msdn.microsoft.com\/en-us\/library\/ms229716%28v=vs.110%29.aspx\n        public List<DirEntry> FTPGetFolderContents(string sServer, string sFolder, bool regressive = true)\n        {\n            log.Debug(\"FTPGetFolderContents\"); \n            log.InfoFormat(\"Reading Folder : {0}\", sFolder);\n\n            List<DirEntry> DirEntries = new List<DirEntry>();\n\n            DirEntries = getDirectoryEntries2(sServer, sFolder);\n\n            if (regressive)\n            {\n                List<DirEntry> ftpFolders = DirEntries.Where(x => (x.EntryType == FtpEntryType.Folder)).ToList();\n\n                foreach (DirEntry f in ftpFolders)\n                {\n                    DirEntries.AddRange(FTPGetFolderContents(sServer, sFolder + f.EntryName));\n                }\n            }\n            return DirEntries;\n        }\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"9845a104bdbccae0f5946e1beb3d2776dfe38dbf","subject":"fixed CORS policy","message":"fixed CORS policy\n","repos":"jbrooks036\/PickinTunes,jbrooks036\/PickinTunes","old_file":"src\/PickinTunes\/Startup.cs","new_file":"src\/PickinTunes\/Startup.cs","new_contents":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Logging;\nusing PickinTunes.Models;\nusing Microsoft.EntityFrameworkCore;\n\nnamespace PickinTunes\n{\n    public class Startup\n    {\n        public Startup(IHostingEnvironment env)\n        {\n            var builder = new ConfigurationBuilder()\n                .SetBasePath(env.ContentRootPath)\n                .AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true)\n                .AddJsonFile($\"appsettings.{env.EnvironmentName}.json\", optional: true)\n                .AddEnvironmentVariables();\n            Configuration = builder.Build();\n        }\n\n        public IConfigurationRoot Configuration { get; }\n\n        \/\/ This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            var connection = @\"Server=(localdb)\\mssqllocaldb;Database=PickinTunes;Trusted_Connection=True;\";\n            services.AddDbContext<PickinTunesContext>(options => options.UseSqlServer(connection));\n\n            \/\/ Add framework services.\n            services.AddMvc();\n            \/\/ MarkZaWill only uses services.AddCors() [no params]\n            \/\/ Allow any header and any method on a request from my local development machine\n            services.AddCors(options =>\n            {\n                options.AddPolicy(\"AllowDevelopmentEnvironment\",\n                    builder => builder\n                        .AllowAnyOrigin()\n                        .AllowAnyMethod()\n                        .AllowAnyHeader());\n            });\n\n        }\n\n        \/\/ This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)\n        {\n            loggerFactory.AddConsole(Configuration.GetSection(\"Logging\"));\n            loggerFactory.AddDebug();\n\n            \/\/ app.UseMvc();\n            app.UseMvc(routes =>\n                {\n                    routes.MapRoute(\n                        name: \"default\",\n                        template: \"{controller=Tune}\/{action=Get}\/{id?}\");\n                }\n            );\n            app.UseCors(\"AllowDevelopmentEnvironment\");\n        }\n    }\n}\n","old_contents":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Logging;\nusing PickinTunes.Models;\nusing Microsoft.EntityFrameworkCore;\n\nnamespace PickinTunes\n{\n    public class Startup\n    {\n        public Startup(IHostingEnvironment env)\n        {\n            var builder = new ConfigurationBuilder()\n                .SetBasePath(env.ContentRootPath)\n                .AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true)\n                .AddJsonFile($\"appsettings.{env.EnvironmentName}.json\", optional: true)\n                .AddEnvironmentVariables();\n            Configuration = builder.Build();\n        }\n\n        public IConfigurationRoot Configuration { get; }\n\n        \/\/ This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            var connection = @\"Server=(localdb)\\mssqllocaldb;Database=PickinTunes;Trusted_Connection=True;\";\n            services.AddDbContext<PickinTunesContext>(options => options.UseSqlServer(connection));\n\n            \/\/ Add framework services.\n            services.AddMvc();\n            \/\/ MarkZaWill only uses services.AddCors() [no params]\n            \/\/ Allow any header and any method on a request from my local development machine\n            services.AddCors(options =>\n            {\n                options.AddPolicy(\"AllowDevelopmentEnvironment\",\n                    builder => builder\n                        .AllowAnyOrigin()\n                        .AllowAnyMethod()\n                        .AllowAnyHeader());\n            });\n\n        }\n\n        \/\/ This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)\n        {\n            loggerFactory.AddConsole(Configuration.GetSection(\"Logging\"));\n            loggerFactory.AddDebug();\n\n            \/\/ app.UseMvc();\n            app.UseMvc(routes =>\n                {\n                    routes.MapRoute(\n                        name: \"default\",\n                        template: \"{controller=Tune}\/{action=Get}\/{id?}\");\n                }\n            );\n            app.UseCors(\"AllowSpecificOrigin\");\n        }\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"bb301f96d4ebbb670f90550466703fa1831efbe9","subject":"Minor - correct spelling in comment","message":"Minor - correct spelling in comment\n","repos":"Teleopti\/Toggle.Net","old_file":"code\/Toggle.Net\/Specifications\/IToggleSpecification.cs","new_file":"code\/Toggle.Net\/Specifications\/IToggleSpecification.cs","new_contents":"\ufeffusing System.Collections.Generic;\nusing Toggle.Net.Internal;\n\nnamespace Toggle.Net.Specifications\n{\n\t\/\/\/ <summary>\n\t\/\/\/ Decides if a <see cref=\"Feature\"\/> is enabled ot not.\n\t\/\/\/ Implementation is shared between different features,\n\t\/\/\/ so make sure you don't keep state that cannot be shared on this instance.\n\t\/\/\/ <\/summary>\n\tpublic interface IToggleSpecification\n\t{\n\t\t\/\/\/ <summary>\n\t\t\/\/\/ Is the <see cref=\"Feature\"\/> enabled or not?\n\t\t\/\/\/ <\/summary>\n\t\t\/\/\/ <param name=\"currentUser\"><\/param>\n\t\t\/\/\/ <param name=\"parameters\"><\/param>\n\t\t\/\/\/ <returns><\/returns>\n\t\tbool IsEnabled(string currentUser, IDictionary<string, string> parameters);\n\n\t\t\/\/\/ <summary>\n\t\t\/\/\/ Called at startup with parameters for every <see cref=\"Feature\"\/> using this specification.\n\t\t\/\/\/ If not valid, throw a <see cref=\"InvalidSpecificationParameterException\"\/>\n\t\t\/\/\/ with suitable message.\n\t\t\/\/\/ <\/summary>\n\t\t\/\/\/ <param name=\"toggleName\"><\/param>\n\t\t\/\/\/ <param name=\"parameters\"><\/param>\n\t\tvoid Validate(string toggleName, IDictionary<string, string> parameters);\n\t}\n}","old_contents":"\ufeffusing System.Collections.Generic;\nusing Toggle.Net.Internal;\n\nnamespace Toggle.Net.Specifications\n{\n\t\/\/\/ <summary>\n\t\/\/\/ Decides if a <see cref=\"Feature\"\/> is enabled ot not.\n\t\/\/\/ Implementation is shared between diffent features,\n\t\/\/\/ so make sure you don't keep state that cannot be shared on this instance.\n\t\/\/\/ <\/summary>\n\tpublic interface IToggleSpecification\n\t{\n\t\t\/\/\/ <summary>\n\t\t\/\/\/ Is the <see cref=\"Feature\"\/> enabled or not?\n\t\t\/\/\/ <\/summary>\n\t\t\/\/\/ <param name=\"currentUser\"><\/param>\n\t\t\/\/\/ <param name=\"parameters\"><\/param>\n\t\t\/\/\/ <returns><\/returns>\n\t\tbool IsEnabled(string currentUser, IDictionary<string, string> parameters);\n\n\t\t\/\/\/ <summary>\n\t\t\/\/\/ Called at startup with parameters for every <see cref=\"Feature\"\/> using this specification.\n\t\t\/\/\/ If not valid, throw a <see cref=\"InvalidSpecificationParameterException\"\/>\n\t\t\/\/\/ with suitable message.\n\t\t\/\/\/ <\/summary>\n\t\t\/\/\/ <param name=\"toggleName\"><\/param>\n\t\t\/\/\/ <param name=\"parameters\"><\/param>\n\t\tvoid Validate(string toggleName, IDictionary<string, string> parameters);\n\t}\n}","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"8bc12744d6ad007a3466bfb0a36dbb6de7f7758d","subject":"Add missing paren to file open\/close","message":"Add missing paren to file open\/close\n\n","repos":"sillsdev\/hearthis,sillsdev\/hearthis,sillsdev\/hearthis","old_file":"src\/HearThis\/UI\/Shell.cs","new_file":"src\/HearThis\/UI\/Shell.cs","new_contents":"\/\/ --------------------------------------------------------------------------------------------\n#region \/\/ Copyright (c) 2015, SIL International. All Rights Reserved.\n\/\/ <copyright from='2011' to='2015' company='SIL International'>\n\/\/\t\tCopyright (c) 2015, SIL International. All Rights Reserved.\n\/\/\n\/\/\t\tDistributable under the terms of the MIT License (http:\/\/sil.mit-license.org\/)\n\/\/ <\/copyright>\n#endregion\n\/\/ --------------------------------------------------------------------------------------------\nusing System;\nusing System.ComponentModel;\nusing System.Diagnostics;\nusing System.Drawing;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing System.Windows.Forms;\nusing HearThis.Communication;\nusing HearThis.Properties;\nusing HearThis.Publishing;\nusing HearThis.Script;\nusing L10NSharp;\nusing NetSparkle;\nusing SIL.IO;\nusing SIL.Windows.Forms.Miscellaneous;\nusing SIL.Windows.Forms.ReleaseNotes;\nusing Paratext;\nusing SIL.DblBundle.Text;\nusing SIL.Extensions;\nusing SIL.Reporting;\n\nnamespace HearThis.UI\n{\n\tpublic partial class Shell : Form\n\t{\n\t\tpublic static Sparkle UpdateChecker;\n\t\tpublic event EventHandler OnProjectChanged;\n\t\tprivate string _projectNameToShow = string.Empty;\n\t\tprivate string _originalActorText;\n\t\tprivate Font _originalActorFont;\n\t\tprivate bool _mouseInMultiVoicePanel;\n\n\n#if MULTIPLEMODES\n\t\tprivate List<string> allowableModes;\n\n\t\tprivate const string kAdministrative = \"Administrator\";\n#endif\n\t\tprivate const string kNormalRecording = \"NormalRecording\";\n\n\t\tpublic Shell()\n\t\t{\n\t\t\tInitializeComponent();\n\t\t\tText = Program.kProduct;\n\n\t\t\t_settingsProtectionHelper.ManageComponent(_settingsItem);\n\t\t\t_settingsProtectionHelper.ManageComponent(toolStripButtonChooseProject);\n\t\t\tSetupUILanguageMenu();\n\n\t\t\t_toolStrip.Renderer = new RecordingToolControl.NoBorderToolStripRenderer();\n\t\t\t_moreMenu.ForeColor = AppPallette.NavigationTextColor;\n\n\t\t\tInitializeModesCombo();\n\n\t\t\t\/\/ Todo: possibly make this conditional on an a device being connected.\n\t\t\t\/\/ If possible notice and show it when a device is later connected.\n\t\t\t\/\/ Or: possibly if no device is active it displays instructions.\n\t\t\t_syncWithAndroidItem.Visible = true;\n\t\t\t_originalActorFont = _actorLabel.Font;\n\t\t\t_originalActorText = _actorLabel.Text;\n\t\t\t_toolStrip.Renderer = new ToolStripColorArrowRenderer();\n\t\t\t_multiVoicePanel.MouseLeave += MultiVoicePanelOnMouseTransition;\n\t\t\t_multiVoicePanel.MouseEnter += MultiVoicePanelOnMouseTransition;\n\t\t\tforeach (Control c in _multiVoicePanel.Controls)\n\t\t\t{\n\t\t\t\tc.MouseEnter += MultiVoicePanelOnMouseTransition;\n\t\t\t\tc.MouseLeave += MultiVoicePanelOnMouseTransition;\n\t\t\t}\n\t\t\t_multiVoicePanel.Paint += (sender, e) =>\n\t\t\t{\n\t\t\t\tif (_mouseInMultiVoicePanel && !Controls.OfType<ActorCharacterChooser>().Any())\n\t\t\t\t{\n\t\t\t\t\tvar borderRect = _multiVoicePanel.ClientRectangle;\n\t\t\t\t\t\/\/ The numbers here were determined to line things up with controls below\n\t\t\t\t\tborderRect = new Rectangle(borderRect.Left + 18, borderRect.Top, borderRect.Width - 43, borderRect.Height);\n\t\t\t\t\tControlPaint.DrawBorder(e.Graphics, borderRect, AppPallette.FaintScriptFocusTextColor,\n\t\t\t\t\t\tButtonBorderStyle.Solid);\n\t\t\t\t}\n\t\t\t};\n\t\t\t_multiVoicePanel.Click += _actorCharacterButton_Click;\n\t\t}\n\n\t\t\/\/\/ <summary>\n\t\t\/\/\/ Unfortunately the mouse 'leaves' the multivoice panel when it enters a child control as well as when it really\n\t\t\/\/\/ leaves the whole panel. So this routine is hooked to happen whenever it leaves or enters any of them.\n\t\t\/\/\/ It figures out whether the mouse is really inside the panel and adjusts the border if this has changed.\n\t\t\/\/\/ <\/summary>\n\t\t\/\/\/ <param name=\"sender1\"><\/param>\n\t\t\/\/\/ <param name=\"eventArgs\"><\/param>\n\t\tprivate void MultiVoicePanelOnMouseTransition(object sender1, EventArgs eventArgs)\n\t\t{\n\t\t\tbool isMouseInMVP = _multiVoicePanel.ClientRectangle.Contains(_multiVoicePanel.PointToClient(Control.MousePosition));\n\t\t\tif (isMouseInMVP != _mouseInMultiVoicePanel)\n\t\t\t{\n\t\t\t\t_mouseInMultiVoicePanel = isMouseInMVP;\n\t\t\t\t_multiVoicePanel.Invalidate();\n\t\t\t}\n\t\t}\n\n\t\tpublic Project Project { get; private set; }\n\n\t\tprivate void OnChooseProject(object sender, EventArgs e)\n\t\t{\n\t\t\tChooseProject();\n\t\t}\n\n\t\tprivate bool ChooseProject()\n\t\t{\n\t\t\tusing (var dlg = new ChooseProject())\n\t\t\t{\n\t\t\t\tif (DialogResult.OK == dlg.ShowDialog())\n\t\t\t\t{\n\t\t\t\t\t\/\/ ENHANCE: Someday it might be nice to save\/restore these in a project file so they could be remembered on\n\t\t\t\t\t\/\/ a per-project basis, but the VAST majority of our users are going to be working on a single project, so\n\t\t\t\t\t\/\/ this might be good enough.\n\t\t\t\t\tSettings.Default.Book = -1;\n\t\t\t\t\tSettings.Default.Chapter = -1;\n\t\t\t\t\tSettings.Default.Block = -1;\n\t\t\t\t\tLoadProject(dlg.SelectedProject);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tprotected override void OnLoad(EventArgs e)\n\t\t{\n\t\t\tbase.OnLoad(e);\n\t\t\tbool loaded = false;\n\t\t\tif (!string.IsNullOrEmpty(Settings.Default.Project))\n\t\t\t{\n\t\t\t\tloaded = LoadProject(Settings.Default.Project);\n\t\t\t}\n\n\t\t\tif (!loaded) \/\/if never did have a project, or that project couldn't be loaded\n\t\t\t{\n\t\t\t\tif (!ChooseProject())\n\t\t\t\t{\n\t\t\t\t\tClose();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar savedBounds = Settings.Default.RestoreBounds;\n\t\t\tif ((savedBounds.Width > MinimumSize.Width) && (savedBounds.Height > MinimumSize.Height) && (IsOnScreen(savedBounds)))\n\t\t\t{\n\t\t\t\tStartPosition = FormStartPosition.Manual;\n\t\t\t\tWindowState = FormWindowState.Normal;\n\t\t\t\tBounds = savedBounds;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tStartPosition = FormStartPosition.CenterScreen;\n\t\t\t\tWindowState = FormWindowState.Maximized;\n\t\t\t}\n\n\t\t\tUpdateChecker = new Sparkle(@\"http:\/\/build.palaso.org\/guestAuth\/repository\/download\/HearThis_HearThisWinDevPublishPt8\/.lastSuccessful\/appcast.xml\",\n\t\t\t\tIcon);\n\t\t\t\/\/ We don't want to do this until the main window is loaded because a) it's very easy for the user to overlook, and b)\n\t\t\t\/\/ more importantly, when the toast notifier closes, it can sometimes clobber an error message being displayed for the user.\n\t\t\tUpdateChecker.CheckOnFirstApplicationIdle();\n\t\t}\n\n\t\t\/\/\/ <summary>\n\t\t\/\/\/ Is a significant (100 x 100) portion of the form on-screen?\n\t\t\/\/\/ <\/summary>\n\t\t\/\/\/ <returns><\/returns>\n\t\tprivate static bool IsOnScreen(Rectangle rect)\n\t\t{\n\t\t\tvar screens = Screen.AllScreens;\n\t\t\tvar formTopLeft = new Rectangle(rect.Left, rect.Top, 100, 100);\n\n\t\t\treturn screens.Any(screen => screen.WorkingArea.Contains(formTopLeft));\n\t\t}\n\n\t\tprivate void SetupUILanguageMenu()\n\t\t{\n\t\t\t_uiLanguageMenu.DropDownItems.Clear();\n\t\t\tforeach (var lang in LocalizationManager.GetUILanguages(true))\n\t\t\t{\n\t\t\t\tvar item = _uiLanguageMenu.DropDownItems.Add(lang.NativeName);\n\t\t\t\titem.Tag = lang;\n\t\t\t\titem.Click += ((a, b) =>\n\t\t\t\t{\n\t\t\t\t\tLocalizationManager.SetUILanguage(((CultureInfo) item.Tag).IetfLanguageTag, true);\n\t\t\t\t\tSettings.Default.UserInterfaceLanguage = ((CultureInfo) item.Tag).IetfLanguageTag;\n\t\t\t\t\titem.Select();\n\t\t\t\t\t_uiLanguageMenu.Text = ((CultureInfo) item.Tag).NativeName;\n\t\t\t\t});\n\t\t\t\tif (((CultureInfo) item.Tag).IetfLanguageTag == Settings.Default.UserInterfaceLanguage)\n\t\t\t\t{\n\t\t\t\t\t_uiLanguageMenu.Text = ((CultureInfo) item.Tag).NativeName;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_uiLanguageMenu.DropDownItems.Add(new ToolStripSeparator());\n\t\t\tvar menu = _uiLanguageMenu.DropDownItems.Add(LocalizationManager.GetString(\"MainWindow.MoreMenuItem\",\n\t\t\t\t\"More...\", \"Last item in menu of UI languages\"));\n\t\t\tmenu.Click += ((a, b) =>\n\t\t\t{\n\t\t\t\tProgram.LocalizationManager.ShowLocalizationDialogBox(false);\n\t\t\t\tSetupUILanguageMenu();\n\t\t\t});\n\t\t}\n\n\t\tprivate void InitializeModesCombo()\n\t\t{\n\t\t\t_btnMode.DropDownItems.Clear();\n#if MULTIPLEMODES\n\t\t\tallowableModes = new List<string>();\n\t\t\tif (Settings.Default.AllowAdministrativeMode)\n\t\t\t{\n\t\t\t\tToolStripItem item = _btnMode.DropDownItems.Add(LocalizationManager.GetString(\"MainWindow.Modes.Administrator\",\n\t\t\t\t\t\"Administrator\"));\n\t\t\t\titem.Tag = kAdministrative;\n\t\t\t\tif (Settings.Default.ActiveMode == kAdministrative)\n\t\t\t\t\tSetMode(item);\n\t\t\t}\n\t\t\tif (Settings.Default.AllowNormalRecordingMode)\n\t\t\t{\n\t\t\t\tToolStripItem item = _btnMode.DropDownItems.Add(LocalizationManager.GetString(\"MainWindow.Modes.NormalRecording\",\n\t\t\t\t\t\"Normal Recording\"));\n\t\t\t\titem.Tag = kNormalRecording;\n\t\t\t\tif (Settings.Default.ActiveMode == kNormalRecording)\n\t\t\t\t\tSetMode(item);\n\t\t\t}\n#endif\n\t\t\t_btnMode.Visible = (_btnMode.DropDownItems.Count > 1);\n\t\t\t_recordingToolControl1.HidingSkippedBlocks = Settings.Default.ActiveMode == kNormalRecording;\n\t\t}\n\n#if MULTIPLEMODES\n\t\tprivate void SetMode(ToolStripItem selectedMode)\n\t\t{\n\t\t\t_btnMode.Text = selectedMode.Text;\n\n\t\t\tswitch ((string)selectedMode.Tag)\n\t\t\t{\n\t\t\t\tcase kAdministrative:\n\t\t\t\t\t_recordingToolControl1.HidingSkippedBlocks = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase kNormalRecording:\n\t\t\t\t\t_recordingToolControl1.HidingSkippedBlocks = true;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSetWindowText();\n\t\t}\n#endif\n\n\t\tprivate void OnSaveClick(object sender, EventArgs e)\n\t\t{\n\t\t\tMessageBox.Show(\n\t\t\t\tLocalizationManager.GetString(\"MainWindow.SaveAutomatically\",\n\t\t\t\t\t\"HearThis automatically saves your work, while you use it. This button is just here to tell you that :-)  To create sound files for playing your recordings, click the Publish button.\"),\n\t\t\t\tLocalizationManager.GetString(\"Common.Save\", \"Save\"));\n\t\t}\n\n\t\tprivate void OnPublishClick(object sender, EventArgs e)\n\t\t{\n\t\t\tusing (var dlg = new PublishDialog(Project))\n\t\t\t{\n\t\t\t\tdlg.ShowDialog();\n\t\t\t}\n\t\t}\n\n\t\tprivate void OnSettingsButtonClicked(object sender, EventArgs e)\n\t\t{\n\t\t\tvar origBreakQuotesIntoBlocksValue = Settings.Default.BreakQuotesIntoBlocks;\n\t\t\tvar origAdditionalBlockBreakChars = Settings.Default.AdditionalBlockBreakCharacters;\n\t\t\tvar origBreakAtParagraphBreaks = Project?.ProjectSettings?.BreakAtParagraphBreaks;\n\t\t\tDialogResult result = _settingsProtectionHelper.LaunchSettingsIfAppropriate(() =>\n\t\t\t{\n\t\t\t\tusing (var dlg = new AdministrativeSettings(Project))\n\t\t\t\t{\n\t\t\t\t\treturn dlg.ShowDialog(FindForm());\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (result == DialogResult.OK)\n\t\t\t{\n\t\t\t\tif (origBreakQuotesIntoBlocksValue != Settings.Default.BreakQuotesIntoBlocks ||\n\t\t\t\t\torigAdditionalBlockBreakChars != Settings.Default.AdditionalBlockBreakCharacters ||\n\t\t\t\t\torigBreakAtParagraphBreaks != Project?.ProjectSettings?.BreakAtParagraphBreaks)\n\t\t\t\t{\n\t\t\t\t\tLoadProject(Settings.Default.Project);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tScriptControl.ScriptBlockPainter.SetClauseSeparators();\n#if MULTIPLEMODES\n\t\t\t\t\tInvoke(new Action(InitializeModesCombo));\n#else\n\t\t\t\t\tInvoke(new Action(() =>\n\t\t\t\t\t{\n\t\t\t\t\t\t_recordingToolControl1.HidingSkippedBlocks = Settings.Default.ActiveMode == kNormalRecording;\n\t\t\t\t\t}));\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void OnAboutClick(object sender, EventArgs e)\n\t\t{\n\t\t\tusing (var dlg = new SILAboutBox(FileLocator.GetFileDistributedWithApplication(\"aboutbox.htm\")))\n\t\t\t{\n\t\t\t\tdlg.CheckForUpdatesClicked += HandleAboutDialogCheckForUpdatesClick;\n\t\t\t\tdlg.ReleaseNotesClicked += HandleAboutDialogReleaseNotesClicked;\n\t\t\t\tdlg.ShowDialog();\n\t\t\t}\n\t\t}\n\n\t\tprivate void HandleAboutDialogReleaseNotesClicked(object sender, EventArgs e)\n\t\t{\n\t\t\tvar path = FileLocator.GetFileDistributedWithApplication(\"ReleaseNotes.md\");\n\t\t\tusing (var dlg = new ShowReleaseNotesDialog(((Form)sender).Icon, path))\n\t\t\t\tdlg.ShowDialog();\n\t\t}\n\n\t\tprivate void HandleAboutDialogCheckForUpdatesClick(object sender, EventArgs e)\n\t\t{\n\t\t\tvar updateStatus = UpdateChecker.CheckForUpdatesAtUserRequest();\n\t\t\tif (updateStatus == Sparkle.UpdateStatus.UpdateNotAvailable)\n\t\t\t\t((SILAboutBox)sender).NotifyNoUpdatesAvailable();\n\t\t}\n\n\t\tprotected override void OnClosing(CancelEventArgs e)\n\t\t{\n\t\t\tbase.OnClosing(e);\n\t\t\tSettings.Default.Save();\n\t\t}\n\n\t\tprotected override void OnActivated(EventArgs e)\n\t\t{\n\t\t\tbase.OnActivated(e);\n\t\t\t_recordingToolControl1.StartFilteringMessages();\n\t\t}\n\n\t\tprotected override void OnDeactivate(EventArgs e)\n\t\t{\n\t\t\tbase.OnDeactivate(e);\n\t\t\t_recordingToolControl1.StopFilteringMessages();\n\t\t}\n\n\t\tprivate bool LoadProject(string name)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t_projectNameToShow = name;\n\t\t\t\tScriptProviderBase scriptProvider;\n\t\t\t\tif (name == SampleScriptProvider.kProjectUiName)\n\t\t\t\t\tscriptProvider = new SampleScriptProvider();\n\t\t\t\telse if (Path.GetExtension(name) == MultiVoiceScriptProvider.MultiVoiceFileExtension)\n\t\t\t\t{\n\t\t\t\t\tif (Settings.Default.Project != name)\n\t\t\t\t\t{\n\t\t\t\t\t\t\/\/ Forget any actor and character we remembered from another project.\n\t\t\t\t\t\tSettings.Default.Actor = Settings.Default.Character = null;\n\t\t\t\t\t}\n\t\t\t\t\tvar mvScriptProvider = MultiVoiceScriptProvider.Load(name);\n\t\t\t\t\tscriptProvider = mvScriptProvider;\n\t\t\t\t\tmvScriptProvider.RestrictToCharacter(Settings.Default.Actor, Settings.Default.Character);\n\t\t\t\t\t_multiVoicePanel.Visible = true;\n\t\t\t\t\t\/\/ This combination puts the two top-docked controls and the fill-docked _recordingToolControl into the right\n\t\t\t\t\t\/\/ sequence in the Controls list so that the top two are in the right order and the recording tool occupies\n\t\t\t\t\t\/\/ the rest of the space.\n\t\t\t\t\t\/\/ I can't find ANY order I can set in the designer which does this properly, possibly because when layout is\n\t\t\t\t\t\/\/ first done the multi voice panel is hidden. Another thing that might work is to put them in the right order\n\t\t\t\t\t\/\/ in the designer and force a layout after making the multi-voice control visible. I haven't tried that.\n\t\t\t\t\t\/\/ If you experiment with changing this watch out for the top controls being in the wrong order and also\n\t\t\t\t\t\/\/ for the recording tool being partly hidden behind one or both of them. The latter is easy to miss because\n\t\t\t\t\t\/\/ there is quite a bit of unused space at the top of the recording control.\n\t\t\t\t\t_multiVoicePanel.BringToFront();\n\t\t\t\t\t_recordingToolControl1.BringToFront();\n\t\t\t\t\tUpdateActorCharacter(mvScriptProvider, true);\n\t\t\t\t}\n\t\t\t\telse if (Path.GetExtension(name) == ExistingProjectsList.kProjectFileExtension ||\n\t\t\t\t\tPath.GetExtension(name) == \".zip\")\n\t\t\t\t{\n\t\t\t\t\tTextBundle<DblTextMetadata<DblMetadataLanguage>, DblMetadataLanguage> bundle;\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tbundle = new TextBundle<DblTextMetadata<DblMetadataLanguage>, DblMetadataLanguage>(name);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e)\n\t\t\t\t\t{\n\t\t\t\t\t\tErrorReport.NotifyUserOfProblem(e,\n\t\t\t\t\t\t\tLocalizationManager.GetString(\"MainWindow.ProjectMetadataInvalid\", \"Project could not be loaded: {0}\"), name);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tvar metadata = bundle.Metadata;\n\n\t\t\t\t\tvar hearThisProjectFolder = Path.Combine(Program.ApplicationDataBaseFolder, metadata.Language.Iso + \"_\" + metadata.Name);\n\n\t\t\t\t\tif (Path.GetExtension(name) == \".zip\" || Path.GetDirectoryName(name) != hearThisProjectFolder)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar projectFile = Path.Combine(hearThisProjectFolder, Path.ChangeExtension(Path.GetFileName(name), ExistingProjectsList.kProjectFileExtension));\n\t\t\t\t\t\tif (Directory.Exists(hearThisProjectFolder))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (File.Exists(projectFile))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\/\/TODO: Deal with collision. Offer to open existing project. Overwrite using this bundle?\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tDirectory.CreateDirectory(hearThisProjectFolder);\n\t\t\t\t\t\tFile.Copy(name, projectFile);\n\t\t\t\t\t\tname = projectFile;\n\t\t\t\t\t\tbundle = new TextBundle<DblTextMetadata<DblMetadataLanguage>, DblMetadataLanguage>(name);\n\t\t\t\t\t}\n\t\t\t\t\tscriptProvider = new ParatextScriptProvider(new TextBundleScripture(bundle));\n\t\t\t\t\t_projectNameToShow = metadata.Name;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tScrText paratextProject = ScrTextCollection.Get(name);\n\t\t\t\t\tif (paratextProject == null)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t_projectNameToShow = paratextProject.JoinedNameAndFullName;\n\t\t\t\t\tscriptProvider = new ParatextScriptProvider(new ParatextScripture(paratextProject));\n\t\t\t\t}\n\t\t\t\tif (!(scriptProvider is IActorCharacterProvider))\n\t\t\t\t{\n\t\t\t\t\t\/\/ Also can't seem to get this right in designer, with the invisible actor chooser panel confusing things.\n\t\t\t\t\t_recordingToolControl1.BringToFront();\n\t\t\t\t}\n\n\t\t\t\tProject = new Project(scriptProvider);\n\t\t\t\tif (Project.ActorCharacterProvider == null)\n\t\t\t\t{\n\t\t\t\t\t_multiVoicePanel.Hide(); \/\/ in case shown by a previously open project.\n\t\t\t\t}\n\t\t\t\tif (OnProjectChanged != null)\n\t\t\t\t\tOnProjectChanged(this, new EventArgs());\n\t\t\t\tSetWindowText();\n\n\t\t\t\tSettings.Default.Project = name;\n\t\t\t\tSettings.Default.Save();\n\t\t\t\t_recordingToolControl1.AdjustMinimumSize();\n\t\t\t\t\/\/ We can shrink as much as the recording tool can.\n\t\t\t\tMinimumSize = new Size(MinimumSize.Width, Height - (_recordingToolControl1.Height - _recordingToolControl1.MinimumSize.Height));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tErrorReport.NotifyUserOfProblem(e, \"Could not open \" + name);\n\t\t\t}\n\t\t\treturn false; \/\/didn't load it\n\t\t}\n\n\t\tprivate void SetWindowText()\n\t\t{\n\t\t\tvar ver = Assembly.GetExecutingAssembly().GetName().Version;\n#if MULTIPLEMODES\n\t\t\tText =\n\t\t\t\tstring.Format(\n\t\t\t\t\tLocalizationManager.GetString(\"MainWindow.WindowTitle\", \"{3} -- HearThis {0}.{1}.{2} ({4})\",\n\t\t\t\t\t\t\"{3} is project name, {0}.{1}.{2} are parts of version number. {4} is the active mode (i.e., view)\"),\n\t\t\t\t\t\tver.Major, ver.Minor, ver.Build, _projectNameToShow, _btnMode.Text);\n#else\n\t\t\tText =\n\t\t\t\tstring.Format(\n\t\t\t\t\tLocalizationManager.GetString(\"MainWindow.WindowTitle\", \"{3} -- {4} {0}.{1}.{2}\",\n\t\t\t\t\t\t\"{4} is product name: HearThis; {3} is project name, {0}.{1}.{2} are parts of version number.\"),\n\t\t\t\t\t\tver.Major, ver.Minor, ver.Build, _projectNameToShow, Program.kProduct);\n#endif\n\t\t}\n\n\t\tprivate void ModeDropDownItemClicked(object sender, ToolStripItemClickedEventArgs e)\n\t\t{\n#if MULTIPLEMODES\n\t\t\tif (Settings.Default.ActiveMode != (string) e.ClickedItem.Tag)\n\t\t\t{\n\t\t\t\tSettings.Default.ActiveMode = (string) e.ClickedItem.Tag;\n\t\t\t\tSetMode(e.ClickedItem);\n\t\t\t}\n#endif\n\t\t}\n\n\t\tprivate void _syncWithAndroidItem_Click(object sender, EventArgs e)\n\t\t{\n\t\t\tAndroidSynchronization.DoAndroidSync(Project);\n\t\t}\n\t\tprivate void Shell_ResizeEnd(object sender, EventArgs e)\n\t\t{\n\t\t\tif (WindowState != FormWindowState.Normal)\n\t\t\t\treturn;\n\n\t\t\tSettings.Default.RestoreBounds = new Rectangle(Left, Top, Width, Height);\n\t\t\tSettings.Default.Save();\n\t\t}\n\n\t\tprivate string _previousActor;\n\t\tprivate string _previousCharacter;\n\n\t\tprivate void _actorCharacterButton_Click(object sender, EventArgs e)\n\t\t{\n\t\t\tvar chooser = new ActorCharacterChooser();\n\t\t\t_previousActor = Project.ActorCharacterProvider.Actor;\n\t\t\t_previousCharacter = Project.ActorCharacterProvider.Character;\n\t\t\tchooser.ActorCharacterProvider = Project.ActorCharacterProvider;\n\t\t\tchooser.Location = new Point(_actorCharacterButton.Left, _multiVoicePanel.Top);\n\t\t\tchooser.Closed += (o, args) =>\n\t\t\t{\n\t\t\t\tUpdateActorCharacter(Project.ActorCharacterProvider, false);\n\t\t\t\t\/\/ Figure out whether the mouse is now in the panel.\n\t\t\t\tMultiVoicePanelOnMouseTransition(null, null);\n\t\t\t\t\/\/ And may need to redraw even if the transition code thinks it hasn't changed,\n\t\t\t\t\/\/ since something seems to cache the state behind the control.\n\t\t\t\t_multiVoicePanel.Invalidate();\n\t\t\t};\n\t\t\tthis.Controls.Add(chooser);\n\t\t\tchooser.BringToFront();\n\t\t\t\/\/ gives it a chance to notice we are up and turn off the border rectangle.\n\t\t\t_multiVoicePanel.Invalidate();\n\t\t}\n\n\t\tprivate string _originalCurrentActorItemText;\n\n\t\tprivate void UpdateActorCharacter(IActorCharacterProvider provider, bool initializing)\n\t\t{\n\t\t\tif (_originalCurrentActorItemText == null)\n\t\t\t\t_originalCurrentActorItemText = _limitToCurrentActorItem.Text;\n\t\t\tif (!initializing && _previousActor == provider.Actor && _previousCharacter == provider.Character)\n\t\t\t\treturn; \/\/ nothing changed.\n\t\t\tif (string.IsNullOrEmpty(provider.Actor))\n\t\t\t{\n\t\t\t\t_actorLabel.Text = _originalActorText;\n\t\t\t\t_characterLabel.Text = \"\";\n\t\t\t\t_actorLabel.Font = new Font(_originalActorFont.FontFamily, 32.0f);\n\t\t\t\t_limitToCurrentActorItem.Visible = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_actorLabel.Text = provider.Actor;\n\t\t\t\t_characterLabel.Text = provider.Character;\n\t\t\t\t_actorLabel.Font = _originalActorFont;\n\t\t\t\t_limitToCurrentActorItem.Visible = true;\n\t\t\t\t_limitToCurrentActorItem.Text = string.Format(_originalCurrentActorItemText, provider.Actor);\n\t\t\t}\n\t\t\t\/\/ When initializing, we want any saved current position to win. Also, we don't yet have\n\t\t\t\/\/ things initialized enough to call this method.\n\t\t\tif (!initializing)\n\t\t\t\t_recordingToolControl1.UpdateForActorCharacter();\n\t\t}\n\n\t\tprivate void _actorLabel_Click(object sender, EventArgs e)\n\t\t{\n\t\t\t_actorCharacterButton_Click(sender, e);\n\t\t}\n\n\t\tprivate void _characterLabel_Click(object sender, EventArgs e)\n\t\t{\n\t\t\t_actorCharacterButton_Click(sender, e);\n\t\t}\n\n\t\tprivate void _saveHearthisPackItem_Click(object sender, EventArgs e)\n\t\t{\n\t\t\tvar dlg = new SaveFileDialog();\n\t\t\tdlg.Filter = HearThisPackFilter;\n\t\t\tdlg.RestoreDirectory = true;\n\t\t\tif (dlg.ShowDialog() != DialogResult.OK || string.IsNullOrEmpty(dlg.FileName))\n\t\t\t\treturn;\n\t\t\tvar packer = new HearThisPackMaker(Project.ProjectFolder);\n\t\t\tif (_limitToCurrentActorItem.Checked && Project.ActorCharacterProvider != null)\n\t\t\t\tpacker.Actor = Project.ActorCharacterProvider.Actor;\n\t\t\tvar progressDlg = new MergeProgressDialog();\n\t\t\t\/\/ See comment in merge...dialog will close when user clicks OK AFTER this method returns.\n\t\t\tprogressDlg.Closed += (o, args) => progressDlg.Dispose();\n\t\t\tprogressDlg.SetSource(Path.GetFileName(dlg.FileName));\n\t\t\tprogressDlg.Show(this);\n\t\t\t\/\/ Enhance: is it worth having the message indicate whether we are restricting to actor?\n\t\t\t\/\/ If it didn't mean yet another message to localize I would.\n\t\t\tprogressDlg.SetLabel(string.Format(LocalizationManager.GetString(\"MainWindow.SavingTo\", \"Saving to {0}\", \"Keep {0} as a placeholder for the file name\")\n\t\t\t\t, Path.GetFileName(dlg.FileName)));\n\t\t\tprogressDlg.Text = string.Format(LocalizationManager.GetString(\"MainWindow.SavingHearThisPack\", \"Saving {0}\", \"{0} will be the file extension, HearThisPack\"), \"HearThisPack\");\n\t\t\tpacker.Pack(dlg.FileName, progressDlg.LogBox);\n\t\t\tprogressDlg.LogBox.WriteMessage(string.Format(LocalizationManager.GetString(\"MainWindow.PackComplete\", \"{0} is complete--click OK to close this window\"), \"HearThisPack\"));\n\t\t\tprogressDlg.SetDone();\n\t\t}\n\n\t\tprivate static string HearThisPackFilter => @\"HearThisPack files (*\" + HearThisPackMaker.HearThisPackExtension + @\")|*\" +\n\t\t                                            HearThisPackMaker.HearThisPackExtension;\n\n\t\tprivate void _mergeHearthisPackItem_Click(object sender, EventArgs e)\n\t\t{\n\t\t\tvar dlg = new OpenFileDialog();\n\t\t\tdlg.Filter = HearThisPackFilter;\n\t\t\tdlg.RestoreDirectory = true;\n\t\t\tdlg.InitialDirectory = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);\n\t\t\tif (dlg.ShowDialog() != DialogResult.OK)\n\t\t\t\treturn;\n\t\t\tusing (var reader = new HearThisPackReader(dlg.FileName))\n\t\t\t{\n\t\t\t\tif (reader.ProjectName.ToLowerInvariant() != Project.Name.ToLowerInvariant())\n\t\t\t\t{\n\t\t\t\t\tvar msg = LocalizationManager.GetString(\"MainWindow.MergeNoData\",\n\t\t\t\t\t\t\"This HearThis pack does not have any data for {0}. It contains data for {1}. If you want to merge it please open that project.\",\n\t\t\t\t\t\t\"Keep {0} as a placeholder for the current project name, {1} for the project in the file\");\n\t\t\t\t\tMessageBox.Show(this,\n\t\t\t\t\t\tstring.Format(msg, Project.Name, reader.ProjectName),\n\t\t\t\t\t\tLocalizationManager.GetString(\"MainWindow.MergeWrongProject\", \"Wrong Project\"),\n\t\t\t\t\t\tMessageBoxButtons.OK,\n\t\t\t\t\t\tMessageBoxIcon.Warning);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar packLink = reader.GetLink();\n\t\t\t\tvar ourLink = new WindowsLink(Program.ApplicationDataBaseFolder);\n\t\t\t\tvar merger = new RepoMerger(Project, ourLink, packLink);\n\t\t\t\tmerger.SendData = false; \/\/ don't need to send anything to the hear this pack\n\t\t\t\t\/\/ Don't change this to using...we want the dialog to stay open after this method returns,\n\t\t\t\t\/\/ so the user can read the progress information (which may be quite useful as a record\n\t\t\t\t\/\/ of what was merged). And we can't dispose it until it closes, so just arrange an\n\t\t\t\t\/\/ event to do it then.\n\t\t\t\tvar progressDlg = new MergeProgressDialog();\n\t\t\t\tprogressDlg.Closed += (o, args) => progressDlg.Dispose();\n\t\t\t\tprogressDlg.SetLabel(Path.GetFileName(dlg.FileName));\n\t\t\t\tprogressDlg.Show(this);\n\t\t\t\tmerger.Merge(progressDlg.LogBox);\n\t\t\t\t_recordingToolControl1.UpdateAfterMerge();\n\t\t\t\tprogressDlg.LogBox.WriteMessage(LocalizationManager.GetString(\"MergeProgressDialog.MergeComplete\", \"Merge is complete--click OK to close this window\"));\n\t\t\t\tprogressDlg.SetDone();\n\t\t\t}\n\t\t}\n\n\t\tprivate void supportToolStripMenuItem_Click(object sender, EventArgs e)\n\t\t{\n\t\t\tProcess.Start(@\"https:\/\/community.scripture.software.sil.org\/\");\n\t\t}\n\t}\n}","old_contents":"\/\/ --------------------------------------------------------------------------------------------\n#region \/\/ Copyright (c) 2015, SIL International. All Rights Reserved.\n\/\/ <copyright from='2011' to='2015' company='SIL International'>\n\/\/\t\tCopyright (c) 2015, SIL International. All Rights Reserved.\n\/\/\n\/\/\t\tDistributable under the terms of the MIT License (http:\/\/sil.mit-license.org\/)\n\/\/ <\/copyright>\n#endregion\n\/\/ --------------------------------------------------------------------------------------------\nusing System;\nusing System.ComponentModel;\nusing System.Diagnostics;\nusing System.Drawing;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing System.Windows.Forms;\nusing HearThis.Communication;\nusing HearThis.Properties;\nusing HearThis.Publishing;\nusing HearThis.Script;\nusing L10NSharp;\nusing NetSparkle;\nusing SIL.IO;\nusing SIL.Windows.Forms.Miscellaneous;\nusing SIL.Windows.Forms.ReleaseNotes;\nusing Paratext;\nusing SIL.DblBundle.Text;\nusing SIL.Extensions;\nusing SIL.Reporting;\n\nnamespace HearThis.UI\n{\n\tpublic partial class Shell : Form\n\t{\n\t\tpublic static Sparkle UpdateChecker;\n\t\tpublic event EventHandler OnProjectChanged;\n\t\tprivate string _projectNameToShow = string.Empty;\n\t\tprivate string _originalActorText;\n\t\tprivate Font _originalActorFont;\n\t\tprivate bool _mouseInMultiVoicePanel;\n\n\n#if MULTIPLEMODES\n\t\tprivate List<string> allowableModes;\n\n\t\tprivate const string kAdministrative = \"Administrator\";\n#endif\n\t\tprivate const string kNormalRecording = \"NormalRecording\";\n\n\t\tpublic Shell()\n\t\t{\n\t\t\tInitializeComponent();\n\t\t\tText = Program.kProduct;\n\n\t\t\t_settingsProtectionHelper.ManageComponent(_settingsItem);\n\t\t\t_settingsProtectionHelper.ManageComponent(toolStripButtonChooseProject);\n\t\t\tSetupUILanguageMenu();\n\n\t\t\t_toolStrip.Renderer = new RecordingToolControl.NoBorderToolStripRenderer();\n\t\t\t_moreMenu.ForeColor = AppPallette.NavigationTextColor;\n\n\t\t\tInitializeModesCombo();\n\n\t\t\t\/\/ Todo: possibly make this conditional on an a device being connected.\n\t\t\t\/\/ If possible notice and show it when a device is later connected.\n\t\t\t\/\/ Or: possibly if no device is active it displays instructions.\n\t\t\t_syncWithAndroidItem.Visible = true;\n\t\t\t_originalActorFont = _actorLabel.Font;\n\t\t\t_originalActorText = _actorLabel.Text;\n\t\t\t_toolStrip.Renderer = new ToolStripColorArrowRenderer();\n\t\t\t_multiVoicePanel.MouseLeave += MultiVoicePanelOnMouseTransition;\n\t\t\t_multiVoicePanel.MouseEnter += MultiVoicePanelOnMouseTransition;\n\t\t\tforeach (Control c in _multiVoicePanel.Controls)\n\t\t\t{\n\t\t\t\tc.MouseEnter += MultiVoicePanelOnMouseTransition;\n\t\t\t\tc.MouseLeave += MultiVoicePanelOnMouseTransition;\n\t\t\t}\n\t\t\t_multiVoicePanel.Paint += (sender, e) =>\n\t\t\t{\n\t\t\t\tif (_mouseInMultiVoicePanel && !Controls.OfType<ActorCharacterChooser>().Any())\n\t\t\t\t{\n\t\t\t\t\tvar borderRect = _multiVoicePanel.ClientRectangle;\n\t\t\t\t\t\/\/ The numbers here were determined to line things up with controls below\n\t\t\t\t\tborderRect = new Rectangle(borderRect.Left + 18, borderRect.Top, borderRect.Width - 43, borderRect.Height);\n\t\t\t\t\tControlPaint.DrawBorder(e.Graphics, borderRect, AppPallette.FaintScriptFocusTextColor,\n\t\t\t\t\t\tButtonBorderStyle.Solid);\n\t\t\t\t}\n\t\t\t};\n\t\t\t_multiVoicePanel.Click += _actorCharacterButton_Click;\n\t\t}\n\n\t\t\/\/\/ <summary>\n\t\t\/\/\/ Unfortunately the mouse 'leaves' the multivoice panel when it enters a child control as well as when it really\n\t\t\/\/\/ leaves the whole panel. So this routine is hooked to happen whenever it leaves or enters any of them.\n\t\t\/\/\/ It figures out whether the mouse is really inside the panel and adjusts the border if this has changed.\n\t\t\/\/\/ <\/summary>\n\t\t\/\/\/ <param name=\"sender1\"><\/param>\n\t\t\/\/\/ <param name=\"eventArgs\"><\/param>\n\t\tprivate void MultiVoicePanelOnMouseTransition(object sender1, EventArgs eventArgs)\n\t\t{\n\t\t\tbool isMouseInMVP = _multiVoicePanel.ClientRectangle.Contains(_multiVoicePanel.PointToClient(Control.MousePosition));\n\t\t\tif (isMouseInMVP != _mouseInMultiVoicePanel)\n\t\t\t{\n\t\t\t\t_mouseInMultiVoicePanel = isMouseInMVP;\n\t\t\t\t_multiVoicePanel.Invalidate();\n\t\t\t}\n\t\t}\n\n\t\tpublic Project Project { get; private set; }\n\n\t\tprivate void OnChooseProject(object sender, EventArgs e)\n\t\t{\n\t\t\tChooseProject();\n\t\t}\n\n\t\tprivate bool ChooseProject()\n\t\t{\n\t\t\tusing (var dlg = new ChooseProject())\n\t\t\t{\n\t\t\t\tif (DialogResult.OK == dlg.ShowDialog())\n\t\t\t\t{\n\t\t\t\t\t\/\/ ENHANCE: Someday it might be nice to save\/restore these in a project file so they could be remembered on\n\t\t\t\t\t\/\/ a per-project basis, but the VAST majority of our users are going to be working on a single project, so\n\t\t\t\t\t\/\/ this might be good enough.\n\t\t\t\t\tSettings.Default.Book = -1;\n\t\t\t\t\tSettings.Default.Chapter = -1;\n\t\t\t\t\tSettings.Default.Block = -1;\n\t\t\t\t\tLoadProject(dlg.SelectedProject);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tprotected override void OnLoad(EventArgs e)\n\t\t{\n\t\t\tbase.OnLoad(e);\n\t\t\tbool loaded = false;\n\t\t\tif (!string.IsNullOrEmpty(Settings.Default.Project))\n\t\t\t{\n\t\t\t\tloaded = LoadProject(Settings.Default.Project);\n\t\t\t}\n\n\t\t\tif (!loaded) \/\/if never did have a project, or that project couldn't be loaded\n\t\t\t{\n\t\t\t\tif (!ChooseProject())\n\t\t\t\t{\n\t\t\t\t\tClose();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar savedBounds = Settings.Default.RestoreBounds;\n\t\t\tif ((savedBounds.Width > MinimumSize.Width) && (savedBounds.Height > MinimumSize.Height) && (IsOnScreen(savedBounds)))\n\t\t\t{\n\t\t\t\tStartPosition = FormStartPosition.Manual;\n\t\t\t\tWindowState = FormWindowState.Normal;\n\t\t\t\tBounds = savedBounds;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tStartPosition = FormStartPosition.CenterScreen;\n\t\t\t\tWindowState = FormWindowState.Maximized;\n\t\t\t}\n\n\t\t\tUpdateChecker = new Sparkle(@\"http:\/\/build.palaso.org\/guestAuth\/repository\/download\/HearThis_HearThisWinDevPublishPt8\/.lastSuccessful\/appcast.xml\",\n\t\t\t\tIcon);\n\t\t\t\/\/ We don't want to do this until the main window is loaded because a) it's very easy for the user to overlook, and b)\n\t\t\t\/\/ more importantly, when the toast notifier closes, it can sometimes clobber an error message being displayed for the user.\n\t\t\tUpdateChecker.CheckOnFirstApplicationIdle();\n\t\t}\n\n\t\t\/\/\/ <summary>\n\t\t\/\/\/ Is a significant (100 x 100) portion of the form on-screen?\n\t\t\/\/\/ <\/summary>\n\t\t\/\/\/ <returns><\/returns>\n\t\tprivate static bool IsOnScreen(Rectangle rect)\n\t\t{\n\t\t\tvar screens = Screen.AllScreens;\n\t\t\tvar formTopLeft = new Rectangle(rect.Left, rect.Top, 100, 100);\n\n\t\t\treturn screens.Any(screen => screen.WorkingArea.Contains(formTopLeft));\n\t\t}\n\n\t\tprivate void SetupUILanguageMenu()\n\t\t{\n\t\t\t_uiLanguageMenu.DropDownItems.Clear();\n\t\t\tforeach (var lang in LocalizationManager.GetUILanguages(true))\n\t\t\t{\n\t\t\t\tvar item = _uiLanguageMenu.DropDownItems.Add(lang.NativeName);\n\t\t\t\titem.Tag = lang;\n\t\t\t\titem.Click += ((a, b) =>\n\t\t\t\t{\n\t\t\t\t\tLocalizationManager.SetUILanguage(((CultureInfo) item.Tag).IetfLanguageTag, true);\n\t\t\t\t\tSettings.Default.UserInterfaceLanguage = ((CultureInfo) item.Tag).IetfLanguageTag;\n\t\t\t\t\titem.Select();\n\t\t\t\t\t_uiLanguageMenu.Text = ((CultureInfo) item.Tag).NativeName;\n\t\t\t\t});\n\t\t\t\tif (((CultureInfo) item.Tag).IetfLanguageTag == Settings.Default.UserInterfaceLanguage)\n\t\t\t\t{\n\t\t\t\t\t_uiLanguageMenu.Text = ((CultureInfo) item.Tag).NativeName;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_uiLanguageMenu.DropDownItems.Add(new ToolStripSeparator());\n\t\t\tvar menu = _uiLanguageMenu.DropDownItems.Add(LocalizationManager.GetString(\"MainWindow.MoreMenuItem\",\n\t\t\t\t\"More...\", \"Last item in menu of UI languages\"));\n\t\t\tmenu.Click += ((a, b) =>\n\t\t\t{\n\t\t\t\tProgram.LocalizationManager.ShowLocalizationDialogBox(false);\n\t\t\t\tSetupUILanguageMenu();\n\t\t\t});\n\t\t}\n\n\t\tprivate void InitializeModesCombo()\n\t\t{\n\t\t\t_btnMode.DropDownItems.Clear();\n#if MULTIPLEMODES\n\t\t\tallowableModes = new List<string>();\n\t\t\tif (Settings.Default.AllowAdministrativeMode)\n\t\t\t{\n\t\t\t\tToolStripItem item = _btnMode.DropDownItems.Add(LocalizationManager.GetString(\"MainWindow.Modes.Administrator\",\n\t\t\t\t\t\"Administrator\"));\n\t\t\t\titem.Tag = kAdministrative;\n\t\t\t\tif (Settings.Default.ActiveMode == kAdministrative)\n\t\t\t\t\tSetMode(item);\n\t\t\t}\n\t\t\tif (Settings.Default.AllowNormalRecordingMode)\n\t\t\t{\n\t\t\t\tToolStripItem item = _btnMode.DropDownItems.Add(LocalizationManager.GetString(\"MainWindow.Modes.NormalRecording\",\n\t\t\t\t\t\"Normal Recording\"));\n\t\t\t\titem.Tag = kNormalRecording;\n\t\t\t\tif (Settings.Default.ActiveMode == kNormalRecording)\n\t\t\t\t\tSetMode(item);\n\t\t\t}\n#endif\n\t\t\t_btnMode.Visible = (_btnMode.DropDownItems.Count > 1);\n\t\t\t_recordingToolControl1.HidingSkippedBlocks = Settings.Default.ActiveMode == kNormalRecording;\n\t\t}\n\n#if MULTIPLEMODES\n\t\tprivate void SetMode(ToolStripItem selectedMode)\n\t\t{\n\t\t\t_btnMode.Text = selectedMode.Text;\n\n\t\t\tswitch ((string)selectedMode.Tag)\n\t\t\t{\n\t\t\t\tcase kAdministrative:\n\t\t\t\t\t_recordingToolControl1.HidingSkippedBlocks = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase kNormalRecording:\n\t\t\t\t\t_recordingToolControl1.HidingSkippedBlocks = true;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSetWindowText();\n\t\t}\n#endif\n\n\t\tprivate void OnSaveClick(object sender, EventArgs e)\n\t\t{\n\t\t\tMessageBox.Show(\n\t\t\t\tLocalizationManager.GetString(\"MainWindow.SaveAutomatically\",\n\t\t\t\t\t\"HearThis automatically saves your work, while you use it. This button is just here to tell you that :-)  To create sound files for playing your recordings, click the Publish button.\"),\n\t\t\t\tLocalizationManager.GetString(\"Common.Save\", \"Save\"));\n\t\t}\n\n\t\tprivate void OnPublishClick(object sender, EventArgs e)\n\t\t{\n\t\t\tusing (var dlg = new PublishDialog(Project))\n\t\t\t{\n\t\t\t\tdlg.ShowDialog();\n\t\t\t}\n\t\t}\n\n\t\tprivate void OnSettingsButtonClicked(object sender, EventArgs e)\n\t\t{\n\t\t\tvar origBreakQuotesIntoBlocksValue = Settings.Default.BreakQuotesIntoBlocks;\n\t\t\tvar origAdditionalBlockBreakChars = Settings.Default.AdditionalBlockBreakCharacters;\n\t\t\tvar origBreakAtParagraphBreaks = Project?.ProjectSettings?.BreakAtParagraphBreaks;\n\t\t\tDialogResult result = _settingsProtectionHelper.LaunchSettingsIfAppropriate(() =>\n\t\t\t{\n\t\t\t\tusing (var dlg = new AdministrativeSettings(Project))\n\t\t\t\t{\n\t\t\t\t\treturn dlg.ShowDialog(FindForm());\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (result == DialogResult.OK)\n\t\t\t{\n\t\t\t\tif (origBreakQuotesIntoBlocksValue != Settings.Default.BreakQuotesIntoBlocks ||\n\t\t\t\t\torigAdditionalBlockBreakChars != Settings.Default.AdditionalBlockBreakCharacters ||\n\t\t\t\t\torigBreakAtParagraphBreaks != Project?.ProjectSettings?.BreakAtParagraphBreaks)\n\t\t\t\t{\n\t\t\t\t\tLoadProject(Settings.Default.Project);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tScriptControl.ScriptBlockPainter.SetClauseSeparators();\n#if MULTIPLEMODES\n\t\t\t\t\tInvoke(new Action(InitializeModesCombo));\n#else\n\t\t\t\t\tInvoke(new Action(() =>\n\t\t\t\t\t{\n\t\t\t\t\t\t_recordingToolControl1.HidingSkippedBlocks = Settings.Default.ActiveMode == kNormalRecording;\n\t\t\t\t\t}));\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void OnAboutClick(object sender, EventArgs e)\n\t\t{\n\t\t\tusing (var dlg = new SILAboutBox(FileLocator.GetFileDistributedWithApplication(\"aboutbox.htm\")))\n\t\t\t{\n\t\t\t\tdlg.CheckForUpdatesClicked += HandleAboutDialogCheckForUpdatesClick;\n\t\t\t\tdlg.ReleaseNotesClicked += HandleAboutDialogReleaseNotesClicked;\n\t\t\t\tdlg.ShowDialog();\n\t\t\t}\n\t\t}\n\n\t\tprivate void HandleAboutDialogReleaseNotesClicked(object sender, EventArgs e)\n\t\t{\n\t\t\tvar path = FileLocator.GetFileDistributedWithApplication(\"ReleaseNotes.md\");\n\t\t\tusing (var dlg = new ShowReleaseNotesDialog(((Form)sender).Icon, path))\n\t\t\t\tdlg.ShowDialog();\n\t\t}\n\n\t\tprivate void HandleAboutDialogCheckForUpdatesClick(object sender, EventArgs e)\n\t\t{\n\t\t\tvar updateStatus = UpdateChecker.CheckForUpdatesAtUserRequest();\n\t\t\tif (updateStatus == Sparkle.UpdateStatus.UpdateNotAvailable)\n\t\t\t\t((SILAboutBox)sender).NotifyNoUpdatesAvailable();\n\t\t}\n\n\t\tprotected override void OnClosing(CancelEventArgs e)\n\t\t{\n\t\t\tbase.OnClosing(e);\n\t\t\tSettings.Default.Save();\n\t\t}\n\n\t\tprotected override void OnActivated(EventArgs e)\n\t\t{\n\t\t\tbase.OnActivated(e);\n\t\t\t_recordingToolControl1.StartFilteringMessages();\n\t\t}\n\n\t\tprotected override void OnDeactivate(EventArgs e)\n\t\t{\n\t\t\tbase.OnDeactivate(e);\n\t\t\t_recordingToolControl1.StopFilteringMessages();\n\t\t}\n\n\t\tprivate bool LoadProject(string name)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t_projectNameToShow = name;\n\t\t\t\tScriptProviderBase scriptProvider;\n\t\t\t\tif (name == SampleScriptProvider.kProjectUiName)\n\t\t\t\t\tscriptProvider = new SampleScriptProvider();\n\t\t\t\telse if (Path.GetExtension(name) == MultiVoiceScriptProvider.MultiVoiceFileExtension)\n\t\t\t\t{\n\t\t\t\t\tif (Settings.Default.Project != name)\n\t\t\t\t\t{\n\t\t\t\t\t\t\/\/ Forget any actor and character we remembered from another project.\n\t\t\t\t\t\tSettings.Default.Actor = Settings.Default.Character = null;\n\t\t\t\t\t}\n\t\t\t\t\tvar mvScriptProvider = MultiVoiceScriptProvider.Load(name);\n\t\t\t\t\tscriptProvider = mvScriptProvider;\n\t\t\t\t\tmvScriptProvider.RestrictToCharacter(Settings.Default.Actor, Settings.Default.Character);\n\t\t\t\t\t_multiVoicePanel.Visible = true;\n\t\t\t\t\t\/\/ This combination puts the two top-docked controls and the fill-docked _recordingToolControl into the right\n\t\t\t\t\t\/\/ sequence in the Controls list so that the top two are in the right order and the recording tool occupies\n\t\t\t\t\t\/\/ the rest of the space.\n\t\t\t\t\t\/\/ I can't find ANY order I can set in the designer which does this properly, possibly because when layout is\n\t\t\t\t\t\/\/ first done the multi voice panel is hidden. Another thing that might work is to put them in the right order\n\t\t\t\t\t\/\/ in the designer and force a layout after making the multi-voice control visible. I haven't tried that.\n\t\t\t\t\t\/\/ If you experiment with changing this watch out for the top controls being in the wrong order and also\n\t\t\t\t\t\/\/ for the recording tool being partly hidden behind one or both of them. The latter is easy to miss because\n\t\t\t\t\t\/\/ there is quite a bit of unused space at the top of the recording control.\n\t\t\t\t\t_multiVoicePanel.BringToFront();\n\t\t\t\t\t_recordingToolControl1.BringToFront();\n\t\t\t\t\tUpdateActorCharacter(mvScriptProvider, true);\n\t\t\t\t}\n\t\t\t\telse if (Path.GetExtension(name) == ExistingProjectsList.kProjectFileExtension ||\n\t\t\t\t\tPath.GetExtension(name) == \".zip\")\n\t\t\t\t{\n\t\t\t\t\tTextBundle<DblTextMetadata<DblMetadataLanguage>, DblMetadataLanguage> bundle;\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tbundle = new TextBundle<DblTextMetadata<DblMetadataLanguage>, DblMetadataLanguage>(name);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e)\n\t\t\t\t\t{\n\t\t\t\t\t\tErrorReport.NotifyUserOfProblem(e,\n\t\t\t\t\t\t\tLocalizationManager.GetString(\"MainWindow.ProjectMetadataInvalid\", \"Project could not be loaded: {0}\"), name);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tvar metadata = bundle.Metadata;\n\n\t\t\t\t\tvar hearThisProjectFolder = Path.Combine(Program.ApplicationDataBaseFolder, metadata.Language.Iso + \"_\" + metadata.Name);\n\n\t\t\t\t\tif (Path.GetExtension(name) == \".zip\" || Path.GetDirectoryName(name) != hearThisProjectFolder)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar projectFile = Path.Combine(hearThisProjectFolder, Path.ChangeExtension(Path.GetFileName(name), ExistingProjectsList.kProjectFileExtension));\n\t\t\t\t\t\tif (Directory.Exists(hearThisProjectFolder))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (File.Exists(projectFile))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\/\/TODO: Deal with collision. Offer to open existing project. Overwrite using this bundle?\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tDirectory.CreateDirectory(hearThisProjectFolder);\n\t\t\t\t\t\tFile.Copy(name, projectFile);\n\t\t\t\t\t\tname = projectFile;\n\t\t\t\t\t\tbundle = new TextBundle<DblTextMetadata<DblMetadataLanguage>, DblMetadataLanguage>(name);\n\t\t\t\t\t}\n\t\t\t\t\tscriptProvider = new ParatextScriptProvider(new TextBundleScripture(bundle));\n\t\t\t\t\t_projectNameToShow = metadata.Name;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tScrText paratextProject = ScrTextCollection.Get(name);\n\t\t\t\t\tif (paratextProject == null)\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t_projectNameToShow = paratextProject.JoinedNameAndFullName;\n\t\t\t\t\tscriptProvider = new ParatextScriptProvider(new ParatextScripture(paratextProject));\n\t\t\t\t}\n\t\t\t\tif (!(scriptProvider is IActorCharacterProvider))\n\t\t\t\t{\n\t\t\t\t\t\/\/ Also can't seem to get this right in designer, with the invisible actor chooser panel confusing things.\n\t\t\t\t\t_recordingToolControl1.BringToFront();\n\t\t\t\t}\n\n\t\t\t\tProject = new Project(scriptProvider);\n\t\t\t\tif (Project.ActorCharacterProvider == null)\n\t\t\t\t{\n\t\t\t\t\t_multiVoicePanel.Hide(); \/\/ in case shown by a previously open project.\n\t\t\t\t}\n\t\t\t\tif (OnProjectChanged != null)\n\t\t\t\t\tOnProjectChanged(this, new EventArgs());\n\t\t\t\tSetWindowText();\n\n\t\t\t\tSettings.Default.Project = name;\n\t\t\t\tSettings.Default.Save();\n\t\t\t\t_recordingToolControl1.AdjustMinimumSize();\n\t\t\t\t\/\/ We can shrink as much as the recording tool can.\n\t\t\t\tMinimumSize = new Size(MinimumSize.Width, Height - (_recordingToolControl1.Height - _recordingToolControl1.MinimumSize.Height));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tErrorReport.NotifyUserOfProblem(e, \"Could not open \" + name);\n\t\t\t}\n\t\t\treturn false; \/\/didn't load it\n\t\t}\n\n\t\tprivate void SetWindowText()\n\t\t{\n\t\t\tvar ver = Assembly.GetExecutingAssembly().GetName().Version;\n#if MULTIPLEMODES\n\t\t\tText =\n\t\t\t\tstring.Format(\n\t\t\t\t\tLocalizationManager.GetString(\"MainWindow.WindowTitle\", \"{3} -- HearThis {0}.{1}.{2} ({4})\",\n\t\t\t\t\t\t\"{3} is project name, {0}.{1}.{2} are parts of version number. {4} is the active mode (i.e., view)\"),\n\t\t\t\t\t\tver.Major, ver.Minor, ver.Build, _projectNameToShow, _btnMode.Text);\n#else\n\t\t\tText =\n\t\t\t\tstring.Format(\n\t\t\t\t\tLocalizationManager.GetString(\"MainWindow.WindowTitle\", \"{3} -- {4} {0}.{1}.{2}\",\n\t\t\t\t\t\t\"{4} is product name: HearThis; {3} is project name, {0}.{1}.{2} are parts of version number.\"),\n\t\t\t\t\t\tver.Major, ver.Minor, ver.Build, _projectNameToShow, Program.kProduct);\n#endif\n\t\t}\n\n\t\tprivate void ModeDropDownItemClicked(object sender, ToolStripItemClickedEventArgs e)\n\t\t{\n#if MULTIPLEMODES\n\t\t\tif (Settings.Default.ActiveMode != (string) e.ClickedItem.Tag)\n\t\t\t{\n\t\t\t\tSettings.Default.ActiveMode = (string) e.ClickedItem.Tag;\n\t\t\t\tSetMode(e.ClickedItem);\n\t\t\t}\n#endif\n\t\t}\n\n\t\tprivate void _syncWithAndroidItem_Click(object sender, EventArgs e)\n\t\t{\n\t\t\tAndroidSynchronization.DoAndroidSync(Project);\n\t\t}\n\t\tprivate void Shell_ResizeEnd(object sender, EventArgs e)\n\t\t{\n\t\t\tif (WindowState != FormWindowState.Normal)\n\t\t\t\treturn;\n\n\t\t\tSettings.Default.RestoreBounds = new Rectangle(Left, Top, Width, Height);\n\t\t\tSettings.Default.Save();\n\t\t}\n\n\t\tprivate string _previousActor;\n\t\tprivate string _previousCharacter;\n\n\t\tprivate void _actorCharacterButton_Click(object sender, EventArgs e)\n\t\t{\n\t\t\tvar chooser = new ActorCharacterChooser();\n\t\t\t_previousActor = Project.ActorCharacterProvider.Actor;\n\t\t\t_previousCharacter = Project.ActorCharacterProvider.Character;\n\t\t\tchooser.ActorCharacterProvider = Project.ActorCharacterProvider;\n\t\t\tchooser.Location = new Point(_actorCharacterButton.Left, _multiVoicePanel.Top);\n\t\t\tchooser.Closed += (o, args) =>\n\t\t\t{\n\t\t\t\tUpdateActorCharacter(Project.ActorCharacterProvider, false);\n\t\t\t\t\/\/ Figure out whether the mouse is now in the panel.\n\t\t\t\tMultiVoicePanelOnMouseTransition(null, null);\n\t\t\t\t\/\/ And may need to redraw even if the transition code thinks it hasn't changed,\n\t\t\t\t\/\/ since something seems to cache the state behind the control.\n\t\t\t\t_multiVoicePanel.Invalidate();\n\t\t\t};\n\t\t\tthis.Controls.Add(chooser);\n\t\t\tchooser.BringToFront();\n\t\t\t\/\/ gives it a chance to notice we are up and turn off the border rectangle.\n\t\t\t_multiVoicePanel.Invalidate();\n\t\t}\n\n\t\tprivate string _originalCurrentActorItemText;\n\n\t\tprivate void UpdateActorCharacter(IActorCharacterProvider provider, bool initializing)\n\t\t{\n\t\t\tif (_originalCurrentActorItemText == null)\n\t\t\t\t_originalCurrentActorItemText = _limitToCurrentActorItem.Text;\n\t\t\tif (!initializing && _previousActor == provider.Actor && _previousCharacter == provider.Character)\n\t\t\t\treturn; \/\/ nothing changed.\n\t\t\tif (string.IsNullOrEmpty(provider.Actor))\n\t\t\t{\n\t\t\t\t_actorLabel.Text = _originalActorText;\n\t\t\t\t_characterLabel.Text = \"\";\n\t\t\t\t_actorLabel.Font = new Font(_originalActorFont.FontFamily, 32.0f);\n\t\t\t\t_limitToCurrentActorItem.Visible = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_actorLabel.Text = provider.Actor;\n\t\t\t\t_characterLabel.Text = provider.Character;\n\t\t\t\t_actorLabel.Font = _originalActorFont;\n\t\t\t\t_limitToCurrentActorItem.Visible = true;\n\t\t\t\t_limitToCurrentActorItem.Text = string.Format(_originalCurrentActorItemText, provider.Actor);\n\t\t\t}\n\t\t\t\/\/ When initializing, we want any saved current position to win. Also, we don't yet have\n\t\t\t\/\/ things initialized enough to call this method.\n\t\t\tif (!initializing)\n\t\t\t\t_recordingToolControl1.UpdateForActorCharacter();\n\t\t}\n\n\t\tprivate void _actorLabel_Click(object sender, EventArgs e)\n\t\t{\n\t\t\t_actorCharacterButton_Click(sender, e);\n\t\t}\n\n\t\tprivate void _characterLabel_Click(object sender, EventArgs e)\n\t\t{\n\t\t\t_actorCharacterButton_Click(sender, e);\n\t\t}\n\n\t\tprivate void _saveHearthisPackItem_Click(object sender, EventArgs e)\n\t\t{\n\t\t\tvar dlg = new SaveFileDialog();\n\t\t\tdlg.Filter = HearThisPackFilter;\n\t\t\tdlg.RestoreDirectory = true;\n\t\t\tif (dlg.ShowDialog() != DialogResult.OK || string.IsNullOrEmpty(dlg.FileName))\n\t\t\t\treturn;\n\t\t\tvar packer = new HearThisPackMaker(Project.ProjectFolder);\n\t\t\tif (_limitToCurrentActorItem.Checked && Project.ActorCharacterProvider != null)\n\t\t\t\tpacker.Actor = Project.ActorCharacterProvider.Actor;\n\t\t\tvar progressDlg = new MergeProgressDialog();\n\t\t\t\/\/ See comment in merge...dialog will close when user clicks OK AFTER this method returns.\n\t\t\tprogressDlg.Closed += (o, args) => progressDlg.Dispose();\n\t\t\tprogressDlg.SetSource(Path.GetFileName(dlg.FileName));\n\t\t\tprogressDlg.Show(this);\n\t\t\t\/\/ Enhance: is it worth having the message indicate whether we are restricting to actor?\n\t\t\t\/\/ If it didn't mean yet another message to localize I would.\n\t\t\tprogressDlg.SetLabel(string.Format(LocalizationManager.GetString(\"MainWindow.SavingTo\", \"Saving to {0}\", \"Keep {0} as a placeholder for the file name\")\n\t\t\t\t, Path.GetFileName(dlg.FileName)));\n\t\t\tprogressDlg.Text = string.Format(LocalizationManager.GetString(\"MainWindow.SavingHearThisPack\", \"Saving {0}\", \"{0} will be the file extension, HearThisPack\"), \"HearThisPack\");\n\t\t\tpacker.Pack(dlg.FileName, progressDlg.LogBox);\n\t\t\tprogressDlg.LogBox.WriteMessage(string.Format(LocalizationManager.GetString(\"MainWindow.PackComplete\", \"{0} is complete--click OK to close this window\"), \"HearThisPack\"));\n\t\t\tprogressDlg.SetDone();\n\t\t}\n\n\t\tprivate static string HearThisPackFilter => @\"HearThisPack files (*\" + HearThisPackMaker.HearThisPackExtension + @\"|*\" +\n\t\t                                            HearThisPackMaker.HearThisPackExtension;\n\n\t\tprivate void _mergeHearthisPackItem_Click(object sender, EventArgs e)\n\t\t{\n\t\t\tvar dlg = new OpenFileDialog();\n\t\t\tdlg.Filter = HearThisPackFilter;\n\t\t\tdlg.RestoreDirectory = true;\n\t\t\tdlg.InitialDirectory = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);\n\t\t\tif (dlg.ShowDialog() != DialogResult.OK)\n\t\t\t\treturn;\n\t\t\tusing (var reader = new HearThisPackReader(dlg.FileName))\n\t\t\t{\n\t\t\t\tif (reader.ProjectName.ToLowerInvariant() != Project.Name.ToLowerInvariant())\n\t\t\t\t{\n\t\t\t\t\tvar msg = LocalizationManager.GetString(\"MainWindow.MergeNoData\",\n\t\t\t\t\t\t\"This HearThis pack does not have any data for {0}. It contains data for {1}. If you want to merge it please open that project.\",\n\t\t\t\t\t\t\"Keep {0} as a placeholder for the current project name, {1} for the project in the file\");\n\t\t\t\t\tMessageBox.Show(this,\n\t\t\t\t\t\tstring.Format(msg, Project.Name, reader.ProjectName),\n\t\t\t\t\t\tLocalizationManager.GetString(\"MainWindow.MergeWrongProject\", \"Wrong Project\"),\n\t\t\t\t\t\tMessageBoxButtons.OK,\n\t\t\t\t\t\tMessageBoxIcon.Warning);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar packLink = reader.GetLink();\n\t\t\t\tvar ourLink = new WindowsLink(Program.ApplicationDataBaseFolder);\n\t\t\t\tvar merger = new RepoMerger(Project, ourLink, packLink);\n\t\t\t\tmerger.SendData = false; \/\/ don't need to send anything to the hear this pack\n\t\t\t\t\/\/ Don't change this to using...we want the dialog to stay open after this method returns,\n\t\t\t\t\/\/ so the user can read the progress information (which may be quite useful as a record\n\t\t\t\t\/\/ of what was merged). And we can't dispose it until it closes, so just arrange an\n\t\t\t\t\/\/ event to do it then.\n\t\t\t\tvar progressDlg = new MergeProgressDialog();\n\t\t\t\tprogressDlg.Closed += (o, args) => progressDlg.Dispose();\n\t\t\t\tprogressDlg.SetLabel(Path.GetFileName(dlg.FileName));\n\t\t\t\tprogressDlg.Show(this);\n\t\t\t\tmerger.Merge(progressDlg.LogBox);\n\t\t\t\t_recordingToolControl1.UpdateAfterMerge();\n\t\t\t\tprogressDlg.LogBox.WriteMessage(LocalizationManager.GetString(\"MergeProgressDialog.MergeComplete\", \"Merge is complete--click OK to close this window\"));\n\t\t\t\tprogressDlg.SetDone();\n\t\t\t}\n\t\t}\n\n\t\tprivate void supportToolStripMenuItem_Click(object sender, EventArgs e)\n\t\t{\n\t\t\tProcess.Start(@\"https:\/\/community.scripture.software.sil.org\/\");\n\t\t}\n\t}\n}","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"e0b8d10854c2ae5a4b45b13d171f9be1a8b204e7","subject":"Escape quotes in CSV value fields.","message":"Escape quotes in CSV value fields.\n\nThis commit prevents GTFS users from having to escape quotes in their\nGTFS fields themselves, instead putting the onus on the library to\nproperly escape fields.  This matches the way commas in text fields are\ncurrently handled.\n\nResolves #73.\n\nSigned-off-by: Jeff Cuevas-Koch <f3e731dfa293c7a83119d8aacfa41b5d2d780be9@cuevaskoch.com>\n","repos":"itinero\/GTFS","old_file":"src\/GTFS\/GTFSWriter.cs","new_file":"src\/GTFS\/GTFSWriter.cs","new_contents":"\ufeff\/\/ The MIT License (MIT)\n\n\/\/ Copyright (c) 2014 Ben Abelshausen\n\n\/\/ Permission is hereby granted, free of charge, to any person obtaining a copy\n\/\/ of this software and associated documentation files (the \"Software\"), to deal\n\/\/ in the Software without restriction, including without limitation the rights\n\/\/ to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\n\/\/ copies of the Software, and to permit persons to whom the Software is\n\/\/ furnished to do so, subject to the following conditions:\n\n\/\/ The above copyright notice and this permission notice shall be included in\n\/\/ all copies or substantial portions of the Software.\n\n\/\/ THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\/\/ IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\/\/ FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\/\/ AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\/\/ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\/\/ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\/\/ THE SOFTWARE.\n\nusing GTFS.IO;\nusing System.Linq;\nusing System.Collections.Generic;\nusing GTFS.Entities;\nusing GTFS.Entities.Enumerations;\nusing System;\nusing System.Text;\n\nnamespace GTFS\n{\n    \/\/\/ <summary>\n    \/\/\/ A GTFS writer.\n    \/\/\/ <\/summary>\n    \/\/\/ <typeparam name=\"T\"><\/typeparam>\n    public class GTFSWriter<T> where T : IGTFSFeed\n    {\n        \/\/\/ <summary>\n        \/\/\/ Writes the given feed to the given target files.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"feed\"><\/param>\n        \/\/\/ <param name=\"target\"><\/param>\n        public void Write(T feed, IEnumerable<IGTFSTargetFile> target)\n        {\n            \/\/ order files by id\n            var agenciesToWrite = feed.Agencies.OrderBy(x => x.Id).ToList();\n            var calendarDatesToWrite = feed.CalendarDates.OrderBy(x => x.ServiceId).OrderBy(y => y.ExceptionType).OrderBy(z => z.Date).ToList();\n            var calendarsToWrite = feed.Calendars.OrderBy(x => x.ServiceId).ToList();\n            var fareAttributesToWrite = feed.FareAttributes.OrderBy(x => x.FareId).ToList();\n            var fareRulesToWrite = feed.FareRules.OrderBy(x => x.RouteId).ToList();\n            var frequenciesToWrite = feed.Frequencies.OrderBy(x => x.TripId).ToList();\n            var routesToWrite = feed.Routes.OrderBy(x => x.Id).ToList();\n            var stopsToWrite = feed.Stops.OrderBy(x => x.Id).ToList();\n            var stopTimesToWrite = feed.StopTimes.OrderBy(x => x.TripId).ToList();\n            var tripsToWrite = feed.Trips.OrderBy(x => x.Id).ToList();\n            var levelsToWrite = feed.Levels.OrderBy(x => x.Id).ToList();\n            var pathwaysToWrite = feed.Pathways.OrderBy(x => x.Id).ToList();\n\n            \/\/ write files on-by-one.\n            this.Write(target.FirstOrDefault<IGTFSTargetFile>((x) => x.Name == \"agency\"), agenciesToWrite);\n            this.Write(target.FirstOrDefault<IGTFSTargetFile>((x) => x.Name == \"calendar_dates\"), calendarDatesToWrite);\n            this.Write(target.FirstOrDefault<IGTFSTargetFile>((x) => x.Name == \"calendar\"), calendarsToWrite);\n            this.Write(target.FirstOrDefault<IGTFSTargetFile>((x) => x.Name == \"fare_attributes\"), fareAttributesToWrite);\n            this.Write(target.FirstOrDefault<IGTFSTargetFile>((x) => x.Name == \"fare_rules\"), fareRulesToWrite);\n            this.Write(target.FirstOrDefault<IGTFSTargetFile>((x) => x.Name == \"feed_info\"), feed.GetFeedInfo());\n            this.Write(target.FirstOrDefault<IGTFSTargetFile>((x) => x.Name == \"frequencies\"), frequenciesToWrite);\n            this.Write(target.FirstOrDefault<IGTFSTargetFile>((x) => x.Name == \"routes\"), routesToWrite);\n            this.Write(target.FirstOrDefault<IGTFSTargetFile>((x) => x.Name == \"shapes\"), feed.Shapes);\n            this.Write(target.FirstOrDefault<IGTFSTargetFile>((x) => x.Name == \"stops\"), stopsToWrite);\n            this.Write(target.FirstOrDefault<IGTFSTargetFile>((x) => x.Name == \"stop_times\"), stopTimesToWrite);\n            this.Write(target.FirstOrDefault<IGTFSTargetFile>((x) => x.Name == \"transfers\"), feed.Transfers);\n            this.Write(target.FirstOrDefault<IGTFSTargetFile>((x) => x.Name == \"trips\"), tripsToWrite);\n            this.Write(target.FirstOrDefault<IGTFSTargetFile>((x) => x.Name == \"levels\"), levelsToWrite);\n            this.Write(target.FirstOrDefault<IGTFSTargetFile>((x) => x.Name == \"pathways\"), pathwaysToWrite);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes all levels to the given levels file.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"levelsFile\"><\/param>\n        \/\/\/ <param name=\"levels\"><\/param>\n        protected virtual void Write(IGTFSTargetFile levelsFile, IEnumerable<Level> levels)\n        {\n            if (levelsFile == null) return;\n            \n            bool initialized = false;\n            var data = new string[3];\n            foreach (var level in levels)\n            {\n                if (!initialized)\n                {\n                    if (levelsFile.Exists)\n                    {\n                        levelsFile.Clear();\n                    }\n\n                    \/\/ write headers.\n                    data[0] = \"level_id\";\n                    data[1] = \"level_index\";\n                    data[2] = \"level_name\";\n                    levelsFile.Write(data);\n                    initialized = true;\n                }\n\n                \/\/ write level details.\n                data[0] = this.WriteFieldString(\"level\", \"level_id\", level.Id);\n                data[1] = this.WriteFieldDouble(\"level\", \"level_index\", level.Index);\n                data[2] = this.WriteFieldString(\"level\", \"level_name\", level.Name, true);\n                levelsFile.Write(data);\n            }\n            levelsFile.Close();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes all pathways to the given pathways file.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"pathwaysFile\"><\/param>\n        \/\/\/ <param name=\"pathways\"><\/param>\n        protected virtual void Write(IGTFSTargetFile pathwaysFile, IEnumerable<Pathway> pathways)\n        {\n            if (pathwaysFile == null) return;\n            \n            bool initialized = false;\n            var data = new string[12];\n            foreach (var pathway in pathways)\n            {\n                if (!initialized)\n                {\n                    if (pathwaysFile.Exists)\n                    {\n                        pathwaysFile.Clear();\n                    }\n\n                    \/\/ write headers.\n                    data[0] = \"pathway_id\";\n                    data[1] = \"from_stop_id\";\n                    data[2] = \"to_stop_id\";\n                    data[3] = \"pathway_mode\";\n                    data[4] = \"is_bidirectional\";\n                    data[5] = \"length\";\n                    data[6] = \"traversal_time\";\n                    data[7] = \"stair_count\";\n                    data[8] = \"max_slope\";\n                    data[9] = \"min_width\";\n                    data[10] = \"signposted_as\";\n                    data[11] = \"reversed_signposted_as\";\n                    pathwaysFile.Write(data);\n                    initialized = true;\n                }\n\n                \/\/ write pathway details.\n                data[0] = this.WriteFieldString(\"pathway\", \"pathway_id\", pathway.Id);\n                data[1] = this.WriteFieldString(\"pathway\", \"from_stop_id\", pathway.FromStopId);\n                data[2] = this.WriteFieldString(\"pathway\", \"to_stop_id\", pathway.ToStopId);\n                data[3] = this.WriteFieldPathwayMode(\"pathway\", \"pathway_mode\", pathway.PathwayMode);\n                data[4] = this.WriteFieldIsBidirectional(\"pathway\", \"is_bidirectional\", pathway.IsBidirectional);\n                data[5] = this.WriteFieldDouble(\"pathway\", \"length\", pathway.Length);\n                data[6] = this.WriteFieldInt(\"pathway\", \"traversal_time\", pathway.TraversalTime);\n                data[7] = this.WriteFieldInt(\"pathway\", \"stair_count\", pathway.StairCount);\n                data[8] = this.WriteFieldDouble(\"pathway\", \"max_slope\", pathway.MaxSlope);\n                data[9] = this.WriteFieldDouble(\"pathway\", \"min_width\", pathway.MinWidth);\n                data[10] = this.WriteFieldString(\"pathway\", \"signposted_as\", pathway.SignpostedAs);\n                data[11] = this.WriteFieldString(\"pathway\", \"reversed_signposted_as\", pathway.ReversedSignpostedAs);\n                pathwaysFile.Write(data);\n            }\n            pathwaysFile.Close();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes all agencies to the given agencies file.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"agenciesFile\"><\/param>\n        \/\/\/ <param name=\"agencies\"><\/param>\n        protected virtual void Write(IGTFSTargetFile agenciesFile, IEnumerable<Agency> agencies)\n        {\n            if (agenciesFile != null)\n            {\n                bool initialized = false;\n                var data = new string[8];\n                foreach (var agency in agencies)\n                {\n                    if (!initialized)\n                    {\n                        if (agenciesFile.Exists)\n                        {\n                            agenciesFile.Clear();\n                        }\n\n                        \/\/ write headers.\n                        data[0] = \"agency_id\";\n                        data[1] = \"agency_name\";\n                        data[2] = \"agency_url\";\n                        data[3] = \"agency_timezone\";\n                        data[4] = \"agency_lang\";\n                        data[5] = \"agency_phone\";\n                        data[6] = \"agency_fare_url\";\n                        data[7] = \"agency_email\";\n                        agenciesFile.Write(data);\n                        initialized = true;\n                    }\n\n                    \/\/ write details.\n                    data[0] = this.WriteFieldString(\"agency\", \"agency_id\", agency.Id);\n                    data[1] = this.WriteFieldString(\"agency\", \"agency_name\", agency.Name, true);\n                    data[2] = this.WriteFieldString(\"agency\", \"agency_url\", agency.URL);\n                    data[3] = this.WriteFieldString(\"agency\", \"agency_timezone\", agency.Timezone);\n                    data[4] = this.WriteFieldString(\"agency\", \"agency_lang\", agency.LanguageCode);\n                    data[5] = this.WriteFieldString(\"agency\", \"agency_phone\", agency.Phone);\n                    data[6] = this.WriteFieldString(\"agency\", \"agency_fare_url\", agency.FareURL);\n                    data[7] = this.WriteFieldString(\"agency\", \"agency_email\", agency.Email);\n                    agenciesFile.Write(data);\n                }\n                agenciesFile.Close();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes all calendar dates.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"file\"><\/param>\n        \/\/\/ <param name=\"entities\"><\/param>\n        protected virtual void Write(IGTFSTargetFile file, IEnumerable<CalendarDate> entities)\n        {\n            if (file != null)\n            {\n                bool initialized = false;\n                var data = new string[3];\n                foreach (var entity in entities)\n                {\n                    if (!initialized)\n                    {\n                        if (file.Exists)\n                        {\n                            file.Clear();\n                        }\n\n                        \/\/ write headers.\n                        data[0] = \"service_id\";\n                        data[1] = \"date\";\n                        data[2] = \"exception_type\";\n                        file.Write(data);\n                        initialized = true;\n                    }\n\n                    \/\/ write details.\n                    data[0] = this.WriteFieldString(\"calendar_dates\", \"service_id\", entity.ServiceId);\n                    data[1] = this.WriteFieldDate(\"calendar_dates\", \"date\", entity.Date);\n                    data[2] = this.WriteFieldExceptionType(\"calendar_dates\", \"exception_type\", entity.ExceptionType);\n                    file.Write(data);\n                }\n                file.Close();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the calenders to the calenders file.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"file\"><\/param>\n        \/\/\/ <param name=\"entities\"><\/param>\n        protected virtual void Write(IGTFSTargetFile file, IEnumerable<Calendar> entities)\n        {\n            if (file != null)\n            {\n                bool initialized = false;\n                var data = new string[10];\n                foreach (var entity in entities)\n                {\n                    if (!initialized)\n                    {\n                        if (file.Exists)\n                        {\n                            file.Clear();\n                        }\n\n                        \/\/ write headers.\n                        data[0] = \"service_id\";\n                        data[1] = \"monday\";\n                        data[2] = \"tuesday\";\n                        data[3] = \"wednesday\";\n                        data[4] = \"thursday\";\n                        data[5] = \"friday\";\n                        data[6] = \"saturday\";\n                        data[7] = \"sunday\";\n                        data[8] = \"start_date\";\n                        data[9] = \"end_date\";\n                        file.Write(data);\n                        initialized = true;\n                    }\n\n                    \/\/ write details.\n                    data[0] = this.WriteFieldString(\"calendar\", \"service_id\", entity.ServiceId);\n                    data[1] = this.WriteFieldBool(\"calendar\", \"monday\", entity.Monday);\n                    data[2] = this.WriteFieldBool(\"calendar\", \"tuesday\", entity.Tuesday);\n                    data[3] = this.WriteFieldBool(\"calendar\", \"wednesday\", entity.Wednesday);\n                    data[4] = this.WriteFieldBool(\"calendar\", \"thursday\", entity.Thursday);\n                    data[5] = this.WriteFieldBool(\"calendar\", \"friday\", entity.Friday);\n                    data[6] = this.WriteFieldBool(\"calendar\", \"saturday\", entity.Saturday);\n                    data[7] = this.WriteFieldBool(\"calendar\", \"sunday\", entity.Sunday);\n                    data[8] = this.WriteFieldDate(\"calendar\", \"start_date\", entity.StartDate);\n                    data[9] = this.WriteFieldDate(\"calendar\", \"end_date\", entity.EndDate);\n                    file.Write(data);\n                }\n                file.Close();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the fare attributes.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"file\"><\/param>\n        \/\/\/ <param name=\"entities\"><\/param>\n        protected virtual void Write(IGTFSTargetFile file, IEnumerable<FareAttribute> entities)\n        {\n            if (file != null)\n            {\n                bool initialized = false;\n                var data = new string[7];\n                foreach (var entity in entities)\n                {\n                    if (!initialized)\n                    {\n                        if (file.Exists)\n                        {\n                            file.Clear();\n                        }\n\n                        \/\/ write headers.\n                        data[0] = \"fare_id\";\n                        data[1] = \"price\";\n                        data[2] = \"currency_type\";\n                        data[3] = \"payment_method\";\n                        data[4] = \"transfers\";\n                        data[5] = \"agency_id\";\n                        data[6] = \"transfer_duration\";\n                        file.Write(data);\n                        initialized = true;\n                    }\n\n                    \/\/ write details.\n                    data[0] = this.WriteFieldString(\"fare_attributes\", \"fare_id\", entity.FareId);\n                    data[1] = this.WriteFieldString(\"fare_attributes\", \"price\", entity.Price);\n                    data[2] = this.WriteFieldString(\"fare_attributes\", \"currency_type\", entity.CurrencyType);\n                    data[3] = this.WriteFieldPaymentMethod(\"fare_attributes\", \"payment_method\", entity.PaymentMethod);\n                    data[4] = this.WriteFieldUint(\"fare_attributes\", \"transfers\", entity.Transfers);\n                    data[5] = this.WriteFieldString(\"fare_attributes\", \"agency_id\", entity.AgencyId);\n                    data[6] = this.WriteFieldString(\"fare_attributes\", \"transfer_duration\", entity.TransferDuration);\n                    file.Write(data);\n                }\n                file.Close();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the fare rules.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"file\"><\/param>\n        \/\/\/ <param name=\"entities\"><\/param>\n        protected virtual void Write(IGTFSTargetFile file, IEnumerable<FareRule> entities)\n        {\n            if (file != null)\n            {\n                bool initialized = false;\n                var data = new string[5];\n                foreach (var entity in entities)\n                {\n                    if (!initialized)\n                    {\n                        if (file.Exists)\n                        {\n                            file.Clear();\n                        }\n\n                        \/\/ write headers.\n                        data[0] = \"fare_id\";\n                        data[1] = \"route_id\";\n                        data[2] = \"origin_id\";\n                        data[3] = \"destination_id\";\n                        data[4] = \"contains_id\";\n                        file.Write(data);\n                        initialized = true;\n                    }\n\n                    \/\/ write details.\n                    data[0] = this.WriteFieldString(\"fare_rules\", \"fare_id\", entity.FareId);\n                    data[1] = this.WriteFieldString(\"fare_rules\", \"route_id\", entity.RouteId);\n                    data[2] = this.WriteFieldString(\"fare_rules\", \"origin_id\", entity.OriginId);\n                    data[3] = this.WriteFieldString(\"fare_rules\", \"destination_id\", entity.DestinationId);\n                    data[4] = this.WriteFieldString(\"fare_rules\", \"contains_id\", entity.ContainsId);\n                    file.Write(data);\n                }\n                file.Close();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the feed info.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"file\"><\/param>\n        \/\/\/ <param name=\"entity\"><\/param>\n        protected virtual void Write(IGTFSTargetFile file, FeedInfo entity)\n        {\n            if (file != null)\n            {\n                bool initialized = false;\n                var data = new string[6];\n                if (!initialized)\n                {\n                    if (file.Exists)\n                    {\n                        file.Clear();\n                    }\n\n                    \/\/ write headers.\n                    data[0] = \"feed_publisher_name\";\n                    data[1] = \"feed_publisher_url\";\n                    data[2] = \"feed_lang\";\n                    data[3] = \"feed_start_date\";\n                    data[4] = \"feed_end_date\";\n                    data[5] = \"feed_version\";\n                    file.Write(data);\n                    initialized = true;\n                }\n\n                \/\/ write details.\n                data[0] = this.WriteFieldString(\"feed_info\", \"feed_publisher_name\", entity.PublisherName, true);\n                data[1] = this.WriteFieldString(\"feed_info\", \"feed_publisher_url\", entity.PublisherUrl, true);\n                data[2] = this.WriteFieldString(\"feed_info\", \"feed_lang\", entity.Lang);\n                data[3] = this.WriteFieldString(\"feed_info\", \"feed_start_date\", entity.StartDate);\n                data[4] = this.WriteFieldString(\"feed_info\", \"feed_end_date\", entity.EndDate);\n                data[5] = this.WriteFieldString(\"feed_info\", \"feed_version\", entity.Version);\n                file.Write(data);\n                file.Close();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the frequencies.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"file\"><\/param>\n        \/\/\/ <param name=\"entities\"><\/param>\n        protected virtual void Write(IGTFSTargetFile file, IEnumerable<Frequency> entities)\n        {\n            if (file != null)\n            {\n                bool initialized = false;\n                var data = new string[5];\n                foreach (var entity in entities)\n                {\n                    if (!initialized)\n                    {\n                        if (file.Exists)\n                        {\n                            file.Clear();\n                        }\n\n                        \/\/ write headers.\n                        data[0] = \"trip_id\";\n                        data[1] = \"start_time\";\n                        data[2] = \"end_time\";\n                        data[3] = \"headway_secs\";\n                        data[4] = \"exact_times\";\n                        file.Write(data);\n                        initialized = true;\n                    }\n\n                    \/\/ write details.\n                    data[0] = this.WriteFieldString(\"frequency\", \"trip_id\", entity.TripId);\n                    data[1] = this.WriteFieldString(\"frequency\", \"start_time\", entity.StartTime);\n                    data[2] = this.WriteFieldString(\"frequency\", \"end_time\", entity.EndTime);\n                    data[3] = this.WriteFieldString(\"frequency\", \"headway_secs\", entity.HeadwaySecs);\n                    data[4] = this.WriteFieldBool(\"frequency\", \"exact_times\", entity.ExactTimes);\n                    file.Write(data);\n                }\n                file.Close();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the routes.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"file\"><\/param>\n        \/\/\/ <param name=\"entities\"><\/param>\n        protected virtual void Write(IGTFSTargetFile file, IEnumerable<Route> entities)\n        {\n            if (file != null)\n            {\n                bool initialized = false;\n                var data = new string[9];\n                foreach (var entity in entities)\n                {\n                    if (!initialized)\n                    {\n                        if (file.Exists)\n                        {\n                            file.Clear();\n                        }\n\n                        \/\/ write headers.\n                        data[0] = \"route_id\";\n                        data[1] = \"agency_id\";\n                        data[2] = \"route_short_name\";\n                        data[3] = \"route_long_name\";\n                        data[4] = \"route_desc\";\n                        data[5] = \"route_type\";\n                        data[6] = \"route_url\";\n                        data[7] = \"route_color\";\n                        data[8] = \"route_text_color\";\n                        file.Write(data);\n                        initialized = true;\n                    }\n\n                    \/\/ write details.\n                    data[0] = this.WriteFieldString(\"routes\", \"route_id\", entity.Id);\n                    data[1] = this.WriteFieldString(\"routes\", \"agency_id\", entity.AgencyId);\n                    data[2] = this.WriteFieldString(\"routes\", \"route_short_name\", entity.ShortName, true);\n                    data[3] = this.WriteFieldString(\"routes\", \"route_long_name\", entity.LongName, true);\n                    data[4] = this.WriteFieldString(\"routes\", \"route_desc\", entity.Description);\n                    data[5] = this.WriteFieldRouteType(\"routes\", \"route_type\", entity.Type);\n                    data[6] = this.WriteFieldString(\"routes\", \"route_url\", entity.Url);\n                    data[7] = this.WriteFieldColor(\"routes\", \"route_color\", entity.Color);\n                    data[8] = this.WriteFieldColor(\"routes\", \"route_text_color\", entity.TextColor);\n                    file.Write(data);\n                }\n                file.Close();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the shapes.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"file\"><\/param>\n        \/\/\/ <param name=\"entities\"><\/param>\n        protected virtual void Write(IGTFSTargetFile file, IEnumerable<Shape> entities)\n        {\n            if (file != null)\n            {\n                bool initialized = false;\n                var data = new string[5];\n                foreach (var entity in entities)\n                {\n                    if (!initialized)\n                    {\n                        if (file.Exists)\n                        {\n                            file.Clear();\n                        }\n\n                        \/\/ write headers.\n                        data[0] = \"shape_id\";\n                        data[1] = \"shape_pt_lat\";\n                        data[2] = \"shape_pt_lon\";\n                        data[3] = \"shape_pt_sequence\";\n                        data[4] = \"shape_dist_traveled\";\n                        file.Write(data);\n                        initialized = true;\n                    }\n\n                    \/\/ write details.\n                    data[0] = this.WriteFieldString(\"shapes\", \"shape_id\", entity.Id);\n                    data[1] = this.WriteFieldDouble(\"shapes\", \"shape_pt_lat\", entity.Latitude);\n                    data[2] = this.WriteFieldDouble(\"shapes\", \"shape_pt_lon\", entity.Longitude);\n                    data[3] = this.WriteFieldUint(\"shapes\", \"shape_pt_sequence\", entity.Sequence);\n                    data[4] = this.WriteFieldDouble(\"shapes\", \"shape_dist_traveled\", entity.DistanceTravelled);\n                    file.Write(data);\n                }\n                file.Close();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the stops.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"file\"><\/param>\n        \/\/\/ <param name=\"entities\"><\/param>\n        protected virtual void Write(IGTFSTargetFile file, IEnumerable<Stop> entities)\n        {\n            if (file != null)\n            {\n                bool initialized = false;\n                var data = new string[14];\n                foreach (var entity in entities)\n                {\n                    if (!initialized)\n                    {\n                        if (file.Exists)\n                        {\n                            file.Clear();\n                        }\n\n                        \/\/ write headers.\n                        data[0] = \"stop_id\";\n                        data[1] = \"stop_code\";\n                        data[2] = \"stop_name\";\n                        data[3] = \"stop_desc\";\n                        data[4] = \"stop_lat\";\n                        data[5] = \"stop_lon\";\n                        data[6] = \"zone_id\";\n                        data[7] = \"stop_url\";\n                        data[8] = \"location_type\";\n                        data[9] = \"parent_station\";\n                        data[10] = \"stop_timezone\";\n                        data[11] = \"wheelchair_boarding\";\n                        data[12] = \"level_id\";\n                        data[13] = \"platform_code\";\n                        file.Write(data);\n                        initialized = true;\n                    }\n\n                    \/\/ write details.\n                    data[0] = this.WriteFieldString(\"stops\", \"stop_id\", entity.Id);\n                    data[1] = this.WriteFieldString(\"stops\", \"stop_code\", entity.Code);\n                    data[2] = this.WriteFieldString(\"stops\", \"stop_name\", entity.Name, true);\n                    data[3] = this.WriteFieldString(\"stops\", \"stop_desc\", entity.Description, true);\n                    data[4] = this.WriteFieldDouble(\"stops\", \"stop_lat\", entity.Latitude);\n                    data[5] = this.WriteFieldDouble(\"stops\", \"stop_lon\", entity.Longitude);\n                    data[6] = this.WriteFieldString(\"stops\", \"zone_id\", entity.Zone);\n                    data[7] = this.WriteFieldString(\"stops\", \"stop_url\", entity.Url);\n                    data[8] = this.WriteFieldLocationType(\"stops\", \"location_type\", entity.LocationType);\n                    data[9] = this.WriteFieldString(\"stops\", \"parent_station\", entity.ParentStation);\n                    data[10] = this.WriteFieldString(\"stops\", \"stop_timezone\", entity.Timezone);\n                    data[11] = this.WriteFieldString(\"stops\", \"wheelchair_boarding\", entity.WheelchairBoarding);\n                    data[12] = this.WriteFieldString(\"stops\", \"level_id\", entity.LevelId);\n                    data[13] = this.WriteFieldString(\"stops\", \"platform_code\", entity.PlatformCode);\n                    file.Write(data);\n                }\n                file.Close();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the stop times.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"file\"><\/param>\n        \/\/\/ <param name=\"entities\"><\/param>\n        protected virtual void Write(IGTFSTargetFile file, IEnumerable<StopTime> entities)\n        {\n            if (file != null)\n            {\n                bool initialized = false;\n                var data = new string[10];\n                foreach (var entity in entities)\n                {\n                    if (!initialized)\n                    {\n                        if (file.Exists)\n                        {\n                            file.Clear();\n                        }\n\n                        \/\/ write headers.\n                        data[0] = \"trip_id\";\n                        data[1] = \"arrival_time\";\n                        data[2] = \"departure_time\";\n                        data[3] = \"stop_id\";\n                        data[4] = \"stop_sequence\";\n                        data[5] = \"stop_headsign\";\n                        data[6] = \"pickup_type\";\n                        data[7] = \"drop_off_type\";\n                        data[8] = \"shape_dist_traveled\";\n                        data[9] = \"timepoint\";\n                        file.Write(data);\n                        initialized = true;\n                    }\n\n                    \/\/ write details.\n                    data[0] = this.WriteFieldString(\"stop_times\", \"trip_id\", entity.TripId);\n                    data[1] = this.WriteFieldTimeOfDay(\"stop_times\", \"arrival_time\", entity.ArrivalTime);\n                    data[2] = this.WriteFieldTimeOfDay(\"stop_times\", \"departure_time\", entity.DepartureTime);\n                    data[3] = this.WriteFieldString(\"stop_times\", \"stop_id\", entity.StopId);\n                    data[4] = this.WriteFieldUint(\"stop_times\", \"stop_sequence\", entity.StopSequence);\n                    data[5] = this.WriteFieldString(\"stop_times\", \"stop_headsign\", entity.StopHeadsign, true);\n                    data[6] = this.WriteFieldPickupType(\"stop_times\", \"pickup_type\", entity.PickupType);\n                    data[7] = this.WriteFieldDropOffType(\"stop_times\", \"drop_off_type\", entity.DropOffType);\n                    data[8] = this.WriteFieldDouble(\"stop_times\", \"shape_dist_traveled\", entity.ShapeDistTravelled);\n                    data[9] = this.WriteFieldTimepointType(\"stop_times\", \"timepoint\", entity.TimepointType);\n                    file.Write(data);\n                }\n                file.Close();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the transfers.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"file\"><\/param>\n        \/\/\/ <param name=\"entities\"><\/param>\n        protected virtual void Write(IGTFSTargetFile file, IEnumerable<Transfer> entities)\n        {\n            if (file != null)\n            {\n                bool initialized = false;\n                var data = new string[4];\n                foreach (var entity in entities)\n                {\n                    if (!initialized)\n                    {\n                        if (file.Exists)\n                        {\n                            file.Clear();\n                        }\n\n                        \/\/ write headers.\n                        data[0] = \"from_stop_id\";\n                        data[1] = \"to_stop_id\";\n                        data[2] = \"transfer_type\";\n                        data[3] = \"min_transfer_time\";\n                        file.Write(data);\n                        initialized = true;\n                    }\n\n                    \/\/ write details.\n                    data[0] = this.WriteFieldString(\"transfers\", \"from_stop_id\", entity.FromStopId);\n                    data[1] = this.WriteFieldString(\"transfers\", \"to_stop_id\", entity.ToStopId);\n                    data[2] = this.WriteFieldTransferType(\"transfers\", \"transfer_type\", entity.TransferType);\n                    data[3] = this.WriteFieldString(\"transfers\", \"min_transfer_time\", entity.MinimumTransferTime);\n                    file.Write(data);\n                }\n                file.Close();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the trips.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"file\"><\/param>\n        \/\/\/ <param name=\"entities\"><\/param>\n        protected virtual void Write(IGTFSTargetFile file, IEnumerable<Trip> entities)\n        {\n            if (file != null)\n            {\n                bool initialized = false;\n                var data = new string[9];\n                foreach (var entity in entities)\n                {\n                    if (!initialized)\n                    {\n                        if (file.Exists)\n                        {\n                            file.Clear();\n                        }\n\n                        \/\/ write headers.\n                        data[0] = \"trip_id\";\n                        data[1] = \"route_id\";\n                        data[2] = \"service_id\";\n                        data[3] = \"trip_headsign\";\n                        data[4] = \"trip_short_name\";\n                        data[5] = \"direction_id\";\n                        data[6] = \"block_id\";\n                        data[7] = \"shape_id\";\n                        data[8] = \"wheelchair_accessible\";\n                        file.Write(data);\n                        initialized = true;\n                    }\n\n                    \/\/ write details.\n                    data[0] = this.WriteFieldString(\"trips\", \"trip_id\", entity.Id);\n                    data[1] = this.WriteFieldString(\"trips\", \"route_id\", entity.RouteId);\n                    data[2] = this.WriteFieldString(\"trips\", \"service_id\", entity.ServiceId);\n                    data[3] = this.WriteFieldString(\"trips\", \"trip_headsign\", entity.Headsign);\n                    data[4] = this.WriteFieldString(\"trips\", \"trip_short_name\", entity.ShortName, true);\n                    data[5] = this.WriteFieldDirectionType(\"trips\", \"direction_id\", entity.Direction);\n                    data[6] = this.WriteFieldString(\"trips\", \"block_id\", entity.BlockId);\n                    data[7] = this.WriteFieldString(\"trips\", \"shape_id\", entity.ShapeId);\n                    data[8] = this.WriteFieldAccessibilityType(\"trips\", \"wheelchair_accessible\", entity.AccessibilityType);\n                    file.Write(data);\n                }\n                file.Close();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes a string-field.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected virtual string WriteFieldString(string name, string fieldName, string value)\n        {\n            var quote = !string.IsNullOrWhiteSpace(value) && value.Contains(\",\");\n            return this.WriteFieldString(name, fieldName, value, quote);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes a string-field.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <param name=\"quote\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected virtual string WriteFieldString(string name, string fieldName, string value, bool quote)\n        {\n            value = value.Replace(\"\\\"\", \"\\\"\\\"\");\n            if (quote)\n            { \/\/ quotes.\n                var valueBuilder = new StringBuilder();\n                valueBuilder.Append('\"');\n                valueBuilder.Append(value);\n                valueBuilder.Append('\"');\n                return valueBuilder.ToString();\n            }\n            return value;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the exception type.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldExceptionType(string name, string fieldName, ExceptionType value)\n        {\n            \/\/A value of 1 indicates that service has been added for the specified date.\n            \/\/A value of 2 indicates that service has been removed for the specified date.\n\n            switch (value)\n            {\n                case ExceptionType.Added:\n                    return \"1\";\n                case ExceptionType.Removed:\n                    return \"2\";\n            }\n            return string.Empty;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the date.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"dateTime\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldDate(string name, string fieldName, DateTime dateTime)\n        {\n            return dateTime.ToString(\"yyyyMMdd\");\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the bool.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldBool(string name, string fieldName, bool? value)\n        {\n            if (value.HasValue)\n            {\n                if (value.Value)\n                {\n                    return \"1\";\n                }\n                return \"0\";\n            }\n            return string.Empty;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the uint.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldUint(string name, string fieldName, uint? value)\n        {\n            if (value.HasValue)\n            {\n                return value.Value.ToString();\n            }\n            return string.Empty;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the payment method.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldPaymentMethod(string name, string fieldName, PaymentMethodType value)\n        {\n            \/\/0 - Fare is paid on board.\n            \/\/1 - Fare must be paid before boarding.\n\n            switch (value)\n            {\n                case PaymentMethodType.OnBoard:\n                    return \"0\";\n                case PaymentMethodType.BeforeBoarding:\n                    return \"1\";\n            }\n            return string.Empty;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes a color.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldColor(string name, string fieldName, int? value)\n        {\n            return value.ToHexColorString();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the route type.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns><\/returns>\n        private string WriteFieldRouteType(string name, string fieldName, RouteTypeExtended value)\n        {\n            return ((int)value).ToString();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes a double.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldDouble(string name, string fieldName, double? value)\n        {\n            if (value.HasValue)\n            {\n                return value.Value.ToString(System.Globalization.CultureInfo.InvariantCulture);\n            }\n            return string.Empty;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes an int.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldInt(string name, string fieldName, int? value)\n        {\n            if (value.HasValue)\n            {\n                return value.Value.ToString(System.Globalization.CultureInfo.InvariantCulture);\n            }\n            return string.Empty;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the location type.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldLocationType(string name, string fieldName, LocationType? value)\n        {\n            if (value.HasValue)\n            {\n                switch (value.Value)\n                {\n                    case LocationType.Stop:\n                        return \"0\";\n                    case LocationType.Station:\n                        return \"1\";\n                }\n            }\n            return string.Empty;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the drop off type.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldDropOffType(string name, string fieldName, DropOffType? value)\n        {\n            if (value.HasValue)\n            {\n                switch (value.Value)\n                {\n                    case DropOffType.Regular:\n                        return \"0\";\n                    case DropOffType.NoPickup:\n                        return \"1\";\n                    case DropOffType.PhoneForPickup:\n                        return \"2\";\n                    case DropOffType.DriverForPickup:\n                        return \"3\";\n                }\n            }\n            return string.Empty;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the timepoint value.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldTimepointType(string name, string fieldName, TimePointType value)\n        {\n            switch (value)\n            {\n                case TimePointType.Approximate:\n                    return \"0\";\n                case TimePointType.Exact:\n                    return \"1\";\n            }\n            return string.Empty;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the pickup type.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldPickupType(string name, string fieldName, PickupType? value)\n        {\n            if (value.HasValue)\n            {\n                switch (value.Value)\n                {\n                    case PickupType.Regular:\n                        return \"0\";\n                    case PickupType.NoPickup:\n                        return \"1\";\n                    case PickupType.PhoneForPickup:\n                        return \"2\";\n                    case PickupType.DriverForPickup:\n                        return \"3\";\n                }\n            }\n            return string.Empty;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes a timeofday.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldTimeOfDay(string name, string fieldName, TimeOfDay? value)\n        {\n            if (!value.HasValue)\n            {\n                return string.Empty;\n            }\n            return string.Format(\"{0}:{1}:{2}\",\n                value.Value.Hours.ToString(\"00\"),\n                value.Value.Minutes.ToString(\"00\"),\n                value.Value.Seconds.ToString(\"00\"));\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes a transfertime.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldTransferType(string name, string fieldName, TransferType value)\n        {\n            switch (value)\n            {\n                case TransferType.Recommended:\n                    return \"0\";\n                case TransferType.TimedTransfer:\n                    return \"1\";\n                case TransferType.MinimumTime:\n                    return \"2\";\n                case TransferType.NotPossible:\n                    return \"3\";\n            }\n\n            return string.Empty;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes an accessibility type.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldAccessibilityType(string name, string fieldName, WheelchairAccessibilityType? value)\n        {\n            if (value.HasValue)\n            {\n                \/\/0 (or empty) - indicates that there is no accessibility information for the trip\n                \/\/1 - indicates that the vehicle being used on this particular trip can accommodate at least one rider in a wheelchair\n                \/\/2 - indicates that no riders in wheelchairs can be accommodated on this trip\n\n                switch (value.Value)\n                {\n                    case WheelchairAccessibilityType.NoInformation:\n                        return \"0\";\n                    case WheelchairAccessibilityType.SomeAccessibility:\n                        return \"1\";\n                    case WheelchairAccessibilityType.NoAccessibility:\n                        return \"2\";\n                }\n            }\n            return string.Empty;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes is bidirectional.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldIsBidirectional(string name, string fieldName, IsBidirectional? value)\n        {\n            if (value.HasValue)\n            {\n                \/\/0: Unidirectional pathway, it can only be used from from_stop_id to to_stop_id.\n                \/\/1: Bidirectional pathway, it can be used in the two directions.\n\n                switch (value.Value)\n                {\n                    case IsBidirectional.Unidirectional:\n                        return \"0\";\n                    case IsBidirectional.Bidirectional:\n                        return \"1\";\n                }\n            }\n            return string.Empty;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes a pathway mode.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldPathwayMode(string name, string fieldName, PathwayMode? value)\n        {\n            if (value.HasValue)\n            {\n                \/\/1 - walkway\n                \/\/2 - stairs\n                \/\/3 - moving sidewalk\/travelator\n                \/\/4 - escalator\n                \/\/5 - elevator\n                \/\/6 - fare gate (or payment gate): A pathway that crosses into an area of the station where a proof of payment is required (usually via a physical payment gate).\n                \/\/7 - exit gate: Indicates a pathway exiting an area where proof-of-payment is required into an area where proof-of-payment is no longer required.\n\n                switch (value.Value)\n                {\n                    case PathwayMode.Walkway:\n                        return \"1\";\n                    case PathwayMode.Stairs:\n                        return \"2\";\n                    case PathwayMode.Travelator:\n                        return \"3\";\n                    case PathwayMode.Escalator:\n                        return \"4\";\n                    case PathwayMode.Elevator:\n                        return \"5\";\n                    case PathwayMode.FareGate:\n                        return \"6\";\n                    case PathwayMode.ExitGate:\n                        return \"7\";\n                }\n            }\n            return string.Empty;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes a direction type.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldDirectionType(string name, string fieldName, DirectionType? value)\n        {\n            if (value.HasValue)\n            {\n\n                \/\/0 - travel in one direction (e.g. outbound travel)\n                \/\/1 - travel in the opposite direction (e.g. inbound travel)\n\n                switch (value.Value)\n                {\n                    case DirectionType.OneDirection:\n                        return \"0\";\n                    case DirectionType.OppositeDirection:\n                        return \"1\";\n                }\n            }\n            return string.Empty;\n        }\n    }\n}\n","old_contents":"\ufeff\/\/ The MIT License (MIT)\n\n\/\/ Copyright (c) 2014 Ben Abelshausen\n\n\/\/ Permission is hereby granted, free of charge, to any person obtaining a copy\n\/\/ of this software and associated documentation files (the \"Software\"), to deal\n\/\/ in the Software without restriction, including without limitation the rights\n\/\/ to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\n\/\/ copies of the Software, and to permit persons to whom the Software is\n\/\/ furnished to do so, subject to the following conditions:\n\n\/\/ The above copyright notice and this permission notice shall be included in\n\/\/ all copies or substantial portions of the Software.\n\n\/\/ THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\/\/ IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\/\/ FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\/\/ AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\/\/ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\/\/ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\/\/ THE SOFTWARE.\n\nusing GTFS.IO;\nusing System.Linq;\nusing System.Collections.Generic;\nusing GTFS.Entities;\nusing GTFS.Entities.Enumerations;\nusing System;\nusing System.Text;\n\nnamespace GTFS\n{\n    \/\/\/ <summary>\n    \/\/\/ A GTFS writer.\n    \/\/\/ <\/summary>\n    \/\/\/ <typeparam name=\"T\"><\/typeparam>\n    public class GTFSWriter<T> where T : IGTFSFeed\n    {\n        \/\/\/ <summary>\n        \/\/\/ Writes the given feed to the given target files.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"feed\"><\/param>\n        \/\/\/ <param name=\"target\"><\/param>\n        public void Write(T feed, IEnumerable<IGTFSTargetFile> target)\n        {\n            \/\/ order files by id\n            var agenciesToWrite = feed.Agencies.OrderBy(x => x.Id).ToList();\n            var calendarDatesToWrite = feed.CalendarDates.OrderBy(x => x.ServiceId).OrderBy(y => y.ExceptionType).OrderBy(z => z.Date).ToList();\n            var calendarsToWrite = feed.Calendars.OrderBy(x => x.ServiceId).ToList();\n            var fareAttributesToWrite = feed.FareAttributes.OrderBy(x => x.FareId).ToList();\n            var fareRulesToWrite = feed.FareRules.OrderBy(x => x.RouteId).ToList();\n            var frequenciesToWrite = feed.Frequencies.OrderBy(x => x.TripId).ToList();\n            var routesToWrite = feed.Routes.OrderBy(x => x.Id).ToList();\n            var stopsToWrite = feed.Stops.OrderBy(x => x.Id).ToList();\n            var stopTimesToWrite = feed.StopTimes.OrderBy(x => x.TripId).ToList();\n            var tripsToWrite = feed.Trips.OrderBy(x => x.Id).ToList();\n            var levelsToWrite = feed.Levels.OrderBy(x => x.Id).ToList();\n            var pathwaysToWrite = feed.Pathways.OrderBy(x => x.Id).ToList();\n\n            \/\/ write files on-by-one.\n            this.Write(target.FirstOrDefault<IGTFSTargetFile>((x) => x.Name == \"agency\"), agenciesToWrite);\n            this.Write(target.FirstOrDefault<IGTFSTargetFile>((x) => x.Name == \"calendar_dates\"), calendarDatesToWrite);\n            this.Write(target.FirstOrDefault<IGTFSTargetFile>((x) => x.Name == \"calendar\"), calendarsToWrite);\n            this.Write(target.FirstOrDefault<IGTFSTargetFile>((x) => x.Name == \"fare_attributes\"), fareAttributesToWrite);\n            this.Write(target.FirstOrDefault<IGTFSTargetFile>((x) => x.Name == \"fare_rules\"), fareRulesToWrite);\n            this.Write(target.FirstOrDefault<IGTFSTargetFile>((x) => x.Name == \"feed_info\"), feed.GetFeedInfo());\n            this.Write(target.FirstOrDefault<IGTFSTargetFile>((x) => x.Name == \"frequencies\"), frequenciesToWrite);\n            this.Write(target.FirstOrDefault<IGTFSTargetFile>((x) => x.Name == \"routes\"), routesToWrite);\n            this.Write(target.FirstOrDefault<IGTFSTargetFile>((x) => x.Name == \"shapes\"), feed.Shapes);\n            this.Write(target.FirstOrDefault<IGTFSTargetFile>((x) => x.Name == \"stops\"), stopsToWrite);\n            this.Write(target.FirstOrDefault<IGTFSTargetFile>((x) => x.Name == \"stop_times\"), stopTimesToWrite);\n            this.Write(target.FirstOrDefault<IGTFSTargetFile>((x) => x.Name == \"transfers\"), feed.Transfers);\n            this.Write(target.FirstOrDefault<IGTFSTargetFile>((x) => x.Name == \"trips\"), tripsToWrite);\n            this.Write(target.FirstOrDefault<IGTFSTargetFile>((x) => x.Name == \"levels\"), levelsToWrite);\n            this.Write(target.FirstOrDefault<IGTFSTargetFile>((x) => x.Name == \"pathways\"), pathwaysToWrite);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes all levels to the given levels file.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"levelsFile\"><\/param>\n        \/\/\/ <param name=\"levels\"><\/param>\n        protected virtual void Write(IGTFSTargetFile levelsFile, IEnumerable<Level> levels)\n        {\n            if (levelsFile == null) return;\n            \n            bool initialized = false;\n            var data = new string[3];\n            foreach (var level in levels)\n            {\n                if (!initialized)\n                {\n                    if (levelsFile.Exists)\n                    {\n                        levelsFile.Clear();\n                    }\n\n                    \/\/ write headers.\n                    data[0] = \"level_id\";\n                    data[1] = \"level_index\";\n                    data[2] = \"level_name\";\n                    levelsFile.Write(data);\n                    initialized = true;\n                }\n\n                \/\/ write level details.\n                data[0] = this.WriteFieldString(\"level\", \"level_id\", level.Id);\n                data[1] = this.WriteFieldDouble(\"level\", \"level_index\", level.Index);\n                data[2] = this.WriteFieldString(\"level\", \"level_name\", level.Name, true);\n                levelsFile.Write(data);\n            }\n            levelsFile.Close();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes all pathways to the given pathways file.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"pathwaysFile\"><\/param>\n        \/\/\/ <param name=\"pathways\"><\/param>\n        protected virtual void Write(IGTFSTargetFile pathwaysFile, IEnumerable<Pathway> pathways)\n        {\n            if (pathwaysFile == null) return;\n            \n            bool initialized = false;\n            var data = new string[12];\n            foreach (var pathway in pathways)\n            {\n                if (!initialized)\n                {\n                    if (pathwaysFile.Exists)\n                    {\n                        pathwaysFile.Clear();\n                    }\n\n                    \/\/ write headers.\n                    data[0] = \"pathway_id\";\n                    data[1] = \"from_stop_id\";\n                    data[2] = \"to_stop_id\";\n                    data[3] = \"pathway_mode\";\n                    data[4] = \"is_bidirectional\";\n                    data[5] = \"length\";\n                    data[6] = \"traversal_time\";\n                    data[7] = \"stair_count\";\n                    data[8] = \"max_slope\";\n                    data[9] = \"min_width\";\n                    data[10] = \"signposted_as\";\n                    data[11] = \"reversed_signposted_as\";\n                    pathwaysFile.Write(data);\n                    initialized = true;\n                }\n\n                \/\/ write pathway details.\n                data[0] = this.WriteFieldString(\"pathway\", \"pathway_id\", pathway.Id);\n                data[1] = this.WriteFieldString(\"pathway\", \"from_stop_id\", pathway.FromStopId);\n                data[2] = this.WriteFieldString(\"pathway\", \"to_stop_id\", pathway.ToStopId);\n                data[3] = this.WriteFieldPathwayMode(\"pathway\", \"pathway_mode\", pathway.PathwayMode);\n                data[4] = this.WriteFieldIsBidirectional(\"pathway\", \"is_bidirectional\", pathway.IsBidirectional);\n                data[5] = this.WriteFieldDouble(\"pathway\", \"length\", pathway.Length);\n                data[6] = this.WriteFieldInt(\"pathway\", \"traversal_time\", pathway.TraversalTime);\n                data[7] = this.WriteFieldInt(\"pathway\", \"stair_count\", pathway.StairCount);\n                data[8] = this.WriteFieldDouble(\"pathway\", \"max_slope\", pathway.MaxSlope);\n                data[9] = this.WriteFieldDouble(\"pathway\", \"min_width\", pathway.MinWidth);\n                data[10] = this.WriteFieldString(\"pathway\", \"signposted_as\", pathway.SignpostedAs);\n                data[11] = this.WriteFieldString(\"pathway\", \"reversed_signposted_as\", pathway.ReversedSignpostedAs);\n                pathwaysFile.Write(data);\n            }\n            pathwaysFile.Close();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes all agencies to the given agencies file.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"agenciesFile\"><\/param>\n        \/\/\/ <param name=\"agencies\"><\/param>\n        protected virtual void Write(IGTFSTargetFile agenciesFile, IEnumerable<Agency> agencies)\n        {\n            if (agenciesFile != null)\n            {\n                bool initialized = false;\n                var data = new string[8];\n                foreach (var agency in agencies)\n                {\n                    if (!initialized)\n                    {\n                        if (agenciesFile.Exists)\n                        {\n                            agenciesFile.Clear();\n                        }\n\n                        \/\/ write headers.\n                        data[0] = \"agency_id\";\n                        data[1] = \"agency_name\";\n                        data[2] = \"agency_url\";\n                        data[3] = \"agency_timezone\";\n                        data[4] = \"agency_lang\";\n                        data[5] = \"agency_phone\";\n                        data[6] = \"agency_fare_url\";\n                        data[7] = \"agency_email\";\n                        agenciesFile.Write(data);\n                        initialized = true;\n                    }\n\n                    \/\/ write details.\n                    data[0] = this.WriteFieldString(\"agency\", \"agency_id\", agency.Id);\n                    data[1] = this.WriteFieldString(\"agency\", \"agency_name\", agency.Name, true);\n                    data[2] = this.WriteFieldString(\"agency\", \"agency_url\", agency.URL);\n                    data[3] = this.WriteFieldString(\"agency\", \"agency_timezone\", agency.Timezone);\n                    data[4] = this.WriteFieldString(\"agency\", \"agency_lang\", agency.LanguageCode);\n                    data[5] = this.WriteFieldString(\"agency\", \"agency_phone\", agency.Phone);\n                    data[6] = this.WriteFieldString(\"agency\", \"agency_fare_url\", agency.FareURL);\n                    data[7] = this.WriteFieldString(\"agency\", \"agency_email\", agency.Email);\n                    agenciesFile.Write(data);\n                }\n                agenciesFile.Close();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes all calendar dates.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"file\"><\/param>\n        \/\/\/ <param name=\"entities\"><\/param>\n        protected virtual void Write(IGTFSTargetFile file, IEnumerable<CalendarDate> entities)\n        {\n            if (file != null)\n            {\n                bool initialized = false;\n                var data = new string[3];\n                foreach (var entity in entities)\n                {\n                    if (!initialized)\n                    {\n                        if (file.Exists)\n                        {\n                            file.Clear();\n                        }\n\n                        \/\/ write headers.\n                        data[0] = \"service_id\";\n                        data[1] = \"date\";\n                        data[2] = \"exception_type\";\n                        file.Write(data);\n                        initialized = true;\n                    }\n\n                    \/\/ write details.\n                    data[0] = this.WriteFieldString(\"calendar_dates\", \"service_id\", entity.ServiceId);\n                    data[1] = this.WriteFieldDate(\"calendar_dates\", \"date\", entity.Date);\n                    data[2] = this.WriteFieldExceptionType(\"calendar_dates\", \"exception_type\", entity.ExceptionType);\n                    file.Write(data);\n                }\n                file.Close();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the calenders to the calenders file.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"file\"><\/param>\n        \/\/\/ <param name=\"entities\"><\/param>\n        protected virtual void Write(IGTFSTargetFile file, IEnumerable<Calendar> entities)\n        {\n            if (file != null)\n            {\n                bool initialized = false;\n                var data = new string[10];\n                foreach (var entity in entities)\n                {\n                    if (!initialized)\n                    {\n                        if (file.Exists)\n                        {\n                            file.Clear();\n                        }\n\n                        \/\/ write headers.\n                        data[0] = \"service_id\";\n                        data[1] = \"monday\";\n                        data[2] = \"tuesday\";\n                        data[3] = \"wednesday\";\n                        data[4] = \"thursday\";\n                        data[5] = \"friday\";\n                        data[6] = \"saturday\";\n                        data[7] = \"sunday\";\n                        data[8] = \"start_date\";\n                        data[9] = \"end_date\";\n                        file.Write(data);\n                        initialized = true;\n                    }\n\n                    \/\/ write details.\n                    data[0] = this.WriteFieldString(\"calendar\", \"service_id\", entity.ServiceId);\n                    data[1] = this.WriteFieldBool(\"calendar\", \"monday\", entity.Monday);\n                    data[2] = this.WriteFieldBool(\"calendar\", \"tuesday\", entity.Tuesday);\n                    data[3] = this.WriteFieldBool(\"calendar\", \"wednesday\", entity.Wednesday);\n                    data[4] = this.WriteFieldBool(\"calendar\", \"thursday\", entity.Thursday);\n                    data[5] = this.WriteFieldBool(\"calendar\", \"friday\", entity.Friday);\n                    data[6] = this.WriteFieldBool(\"calendar\", \"saturday\", entity.Saturday);\n                    data[7] = this.WriteFieldBool(\"calendar\", \"sunday\", entity.Sunday);\n                    data[8] = this.WriteFieldDate(\"calendar\", \"start_date\", entity.StartDate);\n                    data[9] = this.WriteFieldDate(\"calendar\", \"end_date\", entity.EndDate);\n                    file.Write(data);\n                }\n                file.Close();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the fare attributes.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"file\"><\/param>\n        \/\/\/ <param name=\"entities\"><\/param>\n        protected virtual void Write(IGTFSTargetFile file, IEnumerable<FareAttribute> entities)\n        {\n            if (file != null)\n            {\n                bool initialized = false;\n                var data = new string[7];\n                foreach (var entity in entities)\n                {\n                    if (!initialized)\n                    {\n                        if (file.Exists)\n                        {\n                            file.Clear();\n                        }\n\n                        \/\/ write headers.\n                        data[0] = \"fare_id\";\n                        data[1] = \"price\";\n                        data[2] = \"currency_type\";\n                        data[3] = \"payment_method\";\n                        data[4] = \"transfers\";\n                        data[5] = \"agency_id\";\n                        data[6] = \"transfer_duration\";\n                        file.Write(data);\n                        initialized = true;\n                    }\n\n                    \/\/ write details.\n                    data[0] = this.WriteFieldString(\"fare_attributes\", \"fare_id\", entity.FareId);\n                    data[1] = this.WriteFieldString(\"fare_attributes\", \"price\", entity.Price);\n                    data[2] = this.WriteFieldString(\"fare_attributes\", \"currency_type\", entity.CurrencyType);\n                    data[3] = this.WriteFieldPaymentMethod(\"fare_attributes\", \"payment_method\", entity.PaymentMethod);\n                    data[4] = this.WriteFieldUint(\"fare_attributes\", \"transfers\", entity.Transfers);\n                    data[5] = this.WriteFieldString(\"fare_attributes\", \"agency_id\", entity.AgencyId);\n                    data[6] = this.WriteFieldString(\"fare_attributes\", \"transfer_duration\", entity.TransferDuration);\n                    file.Write(data);\n                }\n                file.Close();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the fare rules.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"file\"><\/param>\n        \/\/\/ <param name=\"entities\"><\/param>\n        protected virtual void Write(IGTFSTargetFile file, IEnumerable<FareRule> entities)\n        {\n            if (file != null)\n            {\n                bool initialized = false;\n                var data = new string[5];\n                foreach (var entity in entities)\n                {\n                    if (!initialized)\n                    {\n                        if (file.Exists)\n                        {\n                            file.Clear();\n                        }\n\n                        \/\/ write headers.\n                        data[0] = \"fare_id\";\n                        data[1] = \"route_id\";\n                        data[2] = \"origin_id\";\n                        data[3] = \"destination_id\";\n                        data[4] = \"contains_id\";\n                        file.Write(data);\n                        initialized = true;\n                    }\n\n                    \/\/ write details.\n                    data[0] = this.WriteFieldString(\"fare_rules\", \"fare_id\", entity.FareId);\n                    data[1] = this.WriteFieldString(\"fare_rules\", \"route_id\", entity.RouteId);\n                    data[2] = this.WriteFieldString(\"fare_rules\", \"origin_id\", entity.OriginId);\n                    data[3] = this.WriteFieldString(\"fare_rules\", \"destination_id\", entity.DestinationId);\n                    data[4] = this.WriteFieldString(\"fare_rules\", \"contains_id\", entity.ContainsId);\n                    file.Write(data);\n                }\n                file.Close();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the feed info.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"file\"><\/param>\n        \/\/\/ <param name=\"entity\"><\/param>\n        protected virtual void Write(IGTFSTargetFile file, FeedInfo entity)\n        {\n            if (file != null)\n            {\n                bool initialized = false;\n                var data = new string[6];\n                if (!initialized)\n                {\n                    if (file.Exists)\n                    {\n                        file.Clear();\n                    }\n\n                    \/\/ write headers.\n                    data[0] = \"feed_publisher_name\";\n                    data[1] = \"feed_publisher_url\";\n                    data[2] = \"feed_lang\";\n                    data[3] = \"feed_start_date\";\n                    data[4] = \"feed_end_date\";\n                    data[5] = \"feed_version\";\n                    file.Write(data);\n                    initialized = true;\n                }\n\n                \/\/ write details.\n                data[0] = this.WriteFieldString(\"feed_info\", \"feed_publisher_name\", entity.PublisherName, true);\n                data[1] = this.WriteFieldString(\"feed_info\", \"feed_publisher_url\", entity.PublisherUrl, true);\n                data[2] = this.WriteFieldString(\"feed_info\", \"feed_lang\", entity.Lang);\n                data[3] = this.WriteFieldString(\"feed_info\", \"feed_start_date\", entity.StartDate);\n                data[4] = this.WriteFieldString(\"feed_info\", \"feed_end_date\", entity.EndDate);\n                data[5] = this.WriteFieldString(\"feed_info\", \"feed_version\", entity.Version);\n                file.Write(data);\n                file.Close();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the frequencies.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"file\"><\/param>\n        \/\/\/ <param name=\"entities\"><\/param>\n        protected virtual void Write(IGTFSTargetFile file, IEnumerable<Frequency> entities)\n        {\n            if (file != null)\n            {\n                bool initialized = false;\n                var data = new string[5];\n                foreach (var entity in entities)\n                {\n                    if (!initialized)\n                    {\n                        if (file.Exists)\n                        {\n                            file.Clear();\n                        }\n\n                        \/\/ write headers.\n                        data[0] = \"trip_id\";\n                        data[1] = \"start_time\";\n                        data[2] = \"end_time\";\n                        data[3] = \"headway_secs\";\n                        data[4] = \"exact_times\";\n                        file.Write(data);\n                        initialized = true;\n                    }\n\n                    \/\/ write details.\n                    data[0] = this.WriteFieldString(\"frequency\", \"trip_id\", entity.TripId);\n                    data[1] = this.WriteFieldString(\"frequency\", \"start_time\", entity.StartTime);\n                    data[2] = this.WriteFieldString(\"frequency\", \"end_time\", entity.EndTime);\n                    data[3] = this.WriteFieldString(\"frequency\", \"headway_secs\", entity.HeadwaySecs);\n                    data[4] = this.WriteFieldBool(\"frequency\", \"exact_times\", entity.ExactTimes);\n                    file.Write(data);\n                }\n                file.Close();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the routes.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"file\"><\/param>\n        \/\/\/ <param name=\"entities\"><\/param>\n        protected virtual void Write(IGTFSTargetFile file, IEnumerable<Route> entities)\n        {\n            if (file != null)\n            {\n                bool initialized = false;\n                var data = new string[9];\n                foreach (var entity in entities)\n                {\n                    if (!initialized)\n                    {\n                        if (file.Exists)\n                        {\n                            file.Clear();\n                        }\n\n                        \/\/ write headers.\n                        data[0] = \"route_id\";\n                        data[1] = \"agency_id\";\n                        data[2] = \"route_short_name\";\n                        data[3] = \"route_long_name\";\n                        data[4] = \"route_desc\";\n                        data[5] = \"route_type\";\n                        data[6] = \"route_url\";\n                        data[7] = \"route_color\";\n                        data[8] = \"route_text_color\";\n                        file.Write(data);\n                        initialized = true;\n                    }\n\n                    \/\/ write details.\n                    data[0] = this.WriteFieldString(\"routes\", \"route_id\", entity.Id);\n                    data[1] = this.WriteFieldString(\"routes\", \"agency_id\", entity.AgencyId);\n                    data[2] = this.WriteFieldString(\"routes\", \"route_short_name\", entity.ShortName, true);\n                    data[3] = this.WriteFieldString(\"routes\", \"route_long_name\", entity.LongName, true);\n                    data[4] = this.WriteFieldString(\"routes\", \"route_desc\", entity.Description);\n                    data[5] = this.WriteFieldRouteType(\"routes\", \"route_type\", entity.Type);\n                    data[6] = this.WriteFieldString(\"routes\", \"route_url\", entity.Url);\n                    data[7] = this.WriteFieldColor(\"routes\", \"route_color\", entity.Color);\n                    data[8] = this.WriteFieldColor(\"routes\", \"route_text_color\", entity.TextColor);\n                    file.Write(data);\n                }\n                file.Close();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the shapes.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"file\"><\/param>\n        \/\/\/ <param name=\"entities\"><\/param>\n        protected virtual void Write(IGTFSTargetFile file, IEnumerable<Shape> entities)\n        {\n            if (file != null)\n            {\n                bool initialized = false;\n                var data = new string[5];\n                foreach (var entity in entities)\n                {\n                    if (!initialized)\n                    {\n                        if (file.Exists)\n                        {\n                            file.Clear();\n                        }\n\n                        \/\/ write headers.\n                        data[0] = \"shape_id\";\n                        data[1] = \"shape_pt_lat\";\n                        data[2] = \"shape_pt_lon\";\n                        data[3] = \"shape_pt_sequence\";\n                        data[4] = \"shape_dist_traveled\";\n                        file.Write(data);\n                        initialized = true;\n                    }\n\n                    \/\/ write details.\n                    data[0] = this.WriteFieldString(\"shapes\", \"shape_id\", entity.Id);\n                    data[1] = this.WriteFieldDouble(\"shapes\", \"shape_pt_lat\", entity.Latitude);\n                    data[2] = this.WriteFieldDouble(\"shapes\", \"shape_pt_lon\", entity.Longitude);\n                    data[3] = this.WriteFieldUint(\"shapes\", \"shape_pt_sequence\", entity.Sequence);\n                    data[4] = this.WriteFieldDouble(\"shapes\", \"shape_dist_traveled\", entity.DistanceTravelled);\n                    file.Write(data);\n                }\n                file.Close();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the stops.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"file\"><\/param>\n        \/\/\/ <param name=\"entities\"><\/param>\n        protected virtual void Write(IGTFSTargetFile file, IEnumerable<Stop> entities)\n        {\n            if (file != null)\n            {\n                bool initialized = false;\n                var data = new string[14];\n                foreach (var entity in entities)\n                {\n                    if (!initialized)\n                    {\n                        if (file.Exists)\n                        {\n                            file.Clear();\n                        }\n\n                        \/\/ write headers.\n                        data[0] = \"stop_id\";\n                        data[1] = \"stop_code\";\n                        data[2] = \"stop_name\";\n                        data[3] = \"stop_desc\";\n                        data[4] = \"stop_lat\";\n                        data[5] = \"stop_lon\";\n                        data[6] = \"zone_id\";\n                        data[7] = \"stop_url\";\n                        data[8] = \"location_type\";\n                        data[9] = \"parent_station\";\n                        data[10] = \"stop_timezone\";\n                        data[11] = \"wheelchair_boarding\";\n                        data[12] = \"level_id\";\n                        data[13] = \"platform_code\";\n                        file.Write(data);\n                        initialized = true;\n                    }\n\n                    \/\/ write details.\n                    data[0] = this.WriteFieldString(\"stops\", \"stop_id\", entity.Id);\n                    data[1] = this.WriteFieldString(\"stops\", \"stop_code\", entity.Code);\n                    data[2] = this.WriteFieldString(\"stops\", \"stop_name\", entity.Name, true);\n                    data[3] = this.WriteFieldString(\"stops\", \"stop_desc\", entity.Description, true);\n                    data[4] = this.WriteFieldDouble(\"stops\", \"stop_lat\", entity.Latitude);\n                    data[5] = this.WriteFieldDouble(\"stops\", \"stop_lon\", entity.Longitude);\n                    data[6] = this.WriteFieldString(\"stops\", \"zone_id\", entity.Zone);\n                    data[7] = this.WriteFieldString(\"stops\", \"stop_url\", entity.Url);\n                    data[8] = this.WriteFieldLocationType(\"stops\", \"location_type\", entity.LocationType);\n                    data[9] = this.WriteFieldString(\"stops\", \"parent_station\", entity.ParentStation);\n                    data[10] = this.WriteFieldString(\"stops\", \"stop_timezone\", entity.Timezone);\n                    data[11] = this.WriteFieldString(\"stops\", \"wheelchair_boarding\", entity.WheelchairBoarding);\n                    data[12] = this.WriteFieldString(\"stops\", \"level_id\", entity.LevelId);\n                    data[13] = this.WriteFieldString(\"stops\", \"platform_code\", entity.PlatformCode);\n                    file.Write(data);\n                }\n                file.Close();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the stop times.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"file\"><\/param>\n        \/\/\/ <param name=\"entities\"><\/param>\n        protected virtual void Write(IGTFSTargetFile file, IEnumerable<StopTime> entities)\n        {\n            if (file != null)\n            {\n                bool initialized = false;\n                var data = new string[10];\n                foreach (var entity in entities)\n                {\n                    if (!initialized)\n                    {\n                        if (file.Exists)\n                        {\n                            file.Clear();\n                        }\n\n                        \/\/ write headers.\n                        data[0] = \"trip_id\";\n                        data[1] = \"arrival_time\";\n                        data[2] = \"departure_time\";\n                        data[3] = \"stop_id\";\n                        data[4] = \"stop_sequence\";\n                        data[5] = \"stop_headsign\";\n                        data[6] = \"pickup_type\";\n                        data[7] = \"drop_off_type\";\n                        data[8] = \"shape_dist_traveled\";\n                        data[9] = \"timepoint\";\n                        file.Write(data);\n                        initialized = true;\n                    }\n\n                    \/\/ write details.\n                    data[0] = this.WriteFieldString(\"stop_times\", \"trip_id\", entity.TripId);\n                    data[1] = this.WriteFieldTimeOfDay(\"stop_times\", \"arrival_time\", entity.ArrivalTime);\n                    data[2] = this.WriteFieldTimeOfDay(\"stop_times\", \"departure_time\", entity.DepartureTime);\n                    data[3] = this.WriteFieldString(\"stop_times\", \"stop_id\", entity.StopId);\n                    data[4] = this.WriteFieldUint(\"stop_times\", \"stop_sequence\", entity.StopSequence);\n                    data[5] = this.WriteFieldString(\"stop_times\", \"stop_headsign\", entity.StopHeadsign, true);\n                    data[6] = this.WriteFieldPickupType(\"stop_times\", \"pickup_type\", entity.PickupType);\n                    data[7] = this.WriteFieldDropOffType(\"stop_times\", \"drop_off_type\", entity.DropOffType);\n                    data[8] = this.WriteFieldDouble(\"stop_times\", \"shape_dist_traveled\", entity.ShapeDistTravelled);\n                    data[9] = this.WriteFieldTimepointType(\"stop_times\", \"timepoint\", entity.TimepointType);\n                    file.Write(data);\n                }\n                file.Close();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the transfers.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"file\"><\/param>\n        \/\/\/ <param name=\"entities\"><\/param>\n        protected virtual void Write(IGTFSTargetFile file, IEnumerable<Transfer> entities)\n        {\n            if (file != null)\n            {\n                bool initialized = false;\n                var data = new string[4];\n                foreach (var entity in entities)\n                {\n                    if (!initialized)\n                    {\n                        if (file.Exists)\n                        {\n                            file.Clear();\n                        }\n\n                        \/\/ write headers.\n                        data[0] = \"from_stop_id\";\n                        data[1] = \"to_stop_id\";\n                        data[2] = \"transfer_type\";\n                        data[3] = \"min_transfer_time\";\n                        file.Write(data);\n                        initialized = true;\n                    }\n\n                    \/\/ write details.\n                    data[0] = this.WriteFieldString(\"transfers\", \"from_stop_id\", entity.FromStopId);\n                    data[1] = this.WriteFieldString(\"transfers\", \"to_stop_id\", entity.ToStopId);\n                    data[2] = this.WriteFieldTransferType(\"transfers\", \"transfer_type\", entity.TransferType);\n                    data[3] = this.WriteFieldString(\"transfers\", \"min_transfer_time\", entity.MinimumTransferTime);\n                    file.Write(data);\n                }\n                file.Close();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the trips.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"file\"><\/param>\n        \/\/\/ <param name=\"entities\"><\/param>\n        protected virtual void Write(IGTFSTargetFile file, IEnumerable<Trip> entities)\n        {\n            if (file != null)\n            {\n                bool initialized = false;\n                var data = new string[9];\n                foreach (var entity in entities)\n                {\n                    if (!initialized)\n                    {\n                        if (file.Exists)\n                        {\n                            file.Clear();\n                        }\n\n                        \/\/ write headers.\n                        data[0] = \"trip_id\";\n                        data[1] = \"route_id\";\n                        data[2] = \"service_id\";\n                        data[3] = \"trip_headsign\";\n                        data[4] = \"trip_short_name\";\n                        data[5] = \"direction_id\";\n                        data[6] = \"block_id\";\n                        data[7] = \"shape_id\";\n                        data[8] = \"wheelchair_accessible\";\n                        file.Write(data);\n                        initialized = true;\n                    }\n\n                    \/\/ write details.\n                    data[0] = this.WriteFieldString(\"trips\", \"trip_id\", entity.Id);\n                    data[1] = this.WriteFieldString(\"trips\", \"route_id\", entity.RouteId);\n                    data[2] = this.WriteFieldString(\"trips\", \"service_id\", entity.ServiceId);\n                    data[3] = this.WriteFieldString(\"trips\", \"trip_headsign\", entity.Headsign);\n                    data[4] = this.WriteFieldString(\"trips\", \"trip_short_name\", entity.ShortName, true);\n                    data[5] = this.WriteFieldDirectionType(\"trips\", \"direction_id\", entity.Direction);\n                    data[6] = this.WriteFieldString(\"trips\", \"block_id\", entity.BlockId);\n                    data[7] = this.WriteFieldString(\"trips\", \"shape_id\", entity.ShapeId);\n                    data[8] = this.WriteFieldAccessibilityType(\"trips\", \"wheelchair_accessible\", entity.AccessibilityType);\n                    file.Write(data);\n                }\n                file.Close();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes a string-field.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected virtual string WriteFieldString(string name, string fieldName, string value)\n        {\n            var quote = !string.IsNullOrWhiteSpace(value) && value.Contains(\",\");\n            return this.WriteFieldString(name, fieldName, value, quote);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes a string-field.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <param name=\"quote\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected virtual string WriteFieldString(string name, string fieldName, string value, bool quote)\n        {\n            if (quote)\n            { \/\/ quotes.\n                var valueBuilder = new StringBuilder();\n                valueBuilder.Append('\"');\n                valueBuilder.Append(value);\n                valueBuilder.Append('\"');\n                return valueBuilder.ToString();\n            }\n            return value;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the exception type.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldExceptionType(string name, string fieldName, ExceptionType value)\n        {\n            \/\/A value of 1 indicates that service has been added for the specified date.\n            \/\/A value of 2 indicates that service has been removed for the specified date.\n\n            switch (value)\n            {\n                case ExceptionType.Added:\n                    return \"1\";\n                case ExceptionType.Removed:\n                    return \"2\";\n            }\n            return string.Empty;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the date.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"dateTime\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldDate(string name, string fieldName, DateTime dateTime)\n        {\n            return dateTime.ToString(\"yyyyMMdd\");\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the bool.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldBool(string name, string fieldName, bool? value)\n        {\n            if (value.HasValue)\n            {\n                if (value.Value)\n                {\n                    return \"1\";\n                }\n                return \"0\";\n            }\n            return string.Empty;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the uint.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldUint(string name, string fieldName, uint? value)\n        {\n            if (value.HasValue)\n            {\n                return value.Value.ToString();\n            }\n            return string.Empty;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the payment method.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldPaymentMethod(string name, string fieldName, PaymentMethodType value)\n        {\n            \/\/0 - Fare is paid on board.\n            \/\/1 - Fare must be paid before boarding.\n\n            switch (value)\n            {\n                case PaymentMethodType.OnBoard:\n                    return \"0\";\n                case PaymentMethodType.BeforeBoarding:\n                    return \"1\";\n            }\n            return string.Empty;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes a color.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldColor(string name, string fieldName, int? value)\n        {\n            return value.ToHexColorString();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the route type.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns><\/returns>\n        private string WriteFieldRouteType(string name, string fieldName, RouteTypeExtended value)\n        {\n            return ((int)value).ToString();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes a double.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldDouble(string name, string fieldName, double? value)\n        {\n            if (value.HasValue)\n            {\n                return value.Value.ToString(System.Globalization.CultureInfo.InvariantCulture);\n            }\n            return string.Empty;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes an int.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldInt(string name, string fieldName, int? value)\n        {\n            if (value.HasValue)\n            {\n                return value.Value.ToString(System.Globalization.CultureInfo.InvariantCulture);\n            }\n            return string.Empty;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the location type.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldLocationType(string name, string fieldName, LocationType? value)\n        {\n            if (value.HasValue)\n            {\n                switch (value.Value)\n                {\n                    case LocationType.Stop:\n                        return \"0\";\n                    case LocationType.Station:\n                        return \"1\";\n                }\n            }\n            return string.Empty;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the drop off type.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldDropOffType(string name, string fieldName, DropOffType? value)\n        {\n            if (value.HasValue)\n            {\n                switch (value.Value)\n                {\n                    case DropOffType.Regular:\n                        return \"0\";\n                    case DropOffType.NoPickup:\n                        return \"1\";\n                    case DropOffType.PhoneForPickup:\n                        return \"2\";\n                    case DropOffType.DriverForPickup:\n                        return \"3\";\n                }\n            }\n            return string.Empty;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the timepoint value.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldTimepointType(string name, string fieldName, TimePointType value)\n        {\n            switch (value)\n            {\n                case TimePointType.Approximate:\n                    return \"0\";\n                case TimePointType.Exact:\n                    return \"1\";\n            }\n            return string.Empty;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes the pickup type.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldPickupType(string name, string fieldName, PickupType? value)\n        {\n            if (value.HasValue)\n            {\n                switch (value.Value)\n                {\n                    case PickupType.Regular:\n                        return \"0\";\n                    case PickupType.NoPickup:\n                        return \"1\";\n                    case PickupType.PhoneForPickup:\n                        return \"2\";\n                    case PickupType.DriverForPickup:\n                        return \"3\";\n                }\n            }\n            return string.Empty;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes a timeofday.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldTimeOfDay(string name, string fieldName, TimeOfDay? value)\n        {\n            if (!value.HasValue)\n            {\n                return string.Empty;\n            }\n            return string.Format(\"{0}:{1}:{2}\",\n                value.Value.Hours.ToString(\"00\"),\n                value.Value.Minutes.ToString(\"00\"),\n                value.Value.Seconds.ToString(\"00\"));\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes a transfertime.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldTransferType(string name, string fieldName, TransferType value)\n        {\n            switch (value)\n            {\n                case TransferType.Recommended:\n                    return \"0\";\n                case TransferType.TimedTransfer:\n                    return \"1\";\n                case TransferType.MinimumTime:\n                    return \"2\";\n                case TransferType.NotPossible:\n                    return \"3\";\n            }\n\n            return string.Empty;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes an accessibility type.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldAccessibilityType(string name, string fieldName, WheelchairAccessibilityType? value)\n        {\n            if (value.HasValue)\n            {\n                \/\/0 (or empty) - indicates that there is no accessibility information for the trip\n                \/\/1 - indicates that the vehicle being used on this particular trip can accommodate at least one rider in a wheelchair\n                \/\/2 - indicates that no riders in wheelchairs can be accommodated on this trip\n\n                switch (value.Value)\n                {\n                    case WheelchairAccessibilityType.NoInformation:\n                        return \"0\";\n                    case WheelchairAccessibilityType.SomeAccessibility:\n                        return \"1\";\n                    case WheelchairAccessibilityType.NoAccessibility:\n                        return \"2\";\n                }\n            }\n            return string.Empty;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes is bidirectional.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldIsBidirectional(string name, string fieldName, IsBidirectional? value)\n        {\n            if (value.HasValue)\n            {\n                \/\/0: Unidirectional pathway, it can only be used from from_stop_id to to_stop_id.\n                \/\/1: Bidirectional pathway, it can be used in the two directions.\n\n                switch (value.Value)\n                {\n                    case IsBidirectional.Unidirectional:\n                        return \"0\";\n                    case IsBidirectional.Bidirectional:\n                        return \"1\";\n                }\n            }\n            return string.Empty;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes a pathway mode.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldPathwayMode(string name, string fieldName, PathwayMode? value)\n        {\n            if (value.HasValue)\n            {\n                \/\/1 - walkway\n                \/\/2 - stairs\n                \/\/3 - moving sidewalk\/travelator\n                \/\/4 - escalator\n                \/\/5 - elevator\n                \/\/6 - fare gate (or payment gate): A pathway that crosses into an area of the station where a proof of payment is required (usually via a physical payment gate).\n                \/\/7 - exit gate: Indicates a pathway exiting an area where proof-of-payment is required into an area where proof-of-payment is no longer required.\n\n                switch (value.Value)\n                {\n                    case PathwayMode.Walkway:\n                        return \"1\";\n                    case PathwayMode.Stairs:\n                        return \"2\";\n                    case PathwayMode.Travelator:\n                        return \"3\";\n                    case PathwayMode.Escalator:\n                        return \"4\";\n                    case PathwayMode.Elevator:\n                        return \"5\";\n                    case PathwayMode.FareGate:\n                        return \"6\";\n                    case PathwayMode.ExitGate:\n                        return \"7\";\n                }\n            }\n            return string.Empty;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Writes a direction type.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\"><\/param>\n        \/\/\/ <param name=\"fieldName\"><\/param>\n        \/\/\/ <param name=\"value\"><\/param>\n        \/\/\/ <returns><\/returns>\n        protected string WriteFieldDirectionType(string name, string fieldName, DirectionType? value)\n        {\n            if (value.HasValue)\n            {\n\n                \/\/0 - travel in one direction (e.g. outbound travel)\n                \/\/1 - travel in the opposite direction (e.g. inbound travel)\n\n                switch (value.Value)\n                {\n                    case DirectionType.OneDirection:\n                        return \"0\";\n                    case DirectionType.OppositeDirection:\n                        return \"1\";\n                }\n            }\n            return string.Empty;\n        }\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"a9352ffb15c4632f3b701ef3f488f74791ca9d45","subject":"adding GEOD by ReferenceEquals","message":"adding GEOD by ReferenceEquals\n","repos":"dadhi\/ImTools","old_file":"src\/ImTools\/ImTools.cs","new_file":"src\/ImTools\/ImTools.cs","new_contents":"\/\/ <auto-generated\/>\n\/*\nThe MIT License (MIT)\n\nCopyright (c) 2016-2022 Maksim Volkau\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included \nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*\/\n\n\/\/ ReSharper disable once InconsistentNaming\n\nnamespace ImTools\n{\n    using System;\n    using System.Collections;\n    using System.Collections.Generic;\n    using System.Linq;\n    using System.Text;\n    using System.Threading;\n    using System.Diagnostics;\n    using System.Runtime.CompilerServices; \/\/ For [MethodImpl(AggressiveInlining)]\n\n    \/\/\/ <summary>Helpers for functional composition<\/summary>\n    public static class Fun\n    {\n        \/\/\/ <summary>\n        \/\/\/ Always a true condition.\n        \/\/\/ <\/summary> \n        public static bool Always<T>(T _) => true;\n\n        \/\/\/ <summary>\n        \/\/\/ Identity function returning passed argument as result.\n        \/\/\/ <\/summary> \n        public static T Id<T>(T x) => x;\n\n        \/\/\/ <summary>\n        \/\/\/ Forward pipe operator (`|>` in F#)\n        \/\/\/ <\/summary> \n        public static R To<T, R>(this T x, Func<T, R> map) => map(x);\n\n        \/\/\/ <summary>\n        \/\/\/ Forward pipe operator (`|>` in F#) with the additional state A for two arguments function\n        \/\/\/ <\/summary> \n        public static R To<T, S, R>(this T x, S state, Func<T, S, R> map) => map(x, state);\n\n        \/\/\/ <summary>\n        \/\/\/ Cast to the R type with the forward pipe operator (`|>` in F#)\n        \/\/\/ <\/summary> \n        public static R To<R>(this object x) => (R)x;\n\n        \/\/\/ <summary>\n        \/\/\/ Forward pipe operator (`|>` in F#) but with side effect propagating the original `x` value\n        \/\/\/ <\/summary> \n        public static T Do<T>(this T x, Action<T> effect)\n        {\n            effect(x);\n            return x;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Forward pipe operator (`|>` in F#) but with side effect propagating the original `x` value and the state object\n        \/\/\/ <\/summary> \n        public static T Do<T, S>(this T x, S state, Action<T, S> effect)\n        {\n            effect(x, state);\n            return x;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Lifts argument to Func without allocations ignoring the first argument.\n        \/\/\/ For example if you have `Func{T, R} = _ => instance`,\n        \/\/\/ you may rewrite it without allocations as `instance.ToFunc{A, R}`\n        \/\/\/ <\/summary> \n        public static R ToFunc<T, R>(this R result, T ignoredArg) => result;\n\n        \/\/\/ <summary>Performant swapper<\/summary>\n        [MethodImpl(256)]\n        public static void Swap<T>(ref T a, ref T b)\n        {\n            var t = a;\n            a = b;\n            b = t;\n        }\n    }\n\n    \/\/\/ <summary>Helpers for lazy instantiations<\/summary>\n    public static class Lazy\n    {\n        \/\/\/ <summary>Provides result type inference for creation of lazy.<\/summary>\n        public static Lazy<T> Of<T>(Func<T> valueFactory) => new Lazy<T>(valueFactory);\n    }\n\n    \/\/\/ <summary>Just a helper state with the number of mutable fields with the nice names ;) Maybe used together with Fold or other methods required state<\/summary>\n    public sealed class St<A>\n    {\n        \/\/\/ <summary>A<\/summary>\n        public A a;\n\n        \/\/\/ <summary>Puts the pooled instance back replacing the old one<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public void Pool() => Pooled = this;\n\n        \/\/\/ <summary>Puts the pooled instance back replacing the old one<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public void Reset()\n        {\n            a = default;\n            Pooled = this; \/\/ we don't need to do the atomic update here because we don't care what instance is ended up to be pooled\n        }\n\n        \/\/\/ <summary>Puts the pooled instance back replacing the old one<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public A ResetButGetA()\n        {\n            var a1 = a;\n            a = default;\n            Pooled = this; \/\/ we don't need to do the atomic update here because we don't care what instance is ended up to be pooled\n            return a1;\n        }\n\n        internal static St<A> Pooled;\n    }\n\n    \/\/\/ <summary>Just a helper state with the number of mutable fields with the nice names ;) Maybe used together with Fold or other methods required state<\/summary>\n    public sealed class St<A, B>\n    {\n        \/\/\/ <summary>A<\/summary>\n        public A a;\n        \/\/\/ <summary>B<\/summary>\n        public B b;\n\n        \/\/\/ <summary>Puts the pooled instance back replacing the old one<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public St<A, B> Pool() => Pooled = this;\n\n        \/\/\/ <summary>Puts the pooled instance back replacing the old one<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public void Reset()\n        {\n            a = default;\n            b = default;\n            Pooled = this; \/\/ we don't need to do the atomic update here because we don't care what instance is ended up to be pooled\n        }\n\n        \/\/\/ <summary>Puts the pooled instance back replacing the old one<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public A ResetButGetA()\n        {\n            var a1 = a;\n            a = default;\n            b = default;\n            Pooled = this; \/\/ we don't need to do the atomic update here because we don't care what instance is ended up to be pooled\n            return a1;\n        }\n\n        \/\/\/ <summary>Puts the pooled instance back replacing the old one<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public B ResetButGetB()\n        {\n            var b1 = b;\n            a = default;\n            b = default;\n            Pooled = this; \/\/ we don't need to do the atomic update here because we don't care what instance is ended up to be pooled\n            return b1;\n        }\n\n        internal static St<A, B> Pooled;\n    }\n\n    \/\/\/ <summary>State factory and helper methods<\/summary>\n    public static class St\n    {\n        \/\/\/ <summary>Creates the state out of the passed arguments<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static St<A> Of<A>(A a) => new St<A> { a = a };\n\n        \/\/\/ <summary>Atomically pops the pooled instance (if exist) or creates the new one and sets the fields to the passed arguments<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static St<A> Rent<A>(A a)\n        {\n            var st = Interlocked.Exchange(ref St<A>.Pooled, null) ?? new St<A>();\n            st.a = a;\n            return st;\n        }\n\n        \/\/\/ <summary>Creates the state out of the passed arguments<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static St<A, B> Of<A, B>(A a, B b) => new St<A, B> { a = a, b = b };\n\n        \/\/\/ <summary>Atomically pops the pooled instance (if exist) or creates the new one and sets the fields to the passed arguments<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static St<A, B> Rent<A, B>(A a, B b)\n        {\n            var st = Interlocked.Exchange(ref St<A, B>.Pooled, null) ?? new St<A, B>();\n            st.a = a; st.b = b;\n            return st;\n        }\n    }\n\n    \/\/\/ <summary>Methods to work with immutable arrays and some sugar.<\/summary>\n    public static class ArrayTools\n    {\n        private static class EmptyArray<T>\n        {\n            public static readonly T[] Value = new T[0];\n        }\n\n        \/\/\/ <summary>Returns singleton empty array of provided type.<\/summary> \n        \/\/\/ <typeparam name=\"T\">Array item type.<\/typeparam> <returns>Empty array.<\/returns>\n        public static T[] Empty<T>() => EmptyArray<T>.Value;\n\n        \/\/\/ <summary>Wraps item in array.<\/summary>\n        public static T[] One<T>(this T one) => new[] { one };\n\n        \/\/\/ <summary>Returns true if array is null or have no items.<\/summary> <typeparam name=\"T\">Type of array item.<\/typeparam>\n        \/\/\/ <param name=\"source\">Source array to check.<\/param> <returns>True if null or has no items, false otherwise.<\/returns>\n        public static bool IsNullOrEmpty<T>(this T[] source) => source == null || source.Length == 0;\n\n        \/\/\/ <summary>Returns empty array instead of null, or source array otherwise.<\/summary> <typeparam name=\"T\">Type of array item.<\/typeparam>\n        public static T[] EmptyIfNull<T>(this T[] source) => source ?? Empty<T>();\n\n        \/\/\/ Returns source enumerable if it is array, otherwise converts source to array or an empty array if null.\n        public static T[] ToArrayOrSelf<T>(this IEnumerable<T> source) =>\n            source == null ? Empty<T>() : (source as T[] ?? source.ToArray());\n\n        \/\/\/ Returns source enumerable if it is list, otherwise converts source to IList or an empty array if null.\n        public static IList<T> ToListOrSelf<T>(this IEnumerable<T> source) =>\n            source == null ? Empty<T>() : source as IList<T> ?? source.ToList();\n\n        \/\/\/ <summary>Array copy<\/summary>\n        public static T[] Copy<T>(this T[] source)\n        {\n            if (source == null || source.Length == 0)\n                return source;\n            var copy = new T[source.Length];\n            Array.Copy(source, 0, copy, 0, source.Length);\n            return copy;\n        }\n\n        \/\/\/ <summary>Array copy without checking the items for the null or the emptyness<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static T[] CopyNonEmpty<T>(this T[] source)\n        {\n            var copy = new T[source.Length];\n            Array.Copy(source, 0, copy, 0, source.Length);\n            return copy;\n        }\n\n        \/\/\/ <summary>Returns the new array consisting from all items from source array then the all items from added array.\n        \/\/\/ If source is null or empty then the added array will be returned. If added is null or empty then the source will be returned.<\/summary>\n        public static T[] Append<T>(this T[] source, params T[] added)\n        {\n            if (added == null || added.Length == 0)\n                return source;\n            if (source == null || source.Length == 0)\n                return added;\n            var sourceCount = source.Length;\n            var addedCount = added.Length;\n            var result = new T[sourceCount + addedCount];\n            if (sourceCount < 6)\n                for (var i = 0; i < sourceCount; ++i)\n                    result[i] = source[i];\n            else\n                Array.Copy(source, 0, result, 0, sourceCount);\n            if (addedCount < 6)\n                for (var i = 0; i < addedCount; ++i)\n                    result[sourceCount + i] = added[i];\n            else\n                Array.Copy(added, 0, result, sourceCount, addedCount);\n            return result;\n        }\n\n        \/\/\/ <summary>Performant concat of enumerables in case of arrays. But performance will degrade if you use Concat().Where().<\/summary>\n        public static T[] Append<T>(this IEnumerable<T> source, IEnumerable<T> other) =>\n            source.ToArrayOrSelf().Append(other.ToArrayOrSelf());\n\n        \/\/\/ <summary>Returns new array with <paramref name=\"value\"\/> appended, \n        \/\/\/ or <paramref name=\"value\"\/> at <paramref name=\"index\"\/>, if specified.\n        \/\/\/ If source array could be null or empty, then single value item array will be created despite any index.<\/summary>\n        public static T[] AppendOrUpdate<T>(this T[] source, T value, int index = -1)\n        {\n            if (source == null || source.Length == 0)\n                return new[] { value };\n            var sourceCount = source.Length;\n            index = index < 0 ? sourceCount : index;\n            var result = new T[index < sourceCount ? sourceCount : sourceCount + 1];\n            if (sourceCount < 6)\n                for (var i = 0; i < sourceCount; ++i)\n                    result[i] = source[i];\n            else\n                Array.Copy(source, 0, result, 0, sourceCount);\n            result[index] = value;\n            return result;\n        }\n\n        \/\/\/ <summary>Updates the item in the copy of the array. The array should be non-empty.<\/summary>\n        public static T[] UpdateNonEmpty<T>(this T[] source, T value, int index)\n        {\n            var sourceCount = source.Length;\n            var result = new T[sourceCount];\n            if (sourceCount < 6)\n                for (var i = 0; i < sourceCount; ++i)\n                    result[i] = source[i];\n            else\n                Array.Copy(source, 0, result, 0, sourceCount);\n            result[index] = value;\n            return result;\n        }\n\n        \/\/\/ <summary>Returns the new array consisting from all items from source array then the all items from added array.\n        \/\/\/ Assumes that both arrays are non-empty to avoid the checks.<\/summary>\n        public static T[] AppendNonEmpty<T>(this T[] source, params T[] added)\n        {\n            var sourceCount = source.Length;\n            var addedCount = added.Length;\n            var result = new T[sourceCount + addedCount];\n            if (sourceCount < 6)\n                for (var i = 0; i < sourceCount; ++i)\n                    result[i] = source[i];\n            else\n                Array.Copy(source, 0, result, 0, sourceCount);\n            if (addedCount < 6)\n                for (var i = 0; i < addedCount; ++i)\n                    result[sourceCount + i] = added[i];\n            else\n                Array.Copy(added, 0, result, sourceCount, addedCount);\n            return result;\n        }\n\n        \/\/\/ <summary>Returns the new array consisting from all items from source array plus the value.<\/summary>\n        public static T[] Append<T>(this T[] source, T value)\n        {\n            if (source == null || source.Length == 0)\n                return new T[] { value };\n            var sourceCount = source.Length;\n            var result = new T[sourceCount + 1];\n            if (sourceCount < 6)\n                for (var i = 0; i < sourceCount; ++i)\n                    result[i] = source[i];\n            else\n                Array.Copy(source, 0, result, 0, sourceCount);\n            result[sourceCount] = value;\n            return result;\n        }\n\n        \/\/\/ <summary>Returns new array with <paramref name=\"value\"\/> appended. Assumes that `source` is not empty to avoid the checks.<\/summary>\n        public static T[] AppendToNonEmpty<T>(this T[] source, T value)\n        {\n            var sourceCount = source.Length;\n            var result = new T[sourceCount + 1];\n            if (sourceCount < 6)\n                for (var i = 0; i < sourceCount; ++i)\n                    result[i] = source[i];\n            else\n                Array.Copy(source, 0, result, 0, sourceCount);\n            result[sourceCount] = value;\n            return result;\n        }\n\n        \/\/\/ <summary>Returns new array with <paramref name=\"value\"\/> prepended. Assumes that `source` is not empty to avoid the checks.<\/summary>\n        public static T[] PrependToNonEmpty<T>(this T[] source, T value)\n        {\n            var sourceCount = source.Length;\n            var result = new T[sourceCount + 1];\n            if (sourceCount < 6)\n                for (var i = 0; i < sourceCount; ++i)\n                    result[i + 1] = source[i];\n            else\n                Array.Copy(source, 0, result, 1, sourceCount);\n            result[0] = value;\n            return result;\n        }\n\n        \/\/\/ <summary>Calls predicate on each item in <paramref name=\"source\"\/> array until predicate returns true,\n        \/\/\/ then method will return this item index, or if predicate returns false for each item, method will return -1.<\/summary>\n        public static int IndexOf<T>(this T[] source, Func<T, bool> predicate)\n        {\n            if (source != null && source.Length != 0)\n                for (var i = 0; i < source.Length; ++i)\n                    if (predicate(source[i]))\n                        return i;\n            return -1;\n        }\n\n        \/\/\/ <summary>Minimizes the allocations for closure in predicate lambda with the provided <paramref name=\"state\"\/><\/summary>\n        public static int IndexOf<T, S>(this T[] source, S state, Func<S, T, bool> predicate)\n        {\n            if (source != null && source.Length != 0)\n                for (var i = 0; i < source.Length; ++i)\n                    if (predicate(state, source[i]))\n                        return i;\n            return -1;\n        }\n\n        \/\/\/ <summary>Looks up for item in source array equal to provided value, and returns its index, or -1 if not found.<\/summary>\n        public static int IndexOf<T>(this T[] source, T value)\n        {\n            if (source != null && source.Length != 0)\n                for (var i = 0; i < source.Length; ++i)\n                {\n                    var item = source[i];\n                    if (Equals(item, value))\n                        return i;\n                }\n\n            return -1;\n        }\n\n        \/\/\/ <summary>The same as `IndexOf` but searching for the item by reference<\/summary>\n        public static int IndexOfReference<T>(this T[] source, T reference) where T : class\n        {\n            if (source != null && source.Length != 0)\n                for (var i = 0; i < source.Length; ++i)\n                    if (ReferenceEquals(source[i], reference))\n                        return i;\n            return -1;\n        }\n\n        \/\/\/ <summary>Produces new array without item at specified <paramref name=\"index\"\/>. \n        \/\/\/ Will return <paramref name=\"source\"\/> array if index is out of bounds, or source is null\/empty.<\/summary>\n        public static T[] RemoveAt<T>(this T[] source, int index)\n        {\n            if (source == null || source.Length == 0 || index < 0 || index >= source.Length)\n                return source;\n            if (index == 0 && source.Length == 1)\n                return new T[0];\n            var result = new T[source.Length - 1];\n            if (index != 0)\n                Array.Copy(source, 0, result, 0, index);\n            if (index != result.Length)\n                Array.Copy(source, index + 1, result, index, result.Length - index);\n            return result;\n        }\n\n        \/\/\/ <summary>Looks for item in array using equality comparison, and returns new array with found item remove, or original array if not item found.<\/summary>\n        public static T[] Remove<T>(this T[] source, T value) =>\n            source.RemoveAt(source.IndexOf(value));\n\n        \/\/\/ <summary>Returns first item matching the <paramref name=\"predicate\"\/>, or default item value.<\/summary>\n        public static T FindFirst<T>(this T[] source, Func<T, bool> predicate)\n        {\n            if (source != null && source.Length != 0)\n                for (var i = 0; i < source.Length; ++i)\n                {\n                    var item = source[i];\n                    if (predicate(item))\n                        return item;\n                }\n\n            return default(T);\n        }\n\n        \/\/\/ <summary>Version of FindFirst with the fixed state used by predicate to prevent allocations by predicate lambda closure<\/summary>\n        public static T FindFirst<T, S>(this T[] source, S state, Func<S, T, bool> predicate)\n        {\n            if (source != null && source.Length != 0)\n                for (var i = 0; i < source.Length; ++i)\n                {\n                    var item = source[i];\n                    if (predicate(state, item))\n                        return item;\n                }\n\n            return default(T);\n        }\n\n        \/\/\/ <summary>Returns first item matching the <paramref name=\"predicate\"\/>, or default item value.<\/summary>\n        public static T FindFirst<T>(this IEnumerable<T> source, Func<T, bool> predicate) =>\n            source is T[] sourceArr ? sourceArr.FindFirst(predicate) : source.FirstOrDefault(predicate);\n\n        \/\/\/ <summary>Returns element if collection consist on single element, otherwise returns default value.\n        \/\/\/ It does not throw for collection with many elements<\/summary>\n        public static T SingleOrDefaultIfMany<T>(this IEnumerable<T> source)\n        {\n            if (source is IList<T> list)\n                return list.Count == 1 ? list[0] : default(T);\n\n            if (source == null)\n                return default(T);\n\n            using (var e = source.GetEnumerator())\n            {\n                if (!e.MoveNext())\n                    return default(T);\n                var it = e.Current;\n                return !e.MoveNext() ? it : default(T);\n            }\n        }\n\n        \/\/\/ <summary>Does <paramref name=\"action\"\/> for each item<\/summary>\n        public static void ForEach<T>(this T[] source, Action<T> action)\n        {\n            if (!source.IsNullOrEmpty())\n                for (var i = 0; i < source.Length; i++)\n                    action(source[i]);\n        }\n\n        \/\/\/ Appends source to results\n        public static T[] AppendTo<T>(T[] source, int sourcePos, int count, T[] results = null)\n        {\n            if (results == null)\n            {\n                var newResults = new T[count];\n                if (count == 1)\n                    newResults[0] = source[sourcePos];\n                else\n                    for (int i = 0, j = sourcePos; i < count; ++i, ++j)\n                        newResults[i] = source[j];\n                return newResults;\n            }\n\n            var matchCount = results.Length;\n            var appendedResults = new T[matchCount + count];\n            if (matchCount == 1)\n                appendedResults[0] = results[0];\n            else\n                Array.Copy(results, 0, appendedResults, 0, matchCount);\n\n            if (count == 1)\n                appendedResults[matchCount] = source[sourcePos];\n            else\n                Array.Copy(source, sourcePos, appendedResults, matchCount, count);\n\n            return appendedResults;\n        }\n\n        private static R[] AppendTo<T, R>(T[] source, int sourcePos, int count, Func<T, R> map, R[] results = null)\n        {\n            if (results == null || results.Length == 0)\n            {\n                var newResults = new R[count];\n                if (count == 1)\n                    newResults[0] = map(source[sourcePos]);\n                else\n                    for (int i = 0, j = sourcePos; i < count; ++i, ++j)\n                        newResults[i] = map(source[j]);\n                return newResults;\n            }\n\n            var oldResultsCount = results.Length;\n            var appendedResults = new R[oldResultsCount + count];\n            if (oldResultsCount == 1)\n                appendedResults[0] = results[0];\n            else\n                Array.Copy(results, 0, appendedResults, 0, oldResultsCount);\n\n            if (count == 1)\n                appendedResults[oldResultsCount] = map(source[sourcePos]);\n            else\n            {\n                for (int i = oldResultsCount, j = sourcePos; i < appendedResults.Length; ++i, ++j)\n                    appendedResults[i] = map(source[j]);\n            }\n\n            return appendedResults;\n        }\n\n        private static R[] AppendTo<S, T, R>(T[] source, S state, int sourcePos, int count, Func<S, T, R> map, R[] results = null)\n        {\n            if (results == null || results.Length == 0)\n            {\n                var newResults = new R[count];\n                if (count == 1)\n                    newResults[0] = map(state, source[sourcePos]);\n                else\n                    for (int i = 0, j = sourcePos; i < count; ++i, ++j)\n                        newResults[i] = map(state, source[j]);\n                return newResults;\n            }\n\n            var oldResultsCount = results.Length;\n            var appendedResults = new R[oldResultsCount + count];\n            if (oldResultsCount == 1)\n                appendedResults[0] = results[0];\n            else\n                Array.Copy(results, 0, appendedResults, 0, oldResultsCount);\n\n            if (count == 1)\n                appendedResults[oldResultsCount] = map(state, source[sourcePos]);\n            else\n            {\n                for (int i = oldResultsCount, j = sourcePos; i < appendedResults.Length; ++i, ++j)\n                    appendedResults[i] = map(state, source[j]);\n            }\n\n            return appendedResults;\n        }\n\n        private static R[] AppendTo<A, B, T, R>(T[] source, A a, B b, int sourcePos, int count, Func<A, B, T, R> map, R[] results = null)\n        {\n            if (results == null || results.Length == 0)\n            {\n                var newResults = new R[count];\n                if (count == 1)\n                    newResults[0] = map(a, b, source[sourcePos]);\n                else\n                    for (int i = 0, j = sourcePos; i < count; ++i, ++j)\n                        newResults[i] = map(a, b, source[j]);\n                return newResults;\n            }\n\n            var oldResultsCount = results.Length;\n            var appendedResults = new R[oldResultsCount + count];\n            if (oldResultsCount == 1)\n                appendedResults[0] = results[0];\n            else\n                Array.Copy(results, 0, appendedResults, 0, oldResultsCount);\n\n            if (count == 1)\n                appendedResults[oldResultsCount] = map(a, b, source[sourcePos]);\n            else\n            {\n                for (int i = oldResultsCount, j = sourcePos; i < appendedResults.Length; ++i, ++j)\n                    appendedResults[i] = map(a, b, source[j]);\n            }\n\n            return appendedResults;\n        }\n\n        \/\/\/ <summary>Where method similar to Enumerable.Where but more performant and non necessary allocating.\n        \/\/\/ It returns source array and does Not create new one if all items match the condition.<\/summary>\n        public static T[] Match<T>(this T[] source, Func<T, bool> condition)\n        {\n            if (source == null || source.Length == 0)\n                return source;\n\n            if (source.Length == 1)\n                return condition(source[0]) ? source : Empty<T>();\n\n            if (source.Length == 2)\n            {\n                var c0 = condition(source[0]);\n                var c1 = condition(source[1]);\n                return c0 && c1 ? source : c0 ? new[] { source[0] } : c1 ? new[] { source[1] } : Empty<T>();\n            }\n\n            if (source.Length == 3)\n            {\n                var condition0 = condition(source[0]);\n                var condition1 = condition(source[1]);\n                var condition2 = condition(source[2]);\n                return condition0 && condition1 && condition2 ? source\n                    : condition0 ? (condition1 ? new[] { source[0], source[1] } : condition2 ? new[] { source[0], source[2] } : new[] { source[0] })\n                    : condition1 ? (condition2 ? new[] { source[1], source[2] } : new[] { source[1] })\n                    : condition2 ? new[] { source[2] }\n                    : Empty<T>();\n            }\n\n            var matchStart = 0;\n            T[] matches = null;\n            var matchFound = false;\n            var i = 0;\n            for (; i < source.Length; ++i)\n                if (!(matchFound = condition(source[i]))) \/\/ todo: @unclear check what will happen if the `matchFound` is set back to false\n                {\n                    \/\/ for accumulated matched items\n                    if (i != 0 && i > matchStart)\n                        matches = AppendTo(source, matchStart, i - matchStart, matches);\n                    matchStart = i + 1; \/\/ guess the next match start will be after the non-matched item\n                }\n\n            \/\/ when last match was found but not all items are matched (hence matchStart != 0)\n            if (matchFound && matchStart != 0)\n                return AppendTo(source, matchStart, i - matchStart, matches);\n\n            return matches ?? (matchStart != 0 ? Empty<T>() : source);\n        }\n\n        \/\/\/ <summary>Match with the additional state to use in <paramref name=\"condition\"\/> to minimize the allocations \n        \/\/\/ in <paramref name=\"condition\"\/> lambda closure<\/summary> \n        public static T[] Match<S, T>(this T[] source, S state, Func<S, T, bool> condition)\n        {\n            if (source == null || source.Length == 0)\n                return source;\n\n            if (source.Length == 1)\n                return condition(state, source[0]) ? source : Empty<T>();\n\n            if (source.Length == 2)\n            {\n                var c0 = condition(state, source[0]);\n                var c1 = condition(state, source[1]);\n                return c0 && c1 ? source : c0 ? new[] { source[0] } : c1 ? new[] { source[1] } : Empty<T>();\n            }\n\n            if (source.Length == 3)\n            {\n                var condition0 = condition(state, source[0]);\n                var condition1 = condition(state, source[1]);\n                var condition2 = condition(state, source[2]);\n                return condition0 && condition1 && condition2 ? source\n                    : condition0 ? (condition1 ? new[] { source[0], source[1] } : condition2 ? new[] { source[0], source[2] } : new[] { source[0] })\n                    : condition1 ? (condition2 ? new[] { source[1], source[2] } : new[] { source[1] })\n                    : condition2 ? new[] { source[2] }\n                    : Empty<T>();\n            }\n\n            var matchStart = 0;\n            T[] matches = null;\n            var matchFound = false;\n            var i = 0;\n            for (; i < source.Length; ++i)\n                if (!(matchFound = condition(state, source[i])))\n                {\n                    \/\/ for accumulated matched items\n                    if (i != 0 && i > matchStart)\n                        matches = AppendTo(source, matchStart, i - matchStart, matches);\n                    matchStart = i + 1; \/\/ guess the next match start will be after the non-matched item\n                }\n\n            \/\/ when last match was found but not all items are matched (hence matchStart != 0)\n            if (matchFound && matchStart != 0)\n                return AppendTo(source, matchStart, i - matchStart, matches);\n\n            return matches ?? (matchStart != 0 ? Empty<T>() : source);\n        }\n\n        \/\/\/ <summary>Match with the additional state to use in <paramref name=\"condition\"\/> to minimize the allocations \n        \/\/\/ in <paramref name=\"condition\"\/> lambda closure<\/summary> \n        public static T[] Match<A, B, T>(this T[] source, A a, B b, Func<A, B, T, bool> condition)\n        {\n            if (source == null || source.Length == 0)\n                return source;\n\n            if (source.Length == 1)\n                return condition(a, b, source[0]) ? source : Empty<T>();\n\n            if (source.Length == 2)\n            {\n                var c0 = condition(a, b, source[0]);\n                var c1 = condition(a, b, source[1]);\n                return c0 && c1 ? source : c0 ? new[] { source[0] } : c1 ? new[] { source[1] } : Empty<T>();\n            }\n\n            var matchStart = 0;\n            T[] matches = null;\n            var matchFound = false;\n            var i = 0;\n            for (; i < source.Length; ++i)\n                if (!(matchFound = condition(a, b, source[i])))\n                {\n                    \/\/ for accumulated matched items\n                    if (i != 0 && i > matchStart)\n                        matches = AppendTo(source, matchStart, i - matchStart, matches);\n                    matchStart = i + 1; \/\/ guess the next match start will be after the non-matched item\n                }\n\n            \/\/ when last match was found but not all items are matched (hence matchStart != 0)\n            if (matchFound && matchStart != 0)\n                return AppendTo(source, matchStart, i - matchStart, matches);\n\n            return matches ?? (matchStart != 0 ? Empty<T>() : source);\n        }\n\n        \/\/\/ <summary>Where method similar to Enumerable.Where but more performant and non necessary allocating.\n        \/\/\/ It returns source array and does Not create new one if all items match the condition.<\/summary>\n        public static R[] Match<T, R>(this T[] source, Func<T, bool> condition, Func<T, R> map)\n        {\n            if (source == null)\n                return null;\n\n            if (source.Length == 0)\n                return Empty<R>();\n\n            if (source.Length == 1)\n            {\n                var item = source[0];\n                return condition(item) ? new[] { map(item) } : Empty<R>();\n            }\n\n            if (source.Length == 2)\n            {\n                var c0 = condition(source[0]);\n                var c1 = condition(source[1]);\n                return c0 && c1 ? new[] { map(source[0]), map(source[1]) } : c0 ? new[] { map(source[0]) } : c1 ? new[] { map(source[1]) } : Empty<R>();\n            }\n\n            if (source.Length == 3)\n            {\n                var condition0 = condition(source[0]);\n                var condition1 = condition(source[1]);\n                var condition2 = condition(source[2]);\n                return condition0 && condition1 && condition2 ? new[] { map(source[0]), map(source[1]), map(source[2]) }\n                    : condition0 ? (condition1 ? new[] { map(source[0]), map(source[1]) } : condition2 ? new[] { map(source[0]), map(source[2]) } : new[] { map(source[0]) })\n                    : condition1 ? (condition2 ? new[] { map(source[1]), map(source[2]) } : new[] { map(source[1]) })\n                    : condition2 ? new[] { map(source[2]) }\n                    : Empty<R>();\n            }\n\n            var matchStart = 0;\n            R[] matches = null;\n            var matchFound = false;\n\n            var i = 0;\n            for (; i < source.Length; ++i)\n                if (!(matchFound = condition(source[i])))\n                {\n                    \/\/ for accumulated matched items\n                    if (i != 0 && i > matchStart)\n                        matches = AppendTo(source, matchStart, i - matchStart, map, matches);\n                    matchStart = i + 1; \/\/ guess the next match start will be after the non-matched item\n                }\n\n            \/\/ when last match was found but not all items are matched (hence matchStart != 0)\n            if (matchFound && matchStart != 0)\n                return AppendTo(source, matchStart, i - matchStart, map, matches);\n\n            return matches ?? (matchStart == 0 ? AppendTo(source, 0, source.Length, map) : Empty<R>());\n        }\n\n        \/\/\/ <summary>Match with the additional state to use in <paramref name=\"condition\"\/> and <paramref name=\"map\"\/> \n        \/\/\/ to minimize the allocations in <paramref name=\"condition\"\/> lambda closure <\/summary>\n        public static R[] Match<S, T, R>(this T[] source, S state, Func<S, T, bool> condition, Func<S, T, R> map)\n        {\n            if (source == null)\n                return null;\n            if (source.Length == 0)\n                return Empty<R>();\n\n            if (source.Length == 1)\n            {\n                var item = source[0];\n                return condition(state, item) ? new[] { map(state, item) } : Empty<R>();\n            }\n\n            if (source.Length == 2)\n            {\n                var condition0 = condition(state, source[0]);\n                var condition1 = condition(state, source[1]);\n                return condition0 && condition1 ? new[] { map(state, source[0]), map(state, source[1]) }\n                    : condition0 ? new[] { map(state, source[0]) }\n                    : condition1 ? new[] { map(state, source[1]) }\n                    : Empty<R>();\n            }\n\n            if (source.Length == 3)\n            {\n                var condition0 = condition(state, source[0]);\n                var condition1 = condition(state, source[1]);\n                var condition2 = condition(state, source[2]);\n                return condition0 && condition1 && condition2 ? new[] { map(state, source[0]), map(state, source[1]), map(state, source[2]) }\n                    : condition0 ? (condition1 ? new[] { map(state, source[0]), map(state, source[1]) } : condition2 ? new[] { map(state, source[0]), map(state, source[2]) } : new[] { map(state, source[0]) })\n                    : condition1 ? (condition2 ? new[] { map(state, source[1]), map(state, source[2]) } : new[] { map(state, source[1]) })\n                    : condition2 ? new[] { map(state, source[2]) }\n                    : Empty<R>();\n            }\n\n            var matchStart = 0;\n            R[] matches = null;\n            var matchFound = false;\n\n            var i = 0;\n            for (; i < source.Length; ++i)\n                if (!(matchFound = condition(state, source[i])))\n                {\n                    \/\/ for accumulated matched items\n                    if (i != 0 && i > matchStart)\n                        matches = AppendTo(source, state, matchStart, i - matchStart, map, matches);\n                    matchStart = i + 1; \/\/ guess the next match start will be after the non-matched item\n                }\n\n            \/\/ when last match was found but not all items are matched (hence matchStart != 0)\n            if (matchFound && matchStart != 0)\n                return AppendTo(source, state, matchStart, i - matchStart, map, matches);\n\n            return matches ?? (matchStart == 0 ? AppendTo(source, state, 0, source.Length, map) : Empty<R>());\n        }\n\n        \/\/\/ <summary>Match with the additional state to use in <paramref name=\"condition\"\/> and <paramref name=\"map\"\/> \n        \/\/\/ to minimize the allocations in <paramref name=\"condition\"\/> lambda closure <\/summary>\n        public static R[] Match<A, B, T, R>(this T[] source, A a, B b, Func<A, B, T, bool> condition, Func<A, B, T, R> map)\n        {\n            if (source == null)\n                return null;\n            if (source.Length == 0)\n                return Empty<R>();\n\n            if (source.Length == 1)\n            {\n                var item = source[0];\n                return condition(a, b, item) ? new[] { map(a, b, item) } : Empty<R>();\n            }\n\n            if (source.Length == 2)\n            {\n                var condition0 = condition(a, b, source[0]);\n                var condition1 = condition(a, b, source[1]);\n                return condition0 && condition1 ? new[] { map(a, b, source[0]), map(a, b, source[1]) }\n                    : condition0 ? new[] { map(a, b, source[0]) }\n                    : condition1 ? new[] { map(a, b, source[1]) }\n                    : Empty<R>();\n            }\n\n            var matchStart = 0;\n            R[] matches = null;\n            var matchFound = false;\n\n            var i = 0;\n            for (; i < source.Length; ++i)\n                if (!(matchFound = condition(a, b, source[i])))\n                {\n                    \/\/ for accumulated matched items\n                    if (i != 0 && i > matchStart)\n                        matches = AppendTo(source, a, b, matchStart, i - matchStart, map, matches);\n                    matchStart = i + 1; \/\/ guess the next match start will be after the non-matched item\n                }\n\n            \/\/ when last match was found but not all items are matched (hence matchStart != 0)\n            if (matchFound && matchStart != 0)\n                return AppendTo(source, a, b, matchStart, i - matchStart, map, matches);\n\n            return matches ?? (matchStart == 0 ? AppendTo(source, a, b, 0, source.Length, map) : Empty<R>());\n        }\n\n        \/\/\/ <summary>Maps all items from source to result array.<\/summary>\n        \/\/\/ <typeparam name=\"T\">Source item type<\/typeparam> <typeparam name=\"R\">Result item type<\/typeparam>\n        \/\/\/ <param name=\"source\">Source items<\/param> <param name=\"map\">Function to convert item from source to result.<\/param>\n        \/\/\/ <returns>Converted items<\/returns>\n        public static R[] Map<T, R>(this T[] source, Func<T, R> map)\n        {\n            if (source == null)\n                return null;\n\n            var sourceCount = source.Length;\n            if (sourceCount == 0)\n                return Empty<R>();\n\n            if (sourceCount == 1)\n                return new[] { map(source[0]) };\n\n            if (sourceCount == 2)\n                return new[] { map(source[0]), map(source[1]) };\n\n            var results = new R[sourceCount];\n            for (var i = 0; i < source.Length; i++)\n                results[i] = map(source[i]);\n            return results;\n        }\n\n        \/\/\/ Map with additional state to use in <paramref name=\"map\"\/> to minimize allocations in <paramref name=\"map\"\/> lambda closure \n        public static R[] Map<T, S, R>(this T[] source, S state, Func<S, T, R> map)\n        {\n            if (source == null)\n                return null;\n\n            var sourceCount = source.Length;\n            if (sourceCount == 0)\n                return Empty<R>();\n\n            if (sourceCount == 1)\n                return new[] { map(state, source[0]) };\n\n            if (sourceCount == 2)\n                return new[] { map(state, source[0]), map(state, source[1]) };\n\n            var results = new R[sourceCount];\n            for (var i = 0; i < source.Length; i++)\n                results[i] = map(state, source[i]);\n            return results;\n        }\n\n        \/\/\/ Map with additional two states to use in <paramref name=\"map\"\/> to minimize allocations in <paramref name=\"map\"\/> lambda closure \n        public static R[] Map<T, A, B, R>(this T[] source, A a, B b, Func<A, B, T, R> map)\n        {\n            if (source == null)\n                return null;\n\n            var sourceCount = source.Length;\n            if (sourceCount == 0)\n                return Empty<R>();\n\n            if (sourceCount == 1)\n                return new[] { map(a, b, source[0]) };\n\n            if (sourceCount == 2)\n                return new[] { map(a, b, source[0]), map(a, b, source[1]) };\n\n            var results = new R[sourceCount];\n            for (var i = 0; i < source.Length; i++)\n                results[i] = map(a, b, source[i]);\n            return results;\n        }\n\n        \/\/\/ <summary>Maps all items from source to result collection. If possible uses fast array Map otherwise Enumerable.Select.<\/summary>\n        \/\/\/ <typeparam name=\"T\">Source item type<\/typeparam> <typeparam name=\"R\">Result item type<\/typeparam>\n        \/\/\/ <param name=\"source\">Source items<\/param> <param name=\"map\">Function to convert item from source to result.<\/param>\n        \/\/\/ <returns>Converted items<\/returns>\n        public static IEnumerable<R> Map<T, R>(this IEnumerable<T> source, Func<T, R> map) =>\n            source is T[] arr ? arr.Map(map) : source?.Select(map);\n\n        \/\/\/ <summary>If <paramref name=\"source\"\/> is array uses more effective Match for array, otherwise just calls Where<\/summary>\n        \/\/\/ <typeparam name=\"T\">Type of source items.<\/typeparam>\n        \/\/\/ <param name=\"source\">If null, the null will be returned.<\/param>\n        \/\/\/ <param name=\"condition\">Condition to keep items.<\/param>\n        \/\/\/ <returns>Result items, may be an array.<\/returns>\n        public static IEnumerable<T> Match<T>(this IEnumerable<T> source, Func<T, bool> condition) =>\n            source is T[] arr ? arr.Match(condition) : source?.Where(condition);\n\n        \/\/\/ <summary>If <paramref name=\"source\"\/> is array uses more effective Match for array,\n        \/\/\/ otherwise just calls Where, Select<\/summary>\n        \/\/\/ <typeparam name=\"T\">Type of source items.<\/typeparam> <typeparam name=\"R\">Type of result items.<\/typeparam>\n        \/\/\/ <param name=\"source\">If null, the null will be returned.<\/param>\n        \/\/\/ <param name=\"condition\">Condition to keep items.<\/param>  <param name=\"map\">Converter from source to result item.<\/param>\n        \/\/\/ <returns>Result items, may be an array.<\/returns>\n        public static IEnumerable<R> Match<T, R>(this IEnumerable<T> source, Func<T, bool> condition, Func<T, R> map) =>\n            source is T[] arr ? arr.Match(condition, map) : source?.Where(condition).Select(map);\n    }\n\n    \/\/\/ <summary>Wrapper that provides optimistic-concurrency Swap operation implemented using <see cref=\"Ref.Swap{T}\"\/>.<\/summary>\n    \/\/\/ <typeparam name=\"T\">Type of object to wrap.<\/typeparam>\n    public sealed class Ref<T> where T : class\n    {\n        \/\/\/ <summary>Gets the wrapped value.<\/summary>\n        public T Value => _value;\n        private T _value;\n\n        \/\/\/ <summary>Creates ref to object, optionally with initial value provided.<\/summary>\n        \/\/\/ <param name=\"initialValue\">(optional) Initial value.<\/param>\n        public Ref(T initialValue = default) => _value = initialValue;\n\n        \/\/\/ <summary>Exchanges currently hold object with <paramref name=\"getNewValue\"\/> - see <see cref=\"Ref.Swap{T}\"\/> for details.<\/summary>\n        \/\/\/ <param name=\"getNewValue\">Delegate to produce new object value from current one passed as parameter.<\/param>\n        \/\/\/ <returns>Returns old object value the same way as <see cref=\"Interlocked.Exchange(ref int,int)\"\/><\/returns>\n        \/\/\/ <remarks>Important: <paramref name=\"getNewValue\"\/> May be called multiple times to retry update with value concurrently changed by other code.<\/remarks>\n        public T Swap(Func<T, T> getNewValue) =>\n            Ref.Swap(ref _value, getNewValue);\n\n        \/\/\/ <summary>Swap with the additional state <paramref name=\"a\"\/> required for the delegate <paramref name=\"getNewValue\"\/>.\n        \/\/\/ May prevent closure creation for the delegate<\/summary>\n        public T Swap<A>(A a, Func<T, A, T> getNewValue, int retryCountUntilThrow = Ref.RETRY_COUNT_UNTIL_THROW) =>\n             Ref.Swap(ref _value, a, getNewValue, retryCountUntilThrow);\n\n        \/\/\/ <summary>Swap with the additional state <paramref name=\"a\"\/>, <paramref name=\"b\"\/> required for the delegate <paramref name=\"getNewValue\"\/>.\n        \/\/\/ May prevent closure creation for the delegate<\/summary>\n        public T Swap<A, B>(A a, B b, Func<T, A, B, T> getNewValue, int retryCountUntilThrow = Ref.RETRY_COUNT_UNTIL_THROW) =>\n             Ref.Swap(ref _value, a, b, getNewValue, retryCountUntilThrow);\n\n        \/\/\/ <summary>Swap with the additional state <paramref name=\"a\"\/> required for the delegate <paramref name=\"getNewValue\"\/>.\n        \/\/\/ May prevent closure creation for the delegate<\/summary>\n        public T SwapAndGetNewValue<A>(A a, Func<T, A, T> getNewValue, int retryCountUntilThrow = Ref.RETRY_COUNT_UNTIL_THROW) =>\n             Ref.SwapAndGetNewValue(ref _value, a, getNewValue, retryCountUntilThrow);\n\n        \/\/\/ <summary>Just sets new value ignoring any intermingled changes and returns the original value<\/summary>\n        \/\/\/ <param name=\"newValue\"><\/param> <returns>old value<\/returns>\n        public T Swap(T newValue) => Interlocked.Exchange(ref _value, newValue);\n\n        \/\/\/ <summary>Directly sets the value and returns the new value<\/summary>\n        public T SetNonAtomic(T newValue) => _value = newValue;\n\n        \/\/\/ <summary>Compares current Referred value with <paramref name=\"currentValue\"\/> and if equal replaces current with <paramref name=\"newValue\"\/><\/summary>\n        \/\/\/ <param name=\"currentValue\"><\/param> <param name=\"newValue\"><\/param>\n        \/\/\/ <returns>True if current value was replaced with new value, and false if current value is outdated (already changed by other party).<\/returns>\n        \/\/\/ <example><c>[!CDATA[\n        \/\/\/ var value = SomeRef.Value;\n        \/\/\/ if (!SomeRef.TrySwapIfStillCurrent(value, Update(value))\n        \/\/\/     SomeRef.Swap(v => Update(v)); \/\/ fallback to normal Swap with delegate allocation\n        \/\/\/ ]]<\/c><\/example>\n        public bool TrySwapIfStillCurrent(T currentValue, T newValue) =>\n            Interlocked.CompareExchange(ref _value, newValue, currentValue) == currentValue;\n\n        \/\/\/ <summary>Just sets the new value<\/summary>\n        public void UnsafeSet(T newValue) => _value = newValue;\n    }\n\n    \/\/\/ <summary>Provides optimistic-concurrency consistent <see cref=\"Swap{T}\"\/> operation.<\/summary>\n    public static class Ref\n    {\n        \/\/\/ The default max retry count - can be overridden by `Swap` optional parameter \n        public const int RETRY_COUNT_UNTIL_THROW = 50;\n\n        \/\/\/ <summary>Factory for <see cref=\"Ref{T}\"\/> with type of value inference.<\/summary>\n        \/\/\/ <typeparam name=\"T\">Type of value to wrap.<\/typeparam>\n        \/\/\/ <param name=\"value\">Initial value to wrap.<\/param>\n        \/\/\/ <returns>New ref.<\/returns>\n        public static Ref<T> Of<T>(T value) where T : class => new Ref<T>(value);\n\n        \/\/\/ <summary>Creates new ref to the value of original ref.<\/summary> <typeparam name=\"T\">Ref value type.<\/typeparam>\n        \/\/\/ <param name=\"original\">Original ref.<\/param> <returns>New ref to original value.<\/returns>\n        public static Ref<T> NewRef<T>(this Ref<T> original) where T : class => Of(original.Value);\n\n        \/\/\/ <summary>First, it evaluates new value using <paramref name=\"getNewValue\"\/> function. \n        \/\/\/ Second, it checks that original value is not changed. \n        \/\/\/ If it is changed it will retry first step, otherwise it assigns new value and returns original (the one used for <paramref name=\"getNewValue\"\/>).<\/summary>\n        \/\/\/ <typeparam name=\"T\">Type of value to swap.<\/typeparam>\n        \/\/\/ <param name=\"value\">Reference to change to new value<\/param>\n        \/\/\/ <param name=\"getNewValue\">Delegate to get value from old one.<\/param>\n        \/\/\/ <param name=\"retryCountUntilThrow\">(optional)<\/param>\n        \/\/\/ <returns>Old\/original value. By analogy with <see cref=\"Interlocked.Exchange(ref int,int)\"\/>.<\/returns>\n        \/\/\/ <remarks>Important: <paramref name=\"getNewValue\"\/> May be called multiple times to retry update with value concurrently changed by other code.<\/remarks>\n        [MethodImpl((MethodImplOptions)256)]\n        public static T Swap<T>(ref T value, Func<T, T> getNewValue,\n            int retryCountUntilThrow = RETRY_COUNT_UNTIL_THROW)\n            where T : class\n        {\n            var spinWait = new SpinWait();\n            var retryCount = 0;\n            while (true)\n            {\n                var oldValue = value;\n                var newValue = getNewValue(oldValue);\n                if (Interlocked.CompareExchange(ref value, newValue, oldValue) == oldValue)\n                    return oldValue;\n\n                if (++retryCount > retryCountUntilThrow)\n                    ThrowRetryCountExceeded(retryCountUntilThrow);\n                spinWait.SpinOnce();\n            }\n        }\n\n        private static void ThrowRetryCountExceeded(int retryCountExceeded) =>\n            throw new InvalidOperationException(\n                $\"Ref retried to Update for {retryCountExceeded} times But there is always someone else intervened.\");\n\n        \/\/\/ <summary>Swap with the additional state <paramref name=\"a\"\/> required for the delegate <paramref name=\"getNewValue\"\/>.\n        \/\/\/ May prevent closure creation for the delegate<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static T Swap<T, A>(ref T value, A a, Func<T, A, T> getNewValue,\n            int retryCountUntilThrow = RETRY_COUNT_UNTIL_THROW)\n            where T : class\n        {\n            var spinWait = new SpinWait();\n            var retryCount = 0;\n            while (true)\n            {\n                var oldValue = value;\n                var newValue = getNewValue(oldValue, a);\n                if (Interlocked.CompareExchange(ref value, newValue, oldValue) == oldValue)\n                    return oldValue;\n                if (++retryCount > retryCountUntilThrow)\n                    ThrowRetryCountExceeded(retryCountUntilThrow);\n                spinWait.SpinOnce();\n            }\n        }\n\n        \/\/\/ <summary>Swap with the additional state a required for the delegate.\n        \/\/\/ Helps to avoid closure creation for the delegate<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static T SwapAndGetNewValue<T, A>(ref T value, A a, Func<T, A, T> getNewValue,\n            int retryCountUntilThrow = RETRY_COUNT_UNTIL_THROW)\n            where T : class\n        {\n            var spinWait = new SpinWait();\n            var retryCount = 0;\n            while (true)\n            {\n                var oldValue = value;\n                var newValue = getNewValue(oldValue, a);\n                if (Interlocked.CompareExchange(ref value, newValue, oldValue) == oldValue)\n                    return newValue;\n                if (++retryCount > retryCountUntilThrow)\n                    ThrowRetryCountExceeded(retryCountUntilThrow);\n                spinWait.SpinOnce();\n            }\n        }\n\n        \/\/\/ <summary>Swap with the additional state a, b required for the delegate.\n        \/\/\/ Helps to avoid closure creation for the delegate<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static T Swap<T, A, B>(ref T value, A a, B b, Func<T, A, B, T> getNewValue,\n            int retryCountUntilThrow = RETRY_COUNT_UNTIL_THROW)\n            where T : class\n        {\n            var spinWait = new SpinWait();\n            var retryCount = 0;\n            while (true)\n            {\n                var oldValue = value;\n                var newValue = getNewValue(oldValue, a, b);\n                if (Interlocked.CompareExchange(ref value, newValue, oldValue) == oldValue)\n                    return oldValue;\n                if (++retryCount > retryCountUntilThrow)\n                    ThrowRetryCountExceeded(retryCountUntilThrow);\n                spinWait.SpinOnce();\n            }\n        }\n\n        \/\/\/ <summary>Swap with the additional state a, b, c required for the delegate.\n        \/\/\/ Helps to avoid closure creation for the delegate<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static T Swap<T, A, B, C>(ref T value, A a, B b, C c, Func<T, A, B, C, T> getNewValue,\n            int retryCountUntilThrow = RETRY_COUNT_UNTIL_THROW)\n            where T : class\n        {\n            var spinWait = new SpinWait();\n            var retryCount = 0;\n            while (true)\n            {\n                var oldValue = value;\n                var newValue = getNewValue(oldValue, a, b, c);\n                if (Interlocked.CompareExchange(ref value, newValue, oldValue) == oldValue)\n                    return oldValue;\n                if (++retryCount > retryCountUntilThrow)\n                    ThrowRetryCountExceeded(retryCountUntilThrow);\n                spinWait.SpinOnce();\n            }\n        }\n\n        \/\/\/ <summary>Swap with the additional state a, b, c, d` required for the delegate.\n        \/\/\/ Helps to avoid closure creation for the delegate<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static T Swap<T, A, B, C, D>(ref T value, A a, B b, C c, D d, Func<T, A, B, C, D, T> getNewValue,\n            int retryCountUntilThrow = RETRY_COUNT_UNTIL_THROW)\n            where T : class\n        {\n            var spinWait = new SpinWait();\n            var retryCount = 0;\n            while (true)\n            {\n                var oldValue = value;\n                var newValue = getNewValue(oldValue, a, b, c, d);\n                if (Interlocked.CompareExchange(ref value, newValue, oldValue) == oldValue)\n                    return oldValue;\n                if (++retryCount > retryCountUntilThrow)\n                    ThrowRetryCountExceeded(retryCountUntilThrow);\n                spinWait.SpinOnce();\n            }\n        }\n    }\n\n    \/\/\/ <summary>Printable thing via provided printer <\/summary>\n    public interface IPrintable\n    {\n        \/\/\/ <summary>Print to the provided string builder via the provided printer.<\/summary>\n        StringBuilder Print(StringBuilder s, Func<StringBuilder, object, StringBuilder> printer);\n    }\n\n    \/\/\/ <summary>Produces good enough hash codes for the fields<\/summary>\n    public static class Hasher\n    {\n        \/\/\/ <summary>Combines hashes of two fields<\/summary>\n        public static int Combine<T1, T2>(T1 a, T2 b)\n        {\n            var bh = b?.GetHashCode() ?? 0;\n            if (ReferenceEquals(a, null))\n                return bh;\n            var ah = a.GetHashCode();\n            if (ah == 0)\n                return bh;\n            return Combine(ah, bh);\n        }\n\n        \/\/\/ <summary>Inspired by System.Tuple.CombineHashCodes<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static int Combine(int h1, int h2)\n        {\n            unchecked\n            {\n                return (h1 << 5) + h1 ^ h2;\n            }\n        }\n    }\n\n    \/\/\/ Simple unbounded object pool\n    public sealed class StackPool<T> where T : class\n    {\n        \/\/\/ <summary>Give me an object<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public T RentOrDefault() =>\n            Interlocked.Exchange(ref _s, _s?.Tail)?.Head;\n\n        \/\/\/ <summary>Give it back<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public void Return(T x) =>\n            Interlocked.Exchange(ref _s, new Stack(x, _s));\n\n        private Stack _s;\n\n        private sealed class Stack\n        {\n            public readonly T Head;\n            public readonly Stack Tail;\n            public Stack(T h, Stack t)\n            {\n                Head = h;\n                Tail = t;\n            }\n        }\n    }\n\n    \/\/\/ <summary>Immutable Key-Value pair. It is reference type (could be check for null), \n    \/\/\/ which is different from System value type <see cref=\"KeyValuePair{TKey,TValue}\"\/>.\n    \/\/\/ In addition provides <see cref=\"Equals\"\/> and <see cref=\"GetHashCode\"\/> implementations.<\/summary>\n    \/\/\/ <typeparam name=\"K\">Type of Key.<\/typeparam><typeparam name=\"V\">Type of Value.<\/typeparam>\n    public class KV<K, V> : IPrintable\n    {\n        \/\/\/ <summary>Key.<\/summary>\n        public readonly K Key;\n\n        \/\/\/ <summary>Value.<\/summary>\n        public readonly V Value;\n\n        \/\/\/ <summary>Creates Key-Value object by providing key and value. Does Not check either one for null.<\/summary>\n        \/\/\/ <param name=\"key\">key.<\/param><param name=\"value\">value.<\/param>\n        public KV(K key, V value)\n        {\n            Key = key;\n            Value = value;\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public StringBuilder Print(StringBuilder s, Func<StringBuilder, object, StringBuilder> printer) =>\n            s.Append(\"(\").To(b => Key == null ? b : printer(b, Key))\n                .Append(\", \").To(b => Value == null ? b : printer(b, Value))\n                .Append(')');\n\n        \/\/\/ <summary>Creates nice string view.<\/summary><returns>String representation.<\/returns>\n        public override string ToString() =>\n            Print(new StringBuilder(), (s, x) => s.Append(x)).ToString();\n\n        \/\/\/ <summary>Returns true if both key and value are equal to corresponding key-value of other object.<\/summary>\n        public override bool Equals(object obj)\n        {\n            var other = obj as KV<K, V>;\n            return other != null\n                   && (ReferenceEquals(other.Key, Key) || Equals(other.Key, Key))\n                   && (ReferenceEquals(other.Value, Value) || Equals(other.Value, Value));\n        }\n\n        \/\/\/ <summary>Combines key and value hash code<\/summary>\n        public override int GetHashCode() => Hasher.Combine(Key, Value);\n    }\n\n    \/\/\/ <summary>Helpers for <see cref=\"KV{K,V}\"\/>.<\/summary>\n    public static class KV\n    {\n        \/\/\/ <summary>Creates the key value pair.<\/summary>\n        public static KV<K, V> Of<K, V>(K key, V value) => new KV<K, V>(key, value);\n\n        \/\/\/ <summary>Creates the pair with the new value<\/summary>\n        public static KV<K, V> WithValue<K, V>(this KV<K, V> kv, V value) => new KV<K, V>(kv.Key, value);\n    }\n\n    \/\/\/ Simple helper for creation of the pair of two parts.\n    public static class KeyValuePair\n    {\n        \/\/\/ Pairs key with value.\n        public static KeyValuePair<K, V> Pair<K, V>(this K key, V value) => new KeyValuePair<K, V>(key, value);\n    }\n\n    \/\/\/ <summary>Helper structure which allows to distinguish null value from the default value for optional parameter.<\/summary>\n    public struct Opt<T>\n    {\n        \/\/\/ <summary>Allows to transparently convert parameter argument to opt structure.<\/summary>\n        public static implicit operator Opt<T>(T value) => new Opt<T>(value);\n\n        \/\/\/ <summary>Argument value.<\/summary>\n        public readonly T Value;\n\n        \/\/\/ <summary>Indicates that value is provided.<\/summary>\n        public readonly bool HasValue;\n\n        \/\/\/ <summary>Wraps passed value in structure. Sets the flag that value is present.<\/summary>\n        public Opt(T value)\n        {\n            HasValue = true;\n            Value = value;\n        }\n\n        \/\/\/ <summary>Helper to get value or default value if value is not present.<\/summary>\n        public T OrDefault(T defaultValue = default) => HasValue ? Value : defaultValue;\n    }\n\n    \/\/\/ <summary>Ever growing list methods<\/summary>\n    public static class GrowingList\n    {\n        \/\/\/ <summary>Default initial capacity <\/summary>\n        public const int DefaultInitialCapacity = 2;\n\n        \/\/\/ Push the new slot and return the ref to it\n        public static ref T PushSlot<T>(ref T[] items, int count)\n        {\n            if (items == null)\n                items = new T[DefaultInitialCapacity];\n            else if (count >= items.Length)\n                Expand(ref items);\n            return ref items[count];\n        }\n\n        \/\/\/ Adds the new item possibly extending the item collection\n        public static void Push<T>(ref T[] items, int count, T item)\n        {\n            if (items == null)\n                items = new T[DefaultInitialCapacity];\n            else if (count >= items.Length)\n                Expand(ref items);\n            items[count] = item;\n        }\n\n        \/\/\/ <summary>Expands the items starting with 2<\/summary>\n        internal static void Expand<T>(ref T[] items)\n        {\n            var count = items.Length;\n            var newItems = new T[count << 1]; \/\/ count x 2\n            if (count < 6)\n                for (var i = 0; i < count; ++i)\n                    newItems[i] = items[i];\n            else\n                Array.Copy(items, 0, newItems, 0, count);\n        }\n\n        \/\/\/<summary>Creates the final array out of the list, so that you cannot use after that!<\/summary>\n        public static T[] ResizeToArray<T>(T[] items, int count)\n        {\n            if (count < items.Length)\n                Array.Resize(ref items, count);\n            return items;\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public static string ToString<T>(T[] items, int count) =>\n            $\"Count {count} of {(count == 0 || items == null || items.Length == 0 ? \"empty\" : \"first (\" + items[0] + \") and last (\" + items[count - 1] + \")\")}\";\n    }\n\n    \/\/\/ <summary>Ever growing list<\/summary>\n    public struct GrowingList<T>\n    {\n        \/\/\/ <summary>Default initial capacity <\/summary>\n        public const int DefaultInitialCapacity = 2;\n\n        \/\/\/ <summary>The items array<\/summary>\n        public T[] Items;\n\n        \/\/\/ <summary>The count<\/summary>\n        public int Count;\n\n        \/\/\/ <summary>Constructs the thing<\/summary>\n        public GrowingList(T[] items, int count = 0)\n        {\n            Items = items;\n            Count = count;\n        }\n\n        \/\/\/ <summary>Push the new slot and return the ref to it<\/summary>\n        public ref T PushSlot()\n        {\n            if (Items == null)\n                Items = new T[DefaultInitialCapacity];\n            else if (Count >= Items.Length)\n                GrowingList.Expand(ref Items);\n            return ref Items[Count++];\n        }\n\n        \/\/\/ <summary>Adds the new item possibly extending the item collection<\/summary>\n        public void Push(T item)\n        {\n            if (Items == null)\n                Items = new T[DefaultInitialCapacity];\n            else if (Count >= Items.Length)\n                GrowingList.Expand(ref Items);\n            Items[Count++] = item;\n        }\n\n        \/\/\/ <summary>Pops the item - just moving the counter back<\/summary>\n        public void Pop() => --Count;\n\n        \/\/\/<summary>Creates the final array out of the list, so that you cannot use after that!<\/summary>\n        public T[] ResizeToArray()\n        {\n            var items = Items;\n            if (Count < items.Length)\n                Array.Resize(ref items, Count);\n            return items;\n        }\n\n        \/\/ todo: @naming think of the better name\n        \/\/\/ <summary>Pops the item - just moving the counter back<\/summary>\n        public T PopItem() => Items[--Count];\n\n        \/\/\/ <inheritdoc \/>\n        public override string ToString() =>\n            $\"Count {Count} of {(Count == 0 || Items == null || Items.Length == 0 ? \"empty\" : \"first (\" + Items[0] + \") and last (\" + Items[Count - 1] + \")\")}\";\n    }\n\n    \/\/\/ <summary>Immutable list - simplest linked list with the Head and the Tail.<\/summary>\n    public sealed class ImList<T>\n    {\n        \/\/\/ <summary>Empty list to Push to.<\/summary>\n        public static readonly ImList<T> Empty = new ImList<T>();\n\n        \/\/\/ <summary>True for empty list.<\/summary>\n        public bool IsEmpty => Tail == null;\n\n        \/\/\/ <summary>First value in a list.<\/summary>\n        public readonly T Head;\n\n        \/\/\/ <summary>The rest of values or Empty if list has a single value.<\/summary>\n        public readonly ImList<T> Tail;\n\n        \/\/\/ <summary>Prepends new value and returns new list.<\/summary>\n        public ImList<T> Push(T head) => new ImList<T>(head, this);\n\n        \/\/\/ <summary>Enumerates the list.<\/summary>\n        public IEnumerable<T> Enumerate()\n        {\n            if (Tail == null)\n                yield break;\n            for (var list = this; list.Tail != null; list = list.Tail)\n                yield return list.Head;\n        }\n\n        \/\/\/ <summary>String representation for debugging purposes<\/summary>\n        public override string ToString() => IsEmpty\n            ? \"[]\" : Tail.IsEmpty\n            ? \"[\" + Head + \"]\" : Tail.Tail.IsEmpty\n            ? \"[\" + Head + \",\" + Tail.Head + \"]\" : Tail.Tail.Tail.IsEmpty\n            ? \"[\" + Head + \",\" + Tail.Head + \",\" + Tail.Tail.Head + \"]\"\n            : \"[\" + Head + \",\" + Tail.Head + \",\" + Tail.Tail.Head + \", ...]\";\n\n        private ImList() { }\n        private ImList(T head, ImList<T> tail)\n        {\n            Head = head;\n            Tail = tail;\n        }\n    }\n\n    \/\/\/ <summary>Extension methods providing basic operations on a list.<\/summary>\n    public static class ImList\n    {\n        \/\/\/ Split list into (Head, Tail, IsEmpty) tuple\n        public static void Deconstruct<T>(this ImList<T> list, out T head, out ImList<T> tail, out bool isEmpty)\n        {\n            head = list.Head;\n            tail = list.Tail;\n            isEmpty = list.IsEmpty;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Constructs the reversed list from the parameter array of items\n        \/\/\/ <\/summary>\n        public static ImList<T> List<T>(params T[] items)\n        {\n            var l = ImList<T>.Empty;\n            if (items != null)\n                for (var i = items.Length - 1; i >= 0; --i)\n                    l = l.Push(items[i]);\n            return l;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Constructs the list as the reversed input list\n        \/\/\/ <\/summary>\n        public static ImList<T> ToImList<T>(this IList<T> source)\n        {\n            var l = ImList<T>.Empty;\n            if (source != null)\n                for (var i = source.Count - 1; i >= 0; --i)\n                    l = l.Push(source[i]);\n            return l;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Constructs the list as the reversed enumerable\n        \/\/\/ <\/summary>\n        public static ImList<T> ToImList<T>(this IEnumerable<T> source)\n        {\n            if (source is IList<T> list)\n                return list.ToImList();\n            var l = ImList<T>.Empty;\n\n            if (source != null)\n                foreach (var item in source)\n                    l = l.Push(item);\n            return l.Reverse();\n        }\n\n        \/\/\/ <summary>Constructs list of one element<\/summary>\n        public static ImList<T> List<T>(this T head) => ImList<T>.Empty.Push(head);\n\n        \/\/\/ <summary>Constructs list from head and tail<\/summary>\n        public static ImList<T> List<T>(this T head, ImList<T> tail) => tail.Push(head);\n\n        \/\/\/ <summary>Apples some effect action to each element<\/summary>\n        public static void ForEach<T>(this ImList<T> list, Action<T> effect)\n        {\n            for (; !list.IsEmpty; list = list.Tail)\n                effect(list.Head);\n        }\n\n        \/\/\/ <summary>Fold list to a single value. The respective name for it in LINQ is Aggregate<\/summary>\n        public static S Fold<T, S>(this ImList<T> list, S state, Func<T, S, S> handler)\n        {\n            if (list.IsEmpty)\n                return state;\n            var result = state;\n            for (; !list.IsEmpty; list = list.Tail)\n                result = handler(list.Head, result);\n            return result;\n        }\n\n        \/\/\/ <summary>Fold list to a single value with index of item. The respective name for it in LINQ is Aggregate.<\/summary>\n        public static S Fold<T, S>(this ImList<T> list, S state, Func<T, int, S, S> handler)\n        {\n            if (list.IsEmpty)\n                return state;\n            var result = state;\n            for (var i = 0; !list.IsEmpty; list = list.Tail, ++i)\n                result = handler(list.Head, i, result);\n            return result;\n        }\n\n        \/\/\/ <summary>Returns new list in reverse order.<\/summary>\n        public static ImList<T> Reverse<T>(this ImList<T> list)\n        {\n            if (list.IsEmpty || list.Tail.IsEmpty)\n                return list;\n            var reversed = ImList<T>.Empty;\n            for (; !list.IsEmpty; list = list.Tail)\n                reversed = reversed.Push(list.Head);\n            return reversed;\n        }\n\n        \/\/\/ <summary>Maps the items from the first list to the result list.<\/summary>\n        public static ImList<R> Map<T, R>(this ImList<T> list, Func<T, R> map) =>\n            list.Fold(ImList<R>.Empty, (x, r) => List(map(x), r)).Reverse();\n\n        \/\/\/ <summary>Maps with index<\/summary>\n        public static ImList<R> Map<T, R>(this ImList<T> list, Func<T, int, R> map) =>\n            list.Fold(ImList<R>.Empty, (x, i, r) => List(map(x, i), r)).Reverse();\n\n        \/\/\/ <summary>Copies list to array.<\/summary>\n        public static T[] ToArray<T>(this ImList<T> source) =>\n            source.IsEmpty ? ArrayTools.Empty<T>()\n            : source.Tail.IsEmpty ? new[] { source.Head } : source.Enumerate().ToArray();\n    }\n\n    \/\/\/ Zipper is an immutable persistent data structure, to represent collection with single focused (selected, active) element.\n    \/\/\/ Consist of REVERSED `Left` immutable list, `Focus` element, and the `Right` immutable list. That's why a Zipper name,\n    \/\/\/ where left and right part are joined \/ zipped in focus item.\n    public sealed class ImZipper<T>\n    {\n        \/\/\/ Empty singleton instance to start building your zipper\n        public static readonly ImZipper<T> Empty = new ImZipper<T>();\n\n        \/\/\/ True is zipper does not contain items\n        public bool IsEmpty => Count == 0;\n\n        \/\/\/ Index of Focus item, from `0` to `Count-1`\n        public readonly int Index;\n\n        \/\/\/ Number of items\n        public readonly int Count;\n\n        \/\/\/ Left REVERSED list, so the Head of the list is just prior the Focus item \n        public readonly ImList<T> Left;\n\n        \/\/\/ Right list, where Head is just after the Focus item\n        public readonly ImList<T> Right;\n\n        \/\/\/ Single focus item\n        public readonly T Focus;\n\n        \/\/\/ <inheritdoc \/>\n        public override string ToString() =>\n            IsEmpty ? \"[||]\" : Count + \":\" + Left.Reverse() + \"|\" + Index + \":\" + Focus + \"|\" + Right;\n\n        \/\/\/ Sets a new focus and pushes the old focus to the Left list. \n        public ImZipper<T> Append(T focus) => PushLeft(focus);\n\n        \/\/\/ Sets a new focus and pushes the old focus to the Left list.\n        public ImZipper<T> PushLeft(T focus) =>\n        IsEmpty ? new ImZipper<T>(ImList<T>.Empty, focus, 0, ImList<T>.Empty, 1)\n                : new ImZipper<T>(Left.Push(Focus), focus, Index + 1, Right, Count + 1);\n\n        \/\/\/ Sets a new focus and pushes the old focus to the right list. \n        public ImZipper<T> Insert(T focus) => PushRight(focus);\n\n        \/\/\/ Sets a new focus and pushes the old focus to the right list. \n        public ImZipper<T> PushRight(T focus) =>\n            IsEmpty ? new ImZipper<T>(ImList<T>.Empty, focus, 0, ImList<T>.Empty, 1)\n                : new ImZipper<T>(Left, focus, Index, Right.Push(Focus), Count + 1);\n\n        \/\/\/ Removes a focus, filling the hole with the item from the left list, or from the right if the left is empty\n        public ImZipper<T> PopLeft() =>\n            IsEmpty ? this\n            : Left.IsEmpty && Right.IsEmpty ? Empty\n            : !Left.IsEmpty ? new ImZipper<T>(Left.Tail, Left.Head, Index - 1, Right, Count - 1)\n            : new ImZipper<T>(Left, Right.Head, Index, Right.Tail, Count - 1);\n\n        \/\/\/ Removes a focus, filling the hole with the item from the right list, or from the left if the right is empty\n        public ImZipper<T> PopRight() =>\n            IsEmpty ? this\n            : Left.IsEmpty && Right.IsEmpty ? Empty\n            : !Right.IsEmpty ? new ImZipper<T>(Left, Right.Head, Index, Right.Tail, Count - 1)\n            : new ImZipper<T>(Left.Tail, Left.Head, Index - 1, Right, Count - 1);\n\n        \/\/\/ Shifts focus one element to the left (decrementing its Index).\n        public ImZipper<T> ShiftLeft() =>\n            IsEmpty || Left.IsEmpty ? this\n            : new ImZipper<T>(Left.Tail, Left.Head, Index - 1, Right.Push(Focus), Count);\n\n        \/\/\/ Shifts focus one element to the right (incrementing its Index).\n        public ImZipper<T> ShiftRight() =>\n            IsEmpty || Right.IsEmpty ? this\n            : new ImZipper<T>(Left.Push(Focus), Right.Head, Index + 1, Right.Tail, Count);\n\n        \/\/\/ Sets a new focus and returns a new zipper with the left and right lists unchanged\n        public ImZipper<T> WithFocus(T focus) =>\n            IsEmpty ? this : new ImZipper<T>(Left, focus, Index, Right, Count);\n\n        \/\/\/ Maps over the zipper items producing a new zipper\n        public ImZipper<R> Map<R>(Func<T, R> map) =>\n            IsEmpty ? ImZipper<R>.Empty\n                : new ImZipper<R>(Left.Reverse().Fold(ImList<R>.Empty, (x, r) => r.Push(map(x))),\n                    map(Focus), Index, Right.Map(map), Count);\n\n        \/\/\/ Maps over the zipper items with item index, producing a new zipper\n        public ImZipper<R> Map<R>(Func<T, int, R> map) =>\n            IsEmpty ? ImZipper<R>.Empty\n                : new ImZipper<R>(\n                    Left.Reverse().Fold(ImList<R>.Empty, (x, i, r) => r.Push(map(x, i))),\n                    map(Focus, Index), Index, Right.Map((x, i) => map(x, Index + 1 + i)), Count);\n\n        private ImZipper() => Index = -1;\n\n        private ImZipper(ImList<T> left, T focus, int index, ImList<T> right, int count)\n        {\n            Left = left;\n            Focus = focus;\n            Index = index;\n            Right = right;\n            Count = count;\n        }\n    }\n\n    \/\/\/ Other ImZipper methods\n    public static class ImZipper\n    {\n        \/\/\/ Appends array items to zipper\n        public static ImZipper<T> Zip<T>(params T[] items)\n        {\n            if (items.IsNullOrEmpty())\n                return ImZipper<T>.Empty;\n            var z = ImZipper<T>.Empty;\n            for (var i = 0; i < items.Length; ++i)\n                z = z.PushLeft(items[i]);\n            return z;\n        }\n\n        \/\/\/ Converts to array.\n        public static T[] ToArray<T>(this ImZipper<T> z)\n        {\n            if (z.IsEmpty)\n                return ArrayTools.Empty<T>();\n            var a = new T[z.Count];\n            z.Fold(a, (x, i, xs) =>\n            {\n                xs[i] = x;\n                return xs;\n            });\n            return a;\n        }\n\n        \/\/\/ Shifts focus to a specified index, e.g. a random access\n        public static ImZipper<T> ShiftTo<T>(this ImZipper<T> z, int i)\n        {\n            if (i < 0 || i >= z.Count || i == z.Index)\n                return z;\n            while (i < z.Index)\n                z = z.ShiftLeft();\n            while (i > z.Index)\n                z = z.ShiftRight();\n            return z;\n        }\n\n        \/\/\/ Updates a focus element if it is present, otherwise does nothing.\n        \/\/\/ If the focus item is the equal one, then returns the same zipper back.\n        public static ImZipper<T> Update<T>(this ImZipper<T> z, Func<T, T> update)\n        {\n            if (z.IsEmpty)\n                return z;\n            var result = update(z.Focus);\n            if (ReferenceEquals(z.Focus, result) || result != null && result.Equals(z.Focus))\n                return z;\n            return z.WithFocus(result);\n        }\n\n        \/\/\/ Update the item at random index, by shifting and updating it\n        public static ImZipper<T> UpdateAt<T>(this ImZipper<T> z, int i, Func<T, T> update) =>\n            i < 0 || i >= z.Count ? z : z.ShiftTo(i).Update(update);\n\n        \/\/\/ Update the item at random index, by shifting and updating it\n        public static ImZipper<T> RemoveAt<T>(this ImZipper<T> z, int i) =>\n            i < 0 || i >= z.Count ? z : z.ShiftTo(i).PopLeft();\n\n        \/\/\/ Folds zipper to a single value\n        public static S Fold<T, S>(this ImZipper<T> z, S state, Func<T, S, S> handler) =>\n            z.IsEmpty ? state :\n            z.Right.Fold(handler(z.Focus, z.Left.Reverse().Fold(state, handler)), handler);\n\n        \/\/\/ Folds zipper to a single value by using an item index\n        public static S Fold<T, S>(this ImZipper<T> z, S state, Func<T, int, S, S> handler)\n        {\n            if (z.IsEmpty)\n                return state;\n            var focusIndex = z.Index;\n            var reducedLeft = z.Left.Reverse().Fold(state, handler);\n            return z.Right.Fold(handler(z.Focus, focusIndex, reducedLeft),\n                (x, i, r) => handler(x, focusIndex + i + 1, r));\n        }\n\n        \/\/\/ <summary>Apply some effect action on each element<\/summary>\n        public static void ForEach<T>(this ImZipper<T> z, Action<T> effect)\n        {\n            if (!z.IsEmpty)\n            {\n                if (!z.Left.IsEmpty)\n                    z.Left.Reverse().ForEach(effect);\n                effect(z.Focus);\n                if (!z.Right.IsEmpty)\n                    z.Right.ForEach(effect);\n            }\n        }\n    }\n\n    \/\/\/ Given the old value should and the new value should return result updated value.\n    public delegate V Update<V>(V oldValue, V newValue);\n\n    \/\/\/ Update handler including the key\n    public delegate V Update<K, V>(K key, V oldValue, V newValue);\n\n    \/\/\/ <summary>Entry containing the Value in addition to the Hash<\/summary>\n    public abstract class ImHashMapEntry<K, V> : ImHashMap<K, V>.Entry\n    {\n        \/\/\/ <summary>The value. Maybe modified if you need the Ref{Value} semantics. \n        \/\/\/ You may add the entry with the default Value to the map, and calculate and set it later (e.g. using the CAS).<\/summary>\n        public V Value;\n\n        \/\/\/ <summary>Constructs the entry with the default value<\/summary>\n        protected ImHashMapEntry(int hash) : base(hash) { }\n        \/\/\/ <summary>Constructs the entry with the value<\/summary>\n        protected ImHashMapEntry(int hash, V value) : base(hash) => Value = value;\n\n        \/\/\/ <inheritdoc \/>\n        public sealed override int Count() => 1;\n\n        internal override int ForEach<S>(S state, int startIndex, Action<ImHashMapEntry<K, V>, int, S> handler)\n        {\n            handler(this, startIndex, state);\n            return startIndex + 1;\n        }\n\n#if !DEBUG\n        \/\/\/ <inheritdoc \/>\n        public override string ToString() => \"{K:\" + Key + \",V:\" + Value + \"}\";\n#endif\n    }\n\n    \/\/\/ <summary>Entry containing the Value in addition to the Hash<\/summary>\n    public class VEntry<V> : ImHashMapEntry<int, V>\n    {\n        \/\/\/ <summary>The Key is actually the Hash for this entry and the vice versa.<\/summary>\n        public override int Key => Hash;\n\n        \/\/\/ <summary>Constructs the entry with the default value<\/summary>\n        public VEntry(int hash) : base(hash) { }\n        \/\/\/ <summary>Constructs the entry with the value<\/summary>\n        public VEntry(int hash, V value) : base(hash, value) { }\n\n        internal override ImHashMapEntry<int, V> GetOrNull(int key) => key == Hash ? this : null;\n        internal override ImHashMapEntry<int, V> GetOrNullWithTheSameHash(int key) => this;\n        internal override ImHashMapEntry<int, V> GetOrNullByReferenceEqualsWithTheSameHash(int key) => this;\n        internal override V GetValueOrDefaultByReferenceEqualsWithTheSameHash(int key) => Value;\n        internal override Entry AddWithTheSameKey(ImHashMapEntry<int, V> newEntry) => this;\n        internal override Entry AddOrUpdateWithTheSameHash(ImHashMapEntry<int, V> newEntry) => newEntry;\n        internal override Entry AddOrUpdateWithTheSameHash(ImHashMapEntry<int, V> newEntry, Update<int, V> update) =>\n            ImHashMap.Entry(Hash, update(Hash, Value, newEntry.Value));\n        internal override Entry AddedOrNullWithTheSameHash(ImHashMapEntry<int, V> newEntry) => null;\n        internal override Entry UpdatedOrNullWithTheSameHash(ImHashMapEntry<int, V> newEntry) => newEntry;\n        internal override Entry UpdatedOrNullWithTheSameHash(int key, V value, Update<int, V> update) =>\n            ImHashMap.Entry(Hash, update(Hash, Value, value));\n        internal override Entry RemovedOrNullWithTheSameHash(int key) => this;\n        \/\/\/ <inheritdoc\/>\n        public override Entry AppendOrUpdateInPlaceOrKeep<S>(S state, ImHashMapEntry<int, V> newEntry, UpdaterInPlaceOrKeeper<S> updateOrKeep) =>\n            updateOrKeep(state, this, newEntry) != this ? newEntry : this;\n    }\n\n    \/\/\/ <summary>Entry containing the Key and Value in addition to the Hash<\/summary>\n    public class KVEntry<K, V> : ImHashMapEntry<K, V>\n    {\n        \/\/\/ <summary>The key<\/summary>\n        public override K Key => _key;\n        private readonly K _key;\n\n        \/\/\/ <summary>Constructs the entry with the key and default value<\/summary>\n        public KVEntry(int hash, K key) : base(hash) => _key = key;\n        \/\/\/ <summary>Constructs the entry with the key and value<\/summary>\n        public KVEntry(int hash, K key, V value) : base(hash, value) => _key = key;\n\n        internal override ImHashMapEntry<K, V> GetOrNull(K key) =>\n            _key.Equals(key) ? this : null;\n\n        internal override ImHashMapEntry<K, V> GetOrNullWithTheSameHash(K key) =>\n            _key.Equals(key) ? this : null;\n\n        internal override ImHashMapEntry<K, V> GetOrNullByReferenceEqualsWithTheSameHash(K key) =>\n            ReferenceEquals(_key, key) ? this : null;\n\n        internal override V GetValueOrDefaultByReferenceEqualsWithTheSameHash(K key) =>\n            ReferenceEquals(_key, key) ? Value : default;\n\n        internal override Entry AddWithTheSameKey(ImHashMapEntry<K, V> newEntry) =>\n            new HashConflictingEntry(Hash, this, newEntry);\n\n        internal override Entry AddOrUpdateWithTheSameHash(ImHashMapEntry<K, V> newEntry) =>\n            _key.Equals(newEntry.Key) ? newEntry : new HashConflictingEntry(Hash, this, newEntry);\n\n        internal override Entry AddOrUpdateWithTheSameHash(ImHashMapEntry<K, V> newEntry, Update<K, V> update)\n        {\n            var key = _key;\n            return key.Equals(newEntry.Key)\n                ? ImHashMap.Entry(Hash, key, update(key, Value, newEntry.Value))\n                : new HashConflictingEntry(Hash, this, newEntry);\n        }\n\n        internal override Entry AddedOrNullWithTheSameHash(ImHashMapEntry<K, V> newEntry) =>\n            _key.Equals(newEntry.Key) ? null : new HashConflictingEntry(Hash, this, newEntry);\n\n        internal override Entry UpdatedOrNullWithTheSameHash(ImHashMapEntry<K, V> newEntry) =>\n            _key.Equals(newEntry.Key) ? newEntry : null;\n\n        internal override Entry UpdatedOrNullWithTheSameHash(K key, V value, Update<K, V> update)\n        {\n            if (!_key.Equals(key))\n                return null;\n            value = update(key, Value, value);\n            return ReferenceEquals(Value, value) ? null : ImHashMap.Entry(Hash, key, value);\n        }\n\n        internal override Entry RemovedOrNullWithTheSameHash(K key) => _key.Equals(key) ? this : null;\n\n        \/\/\/ <inheritdoc\/>\n        public override Entry AppendOrUpdateInPlaceOrKeep<S>(S state, ImHashMapEntry<K, V> newEntry, UpdaterInPlaceOrKeeper<S> updateOrKeep) =>\n            !Key.Equals(newEntry.Key)\n                ? new HashConflictingEntry(Hash, this, newEntry)\n                : updateOrKeep(state, this, newEntry) != this ? newEntry : this;\n\n#if !DEBUG\n        \/\/\/ <inheritdoc \/>\n        public override string ToString() => \"{H: \" + Hash + \", K: \" + Key + \", V: \" + Value + \"}\";\n#endif\n    }\n\n    \/\/\/ <summary>The base and the holder class for the map tree leafs and branches, also defines the Empty tree.\n    \/\/\/ The map implementation is based on the \"modified\" 2-3 tree.<\/summary>\n    public class ImHashMap<K, V>\n    {\n        \/\/\/ <summary>Hide the base constructor to prevent the multiple Empty trees creation<\/summary>\n        protected ImHashMap() { }\n\n        \/\/\/ <summary>Empty map to start with. Exists as a single instance.<\/summary>\n        public static readonly ImHashMap<K, V> Empty = new ImHashMap<K, V>();\n\n        \/\/\/ <summary>Prints the map tree in JSON-ish format in release mode and enumerates the keys in DEBUG.<\/summary>\n        public override string ToString()\n        {\n#if DEBUG\n            \/\/ for the debug purposes we just output the first N keys in array\n            const int n = 50;\n            var count = this.Count();\n            var hashes = this.Enumerate().Take(n).Select(x => x.Hash).ToList();\n            return $\"{{hashes: new int[{(count > n ? $\"{n}\/{count}\" : \"\" + count)}] {{{(string.Join(\", \", hashes))}}}}}\";\n#else\n            return \"{}\";\n#endif\n        }\n\n        \/\/\/ <summary>Indicates that the map is empty<\/summary>\n        public bool IsEmpty => this == Empty;\n\n        \/\/\/ <summary>The count of entries in the map<\/summary>\n        public virtual int Count() => 0;\n\n        internal virtual bool MayTurnToBranch2 => false;\n\n        internal virtual Entry GetMinHashEntryOrDefault() => null;\n        internal virtual Entry GetMaxHashEntryOrDefault() => null;\n\n        \/\/\/ <summary>Lookup for the entry by hash. \n        \/\/\/ The returned entry maybe either single entry or the `HashConflictEntry` with multiple key-value entries for the same hash.\n        \/\/\/ If hash does not match the method returns `null`<\/summary>\n        internal virtual Entry GetEntryOrNull(int hash) => null;\n\n        \/\/ todo: @wip remove hash from here for simplicity\n        \/\/\/ <summary>Returns the found entry with the same hash or the new map with added new entry.\n        \/\/\/ Note that the empty map will return the entry the same as if the entry was found - so the consumer should check for the empty map.\n        \/\/\/ Note that the method cannot return the `null` - when the existing entry is not found it will always be the new map with the added entry.<\/summary>\n        internal virtual ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry) => entry;\n\n        \/\/\/ <summary>Returns the new map with old entry replaced by the new entry. \n        \/\/\/ Note that the old entry should be present.<\/summary>\n        internal virtual ImHashMap<K, V> ReplaceEntry(Entry oldEntry, Entry newEntry) => Empty;\n\n        \/\/\/ <summary>Removes the certainly present old entry and returns the new map without it.<\/summary>\n        internal virtual ImHashMap<K, V> RemoveEntry(Entry entry) => Empty;\n\n        \/\/\/ <summary>The delegate is supposed to return entry different from the oldEntry to update, and return the oldEntry to keep it.<\/summary>\n        public delegate ImHashMapEntry<K, V> UpdaterInPlaceOrKeeper<S>(S state, ImHashMapEntry<K, V> oldEntry, ImHashMapEntry<K, V> newEntry);\n\n        \/\/\/ <summary>The base map entry for holding the hash (or int key) and payload (possibly empty)<\/summary>\n        public abstract class Entry : ImHashMap<K, V>\n        {\n            \/\/\/ <summary>The Hash<\/summary>\n            public readonly int Hash;\n\n            \/\/\/ <summary>The Key (possibly the same as Hash)<\/summary>\n            public abstract K Key { get; }\n\n            \/\/\/ <summary>Constructs the entry with the hash<\/summary>\n            protected Entry(int hash) => Hash = hash;\n\n            \/\/\/ <summary>Lookup for the entry by Hash and Key<\/summary>\n            internal abstract ImHashMapEntry<K, V> GetOrNull(K key);\n\n            \/\/\/ <summary>Get entry if it has the equal key, assuming the entry has the same hash already.<\/summary>\n            internal abstract ImHashMapEntry<K, V> GetOrNullWithTheSameHash(K key);\n\n            \/\/\/ <summary>Get entry if it has the reference equal key, assuming the entry has the same hash already.<\/summary>\n            internal abstract ImHashMapEntry<K, V> GetOrNullByReferenceEqualsWithTheSameHash(K key);\n\n            \/\/\/ <summary>Get entry if it has the reference equal key, assuming the entry has the same hash already.<\/summary>\n            internal abstract V GetValueOrDefaultByReferenceEqualsWithTheSameHash(K key);\n\n            \/\/\/ <summary>Appends the new entry to the existing entry, assuming the entry has the same key already.\n            \/\/\/ For `VEntry` returns `this` entry.<\/summary>\n            internal abstract Entry AddWithTheSameKey(ImHashMapEntry<K, V> newEntry);\n\n            \/\/\/ <summary>Always returns updated entry or the updated (hash-conflicting) entry with added `newEntry`.<\/summary>\n            internal abstract Entry AddOrUpdateWithTheSameHash(ImHashMapEntry<K, V> newEntry);\n\n            \/\/\/ <summary>Always returns updated entry with the updated value or the updated (hash-conflicting) entry with added `newEntry`<\/summary>\n            internal abstract Entry AddOrUpdateWithTheSameHash(ImHashMapEntry<K, V> newEntry, Update<K, V> update);\n\n            \/\/\/ <summary>Returns either updated entry or `null` if `newEntry.Key` is not found inside<\/summary>\n            internal abstract Entry UpdatedOrNullWithTheSameHash(ImHashMapEntry<K, V> newEntry);\n\n            \/\/\/ <summary>Returns either updated entry or `null` if `newEntry.Key` is not found inside<\/summary>\n            internal abstract Entry UpdatedOrNullWithTheSameHash(K key, V value, Update<K, V> update);\n\n            \/\/\/ <summary>Returns either added entry or `null` if `newEntry.Key` is not found inside<\/summary>\n            internal abstract Entry AddedOrNullWithTheSameHash(ImHashMapEntry<K, V> newEntry);\n\n            \/\/\/ <summary>Returns the `this` entry if the `key` is equals to its key, otherwise null<\/summary>\n            internal abstract Entry RemovedOrNullWithTheSameHash(K key);\n\n            \/\/\/ <summary>Updating the newEntry in place via the provide delegate based on the current (old) entry or\n            \/\/\/ adding the newEntry to the hash-conflicting entry, or keeping the old one.<\/summary>\n            public abstract Entry AppendOrUpdateInPlaceOrKeep<S>(S state, ImHashMapEntry<K, V> newEntry, UpdaterInPlaceOrKeeper<S> updateOrKeep);\n\n            internal override Entry GetMinHashEntryOrDefault() => this;\n            internal override Entry GetMaxHashEntryOrDefault() => this;\n\n            internal sealed override Entry GetEntryOrNull(int hash) => hash == Hash ? this : null;\n\n            \/\/\/ <inheritdoc \/>\n            internal sealed override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry) =>\n                hash > Hash ? new Leaf2(this, entry) : hash < Hash ? new Leaf2(entry, this) : (ImHashMap<K, V>)this;\n\n            internal sealed override ImHashMap<K, V> ReplaceEntry(Entry oldEntry, Entry newEntry)\n            {\n                Debug.Assert(this == oldEntry, \"When down to the entry, the oldEntry should be present in the entry.\");\n                return newEntry;\n            }\n\n            internal sealed override ImHashMap<K, V> RemoveEntry(Entry removedEntry)\n            {\n                Debug.Assert(this == removedEntry, \"When down to the entry, the removedEntry should be present in the entry.\");\n                return Empty;\n            }\n\n            internal abstract int ForEach<S>(S state, int startIndex, Action<ImHashMapEntry<K, V>, int, S> handler);\n        }\n\n        \/\/\/ <summary>The composite containing the list of entries with the same conflicting Hash.<\/summary>\n        internal sealed class HashConflictingEntry : Entry\n        {\n            public ImHashMapEntry<K, V>[] Conflicts;\n\n            public override K Key => throw new NotSupportedException(\"The Key does not make sense foe multi-key entry: \" + this);\n\n            internal HashConflictingEntry(int hash, params ImHashMapEntry<K, V>[] conflicts) : base(hash) => Conflicts = conflicts;\n\n#if !DEBUG\n            public override string ToString()\n            {\n                var sb = new System.Text.StringBuilder(\"HashConflictingEntry: [\");\n                foreach (var x in Conflicts) \n                    sb.Append(x.ToString()).Append(\", \");\n                return sb.Append(\"]\").ToString();\n            }\n#endif\n\n            public override int Count() => Conflicts.Length;\n\n            internal override ImHashMapEntry<K, V> GetOrNull(K key)\n            {\n                var cs = Conflicts;\n                var i = cs.Length - 1;\n                while (i != -1 && !cs[i].Key.Equals(key)) --i;\n                return i != -1 ? cs[i] : null;\n            }\n\n            internal override ImHashMapEntry<K, V> GetOrNullWithTheSameHash(K key) => GetOrNull(key);\n\n            internal override ImHashMapEntry<K, V> GetOrNullByReferenceEqualsWithTheSameHash(K key)\n            {\n                var cs = Conflicts;\n                var i = cs.Length - 1;\n                while (i != -1 && !ReferenceEquals(cs[i].Key, key)) --i;\n                return i != -1 ? cs[i] : null;\n            }\n\n            internal override V GetValueOrDefaultByReferenceEqualsWithTheSameHash(K key)\n            {\n                var cs = Conflicts;\n                var i = cs.Length - 1;\n                while (i != -1 && !ReferenceEquals(cs[i].Key, key)) --i;\n                return i != -1 ? cs[i].Value : default;\n            }\n\n            internal override Entry AddWithTheSameKey(ImHashMapEntry<K, V> newEntry) =>\n                new HashConflictingEntry(Hash, Conflicts.AppendToNonEmpty(newEntry));\n\n            internal override Entry AddOrUpdateWithTheSameHash(ImHashMapEntry<K, V> newEntry) =>\n                AddOrUpdateWithTheSameHash(newEntry, null);\n\n            internal override Entry AddOrUpdateWithTheSameHash(ImHashMapEntry<K, V> newEntry, Update<K, V> update)\n            {\n                var key = newEntry.Key;\n                var cs = Conflicts;\n                var i = cs.Length - 1;\n                while (i != -1 && !cs[i].Key.Equals(key)) --i;\n                if (i == -1)\n                    return new HashConflictingEntry(Hash, cs.AppendToNonEmpty(newEntry));\n                if (update != null)\n                    newEntry = ImHashMap.Entry(Hash, key, update(key, cs[i].Value, newEntry.Value));\n                return new HashConflictingEntry(Hash, cs.UpdateNonEmpty(newEntry, i));\n            }\n\n            internal override Entry UpdatedOrNullWithTheSameHash(ImHashMapEntry<K, V> newEntry)\n            {\n                var key = newEntry.Key;\n                var cs = Conflicts;\n                var i = cs.Length - 1;\n                while (i != -1 && !cs[i].Key.Equals(key)) --i;\n                return i == -1 ? null : new HashConflictingEntry(Hash, cs.UpdateNonEmpty(newEntry, i));\n            }\n\n            internal override Entry UpdatedOrNullWithTheSameHash(K key, V value, Update<K, V> update)\n            {\n                var cs = Conflicts;\n                var i = cs.Length - 1;\n                while (i != -1 && !cs[i].Key.Equals(key)) --i;\n                if (i == -1)\n                    return null;\n                if (update != null)\n                {\n                    var oldValue = cs[i].Value;\n                    value = update(key, oldValue, value);\n                    if (ReferenceEquals(oldValue, value))\n                        return null;\n                }\n                return new HashConflictingEntry(Hash, cs.UpdateNonEmpty(ImHashMap.Entry(Hash, key, value), i));\n            }\n\n            internal override Entry AddedOrNullWithTheSameHash(ImHashMapEntry<K, V> newEntry)\n            {\n                var key = newEntry.Key;\n                var cs = Conflicts;\n                var i = cs.Length - 1;\n                while (i != -1 && !cs[i].Key.Equals(key)) --i;\n                if (i != -1)\n                    return null;\n                return new HashConflictingEntry(Hash, cs.AppendToNonEmpty(newEntry));\n            }\n\n            internal override Entry RemovedOrNullWithTheSameHash(K key)\n            {\n                var cs = Conflicts;\n                var n = cs.Length;\n                var i = n - 1;\n                while (i != -1 && !cs[i].Key.Equals(key)) --i;\n                if (i == -1)\n                    return null;\n                if (n == 2)\n                    return i == 0 ? cs[1] : cs[0];\n                var newConflicts = new KVEntry<K, V>[n -= 1]; \/\/ the new n is less by one\n                if (i > 0) \/\/ copy the 1st part\n                    Array.Copy(cs, 0, newConflicts, 0, i);\n                if (i < n) \/\/ copy the 2nd part\n                    Array.Copy(cs, i + 1, newConflicts, i, n - i);\n                return new HashConflictingEntry(Hash, newConflicts);\n            }\n\n            \/\/\/ <inheritdoc\/>\n            public override Entry AppendOrUpdateInPlaceOrKeep<S>(S state, ImHashMapEntry<K, V> newEntry, UpdaterInPlaceOrKeeper<S> updateOrKeep)\n            {\n                var key = newEntry.Key;\n                var cs = Conflicts;\n                var i = cs.Length - 1;\n                while (i != -1 && !key.Equals(cs[i].Key)) --i;\n                if (i == -1)\n                    return new HashConflictingEntry(Hash, cs.AppendToNonEmpty(newEntry));\n                var oldEntry = cs[i];\n                if (updateOrKeep(state, oldEntry, newEntry) != oldEntry)\n                    return new HashConflictingEntry(Hash, cs.UpdateNonEmpty(newEntry, i));\n                return this;\n            }\n\n            internal override int ForEach<S>(S state, int startIndex, Action<ImHashMapEntry<K, V>, int, S> handler)\n            {\n                var i = startIndex;\n                foreach (var e in Conflicts)\n                    handler(e, i++, state);\n                return i;\n            }\n        }\n\n        \/\/\/ <summary>Leaf with 2 hash-ordered entries. Important: the both or either of entries may be null for the removed entries<\/summary>\n        internal sealed class Leaf2 : ImHashMap<K, V>\n        {\n            public readonly Entry Entry0, Entry1;\n            public Leaf2(Entry e0, Entry e1)\n            {\n                Debug.Assert(e0.Hash < e1.Hash);\n                Entry0 = e0; Entry1 = e1;\n            }\n\n            public override int Count() => Entry0.Count() + Entry1.Count();\n\n#if !DEBUG\n            public override string ToString() => \"{L2:{E0: \" + Entry0 + \",E1:\" + Entry1 + \"}}\";\n#endif\n\n            internal override Entry GetMinHashEntryOrDefault() => Entry0;\n            internal override Entry GetMaxHashEntryOrDefault() => Entry1;\n\n            internal override Entry GetEntryOrNull(int hash) =>\n                Entry0.Hash == hash ? Entry0 : Entry1.Hash == hash ? Entry1 : null;\n\n            internal override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry) =>\n                hash == Entry0.Hash ? Entry0 : hash == Entry1.Hash ? Entry1 : (ImHashMap<K, V>)new Leaf2Plus(entry, this);\n\n            internal override ImHashMap<K, V> ReplaceEntry(Entry oldEntry, Entry newEntry) =>\n                oldEntry == Entry0 ? new Leaf2(newEntry, Entry1) : new Leaf2(Entry0, newEntry);\n\n            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry) =>\n                Entry0 == removedEntry ? Entry1 : Entry0;\n        }\n\n        \/\/\/ <summary>The leaf containing the Leaf2 plus the newest added entry.<\/summary>\n        internal sealed class Leaf2Plus : ImHashMap<K, V>\n        {\n            public readonly Entry Plus;\n            public readonly Leaf2 L;\n            public Leaf2Plus(Entry plus, Leaf2 leaf)\n            {\n                Plus = plus;\n                L = leaf;\n            }\n\n            public override int Count() => Plus.Count() + L.Entry0.Count() + L.Entry1.Count();\n\n#if !DEBUG\n            public override string ToString() => \"{L21: {P: \" + Plus + \", L: \" + L + \"}}\";\n#endif\n\n            internal override Entry GetMinHashEntryOrDefault() => Plus.Hash < L.Entry0.Hash ? Plus : L.Entry0;\n            internal override Entry GetMaxHashEntryOrDefault() => Plus.Hash > L.Entry1.Hash ? Plus : L.Entry1;\n\n            internal override Entry GetEntryOrNull(int hash)\n            {\n                if (hash == Plus.Hash)\n                    return Plus;\n                var l = L;\n                return hash == l.Entry0.Hash ? l.Entry0 : hash == l.Entry1.Hash ? l.Entry1 : null;\n            }\n\n            internal override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry)\n            {\n                var p = Plus;\n                if (hash == p.Hash)\n                    return p;\n                var l = L;\n                return hash == l.Entry0.Hash ? l.Entry0 : hash == l.Entry1.Hash ? l.Entry1 : (ImHashMap<K, V>)new Leaf2PlusPlus(entry, this);\n            }\n\n            internal override ImHashMap<K, V> ReplaceEntry(Entry oldEntry, Entry newEntry) =>\n                oldEntry == Plus ? new Leaf2Plus(newEntry, L) :\n                oldEntry == L.Entry0 ? new Leaf2Plus(Plus, new Leaf2(newEntry, L.Entry1)) :\n                                       new Leaf2Plus(Plus, new Leaf2(L.Entry0, newEntry));\n\n            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry) =>\n                removedEntry == Plus ? L :\n                removedEntry == L.Entry0 ?\n                    (Plus.Hash < L.Entry1.Hash ? new Leaf2(Plus, L.Entry1) : new Leaf2(L.Entry1, Plus)) :\n                    (Plus.Hash < L.Entry0.Hash ? new Leaf2(Plus, L.Entry0) : new Leaf2(L.Entry0, Plus));\n        }\n\n        \/\/\/ <summary>Leaf with the Leaf2 plus added entry, plus added entry<\/summary>\n        internal sealed class Leaf2PlusPlus : ImHashMap<K, V>\n        {\n            public readonly Entry Plus;\n            public readonly Leaf2Plus L;\n\n            public Leaf2PlusPlus(Entry plus, Leaf2Plus l)\n            {\n                Plus = plus;\n                L = l;\n            }\n\n            public override int Count() => Plus.Count() + L.Count();\n\n#if !DEBUG\n            public override string ToString() => \"{L211:{P:\" + Plus + \",L:\" + L + \"}}\";\n#endif\n\n            internal override Entry GetMinHashEntryOrDefault()\n            {\n                Entry p = Plus, pp = L.Plus, e0 = L.L.Entry0;\n                return p.Hash < pp.Hash ? (p.Hash < e0.Hash ? p : e0) : (pp.Hash < e0.Hash ? pp : e0);\n            }\n            internal override Entry GetMaxHashEntryOrDefault()\n            {\n                Entry p = Plus, pp = L.Plus, e1 = L.L.Entry1;\n                return p.Hash > pp.Hash ? (p.Hash > e1.Hash ? p : e1) : (pp.Hash > e1.Hash ? pp : e1);\n            }\n\n            internal override Entry GetEntryOrNull(int hash)\n            {\n                if (hash == Plus.Hash)\n                    return Plus;\n                if (hash == L.Plus.Hash)\n                    return L.Plus;\n                var l = L.L;\n                return l.Entry0.Hash == hash ? l.Entry0 : l.Entry1.Hash == hash ? l.Entry1 : null;\n            }\n\n            internal override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry)\n            {\n                var p = Plus;\n                var ph = p.Hash;\n                if (ph == hash)\n                    return p;\n\n                var pp = L.Plus;\n                var pph = pp.Hash;\n                if (pph == hash)\n                    return pp;\n\n                var l = L.L;\n                Entry e0 = l.Entry0, e1 = l.Entry1;\n\n                if (hash == e0.Hash)\n                    return e0;\n                if (hash == e1.Hash)\n                    return e1;\n\n                ImHashMap.InsertInOrder(pph, ref pp, ref e0, ref e1);\n                ImHashMap.InsertInOrder(ph, ref p, ref e0, ref e1, ref pp);\n                ImHashMap.InsertInOrder(hash, ref entry, ref e0, ref e1, ref pp, ref p);\n\n                return new Leaf5(e0, e1, pp, p, entry);\n            }\n\n            internal override ImHashMap<K, V> ReplaceEntry(Entry oldEntry, Entry newEntry) =>\n                oldEntry == Plus ? new Leaf2PlusPlus(newEntry, L) :\n                oldEntry == L.Plus ? new Leaf2PlusPlus(Plus, new Leaf2Plus(newEntry, L.L)) :\n                oldEntry == L.L.Entry0 ? new Leaf2PlusPlus(Plus, new Leaf2Plus(L.Plus, new Leaf2(newEntry, L.L.Entry1))) :\n                                         new Leaf2PlusPlus(Plus, new Leaf2Plus(L.Plus, new Leaf2(L.L.Entry0, newEntry)));\n\n            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry) =>\n                removedEntry == Plus ? L :\n                removedEntry == L.Plus ? new Leaf2Plus(Plus, L.L) :\n                removedEntry == L.L.Entry0 ?\n                    (L.Plus.Hash < L.L.Entry1.Hash ? new Leaf2Plus(Plus, new Leaf2(L.Plus, L.L.Entry1)) : new Leaf2Plus(Plus, new Leaf2(L.L.Entry1, L.Plus))) :\n                    (L.Plus.Hash < L.L.Entry0.Hash ? new Leaf2Plus(Plus, new Leaf2(L.Plus, L.L.Entry0)) : new Leaf2Plus(Plus, new Leaf2(L.L.Entry0, L.Plus)));\n        }\n\n        \/\/\/ <summary>Leaf with 5 hash-ordered entries<\/summary>\n        internal sealed class Leaf5 : ImHashMap<K, V>\n        {\n            public readonly Entry Entry0, Entry1, Entry2, Entry3, Entry4;\n\n            public Leaf5(Entry e0, Entry e1, Entry e2, Entry e3, Entry e4)\n            {\n                Debug.Assert(e0.Hash < e1.Hash, \"e0 < e1\");\n                Debug.Assert(e1.Hash < e2.Hash, \"e1 < e2\");\n                Debug.Assert(e2.Hash < e3.Hash, \"e2 < e3\");\n                Debug.Assert(e3.Hash < e4.Hash, \"e3 < e4\");\n                Entry0 = e0; Entry1 = e1; Entry2 = e2; Entry3 = e3; Entry4 = e4;\n            }\n\n            public override int Count() => Entry0.Count() + Entry1.Count() + Entry2.Count() + Entry3.Count() + Entry4.Count();\n\n#if !DEBUG\n            public override string ToString() => \n                \"{L2:{E0:\" + Entry0 + \",E1:\" + Entry1 + \",E2:\" + Entry2 + \",E3:\" + Entry3 + \",E4:\" + Entry4 + \"}}\";\n#endif\n\n            internal override Entry GetMinHashEntryOrDefault() => Entry0;\n            internal override Entry GetMaxHashEntryOrDefault() => Entry4;\n\n            internal override Entry GetEntryOrNull(int hash) =>\n                hash == Entry0.Hash ? Entry0 :\n                hash == Entry1.Hash ? Entry1 :\n                hash == Entry2.Hash ? Entry2 :\n                hash == Entry3.Hash ? Entry3 :\n                hash == Entry4.Hash ? Entry4 :\n                null;\n\n            internal override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry) =>\n                hash == Entry0.Hash ? Entry0 :\n                hash == Entry1.Hash ? Entry1 :\n                hash == Entry2.Hash ? Entry2 :\n                hash == Entry3.Hash ? Entry3 :\n                hash == Entry4.Hash ? Entry4 :\n                (ImHashMap<K, V>)new Leaf5Plus(entry, this);\n\n            internal override ImHashMap<K, V> ReplaceEntry(Entry oldEntry, Entry newEntry) =>\n                oldEntry == Entry0 ? new Leaf5(newEntry, Entry1, Entry2, Entry3, Entry4) :\n                oldEntry == Entry1 ? new Leaf5(Entry0, newEntry, Entry2, Entry3, Entry4) :\n                oldEntry == Entry2 ? new Leaf5(Entry0, Entry1, newEntry, Entry3, Entry4) :\n                oldEntry == Entry3 ? new Leaf5(Entry0, Entry1, Entry2, newEntry, Entry4) :\n                                     new Leaf5(Entry0, Entry1, Entry2, Entry3, newEntry);\n\n            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry) =>\n                removedEntry == Entry0 ? new Leaf2PlusPlus(Entry4, new Leaf2Plus(Entry3, new Leaf2(Entry1, Entry2))) :\n                removedEntry == Entry1 ? new Leaf2PlusPlus(Entry4, new Leaf2Plus(Entry3, new Leaf2(Entry0, Entry2))) :\n                removedEntry == Entry2 ? new Leaf2PlusPlus(Entry4, new Leaf2Plus(Entry3, new Leaf2(Entry0, Entry1))) :\n                removedEntry == Entry3 ? new Leaf2PlusPlus(Entry4, new Leaf2Plus(Entry2, new Leaf2(Entry0, Entry1))) :\n                                         new Leaf2PlusPlus(Entry3, new Leaf2Plus(Entry2, new Leaf2(Entry0, Entry1)));\n        }\n\n        \/\/\/ <summary>Leaf with 5 existing ordered entries plus 1 newly added entry.<\/summary>\n        internal sealed class Leaf5Plus : ImHashMap<K, V>\n        {\n            public readonly Entry Plus;\n            public readonly Leaf5 L;\n\n            public Leaf5Plus(Entry plus, Leaf5 l)\n            {\n                Plus = plus;\n                L = l;\n            }\n\n            public override int Count() => Plus.Count() + L.Count();\n\n#if !DEBUG\n            public override string ToString() => \"{L51:{P:\" + Plus + \",L:\" + L + \"}}\";\n#endif\n\n            internal override Entry GetMinHashEntryOrDefault() => Plus.Hash < L.Entry0.Hash ? Plus : L.Entry0;\n            internal override Entry GetMaxHashEntryOrDefault() => Plus.Hash > L.Entry4.Hash ? Plus : L.Entry4;\n\n            internal override Entry GetEntryOrNull(int hash)\n            {\n                if (hash == Plus.Hash)\n                    return Plus;\n                var l = L;\n                return hash == l.Entry0.Hash ? l.Entry0\n                     : hash == l.Entry1.Hash ? l.Entry1\n                     : hash == l.Entry2.Hash ? l.Entry2\n                     : hash == l.Entry3.Hash ? l.Entry3\n                     : hash == l.Entry4.Hash ? l.Entry4\n                     : null;\n            }\n\n            internal override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry)\n            {\n                var p = Plus;\n                var ph = p.Hash;\n                if (ph == hash)\n                    return p;\n                var l = L;\n                return hash == l.Entry0.Hash ? l.Entry0\n                     : hash == l.Entry1.Hash ? l.Entry1\n                     : hash == l.Entry2.Hash ? l.Entry2\n                     : hash == l.Entry3.Hash ? l.Entry3\n                     : hash == l.Entry4.Hash ? l.Entry4\n                     : (ImHashMap<K, V>)new Leaf5PlusPlus(entry, this);\n            }\n\n            internal override ImHashMap<K, V> ReplaceEntry(Entry oldEntry, Entry newEntry)\n            {\n                var p = Plus;\n                if (oldEntry == p)\n                    return new Leaf5Plus(newEntry, L);\n                var l = L;\n                Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4;\n                return oldEntry == e0 ? new Leaf5Plus(p, new Leaf5(newEntry, e1, e2, e3, e4))\n                    : oldEntry == e1 ? new Leaf5Plus(p, new Leaf5(e0, newEntry, e2, e3, e4))\n                    : oldEntry == e2 ? new Leaf5Plus(p, new Leaf5(e0, e1, newEntry, e3, e4))\n                    : oldEntry == e3 ? new Leaf5Plus(p, new Leaf5(e0, e1, e2, newEntry, e4))\n                    : new Leaf5Plus(p, new Leaf5(e0, e1, e2, e3, newEntry));\n            }\n\n            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry)\n            {\n                var p = Plus;\n                if (p == removedEntry)\n                    return L;\n\n                var l = L;\n                Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4;\n                ImHashMap.InsertInOrder(p.Hash, ref p, ref e0, ref e1, ref e2, ref e3, ref e4);\n\n                return removedEntry == e0 ? new Leaf5(e1, e2, e3, e4, p)\n                    : removedEntry == e1 ? new Leaf5(e0, e2, e3, e4, p)\n                    : removedEntry == e2 ? new Leaf5(e0, e1, e3, e4, p)\n                    : removedEntry == e3 ? new Leaf5(e0, e1, e2, e4, p)\n                    : removedEntry == e4 ? new Leaf5(e0, e1, e2, e3, p)\n                    : new Leaf5(e0, e1, e2, e3, e4);\n            }\n        }\n\n        \/\/\/ <summary>Leaf with 5 existing ordered entries plus 1 newly added, plus 1 newly added.<\/summary>\n        internal sealed class Leaf5PlusPlus : ImHashMap<K, V>\n        {\n            public readonly Entry Plus;\n            public readonly Leaf5Plus L;\n            public Leaf5PlusPlus(Entry plus, Leaf5Plus l)\n            {\n                Plus = plus;\n                L = l;\n            }\n\n            public sealed override int Count() => Plus.Count() + L.Count();\n\n            internal override bool MayTurnToBranch2 => true;\n\n#if !DEBUG\n            public override string ToString() => \"{L511:{P:\" + Plus + \",L:\" + L + \"}}\";\n#endif\n\n            internal sealed override Entry GetMinHashEntryOrDefault()\n            {\n                Entry p = Plus, pp = L.Plus, e0 = L.L.Entry0;\n                return p.Hash < pp.Hash ? (p.Hash < e0.Hash ? p : e0) : (pp.Hash < e0.Hash ? pp : e0);\n            }\n            internal sealed override Entry GetMaxHashEntryOrDefault()\n            {\n                Entry p = Plus, pp = L.Plus, e4 = L.L.Entry4;\n                return p.Hash > pp.Hash ? (p.Hash > e4.Hash ? p : e4) : (pp.Hash > e4.Hash ? pp : e4);\n            }\n\n            internal override Entry GetEntryOrNull(int hash)\n            {\n                if (hash == Plus.Hash)\n                    return Plus;\n                if (hash == L.Plus.Hash)\n                    return L.Plus;\n                var l = L.L;\n                return hash == l.Entry0.Hash ? l.Entry0\n                     : hash == l.Entry1.Hash ? l.Entry1\n                     : hash == l.Entry2.Hash ? l.Entry2\n                     : hash == l.Entry3.Hash ? l.Entry3\n                     : hash == l.Entry4.Hash ? l.Entry4\n                     : null;\n            }\n\n            internal override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry)\n            {\n                ImHashMap<K, V> splitRight = null;\n                var entryOrNewMap = AddOrGetEntry(hash, ref entry, ref splitRight);\n                if (splitRight != null)\n                    return new Branch2(entryOrNewMap, entry, splitRight);\n                return entryOrNewMap;\n            }\n\n            internal ImHashMap<K, V> AddOrGetEntry(int hash, ref Entry entry, ref ImHashMap<K, V> splitRight)\n            {\n                var p = Plus;\n                var ph = p.Hash;\n                if (ph == hash)\n                    return p;\n\n                var pp = L.Plus;\n                var pph = pp.Hash;\n                if (pph == hash)\n                    return pp;\n\n                var l = L.L;\n                var e0 = l.Entry0;\n                if (hash == e0.Hash)\n                    return e0;\n                var e1 = l.Entry1;\n                if (hash == e1.Hash)\n                    return e1;\n                var e2 = l.Entry2;\n                if (hash == e2.Hash)\n                    return e2;\n                var e3 = l.Entry3;\n                if (hash == e3.Hash)\n                    return e3;\n                var e4 = l.Entry4;\n                if (hash == e4.Hash)\n                    return e4;\n\n                var right = hash > e4.Hash && ph > e4.Hash && pph > e4.Hash;\n                var left = !right && hash < e0.Hash && ph < e0.Hash && pph < e0.Hash;\n\n                Entry e = entry; \/\/ store the entry original value cause we may change it for the result\n                ImHashMap.InsertInOrder(pph, ref pp, ref e0, ref e1, ref e2, ref e3, ref e4);\n                ImHashMap.InsertInOrder(ph, ref p, ref e0, ref e1, ref e2, ref e3, ref e4, ref pp);\n                ImHashMap.InsertInOrder(hash, ref e, ref e0, ref e1, ref e2, ref e3, ref e4, ref pp, ref p);\n\n                if (left)\n                {\n                    entry = e2;\n                    splitRight = l;\n                    return new Leaf2(e0, e1);\n                }\n\n                entry = pp;\n                splitRight = new Leaf2(p, e);\n                return right ? l : new Leaf5(e0, e1, e2, e3, e4);\n            }\n\n            internal ImHashMap<K, V> AddEntry(int hash, ref Entry entry, ref ImHashMap<K, V> splitRight)\n            {\n                var l = L.L;\n                Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4, pp = L.Plus, p = Plus;\n                int ph = p.Hash, pph = pp.Hash;\n\n                var right = hash > e4.Hash && ph > e4.Hash && pph > e4.Hash;\n                var left = !right && hash < e0.Hash && ph < e0.Hash && pph < e0.Hash;\n\n                var e = entry; \/\/ store the entry original value cause we may change it for the result\n                ImHashMap.InsertInOrder(pph, ref pp, ref e0, ref e1, ref e2, ref e3, ref e4);\n                ImHashMap.InsertInOrder(ph, ref p, ref e0, ref e1, ref e2, ref e3, ref e4, ref pp);\n                ImHashMap.InsertInOrder(hash, ref e, ref e0, ref e1, ref e2, ref e3, ref e4, ref pp, ref p);\n\n                if (left)\n                {\n                    entry = e2;\n                    splitRight = l;\n                    return new Leaf2(e0, e1);\n                }\n\n                entry = pp;\n                splitRight = new Leaf2(p, e);\n                return right ? l : new Leaf5(e0, e1, e2, e3, e4);\n            }\n\n            internal override ImHashMap<K, V> ReplaceEntry(Entry oldEntry, Entry newEntry)\n            {\n                var p = Plus;\n                if (p == oldEntry)\n                    return new Leaf5PlusPlus(newEntry, L);\n\n                var pp = L.Plus;\n                if (pp == oldEntry)\n                    return new Leaf5PlusPlus(p, new Leaf5Plus(newEntry, L.L));\n\n                var l = L.L;\n                Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4;\n                return\n                    oldEntry == e0 ? new Leaf5PlusPlus(p, new Leaf5Plus(pp, new Leaf5(newEntry, e1, e2, e3, e4))) :\n                    oldEntry == e1 ? new Leaf5PlusPlus(p, new Leaf5Plus(pp, new Leaf5(e0, newEntry, e2, e3, e4))) :\n                    oldEntry == e2 ? new Leaf5PlusPlus(p, new Leaf5Plus(pp, new Leaf5(e0, e1, newEntry, e3, e4))) :\n                    oldEntry == e3 ? new Leaf5PlusPlus(p, new Leaf5Plus(pp, new Leaf5(e0, e1, e2, newEntry, e4))) :\n                                     new Leaf5PlusPlus(p, new Leaf5Plus(pp, new Leaf5(e0, e1, e2, e3, newEntry)));\n            }\n\n            internal ImHashMap<K, V> RemoveMinHashEntryAndAddNewEntry(Entry minEntry, Entry newEntry)\n            {\n                var p = Plus;\n                if (p == minEntry)\n                    return new Leaf5PlusPlus(newEntry, L);\n\n                var pp = L.Plus;\n                if (pp == minEntry)\n                    return new Leaf5PlusPlus(p, new Leaf5Plus(newEntry, L.L));\n\n                var l = L.L;\n                Entry e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4;\n                var hash = newEntry.Hash;\n                l = hash < e1.Hash ? new Leaf5(newEntry, e1, e2, e3, e4)\n                : hash < e2.Hash ? new Leaf5(e1, newEntry, e2, e3, e4)\n                : hash < e3.Hash ? new Leaf5(e1, e2, newEntry, e3, e4)\n                : hash < e4.Hash ? new Leaf5(e1, e2, e3, newEntry, e4)\n                : new Leaf5(e1, e2, e3, e4, newEntry);\n\n                return new Leaf5PlusPlus(p, new Leaf5Plus(pp, l));\n            }\n\n            internal ImHashMap<K, V> RemoveMaxHashEntryAndAddNewEntry(Entry maxEntry, Entry newEntry)\n            {\n                var p = Plus;\n                if (p == maxEntry)\n                    return new Leaf5PlusPlus(newEntry, L);\n\n                var pp = L.Plus;\n                if (pp == maxEntry)\n                    return new Leaf5PlusPlus(p, new Leaf5Plus(newEntry, L.L));\n\n                var l = L.L;\n                Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3;\n                var hash = newEntry.Hash;\n                l = hash < e0.Hash ? new Leaf5(newEntry, e0, e1, e2, e3)\n                : hash < e1.Hash ? new Leaf5(e0, newEntry, e1, e2, e3)\n                : hash < e2.Hash ? new Leaf5(e0, e1, newEntry, e2, e3)\n                : hash < e3.Hash ? new Leaf5(e0, e1, e2, newEntry, e3)\n                : new Leaf5(e0, e1, e2, e3, newEntry);\n\n                return new Leaf5PlusPlus(p, new Leaf5Plus(pp, l));\n            }\n\n            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry)\n            {\n                var p = Plus;\n                if (p == removedEntry)\n                    return L;\n\n                var pp = L.Plus;\n                if (pp == removedEntry)\n                    return new Leaf5Plus(p, L.L);\n\n                var l = L.L;\n                Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4;\n                int pph = pp.Hash, ph = p.Hash;\n\n                ImHashMap.InsertInOrder(pph, ref pp, ref e0, ref e1, ref e2, ref e3, ref e4);\n                ImHashMap.InsertInOrder(ph, ref p, ref e0, ref e1, ref e2, ref e3, ref e4, ref pp);\n\n                return removedEntry == e0 ? new Leaf5Plus(p, new Leaf5(e1, e2, e3, e4, pp))\n                    : removedEntry == e1 ? new Leaf5Plus(p, new Leaf5(e0, e2, e3, e4, pp))\n                    : removedEntry == e2 ? new Leaf5Plus(p, new Leaf5(e0, e1, e3, e4, pp))\n                    : removedEntry == e3 ? new Leaf5Plus(p, new Leaf5(e0, e1, e2, e4, pp))\n                    : removedEntry == e4 ? new Leaf5Plus(p, new Leaf5(e0, e1, e2, e3, pp))\n                    : removedEntry == pp ? new Leaf5Plus(p, new Leaf5(e0, e1, e2, e3, e4))\n                    : new Leaf5Plus(pp, new Leaf5(e0, e1, e2, e3, e4));\n            }\n        }\n\n        \/\/\/ <summary>The 2 branches with the node in between<\/summary>\n        internal sealed class Branch2 : ImHashMap<K, V>\n        {\n            public readonly Entry MidEntry;\n            public readonly ImHashMap<K, V> Left, Right;\n            public Branch2(ImHashMap<K, V> left, Entry entry, ImHashMap<K, V> right)\n            {\n                Debug.Assert(left != Empty && right != Empty, $\"left:{left} != Empty && right:{right} != Empty\");\n                MidEntry = entry;\n                Left = left;\n                Right = right;\n            }\n\n            public override int Count() => MidEntry.Count() + Left.Count() + Right.Count();\n\n#if !DEBUG\n            public override string ToString() => \"{B2:{E:\" + MidEntry + \",L:\" + Left + \",R:\" + Right + \"}}\";\n#endif\n\n            internal override Entry GetMinHashEntryOrDefault() => Left.GetMinHashEntryOrDefault();\n            internal override Entry GetMaxHashEntryOrDefault() => Right.GetMaxHashEntryOrDefault();\n\n            internal override Entry GetEntryOrNull(int hash)\n            {\n                var mh = MidEntry.Hash;\n                return hash > mh ? Right.GetEntryOrNull(hash)\n                    : hash < mh ? Left.GetEntryOrNull(hash)\n                    : MidEntry;\n            }\n\n            internal override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry)\n            {\n                var me = MidEntry;\n                ImHashMap<K, V> entryOrNewBranch = null;\n                if (hash > me.Hash)\n                {\n                    var right = Right;\n                    if (right is Leaf5PlusPlus rl511)\n                    {\n                        \/\/ if (Left is Leaf2 l2)\n                        \/\/ {\n                        \/\/     var e = rl511.GetEntryOrNull(hash);\n                        \/\/     if (e != null)\n                        \/\/         return e;\n                        \/\/     var rMin = rl511.GetMinHashEntryOrDefault();\n                        \/\/     if (hash < rMin.Hash)\n                        \/\/         return new Branch2(new Leaf2Plus(me, l2), entry, rl511);\n                        \/\/     if (rMin == rl511.Plus)\n                        \/\/         return new Branch2(new Leaf2Plus(me, l2), rMin, new Leaf5PlusPlus(entry, rl511.L));\n                        \/\/     if (rMin == rl511.L.Plus)\n                        \/\/         return new Branch2(new Leaf2Plus(me, l2), rMin, new Leaf5PlusPlus(entry, new Leaf5Plus(rl511.Plus, rl511.L.L)));\n                        \/\/     return new Branch2Plus1(entry, this);\n                        \/\/ }\n                        \n                        \/\/ if (Left is Leaf2Plus l2p)\n                        \/\/ {\n                        \/\/     var e = rl511.GetEntryOrNull(hash);\n                        \/\/     if (e != null)\n                        \/\/         return e;\n                        \/\/     var rMin = rl511.GetMinHashEntryOrDefault();\n                        \/\/     if (hash < rMin.Hash)\n                        \/\/         return new Branch2(new Leaf2PlusPlus(me, l2p), entry, rl511);\n                        \/\/     if (rMin == rl511.Plus)\n                        \/\/         return new Branch2(new Leaf2PlusPlus(me, l2p), rMin, new Leaf5PlusPlus(entry, rl511.L));\n                        \/\/     if (rMin == rl511.L.Plus)\n                        \/\/         return new Branch2(new Leaf2PlusPlus(me, l2p), rMin, new Leaf5PlusPlus(entry, new Leaf5Plus(rl511.Plus, rl511.L.L)));\n                        \/\/     return new Branch2Plus1(entry, this);\n                        \/\/ }\n\n                        \/\/ optimizing the split by postponing it by introducing the branch 2 plus 1\n                        if (Left is Leaf5PlusPlus == false)\n                            return rl511.GetEntryOrNull(hash) ?? (ImHashMap<K, V>)new Branch2Plus1(entry, this);\n\n                        ImHashMap<K, V> splitRight = null;\n                        entryOrNewBranch = rl511.AddOrGetEntry(hash, ref entry, ref splitRight);\n                        \/\/ if split is `null` then the only reason is that hash is found\n                        return splitRight != null ? new Branch3(Left, me, entryOrNewBranch, entry, splitRight) : entryOrNewBranch;\n                    }\n\n                    if (right is Branch3Base rb3)\n                    {\n                        ImHashMap<K, V> splitRight = null;\n                        entryOrNewBranch = rb3.AddOrGetEntry(hash, ref entry, ref splitRight);\n                        if (splitRight != null)\n                            return new Branch3(Left, me, entryOrNewBranch, entry, splitRight);\n                    }\n                    else entryOrNewBranch = right.AddOrGetEntry(hash, entry);\n\n                    return entryOrNewBranch is Entry ? entryOrNewBranch : new Branch2(Left, me, entryOrNewBranch);\n                }\n\n                if (hash < me.Hash)\n                {\n                    var left = Left;\n                    if (left is Leaf5PlusPlus ll511)\n                    {\n                        \/\/ if (Right is Leaf2 l2)\n                        \/\/ {\n                        \/\/     var e = ll511.GetEntryOrNull(hash);\n                        \/\/     if (e != null)\n                        \/\/         return e;\n                        \/\/     var lMax = ll511.GetMaxHashEntryOrDefault();\n                        \/\/     if (hash > lMax.Hash)\n                        \/\/         return new Branch2(ll511, entry, new Leaf2Plus(me, l2));\n                        \/\/     if (lMax == ll511.Plus)\n                        \/\/         return new Branch2(new Leaf5PlusPlus(entry, ll511.L), lMax, new Leaf2Plus(me, l2));\n                        \/\/     if (lMax == ll511.L.Plus)\n                        \/\/         return new Branch2(new Leaf5PlusPlus(entry, new Leaf5Plus(ll511.Plus, ll511.L.L)), lMax, new Leaf2Plus(me, l2));\n                        \/\/     return new Branch2Plus1(entry, this);\n                        \/\/ }\n\n                        \/\/ if (Right is Leaf2Plus l2p)\n                        \/\/ {\n                        \/\/     var e = ll511.GetEntryOrNull(hash);\n                        \/\/     if (e != null)\n                        \/\/         return e;\n                        \/\/     var lMax = ll511.GetMaxHashEntryOrDefault();\n                        \/\/     if (hash > lMax.Hash)\n                        \/\/         return new Branch2(ll511, entry, new Leaf2PlusPlus(me, l2p));\n                        \/\/     if (lMax == ll511.Plus)\n                        \/\/         return new Branch2(new Leaf5PlusPlus(entry, ll511.L), lMax, new Leaf2PlusPlus(me, l2p));\n                        \/\/     if (lMax == ll511.L.Plus)\n                        \/\/         return new Branch2(new Leaf5PlusPlus(entry, new Leaf5Plus(ll511.Plus, ll511.L.L)), lMax, new Leaf2PlusPlus(me, l2p));\n                        \/\/     return new Branch2Plus1(entry, this);\n                        \/\/ }\n\n                        if (Right is Leaf5PlusPlus == false)\n                            return ll511.GetEntryOrNull(hash) ?? (ImHashMap<K, V>)new Branch2Plus1(entry, this);\n\n                        ImHashMap<K, V> splitRight = null;\n                        entryOrNewBranch = ll511.AddOrGetEntry(hash, ref entry, ref splitRight);\n                        return splitRight != null ? new Branch3(entryOrNewBranch, entry, splitRight, me, Right) : (ImHashMap<K, V>)entryOrNewBranch;\n                    }\n\n                    if (left is Branch3Base lb3)\n                    {\n                        ImHashMap<K, V> splitRight = null;\n                        entryOrNewBranch = lb3.AddOrGetEntry(hash, ref entry, ref splitRight);\n                        if (splitRight != null)\n                            return new Branch3(entryOrNewBranch, entry, splitRight, me, Right);\n                    }\n                    else entryOrNewBranch = left.AddOrGetEntry(hash, entry);\n\n                    return entryOrNewBranch is Entry ? entryOrNewBranch : new Branch2(entryOrNewBranch, me, Right);\n                }\n\n                return me;\n            }\n\n            internal override ImHashMap<K, V> ReplaceEntry(Entry oldEntry, Entry newEntry)\n            {\n                int hash = oldEntry.Hash, h = MidEntry.Hash;\n                return hash > h ? new Branch2(Left, MidEntry, Right.ReplaceEntry(oldEntry, newEntry))\n                    : hash < h ? new Branch2(Left.ReplaceEntry(oldEntry, newEntry), MidEntry, Right)\n                    : new Branch2(Left, newEntry, Right);\n            }\n\n            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry)\n            {\n                \/\/ The downward phase for deleting an element from a 2-3 tree is the same as the downward phase\n                \/\/ for inserting an element except for the case when the element to be deleted is equal to the value in\n                \/\/ a 2-node or a 3-node. In this case, if the value is not part of a terminal node, the value is replaced\n                \/\/ by its in-order predecessor or in-order successor, just as in binary search tree deletion. So in any\n                \/\/ case, deletion leaves a hole in a terminal node.\n                \/\/ The goal of the rest of the deletion algorithm is to remove the hole without violating the other\n                \/\/ invariants of the 2-3 tree.\n\n                var mid = MidEntry;\n                if (removedEntry.Hash > mid.Hash)\n                {\n                    \/\/ if we done to the Entry then we don't even need to call the Remove\n                    if (Right is Entry)\n                    {\n                        \/\/ if the left node is not full yet then merge\n                        if (Left is Leaf5PlusPlus == false)\n                            return Left.AddOrGetEntry(mid.Hash, mid);\n                        removedEntry = Left.GetMaxHashEntryOrDefault(); \/\/ todo: @perf combine `GetMaxHashEntryOrDefault` with `RemoveEntry`\n                        return new Branch2(Left.RemoveEntry(removedEntry), removedEntry, mid); \/\/! the height does not change\n                    }\n\n                    var newRight = Right.RemoveEntry(removedEntry);\n                    \/\/*rebalance needed: the branch was merged from Br2 to Br3 or to the leaf and the height decreased \n                    if (Right is Branch2 && newRight is Branch2 == false)\n                    {\n                        var left = Left;\n                        \/\/ the the hole has a 2-node as a parent and a 3-node as a sibling.\n                        if (left is Branch3Base lb3) \/\/! the height does not change\n                            return new Branch2(new Branch2(lb3.Left, lb3.Entry0, lb3.Middle), lb3.Entry1, new Branch2(lb3.Right, mid, newRight));\n\n                        if (left is Branch2Plus1 lb21)\n                            return new Branch3(lb21.ToSplitBranch2(out var lMid, out var lRight), lMid, lRight, mid, newRight);\n\n                        \/\/ the the hole has a 2-node as a parent and a 2-node as a sibling.\n                        var lb2 = (Branch2)left;\n                        return new Branch3(lb2.Left, lb2.MidEntry, lb2.Right, mid, newRight);\n                    }\n\n                    return new Branch2(Left, mid, newRight);\n                }\n\n                \/\/ case 1, downward: swap the predecessor entry (max left entry) with the mid entry, then proceed to remove the predecessor from the Left branch\n                if (removedEntry == mid)\n                    removedEntry = mid = Left.GetMaxHashEntryOrDefault();\n\n                \/\/ case 1, upward\n                var newLeft = Left.RemoveEntry(removedEntry);\n                if (newLeft == Empty)\n                {\n                    if (Right is Leaf5PlusPlus == false)\n                        return Right.AddOrGetEntry(mid.Hash, mid);\n                    removedEntry = Right.GetMinHashEntryOrDefault();\n                    return new Branch2(mid, removedEntry, Right.RemoveEntry(removedEntry)); \/\/! the height does not change\n                }\n\n                \/\/*rebalance needed: the branch was merged from Br2 to Br3 or to the leaf and the height decreased \n                if (Left is Branch2 && newLeft is Branch2 == false)\n                {\n                    var right = Right;\n                    \/\/ the the hole has a 2-node as a parent and a 3-node as a sibling.\n                    if (right is Branch3Base rb3) \/\/! the height does not change\n                        return new Branch2(new Branch2(newLeft, mid, rb3.Left), rb3.Entry0, new Branch2(rb3.Middle, rb3.Entry1, rb3.Right));\n\n                    if (right is Branch2Plus1 rb21)\n                        return new Branch3(newLeft, mid, rb21.ToSplitBranch2(out var rMid, out var rRight), rMid, rRight);\n\n                    \/\/ the the hole has a 2-node as a parent and a 2-node as a sibling.\n                    var rb2 = (Branch2)right;\n                    return new Branch3(newLeft, mid, rb2.Left, rb2.MidEntry, rb2.Right);\n                }\n\n                return new Branch2(newLeft, mid, Right);\n            }\n        }\n\n        \/\/\/ <summary>The 2 branches with the node in between<\/summary>\n        internal sealed class Branch2Plus1 : ImHashMap<K, V>\n        {\n            public readonly Entry Plus;\n            public readonly Branch2 B;\n            public Branch2Plus1(Entry plus, Branch2 branch)\n            {\n                Plus = plus;\n                B = branch;\n            }\n\n            public override int Count() => Plus.Count() + B.Count();\n\n#if !DEBUG\n            public override string ToString() => \"{B21:{Plus:\" + Plus + \",B:\" + B + \"}}\";\n#endif\n\n            internal ImHashMap<K, V> ToSplitBranch2(out Entry newMid, out ImHashMap<K, V> newRight)\n            {\n                var b = B;\n                var m = b.MidEntry;\n                var l511 = b.Left as Leaf5PlusPlus;\n                if (l511 != null)\n                {\n                    newRight = b.Right.AddOrGetEntry(m.Hash, m); \/\/ @perf replace with the AddEntry method\n                    newMid = l511.GetMaxHashEntryOrDefault();\n                    if (newMid.Hash > Plus.Hash)\n                        return l511.RemoveMaxHashEntryAndAddNewEntry(newMid, Plus);\n                    newMid = Plus;\n                    return l511;\n                }\n\n                newRight = l511 = (Leaf5PlusPlus)b.Right;\n                newMid = l511.GetMinHashEntryOrDefault();\n                if (newMid.Hash < Plus.Hash)\n                    newRight = l511.RemoveMinHashEntryAndAddNewEntry(newMid, Plus);\n                else\n                    newMid = Plus;\n                return b.Left.AddOrGetEntry(m.Hash, m); \/\/ @perf replace with the AddEntry method\n            }\n\n            internal override Entry GetMinHashEntryOrDefault()\n            {\n                var m = B.Left.GetMinHashEntryOrDefault();\n                return m.Hash < Plus.Hash ? m : Plus;\n            }\n\n            internal sealed override Entry GetMaxHashEntryOrDefault()\n            {\n                var m = B.Right.GetMaxHashEntryOrDefault();\n                return m.Hash > Plus.Hash ? m : Plus;\n            }\n\n            internal override Entry GetEntryOrNull(int hash)\n            {\n                if (Plus.Hash == hash)\n                    return Plus;\n                var mh = B.MidEntry.Hash;\n                return hash > mh ? B.Right.GetEntryOrNull(hash)\n                    : hash < mh ? B.Left.GetEntryOrNull(hash)\n                    : B.MidEntry;\n            }\n\n            internal override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry)\n            {\n                var ph = Plus.Hash;\n                if (ph == hash) \/\/ ok, fast return here\n                    return Plus;\n\n                var b = B;\n                var m = b.MidEntry;\n                ImHashMap<K, V> entryOrNewBranch = null;\n                if (hash > m.Hash)\n                {\n                    var right = b.Right;\n                    ImHashMap<K, V> splitRight = null;\n                    if (right is Leaf5PlusPlus rl)\n                    {\n                        entryOrNewBranch = rl.AddOrGetEntry(hash, ref entry, ref splitRight);\n                        if (entryOrNewBranch is Entry)\n                            return entryOrNewBranch;\n\n                        \/\/ we know that the `splitRight` is not null because otherwise it would not be Branch2Plus1 in the first place \n                        Debug.Assert(ph > m.Hash, \"Because right was on the verge of balance and the fact that the other branch is not on the verge was the reason of Branch2Plus1 creation\");\n                        return ph > entry.Hash\n                            ? new Branch3(b.Left, m, entryOrNewBranch, entry, splitRight is Leaf2 l2 ? new Leaf2Plus(Plus, l2) : (ImHashMap<K, V>)new Leaf5Plus(Plus, (Leaf5)splitRight))\n                            : new Branch3(b.Left, m, entryOrNewBranch is Leaf5 l5 ? new Leaf5Plus(Plus, l5) : (ImHashMap<K, V>)new Leaf2Plus(Plus, (Leaf2)entryOrNewBranch), entry, splitRight);\n                    }\n\n                    \/\/ right is not on the verge, then the Plus would be added to the left\n                    entryOrNewBranch = right.AddOrGetEntry(hash, entry);\n                    if (entryOrNewBranch is Entry)\n                        return entryOrNewBranch;\n\n                    entry = Plus;\n                    var newLeft = ((Leaf5PlusPlus)b.Left).AddEntry(ph, ref entry, ref splitRight);\n                    return new Branch3(newLeft, entry, splitRight, m, entryOrNewBranch);\n                }\n\n                if (hash < m.Hash)\n                {\n                    var left = b.Left;\n                    ImHashMap<K, V> splitRight = null;\n                    if (left is Leaf5PlusPlus ll)\n                    {\n                        entryOrNewBranch = ll.AddOrGetEntry(hash, ref entry, ref splitRight);\n                        if (entryOrNewBranch is Entry)\n                            return entryOrNewBranch; \/\/ we know that the `r` is Leaf so the only possibility why `splitRight` is null because the same hash entry is found\n\n                        return ph < entry.Hash\n                            ? new Branch3(entryOrNewBranch is Leaf5 l5 ? new Leaf5Plus(Plus, l5) : (ImHashMap<K, V>)new Leaf2Plus(Plus, (Leaf2)entryOrNewBranch), entry, splitRight, m, b.Right)\n                            : new Branch3(entryOrNewBranch, entry, splitRight is Leaf2 l2 ? new Leaf2Plus(Plus, l2) : (ImHashMap<K, V>)new Leaf5Plus(Plus, (Leaf5)splitRight), m, b.Right);\n                    }\n\n                    entryOrNewBranch = left.AddOrGetEntry(hash, entry);\n                    if (entryOrNewBranch is Entry)\n                        return entryOrNewBranch;\n\n                    entry = Plus;\n                    var newMiddle = ((Leaf5PlusPlus)b.Right).AddEntry(ph, ref entry, ref splitRight);\n                    return new Branch3(entryOrNewBranch, m, newMiddle, entry, splitRight);\n                }\n\n                return m;\n            }\n\n            internal override ImHashMap<K, V> ReplaceEntry(Entry oldEntry, Entry newEntry) =>\n                oldEntry == Plus ? new Branch2Plus1(newEntry, B) : new Branch2Plus1(Plus, (Branch2)B.ReplaceEntry(oldEntry, newEntry));\n\n            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry)\n            {\n                if (removedEntry == Plus)\n                    return B;\n                var b = B;\n                Entry p = Plus, m = b.MidEntry;\n                if (removedEntry == m)\n                {\n                    if (b.Right is Leaf5PlusPlus rl)\n                    {\n                        var rightMin = rl.GetMinHashEntryOrDefault();\n                        return rightMin.Hash > p.Hash\n                            ? new Branch2(b.Left, p, rl)\n                            : new Branch2(b.Left, rightMin, rl.RemoveMinHashEntryAndAddNewEntry(rightMin, p));\n                    }\n                    var ll = (Leaf5PlusPlus)b.Left;\n                    var leftMax = ll.GetMaxHashEntryOrDefault();\n                    return leftMax.Hash < p.Hash\n                        ? new Branch2(ll, p, b.Right)\n                        : new Branch2(ll.RemoveMaxHashEntryAndAddNewEntry(leftMax, p), leftMax, b.Right);\n                }\n\n                if (removedEntry.Hash > m.Hash)\n                {\n                    if (b.Right is Leaf5PlusPlus rl)\n                        return new Branch2(b.Left, m, rl.RemoveEntry(removedEntry).AddOrGetEntry(p.Hash, p));\n                    var newRight = b.Right.RemoveEntry(removedEntry);\n                    if (newRight == Empty)\n                    {\n                        var ll = (Leaf5PlusPlus)b.Left;\n                        var leftMax = ll.GetMaxHashEntryOrDefault();\n                        return leftMax.Hash < p.Hash\n                            ? new Branch2(ll.RemoveEntry(leftMax), leftMax, p)\n                            : new Branch2(ll.RemoveEntry(leftMax), p, leftMax);\n                    }\n                    return new Branch2Plus1(p, new Branch2(b.Left, m, newRight));\n                }\n                {\n                    if (b.Left is Leaf5PlusPlus ll)\n                        return new Branch2(ll.RemoveEntry(removedEntry).AddOrGetEntry(p.Hash, p), m, b.Right);\n                    var newLeft = b.Left.RemoveEntry(removedEntry);\n                    if (newLeft == Empty)\n                    {\n                        var rl = (Leaf5PlusPlus)b.Right;\n                        var rightMin = rl.GetMinHashEntryOrDefault();\n                        return rightMin.Hash > p.Hash\n                            ? new Branch2(p, rightMin, rl.RemoveEntry(rightMin))\n                            : new Branch2(rightMin, p, rl.RemoveEntry(rightMin));\n                    }\n                    return new Branch2Plus1(p, new Branch2(newLeft, m, b.Right));\n                }\n            }\n        }\n\n        internal abstract class Branch3Base : ImHashMap<K, V>\n        {\n            public abstract Entry Entry0 { get; }\n            public abstract Entry Entry1 { get; }\n            public abstract ImHashMap<K, V> Left { get; }\n            public abstract ImHashMap<K, V> Middle { get; }\n            public abstract ImHashMap<K, V> Right { get; }\n            public override int Count() => Left.Count() + Entry0.Count() + Middle.Count() + Entry1.Count() + Right.Count();\n\n            internal override bool MayTurnToBranch2 => true;\n\n#if !DEBUG\n            public override string ToString() => \"{B3:{E0:\" + Entry0 + \",E1:\" + Entry0 + \",L:\" + Left + \",M:\" + Middle + \",R:\" + Right + \"}}\";\n#endif\n\n            internal override Entry GetMinHashEntryOrDefault() => Left.GetMinHashEntryOrDefault();\n            internal override Entry GetMaxHashEntryOrDefault() => Right.GetMaxHashEntryOrDefault();\n\n            internal override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry)\n            {\n                var h1 = Entry1.Hash;\n                if (hash > h1)\n                {\n                    var right = Right;\n                    var newRight = right.AddOrGetEntry(hash, entry);\n                    if (newRight is Entry)\n                        return newRight;\n\n                    if (right.MayTurnToBranch2 && newRight is Branch2)\n                        return new Branch2(new Branch2(Left, Entry0, Middle), Entry1, newRight);\n\n                    return this is Branch3 b ? new Branch3Right(b, newRight)\n                        : this is Branch3Right br ? new Branch3Right(br.B, newRight)\n                        : new Branch3(Left, Entry0, Middle, Entry1, newRight);\n                }\n\n                var h0 = Entry0.Hash;\n                if (hash < h0)\n                {\n                    var left = Left;\n                    var newLeft = left.AddOrGetEntry(hash, entry);\n                    if (newLeft is Entry)\n                        return newLeft;\n\n                    if (left.MayTurnToBranch2 && newLeft is Branch2)\n                        return new Branch2(newLeft, Entry0, new Branch2(Middle, Entry1, Right));\n\n                    return this is Branch3 b ? new Branch3Left(b, newLeft) : this is Branch3Left br ? new Branch3Left(br.B, newLeft)\n                        : new Branch3(newLeft, Entry0, Middle, Entry1, Right);\n                }\n\n                if (hash > h0 && hash < h1)\n                {\n                    var middle = Middle;\n                    ImHashMap<K, V> splitMiddleRight = null;\n                    var newMiddle =\n                        middle is Branch3Base mb3 ? mb3.AddOrGetEntry(hash, ref entry, ref splitMiddleRight) :\n                        middle is Leaf5PlusPlus ml511 ? ml511.AddOrGetEntry(hash, ref entry, ref splitMiddleRight) :\n                        middle.AddOrGetEntry(hash, entry);\n\n                    if (splitMiddleRight != null)\n                        return new Branch2(new Branch2(Left, Entry0, newMiddle), entry, new Branch2(splitMiddleRight, Entry1, Right));\n\n                    if (newMiddle is Entry)\n                        return newMiddle;\n\n                    return this is Branch3 b ? new Branch3Middle(b, newMiddle)\n                        : this is Branch3Middle br ? new Branch3Middle(br.B, newMiddle)\n                        : new Branch3(Left, Entry0, newMiddle, Entry1, Right);\n                }\n\n                return hash == h0 ? Entry0 : Entry1;\n            }\n\n            internal ImHashMap<K, V> AddOrGetEntry(int hash, ref Entry entry, ref ImHashMap<K, V> splitRight)\n            {\n                var h1 = Entry1.Hash;\n                if (hash > h1)\n                {\n                    var right = Right;\n                    var newRight = right.AddOrGetEntry(hash, entry);\n                    if (newRight is Entry)\n                        return newRight;\n                    if (right.MayTurnToBranch2 && newRight is Branch2)\n                    {\n                        entry = Entry1;\n                        splitRight = newRight;\n                        return new Branch2(Left, Entry0, Middle);\n                    }\n                    return this is Branch3 b ? new Branch3Right(b, newRight)\n                        : this is Branch3Right br ? new Branch3Right(br.B, newRight)\n                        : new Branch3(Left, Entry0, Middle, Entry1, newRight);\n                }\n\n                var h0 = Entry0.Hash;\n                if (hash < h0)\n                {\n                    var left = Left;\n                    var newLeft = left.AddOrGetEntry(hash, entry);\n                    if (newLeft is Entry)\n                        return newLeft;\n                    if (left.MayTurnToBranch2 && newLeft is Branch2)\n                    {\n                        entry = Entry0;\n                        splitRight = new Branch2(Middle, Entry1, Right);\n                        return newLeft;\n                    }\n                    return this is Branch3 b ? new Branch3Left(b, newLeft)\n                        : this is Branch3Left br ? new Branch3Left(br.B, newLeft)\n                        : new Branch3(newLeft, Entry0, Middle, Entry1, Right);\n                }\n\n                if (hash > h0 && hash < h1)\n                {\n                    var middle = Middle;\n                    ImHashMap<K, V> newMiddle = null, splitMiddleRight = null;\n                    if (middle is Leaf5PlusPlus ml511)\n                    {\n                        newMiddle = ml511.AddOrGetEntry(hash, ref entry, ref splitMiddleRight);\n                        if (splitMiddleRight == null)\n                            return newMiddle;\n                        \/\/ entry = entry; we don't need to assign the entry because it is already containing the proper value\n                        splitRight = new Branch2(splitMiddleRight, Entry1, Right);\n                        return new Branch2(Left, Entry0, newMiddle);\n                    }\n\n                    if (middle is Branch3Base mb3)\n                    {\n                        newMiddle = mb3.AddOrGetEntry(hash, ref entry, ref splitMiddleRight);\n                        if (splitMiddleRight != null)\n                        {\n                            splitRight = new Branch2(splitMiddleRight, Entry1, Right);\n                            return new Branch2(Left, Entry0, newMiddle);\n                        }\n                    }\n                    else\n                        newMiddle = middle.AddOrGetEntry(hash, entry);\n                    if (newMiddle is Entry)\n                        return newMiddle;\n                    return this is Branch3 b ? new Branch3Middle(b, newMiddle) : this is Branch3Middle br ? new Branch3Middle(br.B, newMiddle)\n                        : new Branch3(Left, Entry0, newMiddle, Entry1, Right);\n                }\n\n                return hash == h0 ? Entry0 : Entry1;\n            }\n\n            internal override ImHashMap<K, V> ReplaceEntry(Entry oldEntry, Entry newEntry)\n            {\n                int hash = oldEntry.Hash, h0 = Entry0.Hash, h1 = Entry1.Hash;\n                return hash > h1 ? new Branch3(Left, Entry0, Middle, Entry1, Right.ReplaceEntry(oldEntry, newEntry))\n                    : hash < h0 ? new Branch3(Left.ReplaceEntry(oldEntry, newEntry), Entry0, Middle, Entry1, Right)\n                    : hash > h0 && hash < h1 ? new Branch3(Left, Entry0, Middle.ReplaceEntry(oldEntry, newEntry), Entry1, Right)\n                    : hash == h0 ? new Branch3(Left, newEntry, Middle, Entry1, Right) : new Branch3(Left, Entry0, Middle, newEntry, Right);\n            }\n\n            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry)\n            {\n                Entry midLeft = Entry0, midRight = Entry1;\n                ImHashMap<K, V> middle = Middle, right = Right;\n\n                \/\/ case 1, downward: swap the predecessor entry (max left entry) with the mid entry, then proceed to remove the predecessor from the Left branch\n                if (removedEntry == midLeft)\n                    removedEntry = midLeft = Left.GetMaxHashEntryOrDefault();\n\n                if (removedEntry.Hash <= midLeft.Hash)\n                {\n                    var newLeft = Left.RemoveEntry(removedEntry);\n                    if (newLeft == Empty)\n                    {\n                        if (middle is Leaf5PlusPlus == false)\n                            return new Branch2(middle.AddOrGetEntry(midLeft.Hash, midLeft), midRight, right); \/\/! the height does not change\n                        return new Branch3(midLeft, removedEntry = middle.GetMinHashEntryOrDefault(), middle.RemoveEntry(removedEntry), midRight, right); \/\/! the height does not change\n                    }\n\n                    \/\/ rebalance is needed because the branch was merged from Br2 to Br3 or to Leaf and the height decrease\n                    if (Left is Branch2 && newLeft is Branch2 == false)\n                    {\n                        \/\/ the hole has a 3-node as a parent and a 3-node as a sibling.\n                        if (middle is Branch3Base mb3) \/\/! the height does not change\n                            return new Branch3(new Branch2(newLeft, midLeft, mb3.Left), mb3.Entry0, new Branch2(mb3.Middle, mb3.Entry1, mb3.Right), midRight, right);\n\n                        if (middle is Branch2Plus1 mb21)\n                            return new Branch2(new Branch3(newLeft, midLeft, mb21.ToSplitBranch2(out var mMid, out var mRight), mMid, mRight), midRight, right);\n\n                        \/\/ the hole has a 3-node as a parent and a 2-node as a sibling.\n                        var mb2 = (Branch2)middle;\n                        return new Branch2(new Branch3(newLeft, midLeft, mb2.Left, mb2.MidEntry, mb2.Right), midRight, right);\n                    }\n\n                    return new Branch3(newLeft, midLeft, middle, midRight, right); \/\/ no rebalance needed\n                }\n\n                if (removedEntry == midRight)\n                    removedEntry = midRight = middle.GetMaxHashEntryOrDefault();\n\n                if (removedEntry.Hash <= midRight.Hash)\n                {\n                    var newMiddle = middle.RemoveEntry(removedEntry);\n                    if (newMiddle == Empty)\n                    {\n                        if (right is Leaf5PlusPlus == false)\n                            return new Branch2(Left, midLeft, right.AddOrGetEntry(midRight.Hash, midRight)); \/\/ the Br3 become the Br2 but the height did not change - so no rebalance needed\n                        return new Branch3(Left, midLeft, midRight, removedEntry = right.GetMinHashEntryOrDefault(), right.RemoveEntry(removedEntry)); \/\/! the height does not change\n                    }\n\n                    if (middle is Branch2 && newMiddle is Branch2 == false)\n                    {\n                        \/\/ the hole has a 3-node as a parent and a 3-node as a sibling.\n                        if (right is Branch3Base rb3) \/\/! the height does not change\n                            return new Branch3(Left, midLeft, new Branch2(newMiddle, midRight, rb3.Left), rb3.Entry0, new Branch2(rb3.Middle, rb3.Entry1, rb3.Right));\n\n                        if (right is Branch2Plus1 rb21)\n                            return new Branch2(Left, midLeft, new Branch3(newMiddle, midRight, rb21.ToSplitBranch2(out var rMid, out var rRight), rMid, rRight));\n\n                        \/\/ the hole has a 3-node as a parent and a 2-node as a sibling.\n                        var rb2 = (Branch2)right;\n                        return new Branch2(Left, midLeft, new Branch3(newMiddle, midRight, rb2.Left, rb2.MidEntry, rb2.Right));\n                    }\n\n                    return new Branch3(Left, midLeft, newMiddle, midRight, right);\n                }\n\n                var newRight = right.RemoveEntry(removedEntry);\n                if (newRight == Empty)\n                {\n                    if (middle is Leaf5PlusPlus == false)\n                        return new Branch2(Left, midLeft, middle.AddOrGetEntry(midRight.Hash, midRight));\n                    return new Branch3(Left, midLeft, middle.RemoveEntry(removedEntry = middle.GetMaxHashEntryOrDefault()), removedEntry, midRight);\n                }\n\n                \/\/ right was a Br2 but now is Leaf or Br3 - means the branch height is decrease\n                if (right is Branch2 && newRight is Branch2 == false)\n                {\n                    \/\/ the hole has a 3-node as a parent and a 3-node as a sibling.new\n                    if (middle is Branch3Base mb3) \/\/! the height does not change\n                        return new Branch3(Left, midLeft, new Branch2(mb3.Left, mb3.Entry0, mb3.Middle), mb3.Entry1, new Branch2(mb3.Right, midRight, newRight));\n\n                    if (middle is Branch2Plus1 mb21)\n                        return new Branch2(Left, midLeft, new Branch3(mb21.ToSplitBranch2(out var mMid, out var mRight), mMid, mRight, midRight, newRight));\n\n                    \/\/ the hole has a 3-node as a parent and a 2-node as a sibling.\n                    var mb2 = (Branch2)middle;\n                    return new Branch2(Left, midLeft, new Branch3(mb2.Left, mb2.MidEntry, mb2.Right, midRight, newRight));\n                }\n\n                return new Branch3(Left, midLeft, middle, midRight, newRight);\n            }\n        }\n\n        internal sealed class Branch3Right : Branch3Base\n        {\n            public override Entry Entry0 => B.E0;\n            public override Entry Entry1 => B.E1;\n            public override ImHashMap<K, V> Left => B.L;\n            public override ImHashMap<K, V> Middle => B.M;\n            internal readonly ImHashMap<K, V> R;\n            public override ImHashMap<K, V> Right => R;\n            public readonly Branch3 B;\n            public Branch3Right(Branch3 br3, ImHashMap<K, V> right)\n            {\n                B = br3;\n                R = right;\n            }\n\n            internal override Entry GetEntryOrNull(int hash)\n            {\n                var b = B;\n                var h1 = b.E1.Hash;\n                if (hash > h1)\n                    return R.GetEntryOrNull(hash);\n                var h0 = b.E0.Hash;\n                if (hash < h0)\n                    return b.L.GetEntryOrNull(hash);\n                return h0 == hash ? b.E0 : h1 == hash ? b.E1 : b.M.GetEntryOrNull(hash);\n            }\n        }\n\n        internal sealed class Branch3Left : Branch3Base\n        {\n            public override Entry Entry0 => B.E0;\n            public override Entry Entry1 => B.E1;\n            internal readonly ImHashMap<K, V> L;\n            public override ImHashMap<K, V> Left => L;\n            public override ImHashMap<K, V> Middle => B.M;\n            public override ImHashMap<K, V> Right => B.R;\n            public readonly Branch3 B;\n            public Branch3Left(Branch3 b, ImHashMap<K, V> l)\n            {\n                B = b;\n                L = l;\n            }\n\n            internal override Entry GetEntryOrNull(int hash)\n            {\n                var b = B;\n                var h1 = b.E1.Hash;\n                if (hash > h1)\n                    return B.R.GetEntryOrNull(hash);\n                var h0 = b.E0.Hash;\n                if (hash < h0)\n                    return L.GetEntryOrNull(hash);\n                return h0 == hash ? b.E0 : h1 == hash ? b.E1 : b.M.GetEntryOrNull(hash);\n            }\n        }\n\n        internal sealed class Branch3Middle : Branch3Base\n        {\n            public override Entry Entry0 => B.E0;\n            public override Entry Entry1 => B.E1;\n            public override ImHashMap<K, V> Left => B.L;\n            internal readonly ImHashMap<K, V> M;\n            public override ImHashMap<K, V> Middle => M;\n            public override ImHashMap<K, V> Right => B.R;\n            public readonly Branch3 B;\n            public Branch3Middle(Branch3 b, ImHashMap<K, V> m)\n            {\n                B = b;\n                M = m;\n            }\n            internal override Entry GetEntryOrNull(int hash)\n            {\n                var b = B;\n                var h1 = b.E1.Hash;\n                if (hash > h1)\n                    return B.R.GetEntryOrNull(hash);\n                var h0 = b.E0.Hash;\n                if (hash < h0)\n                    return b.L.GetEntryOrNull(hash);\n                return h0 == hash ? b.E0 : h1 == hash ? b.E1 : M.GetEntryOrNull(hash);\n            }\n        }\n\n        \/\/\/ <summary>The 3 branches with the 2 nodes in between<\/summary>\n        internal sealed class Branch3 : Branch3Base\n        {\n            internal readonly Entry E0, E1;\n            public override Entry Entry0 => E0;\n            public override Entry Entry1 => E1;\n            internal readonly ImHashMap<K, V> L, M, R;\n            public override ImHashMap<K, V> Left => L;\n            public override ImHashMap<K, V> Middle => M;\n            public override ImHashMap<K, V> Right => R;\n            public Branch3(ImHashMap<K, V> left, Entry e0, ImHashMap<K, V> middle, Entry e1, ImHashMap<K, V> right)\n            {\n                Debug.Assert(e0.Hash < e1.Hash, $\"e0.Hash:{e0.Hash} < e1.Hash{e1.Hash}\");\n                L = left;\n                E0 = e0;\n                M = middle;\n                E1 = e1;\n                R = right;\n            }\n            internal override Entry GetEntryOrNull(int hash)\n            {\n                var h1 = E1.Hash;\n                if (hash > h1)\n                    return R.GetEntryOrNull(hash);\n                var h0 = E0.Hash;\n                if (hash < h0)\n                    return L.GetEntryOrNull(hash);\n                return h0 == hash ? E0 : h1 == hash ? E1 : M.GetEntryOrNull(hash);\n            }\n        }\n    }\n\n    \/\/\/ <summary>Helper stack wrapper for the array<\/summary>\n    public sealed class MapParentStack\n    {\n        private const int DefaultInitialCapacity = 4;\n        private object[] _items;\n\n        \/\/\/ <summary>Creates the list of the `DefaultInitialCapacity`<\/summary>\n        public MapParentStack() => _items = new object[DefaultInitialCapacity];\n\n        \/\/\/ <summary>Pushes the item<\/summary>\n        public void Put(object item, int index)\n        {\n            if (index >= _items.Length)\n                _items = Expand(_items);\n            _items[index] = item;\n        }\n\n        \/\/\/ <summary>Gets the item by index<\/summary>\n        public object Get(int index) => _items[index];\n\n        private static object[] Expand(object[] items)\n        {\n            var count = items.Length;\n            var newItems = new object[count << 1]; \/\/ count * 2\n            Array.Copy(items, 0, newItems, 0, count);\n            return newItems;\n        }\n    }\n\n    \/\/\/ <summary>Helper stack wrapper for the array<\/summary>\n    public sealed class ImMapParentStack<K, V>\n    {\n        \/\/\/ <summary>Entry in a stack<\/summary>\n        public struct Entry\n        {\n            \/\/\/ <summary>The next entry to traverse<\/summary>\n            public ImHashMap<K, V>.Entry NextEntry;\n            \/\/\/ <summary>The next branch to traverse<\/summary>\n            public ImHashMap<K, V> NextBranch;\n        }\n\n        private const int DefaultInitialCapacity = 4;\n\n        \/\/\/ <summary>The items<\/summary>\n        public Entry[] Items;\n\n        \/\/\/ <summary>Creates the list of the `DefaultInitialCapacity`<\/summary>\n        public ImMapParentStack(int capacity = DefaultInitialCapacity) => Items = new Entry[capacity];\n\n        \/\/\/ <summary>Pushes the item<\/summary>\n        public void Put(int index, ImHashMap<K, V>.Entry entry, ImHashMap<K, V> branch)\n        {\n            if (index >= Items.Length)\n                Items = Expand(Items);\n            ref var e = ref Items[index];\n            e.NextEntry = entry;\n            e.NextBranch = branch;\n        }\n\n        private static Entry[] Expand(Entry[] items)\n        {\n            var count = items.Length;\n            var newItems = new Entry[count << 1]; \/\/ count * 2\n            Array.Copy(items, 0, newItems, 0, count);\n            return newItems;\n        }\n    }\n\n    \/\/\/ <summary>The map methods<\/summary>\n    public static class ImHashMap\n    {\n        [MethodImpl((MethodImplOptions)256)]\n        internal static void InsertInOrder<K, V>(int ph, ref ImHashMap<K, V>.Entry p,\n            ref ImHashMap<K, V>.Entry e0, ref ImHashMap<K, V>.Entry e1)\n        {\n            var t = default(ImHashMap<K, V>.Entry);\n            if (ph < e1.Hash)\n            {\n                t = e1; e1 = p; p = t;\n                if (ph < e0.Hash)\n                {\n                    t = e0; e0 = e1; e1 = t;\n                }\n            }\n        }\n\n        [MethodImpl((MethodImplOptions)256)]\n        internal static void InsertInOrder<K, V>(int ph, ref ImHashMap<K, V>.Entry p,\n            ref ImHashMap<K, V>.Entry e0, ref ImHashMap<K, V>.Entry e1, ref ImHashMap<K, V>.Entry e2)\n        {\n            var t = default(ImHashMap<K, V>.Entry);\n            if (ph < e2.Hash)\n            {\n                t = e2; e2 = p; p = t;\n                if (ph < e1.Hash)\n                {\n                    t = e1; e1 = e2; e2 = t;\n                    if (ph < e0.Hash)\n                    {\n                        t = e0; e0 = e1; e1 = t;\n                    }\n                }\n            }\n        }\n\n        [MethodImpl((MethodImplOptions)256)]\n        internal static void InsertInOrder<K, V>(int ph, ref ImHashMap<K, V>.Entry p,\n            ref ImHashMap<K, V>.Entry e0, ref ImHashMap<K, V>.Entry e1, ref ImHashMap<K, V>.Entry e2, ref ImHashMap<K, V>.Entry e3)\n        {\n            var t = default(ImHashMap<K, V>.Entry);\n            if (ph < e3.Hash)\n            {\n                t = e3; e3 = p; p = t;\n                if (ph < e2.Hash)\n                {\n                    t = e2; e2 = e3; e3 = t;\n                    if (ph < e1.Hash)\n                    {\n                        t = e1; e1 = e2; e2 = t;\n                        if (ph < e0.Hash)\n                        {\n                            t = e0; e0 = e1; e1 = t;\n                        }\n                    }\n                }\n            }\n        }\n\n        [MethodImpl((MethodImplOptions)256)]\n        internal static void InsertInOrder<K, V>(int ph, ref ImHashMap<K, V>.Entry p,\n            ref ImHashMap<K, V>.Entry e0, ref ImHashMap<K, V>.Entry e1, ref ImHashMap<K, V>.Entry e2, ref ImHashMap<K, V>.Entry e3, ref ImHashMap<K, V>.Entry e4)\n        {\n            var t = default(ImHashMap<K, V>.Entry);\n            if (ph < e4.Hash)\n            {\n                t = e4; e4 = p; p = t;\n                if (ph < e3.Hash)\n                {\n                    t = e3; e3 = e4; e4 = t;\n                    if (ph < e2.Hash)\n                    {\n                        t = e2; e2 = e3; e3 = t;\n                        if (ph < e1.Hash)\n                        {\n                            t = e1; e1 = e2; e2 = t;\n                            if (ph < e0.Hash)\n                            {\n                                t = e0; e0 = e1; e1 = t;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        [MethodImpl((MethodImplOptions)256)]\n        internal static void InsertInOrder<K, V>(int ph, ref ImHashMap<K, V>.Entry p,\n            ref ImHashMap<K, V>.Entry e0, ref ImHashMap<K, V>.Entry e1, ref ImHashMap<K, V>.Entry e2, ref ImHashMap<K, V>.Entry e3, ref ImHashMap<K, V>.Entry e4,\n            ref ImHashMap<K, V>.Entry e5)\n        {\n            var t = default(ImHashMap<K, V>.Entry);\n            if (ph < e5.Hash)\n            {\n                t = e5; e5 = p; p = t;\n                if (ph < e4.Hash)\n                {\n                    t = e4; e4 = e5; e5 = t;\n                    if (ph < e3.Hash)\n                    {\n                        t = e3; e3 = e4; e4 = t;\n                        if (ph < e2.Hash)\n                        {\n                            t = e2; e2 = e3; e3 = t;\n                            if (ph < e1.Hash)\n                            {\n                                t = e1; e1 = e2; e2 = t;\n                                if (ph < e0.Hash)\n                                {\n                                    t = e0; e0 = e1; e1 = t;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        [MethodImpl((MethodImplOptions)256)]\n        internal static void InsertInOrder<K, V>(int ph, ref ImHashMap<K, V>.Entry p,\n            ref ImHashMap<K, V>.Entry e0, ref ImHashMap<K, V>.Entry e1, ref ImHashMap<K, V>.Entry e2, ref ImHashMap<K, V>.Entry e3, ref ImHashMap<K, V>.Entry e4,\n            ref ImHashMap<K, V>.Entry e5, ref ImHashMap<K, V>.Entry e6)\n        {\n            var t = default(ImHashMap<K, V>.Entry);\n            if (ph < e6.Hash)\n            {\n                t = e6; e6 = p; p = t;\n                if (ph < e5.Hash)\n                {\n                    t = e5; e5 = e6; e6 = t;\n                    if (ph < e4.Hash)\n                    {\n                        t = e4; e4 = e5; e5 = t;\n                        if (ph < e3.Hash)\n                        {\n                            t = e3; e3 = e4; e4 = t;\n                            if (ph < e2.Hash)\n                            {\n                                t = e2; e2 = e3; e3 = t;\n                                if (ph < e1.Hash)\n                                {\n                                    t = e1; e1 = e2; e2 = t;\n                                    if (ph < e0.Hash)\n                                    {\n                                        t = e0; e0 = e1; e1 = t;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        private static readonly object _enumerationB3Tombstone = new object();\n\n        internal struct ImMapStack<K, V>\n        {\n            ImHashMap<K, V>.Entry e0, e1, e2, e3, e4, e5, e6, e7;\/\/, e8, e9, e10, e11, e12, e13, e14, e15;\n            ImHashMap<K, V> b0, b1, b2, b3, b4, b5, b6, b7;\/\/, b8, b9, b10, b11, b12, b13, b14, b15;\n            ImMapParentStack<K, V> _deeper;\n            const byte _deeperStartsAtLevel = 8;\n            public void Put(ushort i, ImHashMap<K, V>.Entry e, ImHashMap<K, V> b)\n            {\n                switch (i)\n                {\n                    case 0: e0 = e; b0 = b; break;\n                    case 1: e1 = e; b1 = b; break;\n                    case 2: e2 = e; b2 = b; break;\n                    case 3: e3 = e; b3 = b; break;\n                    case 4: e4 = e; b4 = b; break;\n                    case 5: e5 = e; b5 = b; break;\n                    case 6: e6 = e; b6 = b; break;\n                    case 7: e7 = e; b7 = b; break;\n                    default:\n                        if (_deeper == null)\n                            _deeper = new ImMapParentStack<K, V>(8);\n                        _deeper.Put(i - _deeperStartsAtLevel, e, b);\n                        break;\n                }\n            }\n\n            public void Put(ushort i, ImHashMap<K, V>.Entry e, ImHashMap<K, V> b, ImHashMap<K, V>.Entry eNext, ImHashMap<K, V> bNext)\n            {\n                switch (i)\n                {\n                    case 0: e0 = e; b0 = b; e1 = eNext; b1 = bNext; break;\n                    case 1: e1 = e; b1 = b; e2 = eNext; b2 = bNext; break;\n                    case 2: e2 = e; b2 = b; e3 = eNext; b3 = bNext; break;\n                    case 3: e3 = e; b3 = b; e4 = eNext; b4 = bNext; break;\n                    case 4: e4 = e; b4 = b; e5 = eNext; b5 = bNext; break;\n                    case 5: e5 = e; b5 = b; e6 = eNext; b6 = bNext; break;\n                    case 6: e6 = e; b6 = b; e7 = eNext; b7 = bNext; break;\n                    case 7:\n                        e7 = e; b7 = b;\n                        if (_deeper == null) _deeper = new ImMapParentStack<K, V>(8);\n                        _deeper.Put(0, eNext, bNext);\n                        break;\n                    default:\n                        if (_deeper == null) _deeper = new ImMapParentStack<K, V>(8);\n                        i -= _deeperStartsAtLevel;\n                        _deeper.Put(i, e, b);\n                        _deeper.Put(i + 1, eNext, bNext);\n                        break;\n                }\n            }\n\n            public void Get(ushort i, ref ImHashMap<K, V>.Entry e, ref ImHashMap<K, V> b)\n            {\n                switch (i)\n                {\n                    case 0: e = e0; b = b0; break;\n                    case 1: e = e1; b = b1; break;\n                    case 2: e = e2; b = b2; break;\n                    case 3: e = e3; b = b3; break;\n                    case 4: e = e4; b = b4; break;\n                    case 5: e = e5; b = b5; break;\n                    case 6: e = e6; b = b6; break;\n                    case 7: e = e7; b = b7; break;\n                    default:\n                        Debug.Assert(_deeper != null, \"Expecting the `deeper` parent stack created before accessing it here at level \" + i);\n                        ref var p = ref _deeper.Items[i - _deeperStartsAtLevel];\n                        e = p.NextEntry; b = p.NextBranch;\n                        break;\n                }\n            }\n        }\n\n        \/\/\/ <summary>Non-allocating enumerator<\/summary>\n        public struct ImMapEnumerable<K, V> : IEnumerable<ImHashMapEntry<K, V>>, IEnumerable\n        {\n            private readonly ImHashMap<K, V> _map;\n\n            \/\/\/ <summary>Constructor<\/summary>\n            public ImMapEnumerable(ImHashMap<K, V> map) => _map = map;\n\n            \/\/\/ <summary>Returns non-allocating enumerator<\/summary>\n            public ImMapEnumerator<K, V> GetEnumerator() => new ImMapEnumerator<K, V> { _map = _map };\n\n            IEnumerator<ImHashMapEntry<K, V>> IEnumerable<ImHashMapEntry<K, V>>.GetEnumerator() => new ImMapEnumerator<K, V> { _map = _map };\n            IEnumerator IEnumerable.GetEnumerator() => new ImMapEnumerator<K, V> { _map = _map };\n        }\n\n        \/\/\/ <summary>Enumerator on stack, without allocation<\/summary>\n        public struct ImMapEnumerator<K, V> : IEnumerator<ImHashMapEntry<K, V>>, IDisposable, IEnumerator\n        {\n            internal ImHashMap<K, V> _map;\n            private short _state;\n            private short _conflictIndex;\n            private ushort _index;\n            private ImMapStack<K, V> _ps;\n            private ImHashMap<K, V> _nextBranch;\n            private ImHashMap<K, V>.Branch2Plus1 _b21LeftWasEnumerated;\n\n            private ImHashMap<K, V>.Entry _a, _b, _c, _d, _e, _f, _g, _h;\n            private ImHashMap<K, V>.Entry _hc; \/\/ is for possibly HashConflictingEntry\n            private ImHashMapEntry<K, V> _current;\n\n            \/\/\/ <inheritdoc \/>\n            public ImHashMapEntry<K, V> Current => _current;\n            object IEnumerator.Current => _current;\n\n            private bool SetCurrentAndState(ImHashMap<K, V>.Entry e, short nextState, short prevState)\n            {\n                _state = nextState;\n                if (e is ImHashMapEntry<K, V> kv)\n                    _current = kv;\n                else\n                {\n                    var hc = (ImHashMap<K, V>.HashConflictingEntry)e;\n                    var cs = hc.Conflicts;\n                    _current = cs[_conflictIndex];\n                    \/\/ undo the next state until we are done with conflicts\n                    if (++_conflictIndex < cs.Length)\n                        _state = prevState;\n                    else \/\/ reset the index of conflicts todo: @perf use special value to avoid the type check later\n                        _conflictIndex = 0;\n                }\n                return true;\n            }\n\n            private bool SetCurrentAndState(short nextState, short prevState)\n            {\n                _state = nextState;\n                if (_hc is ImHashMapEntry<K, V> kv)\n                {\n                    _current = kv;\n                    _hc = null;\n                }\n                else\n                {\n                    var hc = (ImHashMap<K, V>.HashConflictingEntry)_hc;\n                    var cs = hc.Conflicts;\n                    _current = cs[_conflictIndex];\n                    \/\/ undo the next state until we are done with conflicts\n                    if (++_conflictIndex < cs.Length)\n                        _state = prevState;\n                    else \/\/ reset the index of conflicts todo: @perf use special value to avoid the type check later\n                    {\n                        _conflictIndex = 0;\n                        _hc = null;\n                    }\n                }\n                return true;\n            }\n\n            \/\/\/ <inheritdoc \/>\n            public bool MoveNext()\n            {\n                ImHashMap<K, V>.Leaf5PlusPlus b21FullLeaf511;\n                switch (_state)\n                {\n                    case 0:\n                        if (_map == ImHashMap<K, V>.Empty)\n                            return false;\n                        if (_map is ImHashMap<K, V>.Entry singleEntryMap)\n                            return SetCurrentAndState(singleEntryMap, 1, 0);\n                        _state = -1; \/\/ todo: @perf optimize just by setting _state = -1 for all\n                        goto Label0;\n                    case 1:\n                        \/\/ end of enumeration\n                        _state = -1;\n                        _current = null;\n                        return false;\n                    case 2:\n                        b21FullLeaf511 = (ImHashMap<K, V>.Leaf5PlusPlus)_b21LeftWasEnumerated.B.Right;\n                        _g = _b21LeftWasEnumerated.Plus;\n                        _b21LeftWasEnumerated = null;\n                        _map = ImHashMap<K, V>.Empty;\n                        _state = -1;\n                        goto SortLeaf511Label;\n                    case 3:\n                        return SetCurrentAndState(_a, 4, 3);\n                    case 4:\n                        return SetCurrentAndState(_b, 5, 4);\n                    case 5:\n                        return SetCurrentAndState(_c, 6, 5);\n                    case 6:\n                        return SetCurrentAndState(_d, 7, 6);\n                    case 7:\n                        return SetCurrentAndState(_e, 8, 7);\n                    case 8:\n                        return SetCurrentAndState(_f, 9, 8);\n                    case 9:\n                        return SetCurrentAndState(_g, 10, 9);\n                    case 10:\n                        if (_h == null)\n                        {\n                            _state = -1;\n                            goto Label2;\n                        }\n                        return SetCurrentAndState(_h, 11, 10);\n                    case 11:\n                        _state = -1;\n                        goto Label2;\n                    case 12:\n                        return SetCurrentAndState(_a, 13, 12);\n                    case 13:\n                        _state = -1;\n                        goto Label3;\n                    case 14:\n                        return SetCurrentAndState(_h, 15, 14);\n                    case 15:\n                        return SetCurrentAndState(_g, 16, 15);\n                    case 16:\n                        _state = -1; _h = null; _g = null;\n                        goto Label3;\n                    case 17:\n                        return SetCurrentAndState(_g, 18, 17);\n                    case 18:\n                        return SetCurrentAndState(_h, 19, 18);\n                    case 19:\n                        return SetCurrentAndState(_e, 20, 19);\n                    case 20:\n                        _state = -1; _g = null; _h = null; _e = null;\n                        goto Label3;\n                    case 21:\n                        return SetCurrentAndState(_a, 22, 21);\n                    case 22:\n                        return SetCurrentAndState(_b, 23, 22);\n                    case 23:\n                        return SetCurrentAndState(_c, 24, 23);\n                    case 24:\n                        return SetCurrentAndState(_d, 25, 24);\n                    case 25:\n                        _state = -1;\n                        break;\n                    case 26:\n                        return SetCurrentAndState(_e, 27, 26);\n                    case 27:\n                        return SetCurrentAndState(_h, 28, 27);\n                    case 28:\n                        return SetCurrentAndState(_g, 29, 28);\n                    case 29:\n                        return SetCurrentAndState(_f, 30, 29);\n                    case 30:\n                        return SetCurrentAndState(_d, 31, 30);\n                    case 31:\n                        _state = -1; _e = null; _h = null; _g = null; _f = null; _d = null;\n                        break;\n                    case 32:\n                        return SetCurrentAndState(_d, 33, 32);\n                    case 33:\n                        return SetCurrentAndState(_f, 34, 33);\n                    case 34:\n                        return SetCurrentAndState(_g, 35, 34);\n                    case 35:\n                        return SetCurrentAndState(_h, 36, 35);\n                    case 36:\n                        return SetCurrentAndState(_c, 37, 36);\n                    case 37:\n                        return SetCurrentAndState(_e, 38, 37);\n                    case 38:\n                        _state = -1; _d = null; _f = null; _g = null; _h = null; _e = null; _c = null;\n                        break;\n                    case 39:\n                        _state = -1;\n                        break;\n                    case 40:\n                        _state = -1;\n                        _map = _nextBranch;\n                        _a = null;\n                        _nextBranch = null;\n                        goto Label0;\n                    case 41:\n                        goto HashConflictingEntryLabel0;\n                    case 42:\n                        goto HashConflictingEntryLabel1;\n                    case 43:\n                        goto HashConflictingEntryLabel2;\n                    case 44:\n                        goto HashConflictingEntryLabel3;\n                    case 45:\n                        goto HashConflictingEntryLabel4;\n                    case 46:\n                        goto HashConflictingEntryLabel5;\n                    case 47:\n                        goto HashConflictingEntryLabel6;\n                    case 48:\n                        goto HashConflictingEntryLabel7;\n                    case 49:\n                        goto HashConflictingEntryLabel8;\n                    default:\n                        return false;\n                }\n            Label6:\n                _a = null; _b = null; _c = null; _d = null;\n            Label3:\n                if (_b21LeftWasEnumerated == null)\n                {\n                    if (_index == 0)\n                        return false;\n                    ImHashMap<K, V>.Entry current = null;\n                    var popIndex = (ushort)(_index - 1);\n                    _ps.Get(popIndex, ref current, ref _nextBranch);\n                    \/\/ Sets the previous state so that we are modifying any fields like _a, _b, etc. and directly goto back to this label\n                    SetCurrentAndState(current, 40, 13);\n                    if (_state == 40)\n                        _index = popIndex; \/\/ proceed\n                    return true;\n                }\n            Label0:\n                while (true)\n                {\n                    if (_map is ImHashMap<K, V>.Branch2 branch2)\n                    {\n                        _ps.Put(_index++, branch2.MidEntry, branch2.Right);\n                        _map = branch2.Left;\n                    }\n                    else if (_map is ImHashMap<K, V>.Branch3Base branch3)\n                    {\n                        _ps.Put(_index, branch3.Entry1, branch3.Right, branch3.Entry0, branch3.Middle);\n                        _index += 2;\n                        _map = branch3.Left;\n                    }\n                    else break;\n                }\n\n                if (_b21LeftWasEnumerated == null && !(_map is ImHashMap<K, V>.Branch2Plus1))\n                    goto AllLeafsAndEntryLabel;\n\n                _g = null; _h = null;\n            HashConflictingEntryLabel0:\n                if (_b21LeftWasEnumerated != null)\n                    return SetCurrentAndState(_b21LeftWasEnumerated.B.MidEntry, 2, 41);\n\n                var branch2Plus1 = (ImHashMap<K, V>.Branch2Plus1)_map;\n                var b21b = branch2Plus1.B;\n                if (b21b.Right is ImHashMap<K, V>.Leaf5PlusPlus)\n                {\n                    _b21LeftWasEnumerated = branch2Plus1;\n                    _map = b21b.Left;\n                    goto B21NotFilledLeftLeafLabel;\n                }\n\n                b21FullLeaf511 = (ImHashMap<K, V>.Leaf5PlusPlus)b21b.Left;\n                _h = b21b.MidEntry;\n                _g = branch2Plus1.Plus;\n                _map = b21b.Right;\n\n            SortLeaf511Label:\n                {\n                    var l = b21FullLeaf511.L.L;\n                    ImHashMap<K, V>.Entry e0 = l.Entry0;\n                    _a = l.Entry1;\n                    _b = l.Entry2;\n                    _c = l.Entry3;\n                    _d = l.Entry4;\n                    _f = b21FullLeaf511.Plus;\n                    _e = b21FullLeaf511.L.Plus;\n                    InsertInOrder(_e.Hash, ref _e, ref e0, ref _a, ref _b, ref _c, ref _d);\n                    InsertInOrder(_f.Hash, ref _f, ref e0, ref _a, ref _b, ref _c, ref _d, ref _e);\n                    InsertInOrder(_g.Hash, ref _g, ref e0, ref _a, ref _b, ref _c, ref _d, ref _e, ref _f);\n                    _hc = e0;\n                }\n            HashConflictingEntryLabel1:\n                return SetCurrentAndState(3, 42);\n\n            Label2:\n                _a = null; _b = null; _c = null; _d = null; _e = null; _f = null;\n\n            B21NotFilledLeftLeafLabel:\n                _g = null; _h = null;\n\n            AllLeafsAndEntryLabel:\n            HashConflictingEntryLabel2:\n                if (_map is ImHashMap<K, V>.Leaf2 l2)\n                {\n                    _a = l2.Entry1;\n                    return SetCurrentAndState(l2.Entry0, 12, 43);\n                }\n\n                if (_map is ImHashMap<K, V>.Leaf2Plus l21)\n                {\n                    var l = l21.L;\n                    ImHashMap<K, V>.Entry e0 = l.Entry0;\n                    _h = l.Entry1;\n                    _g = l21.Plus;\n                    InsertInOrder(_g.Hash, ref _g, ref e0, ref _h);\n                    _hc = e0;\n                }\n            HashConflictingEntryLabel3:\n                if (_hc != null)\n                    return SetCurrentAndState(14, 44);\n\n                if (_map is ImHashMap<K, V>.Leaf2PlusPlus l211)\n                {\n                    var l1 = l211.L.L;\n                    ImHashMap<K, V>.Entry e0 = l1.Entry0;\n                    _g = l1.Entry1;\n                    _h = l211.L.Plus;\n                    _e = l211.Plus;\n                    InsertInOrder(_h.Hash, ref _h, ref e0, ref _g);\n                    InsertInOrder(_e.Hash, ref _e, ref e0, ref _g, ref _h);\n                    _hc = e0;\n                }\n            HashConflictingEntryLabel4:\n                if (_hc != null)\n                    return SetCurrentAndState(17, 45);\n\n                if (_map is ImHashMap<K, V>.Leaf5 l5)\n                {\n                    _a = l5.Entry1;\n                    _b = l5.Entry2;\n                    _c = l5.Entry3;\n                    _d = l5.Entry4;\n                    _hc = l5.Entry0;\n                }\n            HashConflictingEntryLabel5:\n                if (_hc != null)\n                    return SetCurrentAndState(21, 46);\n\n                if (_map is ImHashMap<K, V>.Leaf5Plus l51)\n                {\n                    var leaf5 = l51.L;\n                    ImHashMap<K, V>.Entry e0 = leaf5.Entry0;\n                    _e = leaf5.Entry1;\n                    _h = leaf5.Entry2;\n                    _g = leaf5.Entry3;\n                    _f = leaf5.Entry4;\n                    _d = l51.Plus;\n                    InsertInOrder(_d.Hash, ref _d, ref e0, ref _e, ref _h, ref _g, ref _f);\n                    _hc = e0;\n                }\n            HashConflictingEntryLabel6:\n                if (_hc != null)\n                    return SetCurrentAndState(26, 47);\n\n                if (_map is ImHashMap<K, V>.Leaf5PlusPlus l511)\n                {\n                    var leaf51 = l511.L.L;\n                    ImHashMap<K, V>.Entry e0 = leaf51.Entry0;\n                    _d = leaf51.Entry1;\n                    _f = leaf51.Entry2;\n                    _g = leaf51.Entry3;\n                    _h = leaf51.Entry4;\n                    _c = l511.L.Plus;\n                    _e = l511.Plus;\n                    InsertInOrder(_c.Hash, ref _c, ref e0, ref _d, ref _f, ref _g, ref _h);\n                    InsertInOrder(_e.Hash, ref _e, ref e0, ref _d, ref _f, ref _g, ref _h, ref _c);\n                    _hc = e0;\n                }\n            HashConflictingEntryLabel7:\n                if (_hc != null)\n                    return SetCurrentAndState(32, 48);\n\n                HashConflictingEntryLabel8:\n                if (_map is ImHashMap<K, V>.Entry e)\n                    return SetCurrentAndState(e, 39, 49);\n\n                goto Label6;\n            }\n\n            bool IEnumerator.MoveNext() => MoveNext();\n            void IEnumerator.Reset() => throw new NotSupportedException();\n            void IDisposable.Dispose() { }\n        }\n\n        \/\/\/ <summary>Enumerates all the map entries in the hash order.\n        \/\/\/ `parents` parameter allows to reuse the stack memory used for traversal between multiple enumerates.\n        \/\/\/ So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent `Enumerate` calls<\/summary>\n        public static ImMapEnumerable<K, V> Enumerate<K, V>(this ImHashMap<K, V> map) => new ImMapEnumerable<K, V>(map);\n\n        \/\/\/ <summary>Depth-first in-order of hash traversal as described in http:\/\/en.wikipedia.org\/wiki\/Tree_traversal.\n        \/\/\/ The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.\n        \/\/\/ So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls<\/summary>\n        public static S ForEach<K, V, S>(this ImHashMap<K, V> map, S state, Action<ImHashMapEntry<K, V>, int, S> handler, MapParentStack parents = null)\n        {\n            if (map == ImHashMap<K, V>.Empty)\n                return state;\n            if (map is ImHashMap<K, V>.Entry singleEntry)\n            {\n                singleEntry.ForEach(state, 0, handler);\n                return state;\n            }\n\n            ImHashMap<K, V>.Branch2Plus1 b21LeftWasEnumerated = null;\n            int count = 0, i = 0;\n            while (true)\n            {\n                if (map is ImHashMap<K, V>.Branch2 b2)\n                {\n                    if (parents == null)\n                        parents = new MapParentStack();\n                    parents.Put(map, count++);\n                    map = b2.Left;\n                    continue;\n                }\n\n                if (map is ImHashMap<K, V>.Branch3Base b3)\n                {\n                    if (parents == null)\n                        parents = new MapParentStack();\n                    parents.Put(map, count++);\n                    map = b3.Left;\n                    continue;\n                }\n\n                if (b21LeftWasEnumerated != null || map is ImHashMap<K, V>.Branch2Plus1)\n                {\n                    ImHashMap<K, V>.Leaf5PlusPlus l511 = null;\n                    ImHashMap<K, V>.Entry pl = null, mid = null;\n                    if (b21LeftWasEnumerated != null)\n                    {\n                        i = b21LeftWasEnumerated.B.MidEntry.ForEach(state, i, handler);\n\n                        l511 = (ImHashMap<K, V>.Leaf5PlusPlus)b21LeftWasEnumerated.B.Right;\n                        pl = b21LeftWasEnumerated.Plus;\n                        b21LeftWasEnumerated = null; \/\/ we done with the branch\n                        map = ImHashMap<K, V>.Empty;     \/\/ forcing to skip leaves below\n                    }\n                    else\n                    {\n                        var b21 = (ImHashMap<K, V>.Branch2Plus1)map;\n                        if (b21.B.Right is ImHashMap<K, V>.Leaf5PlusPlus) \/\/ so we need to enumerate the left as a normal branch2 with the code below.\n                        {\n                            b21LeftWasEnumerated = b21;\n                            map = b21.B.Left;\n                        }\n                        else \/\/ we need to sort out the left side with Plus entry\n                        {\n                            l511 = (ImHashMap<K, V>.Leaf5PlusPlus)b21.B.Left;\n                            mid = b21.B.MidEntry;\n                            pl = b21.Plus;\n                            map = b21.B.Right; \/\/ it is a leaf so, no need to continue, just proceed with the leafs below\n                        }\n                    }\n                    if (l511 != null)\n                    {\n                        var l = l511.L.L;\n                        ImHashMap<K, V>.Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4, p = l511.Plus, pp = l511.L.Plus;\n\n                        ImHashMap.InsertInOrder(pp.Hash, ref pp, ref e0, ref e1, ref e2, ref e3, ref e4);\n                        ImHashMap.InsertInOrder(p.Hash, ref p, ref e0, ref e1, ref e2, ref e3, ref e4, ref pp);\n                        ImHashMap.InsertInOrder(pl.Hash, ref pl, ref e0, ref e1, ref e2, ref e3, ref e4, ref pp, ref p);\n\n                        i = e0.ForEach(state, i, handler);\n                        i = e1.ForEach(state, i, handler);\n                        i = e2.ForEach(state, i, handler);\n                        i = e3.ForEach(state, i, handler);\n                        i = e4.ForEach(state, i, handler);\n                        i = pp.ForEach(state, i, handler);\n                        i = p.ForEach(state, i, handler);\n                        i = pl.ForEach(state, i, handler);\n\n                        if (mid != null)\n                            i = mid.ForEach(state, i, handler);\n                    }\n                }\n\n                if (map is ImHashMap<K, V>.Leaf2 l2)\n                {\n                    i = l2.Entry0.ForEach(state, i, handler);\n                    i = l2.Entry1.ForEach(state, i, handler);\n                }\n                else if (map is ImHashMap<K, V>.Leaf2Plus l21)\n                {\n                    var l = l21.L;\n                    ImHashMap<K, V>.Entry e0 = l.Entry0, e1 = l.Entry1, pp = l21.Plus;\n\n                    ImHashMap.InsertInOrder(pp.Hash, ref pp, ref e0, ref e1);\n\n                    i = e0.ForEach(state, i, handler);\n                    i = e1.ForEach(state, i, handler);\n                    i = pp.ForEach(state, i, handler);\n                }\n                else if (map is ImHashMap<K, V>.Leaf2PlusPlus l211)\n                {\n                    var l = l211.L.L;\n                    ImHashMap<K, V>.Entry e0 = l.Entry0, e1 = l.Entry1, pp = l211.L.Plus, p = l211.Plus;\n\n                    ImHashMap.InsertInOrder(pp.Hash, ref pp, ref e0, ref e1);\n                    ImHashMap.InsertInOrder(p.Hash, ref p, ref e0, ref e1, ref pp);\n\n                    i = e0.ForEach(state, i, handler);\n                    i = e1.ForEach(state, i, handler);\n                    i = pp.ForEach(state, i, handler);\n                    i = p.ForEach(state, i, handler);\n                }\n                else if (map is ImHashMap<K, V>.Leaf5 l5)\n                {\n                    i = l5.Entry0.ForEach(state, i, handler);\n                    i = l5.Entry1.ForEach(state, i, handler);\n                    i = l5.Entry2.ForEach(state, i, handler);\n                    i = l5.Entry3.ForEach(state, i, handler);\n                    i = l5.Entry4.ForEach(state, i, handler);\n                }\n                else if (map is ImHashMap<K, V>.Leaf5Plus l51)\n                {\n                    var l = l51.L;\n                    ImHashMap<K, V>.Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4, pp = l51.Plus;\n\n                    ImHashMap.InsertInOrder(pp.Hash, ref pp, ref e0, ref e1, ref e2, ref e3, ref e4);\n\n                    i = e0.ForEach(state, i, handler);\n                    i = e1.ForEach(state, i, handler);\n                    i = e2.ForEach(state, i, handler);\n                    i = e3.ForEach(state, i, handler);\n                    i = e4.ForEach(state, i, handler);\n                    i = pp.ForEach(state, i, handler);\n                }\n                else if (map is ImHashMap<K, V>.Leaf5PlusPlus l511)\n                {\n                    var l = l511.L.L;\n                    ImHashMap<K, V>.Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4, p = l511.Plus, pp = l511.L.Plus;\n\n                    ImHashMap.InsertInOrder(pp.Hash, ref pp, ref e0, ref e1, ref e2, ref e3, ref e4);\n                    ImHashMap.InsertInOrder(p.Hash, ref p, ref e0, ref e1, ref e2, ref e3, ref e4, ref pp);\n\n                    i = e0.ForEach(state, i, handler);\n                    i = e1.ForEach(state, i, handler);\n                    i = e2.ForEach(state, i, handler);\n                    i = e3.ForEach(state, i, handler);\n                    i = e4.ForEach(state, i, handler);\n                    i = pp.ForEach(state, i, handler);\n                    i = p.ForEach(state, i, handler);\n                }\n                else if (map is ImHashMap<K, V>.Entry l1)\n                    i = l1.ForEach(state, i, handler);\n\n                if (b21LeftWasEnumerated != null)\n                    continue;\n\n                if (count == 0)\n                    break; \/\/ we yield the leaf and there is nothing in stack - we are DONE!\n\n                var b = parents.Get(--count); \/\/ otherwise get the parent\n                if (b is ImHashMap<K, V>.Branch2 pb2)\n                {\n                    i = pb2.MidEntry.ForEach(state, i, handler);\n                    map = pb2.Right;\n                }\n                else if (b != _enumerationB3Tombstone)\n                {\n                    var pb3 = (ImHashMap<K, V>.Branch3Base)b;\n                    i = pb3.Entry0.ForEach(state, i, handler);\n                    map = pb3.Middle;\n                    parents.Put(_enumerationB3Tombstone, ++count);\n                    ++count;\n                }\n                else\n                {\n                    var pb3 = (ImHashMap<K, V>.Branch3Base)parents.Get(--count);\n                    i = pb3.Entry1.ForEach(state, i, handler);\n                    map = pb3.Right;\n                }\n            }\n\n            return state;\n        }\n\n        \/\/\/ <summary>Do something for each entry.\n        \/\/\/ The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.\n        \/\/\/ So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls<\/summary>\n        public static void ForEach<K, V>(this ImHashMap<K, V> map, Action<ImHashMapEntry<K, V>, int> handler, MapParentStack parents = null) =>\n            map.ForEach(handler, (e, i, r) => r(e, i), parents);\n\n        \/\/\/ <summary>Collect something for each entry.\n        \/\/\/ The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.\n        \/\/\/ So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls<\/summary>\n        public static S Fold<K, V, S>(this ImHashMap<K, V> map, S state, Func<ImHashMapEntry<K, V>, int, S, S> handler, MapParentStack parents = null) =>\n            map.ForEach(St.Rent(state, handler), (e, i, s) => s.a = s.b(e, i, s.a), parents).ResetButGetA();\n\n        \/\/\/ <summary>Converts the map to an array with the minimum allocations<\/summary>\n        public static S[] ToArray<K, V, S>(this ImHashMap<K, V> map, Func<ImHashMapEntry<K, V>, S> selector) =>\n            map == ImHashMap<K, V>.Empty ? ArrayTools.Empty<S>() :\n                map.ForEach(St.Rent(new S[map.Count()], selector), (e, i, s) => s.a[i] = s.b(e)).ResetButGetA();\n\n        \/\/\/ <summary>Converts the map to an array with the minimum allocations<\/summary>\n        public static ImHashMapEntry<K, V>[] ToArray<K, V>(this ImHashMap<K, V> map) =>\n            map == ImHashMap<K, V>.Empty ? ArrayTools.Empty<ImHashMapEntry<K, V>>() : map.ForEach(new ImHashMapEntry<K, V>[map.Count()], (e, i, a) => a[i] = e);\n\n        \/\/\/ <summary>Converts the map to the dictionary<\/summary>\n        public static Dictionary<K, V> ToDictionary<K, V>(this ImHashMap<K, V> map) =>\n            map == ImHashMap<K, V>.Empty\n                ? new Dictionary<K, V>(0)\n                : map.ForEach(new Dictionary<K, V>(), (e, _, d) => d.Add(e.Key, e.Value));\n\n        \/\/\/ <summary>Returns <see langword=\"true\"\/> if map contains the hash, otherwise returns <see langword=\"false\"\/><\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static bool Contains<V>(this ImHashMap<int, V> map, int key) => map.GetEntryOrNull(key) != null;\n\n        \/\/\/ <summary>Returns <see langword=\"true\"\/> if map contains the hash and key, otherwise returns <see langword=\"false\"\/><\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static bool Contains<K, V>(this ImHashMap<K, V> map, int hash, K key) => map.GetEntryOrDefault(hash, key) != null;\n\n        \/\/\/ <summary>Returns <see langword=\"true\"\/> if map contains the key, otherwise returns <see langword=\"false\"\/><\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static bool Contains<K, V>(this ImHashMap<K, V> map, K key) => map.GetEntryOrDefault(key.GetHashCode(), key) != null;\n\n        \/\/\/ <summary>Returns the entry ASSUMING it is present otherwise its behavior is UNDEFINED.\n        \/\/\/ You can use the method after the Add and Update methods on the same map instance - \n        \/\/\/ because the map is immutable it is for sure contains added or updated entry.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMapEntry<int, V> GetSurePresentEntry<V>(this ImHashMap<int, V> map, int hash) =>\n            (VEntry<V>)map.GetEntryOrNull(hash);\n\n        \/\/\/ <summary>Returns the entry ASSUMING it is present otherwise its behavior is UNDEFINED.\n        \/\/\/ You can use the method after the Add and Update methods on the same map instance - \n        \/\/\/ because the map is immutable it is for sure contains added or updated entry.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMapEntry<K, V> GetSurePresentEntry<K, V>(this ImHashMap<K, V> map, int hash, K key) =>\n            map.GetEntryOrNull(hash).GetOrNull(key);\n\n        \/\/\/ <summary>Lookup for the entry by hash, returns the found entry or `null`.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMapEntry<int, V> GetEntryOrDefault<V>(this ImHashMap<int, V> map, int hash) =>\n            (VEntry<V>)map.GetEntryOrNull(hash);\n\n        \/\/\/ <summary>Lookup for the entry by key and hash, returns the found entry or `null`.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMapEntry<K, V> GetEntryOrDefault<K, V>(this ImHashMap<K, V> map, int hash, K key) =>\n            map.GetEntryOrNull(hash)?.GetOrNullWithTheSameHash(key);\n\n        \/\/\/ <summary>Lookup for the entry by key and hash, returns the found entry or `null`.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMapEntry<K, V> GetEntryOrDefault<K, V>(this ImHashMap<K, V> map, K key) =>\n            map.GetEntryOrNull(key.GetHashCode())?.GetOrNullWithTheSameHash(key);\n\n        \/\/\/ <summary>Lookup for the entry by key and hash, comparing the key by reference, returns the found entry or `null`.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMapEntry<K, V> GetEntryOrDefaultByReferenceEquals<K, V>(this ImHashMap<K, V> map, int hash, K key) where K : class =>\n            map.GetEntryOrNull(hash)?.GetOrNullByReferenceEqualsWithTheSameHash(key);\n\n        \/\/\/ <summary>Lookup for the entry by key and hash, comparing the key by reference, returns the found entry or `null`.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMapEntry<K, V> GetEntryOrDefaultByReferenceEquals<K, V>(this ImHashMap<K, V> map, K key) where K : class =>\n            map.GetEntryOrNull(key.GetHashCode())?.GetOrNullByReferenceEqualsWithTheSameHash(key);\n\n        \/\/\/ <summary>Lookup for the value by hash, returns the default `V` if hash is not found.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static V GetValueOrDefault<V>(this ImHashMap<int, V> map, int hash)\n        {\n            var e = (VEntry<V>)map.GetEntryOrNull(hash);\n            return e != null ? e.Value : default;\n        }\n\n        \/\/\/ <summary>Lookup for the value by hash, returns the default `V` if hash is not found.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static V GetValueOrDefault<V>(this ImHashMap<int, V> map, int hash, V defaultValue)\n        {\n            var e = (VEntry<V>)map.GetEntryOrNull(hash);\n            return e != null ? e.Value : defaultValue;\n        }\n\n        \/\/\/ <summary>Lookup for the value by hash, returns the default `V` if hash is not found.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static V GetValueOrDefault<K, V>(this ImHashMap<K, V> map, int hash, K key) =>\n            map.GetEntryOrNull(hash)?.GetOrNullWithTheSameHash(key) is ImHashMapEntry<K, V> kv ? kv.Value : default;\n\n        \/\/\/ <summary>Lookup for the value by hash, returns the default `V` if hash is not found.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static V GetValueOrDefault<K, V>(this ImHashMap<K, V> map, int hash, K key, V defaultValue) =>\n            map.GetEntryOrNull(hash)?.GetOrNullWithTheSameHash(key) is ImHashMapEntry<K, V> kv ? kv.Value : defaultValue;\n\n        \/\/\/ <summary>Lookup for the value by key and its hash, returns the default `V` if hash is not found.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static V GetValueOrDefault<K, V>(this ImHashMap<K, V> map, K key) =>\n            map.GetEntryOrNull(key.GetHashCode())?.GetOrNullWithTheSameHash(key) is ImHashMapEntry<K, V> kv ? kv.Value : default;\n\n        \/\/\/ <summary>Lookup for the value by key and its hash, returns the default `V` if hash is not found.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static V GetValueOrDefault<K, V>(this ImHashMap<K, V> map, K key, V defaultValue) =>\n            map.GetEntryOrNull(key.GetHashCode())?.GetOrNullWithTheSameHash(key) is ImHashMapEntry<K, V> kv ? kv.Value : defaultValue;\n\n        \/\/\/ <summary>Lookup for the value by the key using the hash and checking the key with the `object.ReferenceEquals` for equality,\n        \/\/\/  returns found value or the default value if not found<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static V GetValueOrDefaultByReferenceEquals<K, V>(this ImHashMap<K, V> map, int hash, K key) where K : class\n        {\n            var e = map.GetEntryOrNull(hash);\n            return e != null ? e.GetValueOrDefaultByReferenceEqualsWithTheSameHash(key) : default;\n        }\n\n        \/\/\/ <summary>Lookup for the value by the key using the hash and checking the key with the `object.ReferenceEquals` for equality,\n        \/\/\/  returns found value or the default value if not found<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static V GetValueOrDefaultByReferenceEquals<K, V>(this ImHashMap<K, V> map, K key) where K : class\n        {\n            var e = map.GetEntryOrNull(key.GetHashCode());\n            return e != null ? e.GetValueOrDefaultByReferenceEqualsWithTheSameHash(key) : default;\n        }\n\n        \/\/\/ <summary>Lookup for the value by its hash, returns the `true` and the found value or the `false` otherwise<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static bool TryFind<V>(this ImHashMap<int, V> map, int hash, out V value)\n        {\n            var e = (VEntry<V>)map.GetEntryOrNull(hash);\n            if (e != null)\n            {\n                value = e.Value;\n                return true;\n            }\n            value = default;\n            return false;\n        }\n\n        \/\/\/ <summary>Lookup for the value by its key, returns the `true` and the found value or the `false` otherwise<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static bool TryFind<K, V>(this ImHashMap<K, V> map, int hash, K key, out V value)\n        {\n            var kv = map.GetEntryOrNull(hash)?.GetOrNullWithTheSameHash(key);\n            if (kv != null)\n            {\n                value = kv.Value;\n                return true;\n            }\n            value = default;\n            return false;\n        }\n\n        \/\/\/ <summary>Lookup for the value by the key using its hash and checking the key with the `object.Equals` for equality,\n        \/\/\/ returns the `true` and the found value or the `false` otherwise<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static bool TryFind<K, V>(this ImHashMap<K, V> map, K key, out V value) =>\n            map.TryFind(key.GetHashCode(), key, out value);\n\n        \/\/\/ <summary>Lookup for the value by its key, returns the `true` and the found value or the `false` otherwise<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static bool TryFindByReferenceEquals<K, V>(this ImHashMap<K, V> map, int hash, K key, out V value) where K : class\n        {\n            var kv = map.GetEntryOrNull(hash)?.GetOrNullByReferenceEqualsWithTheSameHash(key);\n            if (kv != null)\n            {\n                value = kv.Value;\n                return true;\n            }\n            value = default;\n            return false;\n        }\n\n        \/\/\/ <summary>Lookup for the value by its key, returns the `true` and the found value or the `false` otherwise<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static bool TryFindByReferenceEquals<K, V>(this ImHashMap<K, V> map, K key, out V value) where K : class =>\n            map.TryFindByReferenceEquals(key.GetHashCode(), key, out value);\n\n        \/\/\/ <summary>Creates the entry with the `int` key (which will be used as the key)<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMapEntry<int, V> Entry<V>(int key, V value) => new VEntry<V>(key, value);\n\n        \/\/\/ <summary>Creates the entry with the `int` key but without assigning its value yet<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMapEntry<int, V> DefaultEntry<V>(int key) => new VEntry<V>(key);\n\n        \/\/\/ <summary>Copies the entry but without its value<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMapEntry<int, V> WithDefaultValue<V>(this ImHashMapEntry<int, V> e) => new VEntry<V>(e.Hash);\n\n        \/\/\/ <summary>Creates the entry with the custom provided hash<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMapEntry<K, V> Entry<K, V>(int hash, K key, V value) => new KVEntry<K, V>(hash, key, value);\n\n        \/\/\/ <summary>Creates the entry but without assigning its value yet<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMapEntry<K, V> DefaultEntry<K, V>(int hash, K key) => new KVEntry<K, V>(hash, key);\n\n        \/\/\/ <summary>Copies the entry but without its value<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMapEntry<K, V> WithDefaultValue<K, V>(this ImHashMapEntry<K, V> e) => new KVEntry<K, V>(e.Hash, e.Key);\n\n        \/\/\/ <summary>Sugar to set the value and return the entry<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMapEntry<K, V> SetValue<K, V>(this ImHashMapEntry<K, V> e, V value)\n        {\n            e.Value = value;\n            return e;\n        }\n\n        \/\/\/ <summary>Adds the entry and returns the new map or if the hash is present then return the found entry or the newEntry if the map is empty, \n        \/\/\/ so you may check the result like this `if (res is ImMapEntry&lt;V&gt; entry &amp;&amp; entry != newEntry)`<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<int, V> AddOrGetEntry<V>(this ImHashMap<int, V> map, ImHashMapEntry<int, V> newEntry) =>\n            map.AddOrGetEntry(newEntry.Hash, newEntry);\n\n        \/\/\/ <summary>Adds the entry and returns the new map or if the hash is present then return the found entry or the newEntry if the map is empty, \n        \/\/\/ so you may check the result like this `if (res is ImMapEntry&lt;V&gt; entry &amp;&amp; entry != newEntry)`<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<K, V> AddOrGetEntry<K, V>(this ImHashMap<K, V> map, ImHashMapEntry<K, V> newEntry)\n        {\n            var mapOrOldEntry = map.AddOrGetEntry(newEntry.Hash, newEntry);\n            if (mapOrOldEntry is ImHashMap<K, V>.Entry oldEntry && oldEntry != newEntry)\n                return oldEntry.GetOrNullWithTheSameHash(newEntry.Key) ?? map.ReplaceEntry(oldEntry, oldEntry.AddWithTheSameKey(newEntry));\n            return mapOrOldEntry;\n        }\n\n        \/\/\/ <summary>Adds or updates (no in-place mutation) the map with the new entry, always returning the NEW map!<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<int, V> AddOrUpdateEntry<V>(this ImHashMap<int, V> map, ImHashMapEntry<int, V> newEntry)\n        {\n            var mapOrOldEntry = map.AddOrGetEntry(newEntry.Hash, newEntry);\n            if (mapOrOldEntry is ImHashMap<int, V>.Entry oldEntry && oldEntry != newEntry)\n                return map.ReplaceEntry(oldEntry, newEntry);\n            return mapOrOldEntry;\n        }\n\n        \/\/ todo: @perf add ...ByReferenceEquals\n        \/\/\/ <summary>Adds or updates (no in-place mutation) the map with the new entry, always returning the NEW map!<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<K, V> AddOrUpdateEntry<K, V>(this ImHashMap<K, V> map, ImHashMapEntry<K, V> newEntry)\n        {\n            var mapOrOldEntry = map.AddOrGetEntry(newEntry.Hash, newEntry);\n            if (mapOrOldEntry is ImHashMap<K, V>.Entry oldEntry && oldEntry != newEntry)\n                return map.ReplaceEntry(oldEntry, oldEntry.AddOrUpdateWithTheSameHash(newEntry));\n            return mapOrOldEntry;\n        }\n\n        \/\/\/ <summary>Adds or updates (no in-place mutation) the map with value by the passed hash and key, always returning the NEW map!<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<int, V> AddOrUpdate<V>(this ImHashMap<int, V> map, int hash, V value) =>\n            map.AddOrUpdateEntry(Entry(hash, value));\n\n        \/\/\/ <summary>Adds or updates (no in-place mutation) the map with value by the passed hash and key, always returning the NEW map!<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<K, V> AddOrUpdate<K, V>(this ImHashMap<K, V> map, int hash, K key, V value) =>\n            map.AddOrUpdateEntry(Entry(hash, key, value));\n\n        \/\/\/ <summary>Adds or updates (no in-place mutation) the map with value by the passed key, always returning the NEW map!<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<K, V> AddOrUpdate<K, V>(this ImHashMap<K, V> map, K key, V value) =>\n            map.AddOrUpdateEntry(Entry(key.GetHashCode(), key, value));\n\n        \/\/\/ <summary>Adds or updates (no in-place mutation) the map with value by the passed hash and key, always returning the NEW map!<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<int, V> AddOrUpdate<V>(this ImHashMap<int, V> map, int hash, V value, Update<int, V> update)\n        {\n            var newEntry = Entry(hash, value);\n            var mapOrOldEntry = map.AddOrGetEntry(hash, newEntry);\n            if (mapOrOldEntry is ImHashMapEntry<int, V> oldEntry && oldEntry != newEntry)\n                return map.ReplaceEntry(oldEntry, Entry(hash, update(hash, oldEntry.Value, value)));\n            return mapOrOldEntry;\n        }\n\n        \/\/\/ <summary>Adds or updates (no in-place mutation) the map with value by the passed key, always returning the NEW map!<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<K, V> AddOrUpdate<K, V>(this ImHashMap<K, V> map, int hash, K key, V value, Update<K, V> update)\n        {\n            var newEntry = Entry(hash, key, value);\n            var mapOrOldEntry = map.AddOrGetEntry(hash, newEntry);\n            if (mapOrOldEntry is ImHashMap<K, V>.Entry oldEntry && oldEntry != newEntry)\n                return map.ReplaceEntry(oldEntry, oldEntry.AddOrUpdateWithTheSameHash(newEntry, update));\n            return mapOrOldEntry;\n        }\n\n        \/\/\/ <summary>Adds or updates (no in-place mutation) the map with value by the passed key, always returning the NEW map!<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<K, V> AddOrUpdate<K, V>(this ImHashMap<K, V> map, K key, V value, Update<K, V> update) =>\n            map.AddOrUpdate(key.GetHashCode(), key, value, update);\n\n        \/\/\/ <summary>Produces the new map with the new entry or keeps the existing map if the entry with the key is already present<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<int, V> AddOrKeepEntry<V>(this ImHashMap<int, V> map, ImHashMapEntry<int, V> newEntry)\n        {\n            var mapOrOldEntry = map.AddOrGetEntry(newEntry.Hash, newEntry);\n            return mapOrOldEntry is ImHashMapEntry<int, V> oldEntry && oldEntry != newEntry ? map : mapOrOldEntry;\n        }\n\n        \/\/\/ <summary>Produces the new map with the new entry or keeps the existing map if the entry with the hash is already present<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<int, V> AddOrKeep<V>(this ImHashMap<int, V> map, int hash, V value) =>\n            map.AddOrKeepEntry(Entry(hash, value));\n\n        \/\/\/ <summary>Produces the new map with the new entry or keeps the existing map if the entry with the key is already present<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<K, V> AddOrKeepEntry<K, V>(this ImHashMap<K, V> map, ImHashMapEntry<K, V> newEntry)\n        {\n            var hash = newEntry.Hash;\n            var mapOrOldEntry = map.AddOrGetEntry(hash, newEntry);\n            if (mapOrOldEntry is ImHashMap<K, V>.Entry oldEntry && oldEntry != newEntry)\n            {\n                var added = oldEntry.AddedOrNullWithTheSameHash(newEntry);\n                return added == null ? map : map.ReplaceEntry(oldEntry, added);\n            }\n            return mapOrOldEntry;\n        }\n\n        \/\/\/ <summary>Produces the new map with the new entry or keeps the existing map if the entry with the key is already present<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<K, V> AddOrKeep<K, V>(this ImHashMap<K, V> map, int hash, K key, V value) =>\n            map.AddOrKeepEntry(Entry(hash, key, value));\n\n        \/\/\/ <summary>Produces the new map with the new entry or keeps the existing map if the entry with the key is already present<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<K, V> AddOrKeep<K, V>(this ImHashMap<K, V> map, K key, V value) =>\n            map.AddOrKeepEntry(Entry(key.GetHashCode(), key, value));\n\n        \/\/\/ <summary>Updates the map with the new value if the hash is found otherwise returns the same unchanged map.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<int, V> Update<V>(this ImHashMap<int, V> map, int hash, V value)\n        {\n            var entry = map.GetEntryOrNull(hash);\n            return entry == null ? map : map.ReplaceEntry(entry, Entry(hash, value));\n        }\n\n        \/\/\/ <summary>Updates the map with the default value if the hash is found otherwise returns the same unchanged map.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<int, V> UpdateToDefault<V>(this ImHashMap<int, V> map, int hash)\n        {\n            var entry = map.GetEntryOrNull(hash);\n            return entry == null ? map : map.ReplaceEntry(entry, DefaultEntry<V>(hash));\n        }\n\n        \/\/\/ <summary>Updates the map with the new value if the key is found otherwise returns the same unchanged map.<\/summary>\n        public static ImHashMap<K, V> Update<K, V>(this ImHashMap<K, V> map, int hash, K key, V value)\n        {\n            var entry = map.GetEntryOrNull(hash);\n            if (entry == null)\n                return map;\n            var updated = entry.UpdatedOrNullWithTheSameHash(Entry(hash, key, value));\n            return updated == null ? map : map.ReplaceEntry(entry, updated);\n        }\n\n        \/\/\/ <summary>Updates the map with the new value if the key is found otherwise returns the same unchanged map.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<K, V> Update<K, V>(this ImHashMap<K, V> map, K key, V value) =>\n            map.Update(key.GetHashCode(), key, value);\n\n        \/\/\/ <summary>Updates the map with the new value if the key is found otherwise returns the same unchanged map.<\/summary>\n        public static ImHashMap<K, V> UpdateToDefault<K, V>(this ImHashMap<K, V> map, int hash, K key)\n        {\n            var entry = map.GetEntryOrNull(hash);\n            if (entry == null)\n                return map;\n            var updated = entry.UpdatedOrNullWithTheSameHash(DefaultEntry<K, V>(hash, key));\n            return updated == null ? map : map.ReplaceEntry(entry, updated);\n        }\n\n        \/\/\/ <summary>Updates the map with the new value if the key is found otherwise returns the same unchanged map.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<K, V> UpdateToDefault<K, V>(this ImHashMap<K, V> map, K key) =>\n            map.UpdateToDefault(key.GetHashCode(), key);\n\n        \/\/\/ <summary>Updates the map with the new value and the `update` function if the key is found otherwise returns the same unchanged map.\n        \/\/\/ If `update` returns the same map if the updated result is the same<\/summary>\n        public static ImHashMap<K, V> Update<K, V>(this ImHashMap<K, V> map, int hash, K key, V value, Update<K, V> update)\n        {\n            var entry = map.GetEntryOrNull(hash);\n            if (entry == null)\n                return map;\n            var updated = entry.UpdatedOrNullWithTheSameHash(key, value, update);\n            return updated == null ? map : map.ReplaceEntry(entry, updated);\n        }\n\n        \/\/\/ <summary>Updates the map with the new value and the `update` function if the key is found otherwise returns the same unchanged map.\n        \/\/\/ If `update` returns the same map if the updated result is the same<\/summary>\n        public static ImHashMap<K, V> Update<K, V>(this ImHashMap<K, V> map, K key, V value, Update<K, V> update) =>\n            map.Update(key.GetHashCode(), key, value, update);\n\n        \/\/\/ <summary>Returns the new map without the specified hash (if found) or returns the same map otherwise<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<int, V> Remove<V>(this ImHashMap<int, V> map, int hash)\n        {\n            var entryToRemove = map.GetEntryOrNull(hash);\n            return entryToRemove == null ? map : map.RemoveEntry(entryToRemove);\n        }\n\n        \/\/ todo: @perf minimize virtual calls\n        \/\/ todo: @perf or rather what if I move a static method inside the map and override it in VEntry or KVEntry to speedup it for 1 item map, at least\n        \/\/\/ <summary>Returns the new map without the specified hash and key (if found) or returns the same map otherwise<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<K, V> Remove<K, V>(this ImHashMap<K, V> map, int hash, K key)\n        {\n            var entryToRemove = map.GetEntryOrNull(hash);\n            if (entryToRemove != null)\n            {\n                var removed = entryToRemove.RemovedOrNullWithTheSameHash(key);\n                if (removed == entryToRemove)\n                    return map.RemoveEntry(entryToRemove);\n                if (removed != null)\n                    return map.ReplaceEntry(entryToRemove, removed);\n            }\n            return map;\n        }\n\n        \/\/\/ <summary>Returns the new map without the specified hash and key (if found) or returns the same map otherwise<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<K, V> Remove<K, V>(this ImHashMap<K, V> map, K key) =>\n            map == ImHashMap<K, V>.Empty ? map : map.Remove(key.GetHashCode(), key); \/\/ it make sense to have the empty map condition here to prevent the probably costly `GetHashCode()` for the empty map.\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ The fixed array of maps (partitions) where the key first (lower) bits are used to locate the partion to lookup into.\n    \/\/\/ Note: The partition array is NOT immutable and operates by swapping the updated partition with the new one.\n    \/\/\/ The number of partitions may be specified by user or you can use the default number 16.\n    \/\/\/ The default number 16 was selected to be not so big to pay for the few items and not so small to diminish the use of partitions.\n    \/\/\/ <\/summary>\n    public static class PartitionedHashMap\n    {\n        \/\/\/ <summary>The default number of partions<\/summary>\n        public const int PARTITION_COUNT_POWER_OF_TWO = 16;\n\n        \/\/\/ <summary>The default mask to partition the key<\/summary>\n        public const int PARTITION_HASH_MASK = PARTITION_COUNT_POWER_OF_TWO - 1;\n\n        \/\/\/ <summary>Creates the new collection with the empty partions<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<K, V>[] CreateEmpty<K, V>(int partitionCountOfPowerOfTwo = PARTITION_COUNT_POWER_OF_TWO)\n        {\n            var parts = new ImHashMap<K, V>[partitionCountOfPowerOfTwo];\n            for (var i = 0; i < parts.Length; ++i)\n                parts[i] = ImHashMap<K, V>.Empty;\n            return parts;\n        }\n\n        \/\/\/ <summary>Creates the new collection with the empty partions<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<int, V>[] CreateEmpty<V>(int partitionCountOfPowerOfTwo = PARTITION_COUNT_POWER_OF_TWO)\n        {\n            var parts = new ImHashMap<int, V>[partitionCountOfPowerOfTwo];\n            for (var i = 0; i < parts.Length; ++i)\n                parts[i] = ImHashMap<int, V>.Empty;\n            return parts;\n        }\n\n        \/\/\/ <summary>Lookup for the value by the key using its hash, returns the default `V` if not found.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static V GetValueOrDefault<V>(this ImHashMap<int, V>[] parts, int hash, int partHashMask = PARTITION_HASH_MASK)\n        {\n            var p = parts[hash & partHashMask];\n            return p != null && p.GetEntryOrNull(hash) is ImHashMapEntry<int, V> kv ? kv.Value : default;\n        }\n\n        \/\/\/ <summary>Lookup for the value by the key and its hash, returns the default `V` if not found.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static V GetValueOrDefault<K, V>(this ImHashMap<K, V>[] parts, int hash, K key, int partHashMask = PARTITION_HASH_MASK)\n        {\n            var p = parts[hash & partHashMask];\n            return p != null ? p.GetValueOrDefault(hash, key) : default;\n        }\n\n        \/\/\/ <summary>Lookup for the value by the key and its hash, returns the default `V` if not found.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static V GetValueOrDefault<K, V>(this ImHashMap<K, V>[] parts, K key, int partHashMask = PARTITION_HASH_MASK) =>\n            parts.GetValueOrDefault(key.GetHashCode(), key, partHashMask);\n\n\n        \/\/\/ <summary>Lookup for the value by the key using the hash and checking the key with the `object.ReferenceEquals` for equality,\n        \/\/\/  returns found value or the default value if not found<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static V GetValueOrDefaultByReferenceEquals<K, V>(this ImHashMap<K, V>[] parts, int hash, K key, int partHashMask = PARTITION_HASH_MASK) where K : class\n        {\n            var p = parts[hash & partHashMask];\n            return p != null ? p.GetValueOrDefaultByReferenceEquals(hash, key) : default;\n        }\n\n        \/\/\/ <summary>Lookup for the value by the key using its hash and checking the key with the `object.ReferenceEquals` for equality, \n        \/\/\/ returns the default `V` if hash, key are not found.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static V GetValueOrDefaultByReferenceEquals<K, V>(this ImHashMap<K, V>[] parts, K key, int partHashMask = PARTITION_HASH_MASK) where K : class =>\n            parts.GetValueOrDefaultByReferenceEquals(key.GetHashCode(), key, partHashMask);\n\n        \/\/\/ <summary>Lookup for the value by the key using the hash, returns the `true` and the found value or the `false`<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static bool TryFind<V>(this ImHashMap<int, V>[] parts, int hash, out V value, int partHashMask = PARTITION_HASH_MASK)\n        {\n            var p = parts[hash & partHashMask];\n            if (p != null)\n                return p.TryFind(hash, out value);\n            value = default;\n            return false;\n        }\n\n        \/\/\/ <summary>Lookup for the value by the key and the hash, returns the `true` and the found value or the `false`<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static bool TryFind<K, V>(this ImHashMap<K, V>[] parts, int hash, K key, out V value, int partHashMask = PARTITION_HASH_MASK)\n        {\n            var p = parts[hash & partHashMask];\n            if (p != null)\n                return p.TryFind(hash, key, out value);\n            value = default;\n            return false;\n        }\n\n        \/\/\/ <summary>Lookup for the value by the key and the hash, returns the `true` and the found value or the `false`<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static bool TryFind<K, V>(this ImHashMap<K, V>[] parts, K key, out V value, int partHashMask = PARTITION_HASH_MASK) =>\n            parts.TryFind(key.GetHashCode(), key, out value, partHashMask);\n\n        \/\/\/ <summary>Lookup for the value by the key using the hash code and checking the key with the `object.ReferenceEquals` for equality,\n        \/\/\/ returns the `true` and the found value or the `false`<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static bool TryFindByReferenceEquals<K, V>(this ImHashMap<K, V>[] parts, int hash, K key, out V value,\n            int partHashMask = PARTITION_HASH_MASK) where K : class\n        {\n            var p = parts[hash & partHashMask];\n            if (p != null)\n                return p.TryFindByReferenceEquals(hash, key, out value);\n            value = default;\n            return false;\n        }\n\n        \/\/\/ <summary>Lookup for the value by the key using the hash code and checking the key with the `object.ReferenceEquals` for equality,\n        \/\/\/ returns the `true` and the found value or the `false`<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static bool TryFindByReferenceEquals<K, V>(this ImHashMap<K, V>[] parts, K key, out V value,\n            int partHashMask = PARTITION_HASH_MASK) where K : class =>\n            parts.TryFindByReferenceEquals(key.GetHashCode(), key, out value, partHashMask);\n\n        \/\/\/ <summary>Returns the SAME partitioned maps array instance but with the NEW added or updated partion<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static void AddOrUpdate<V>(this ImHashMap<int, V>[] parts, int hash, V value, int partHashMask = PARTITION_HASH_MASK)\n        {\n            ref var part = ref parts[hash & partHashMask];\n            var p = part;\n            if (Interlocked.CompareExchange(ref part, p.AddOrUpdate(hash, value), p) != p)\n                RefAddOrUpdatePart(ref part, hash, value);\n        }\n\n        private static void RefAddOrUpdatePart<V>(ref ImHashMap<int, V> part, int hash, V value) =>\n            Ref.Swap(ref part, hash, value, (x, h, v) => x.AddOrUpdate(h, v));\n\n        \/\/\/ <summary>Returns the SAME partitioned maps array instance but with the NEW added or updated partion<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static void AddOrUpdate<K, V>(this ImHashMap<K, V>[] parts, int hash, K key, V value, int partHashMask = PARTITION_HASH_MASK)\n        {\n            ref var part = ref parts[hash & partHashMask];\n            var p = part;\n            if (Interlocked.CompareExchange(ref part, p.AddOrUpdate(hash, key, value), p) != p)\n                RefAddOrUpdatePart(ref part, hash, key, value);\n        }\n\n        \/\/\/ <summary>Returns the SAME partitioned maps array instance but with the NEW added or updated partion<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static void AddOrUpdate<K, V>(this ImHashMap<K, V>[] parts, K key, V value, int partHashMask = PARTITION_HASH_MASK) =>\n            parts.AddOrUpdate(key.GetHashCode(), key, value, partHashMask);\n\n        private static void RefAddOrUpdatePart<K, V>(ref ImHashMap<K, V> part, int hash, K key, V value) =>\n            Ref.Swap(ref part, hash, key, value, (x, h, k, v) => x.AddOrUpdate(h, k, v));\n\n        \/\/\/ <summary>Returns the SAME partitioned maps array instance but with the NEW added or updated partion<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static void AddOrUpdate<V>(this ImHashMap<int, V>[] parts, int hash, V value, Update<int, V> update, int partHashMask = PARTITION_HASH_MASK)\n        {\n            ref var part = ref parts[hash & partHashMask];\n            var p = part;\n            if (Interlocked.CompareExchange(ref part, p.AddOrUpdate(hash, value, update), p) != p)\n                Ref.Swap(ref part, hash, value, update, (x, h, k, u) => x.AddOrUpdate(h, k, u));\n        }\n\n        \/\/\/ <summary>Returns the SAME partitioned maps array instance but with the NEW added or updated partion<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static void AddOrUpdate<K, V>(this ImHashMap<K, V>[] parts, int hash, K key, V value, Update<K, V> update, int partHashMask = PARTITION_HASH_MASK)\n        {\n            ref var part = ref parts[hash & partHashMask];\n            var p = part;\n            if (Interlocked.CompareExchange(ref part, p.AddOrUpdate(hash, key, value, update), p) != p)\n                Ref.Swap(ref part, hash, key, value, update, (x, h, k, v, u) => x.AddOrUpdate(h, k, v, u));\n        }\n\n        \/\/\/ <summary>Returns the SAME partitioned maps array instance but with the NEW added or updated partion<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static void AddOrUpdate<K, V>(this ImHashMap<K, V>[] parts, K key, V value, Update<K, V> update, int partHashMask = PARTITION_HASH_MASK) =>\n            parts.AddOrUpdate(key.GetHashCode(), key, value, update);\n\n        \/\/\/ <summary>Returns the SAME partitioned maps array instance but with the NEW added or the same kept partion<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static void AddOrKeep<V>(this ImHashMap<int, V>[] parts, int hash, V value, int partHashMask = PARTITION_HASH_MASK)\n        {\n            ref var part = ref parts[hash & partHashMask];\n            var p = part;\n            if (Interlocked.CompareExchange(ref part, p.AddOrKeep(hash, value), p) != p)\n                RefAddOrKeepPart(ref part, hash, value);\n        }\n\n        private static void RefAddOrKeepPart<V>(ref ImHashMap<int, V> part, int hash, V value) =>\n            Ref.Swap(ref part, hash, value, (x, h, v) => x.AddOrUpdate(h, v));\n\n        \/\/\/ <summary>Returns the SAME partitioned maps array instance but with the NEW added or the same kept partion<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static void AddOrKeep<K, V>(this ImHashMap<K, V>[] parts, int hash, K key, V value, int partHashMask = PARTITION_HASH_MASK)\n        {\n            ref var part = ref parts[hash & partHashMask];\n            var p = part;\n            if (Interlocked.CompareExchange(ref part, p.AddOrKeep(hash, key, value), p) != p)\n                RefAddOrKeepPart(ref part, hash, key, value);\n        }\n\n        private static void RefAddOrKeepPart<K, V>(ref ImHashMap<K, V> part, int hash, K key, V value) =>\n            Ref.Swap(ref part, hash, key, value, (x, h, k, v) => x.AddOrUpdate(h, k, v));\n\n        \/\/\/ <summary>Updates the map with the new value if the hash is found otherwise returns the same unchanged map.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static void Update<V>(this ImHashMap<int, V>[] parts, int hash, V value, int partHashMask = PARTITION_HASH_MASK)\n        {\n            ref var part = ref parts[hash & partHashMask];\n            var p = part;\n            if (Interlocked.CompareExchange(ref part, p.Update(hash, value), p) != p)\n                RefUpdatePart(ref part, hash, value);\n        }\n\n        private static void RefUpdatePart<V>(ref ImHashMap<int, V> part, int hash, V value) =>\n            Ref.Swap(ref part, hash, value, (x, h, v) => x.Update(h, v));\n\n        \/\/\/ <summary>Do something for each entry.\n        \/\/\/ The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.\n        \/\/\/ So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static IEnumerable<ImHashMapEntry<K, V>> Enumerate<K, V>(this ImHashMap<K, V>[] parts)\n        {\n            foreach (var map in parts)\n            {\n                if (map == ImHashMap<K, V>.Empty)\n                    continue;\n                foreach (var entry in map.Enumerate())\n                    yield return entry;\n            }\n        }\n\n        \/\/\/ <summary>Do something for each entry.\n        \/\/\/ The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.\n        \/\/\/ So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls<\/summary>\n        public static S ForEach<K, V, S>(this ImHashMap<K, V>[] parts, S state, Action<ImHashMapEntry<K, V>, int, S> handler, MapParentStack parents = null)\n        {\n            if (parents == null)\n                parents = new MapParentStack();\n            foreach (var map in parts)\n            {\n                if (map == ImHashMap<K, V>.Empty)\n                    continue;\n                state = map.ForEach(state, handler, parents);\n            }\n            return state;\n        }\n    }\n}\n","old_contents":"\/\/ <auto-generated\/>\n\/*\nThe MIT License (MIT)\n\nCopyright (c) 2016-2022 Maksim Volkau\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included \nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*\/\n\n\/\/ ReSharper disable once InconsistentNaming\n\nnamespace ImTools\n{\n    using System;\n    using System.Collections;\n    using System.Collections.Generic;\n    using System.Linq;\n    using System.Text;\n    using System.Threading;\n    using System.Diagnostics;\n    using System.Runtime.CompilerServices; \/\/ For [MethodImpl(AggressiveInlining)]\n\n    \/\/\/ <summary>Helpers for functional composition<\/summary>\n    public static class Fun\n    {\n        \/\/\/ <summary>\n        \/\/\/ Always a true condition.\n        \/\/\/ <\/summary> \n        public static bool Always<T>(T _) => true;\n\n        \/\/\/ <summary>\n        \/\/\/ Identity function returning passed argument as result.\n        \/\/\/ <\/summary> \n        public static T Id<T>(T x) => x;\n\n        \/\/\/ <summary>\n        \/\/\/ Forward pipe operator (`|>` in F#)\n        \/\/\/ <\/summary> \n        public static R To<T, R>(this T x, Func<T, R> map) => map(x);\n\n        \/\/\/ <summary>\n        \/\/\/ Forward pipe operator (`|>` in F#) with the additional state A for two arguments function\n        \/\/\/ <\/summary> \n        public static R To<T, S, R>(this T x, S state, Func<T, S, R> map) => map(x, state);\n\n        \/\/\/ <summary>\n        \/\/\/ Cast to the R type with the forward pipe operator (`|>` in F#)\n        \/\/\/ <\/summary> \n        public static R To<R>(this object x) => (R)x;\n\n        \/\/\/ <summary>\n        \/\/\/ Forward pipe operator (`|>` in F#) but with side effect propagating the original `x` value\n        \/\/\/ <\/summary> \n        public static T Do<T>(this T x, Action<T> effect)\n        {\n            effect(x);\n            return x;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Forward pipe operator (`|>` in F#) but with side effect propagating the original `x` value and the state object\n        \/\/\/ <\/summary> \n        public static T Do<T, S>(this T x, S state, Action<T, S> effect)\n        {\n            effect(x, state);\n            return x;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Lifts argument to Func without allocations ignoring the first argument.\n        \/\/\/ For example if you have `Func{T, R} = _ => instance`,\n        \/\/\/ you may rewrite it without allocations as `instance.ToFunc{A, R}`\n        \/\/\/ <\/summary> \n        public static R ToFunc<T, R>(this R result, T ignoredArg) => result;\n\n        \/\/\/ <summary>Performant swapper<\/summary>\n        [MethodImpl(256)]\n        public static void Swap<T>(ref T a, ref T b)\n        {\n            var t = a;\n            a = b;\n            b = t;\n        }\n    }\n\n    \/\/\/ <summary>Helpers for lazy instantiations<\/summary>\n    public static class Lazy\n    {\n        \/\/\/ <summary>Provides result type inference for creation of lazy.<\/summary>\n        public static Lazy<T> Of<T>(Func<T> valueFactory) => new Lazy<T>(valueFactory);\n    }\n\n    \/\/\/ <summary>Just a helper state with the number of mutable fields with the nice names ;) Maybe used together with Fold or other methods required state<\/summary>\n    public sealed class St<A>\n    {\n        \/\/\/ <summary>A<\/summary>\n        public A a;\n\n        \/\/\/ <summary>Puts the pooled instance back replacing the old one<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public void Pool() => Pooled = this;\n\n        \/\/\/ <summary>Puts the pooled instance back replacing the old one<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public void Reset()\n        {\n            a = default;\n            Pooled = this; \/\/ we don't need to do the atomic update here because we don't care what instance is ended up to be pooled\n        }\n\n        \/\/\/ <summary>Puts the pooled instance back replacing the old one<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public A ResetButGetA()\n        {\n            var a1 = a;\n            a = default;\n            Pooled = this; \/\/ we don't need to do the atomic update here because we don't care what instance is ended up to be pooled\n            return a1;\n        }\n\n        internal static St<A> Pooled;\n    }\n\n    \/\/\/ <summary>Just a helper state with the number of mutable fields with the nice names ;) Maybe used together with Fold or other methods required state<\/summary>\n    public sealed class St<A, B>\n    {\n        \/\/\/ <summary>A<\/summary>\n        public A a;\n        \/\/\/ <summary>B<\/summary>\n        public B b;\n\n        \/\/\/ <summary>Puts the pooled instance back replacing the old one<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public St<A, B> Pool() => Pooled = this;\n\n        \/\/\/ <summary>Puts the pooled instance back replacing the old one<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public void Reset()\n        {\n            a = default;\n            b = default;\n            Pooled = this; \/\/ we don't need to do the atomic update here because we don't care what instance is ended up to be pooled\n        }\n\n        \/\/\/ <summary>Puts the pooled instance back replacing the old one<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public A ResetButGetA()\n        {\n            var a1 = a;\n            a = default;\n            b = default;\n            Pooled = this; \/\/ we don't need to do the atomic update here because we don't care what instance is ended up to be pooled\n            return a1;\n        }\n\n        \/\/\/ <summary>Puts the pooled instance back replacing the old one<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public B ResetButGetB()\n        {\n            var b1 = b;\n            a = default;\n            b = default;\n            Pooled = this; \/\/ we don't need to do the atomic update here because we don't care what instance is ended up to be pooled\n            return b1;\n        }\n\n        internal static St<A, B> Pooled;\n    }\n\n    \/\/\/ <summary>State factory and helper methods<\/summary>\n    public static class St\n    {\n        \/\/\/ <summary>Creates the state out of the passed arguments<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static St<A> Of<A>(A a) => new St<A> { a = a };\n\n        \/\/\/ <summary>Atomically pops the pooled instance (if exist) or creates the new one and sets the fields to the passed arguments<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static St<A> Rent<A>(A a)\n        {\n            var st = Interlocked.Exchange(ref St<A>.Pooled, null) ?? new St<A>();\n            st.a = a;\n            return st;\n        }\n\n        \/\/\/ <summary>Creates the state out of the passed arguments<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static St<A, B> Of<A, B>(A a, B b) => new St<A, B> { a = a, b = b };\n\n        \/\/\/ <summary>Atomically pops the pooled instance (if exist) or creates the new one and sets the fields to the passed arguments<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static St<A, B> Rent<A, B>(A a, B b)\n        {\n            var st = Interlocked.Exchange(ref St<A, B>.Pooled, null) ?? new St<A, B>();\n            st.a = a; st.b = b;\n            return st;\n        }\n    }\n\n    \/\/\/ <summary>Methods to work with immutable arrays and some sugar.<\/summary>\n    public static class ArrayTools\n    {\n        private static class EmptyArray<T>\n        {\n            public static readonly T[] Value = new T[0];\n        }\n\n        \/\/\/ <summary>Returns singleton empty array of provided type.<\/summary> \n        \/\/\/ <typeparam name=\"T\">Array item type.<\/typeparam> <returns>Empty array.<\/returns>\n        public static T[] Empty<T>() => EmptyArray<T>.Value;\n\n        \/\/\/ <summary>Wraps item in array.<\/summary>\n        public static T[] One<T>(this T one) => new[] { one };\n\n        \/\/\/ <summary>Returns true if array is null or have no items.<\/summary> <typeparam name=\"T\">Type of array item.<\/typeparam>\n        \/\/\/ <param name=\"source\">Source array to check.<\/param> <returns>True if null or has no items, false otherwise.<\/returns>\n        public static bool IsNullOrEmpty<T>(this T[] source) => source == null || source.Length == 0;\n\n        \/\/\/ <summary>Returns empty array instead of null, or source array otherwise.<\/summary> <typeparam name=\"T\">Type of array item.<\/typeparam>\n        public static T[] EmptyIfNull<T>(this T[] source) => source ?? Empty<T>();\n\n        \/\/\/ Returns source enumerable if it is array, otherwise converts source to array or an empty array if null.\n        public static T[] ToArrayOrSelf<T>(this IEnumerable<T> source) =>\n            source == null ? Empty<T>() : (source as T[] ?? source.ToArray());\n\n        \/\/\/ Returns source enumerable if it is list, otherwise converts source to IList or an empty array if null.\n        public static IList<T> ToListOrSelf<T>(this IEnumerable<T> source) =>\n            source == null ? Empty<T>() : source as IList<T> ?? source.ToList();\n\n        \/\/\/ <summary>Array copy<\/summary>\n        public static T[] Copy<T>(this T[] source)\n        {\n            if (source == null || source.Length == 0)\n                return source;\n            var copy = new T[source.Length];\n            Array.Copy(source, 0, copy, 0, source.Length);\n            return copy;\n        }\n\n        \/\/\/ <summary>Array copy without checking the items for the null or the emptyness<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static T[] CopyNonEmpty<T>(this T[] source)\n        {\n            var copy = new T[source.Length];\n            Array.Copy(source, 0, copy, 0, source.Length);\n            return copy;\n        }\n\n        \/\/\/ <summary>Returns the new array consisting from all items from source array then the all items from added array.\n        \/\/\/ If source is null or empty then the added array will be returned. If added is null or empty then the source will be returned.<\/summary>\n        public static T[] Append<T>(this T[] source, params T[] added)\n        {\n            if (added == null || added.Length == 0)\n                return source;\n            if (source == null || source.Length == 0)\n                return added;\n            var sourceCount = source.Length;\n            var addedCount = added.Length;\n            var result = new T[sourceCount + addedCount];\n            if (sourceCount < 6)\n                for (var i = 0; i < sourceCount; ++i)\n                    result[i] = source[i];\n            else\n                Array.Copy(source, 0, result, 0, sourceCount);\n            if (addedCount < 6)\n                for (var i = 0; i < addedCount; ++i)\n                    result[sourceCount + i] = added[i];\n            else\n                Array.Copy(added, 0, result, sourceCount, addedCount);\n            return result;\n        }\n\n        \/\/\/ <summary>Performant concat of enumerables in case of arrays. But performance will degrade if you use Concat().Where().<\/summary>\n        public static T[] Append<T>(this IEnumerable<T> source, IEnumerable<T> other) =>\n            source.ToArrayOrSelf().Append(other.ToArrayOrSelf());\n\n        \/\/\/ <summary>Returns new array with <paramref name=\"value\"\/> appended, \n        \/\/\/ or <paramref name=\"value\"\/> at <paramref name=\"index\"\/>, if specified.\n        \/\/\/ If source array could be null or empty, then single value item array will be created despite any index.<\/summary>\n        public static T[] AppendOrUpdate<T>(this T[] source, T value, int index = -1)\n        {\n            if (source == null || source.Length == 0)\n                return new[] { value };\n            var sourceCount = source.Length;\n            index = index < 0 ? sourceCount : index;\n            var result = new T[index < sourceCount ? sourceCount : sourceCount + 1];\n            if (sourceCount < 6)\n                for (var i = 0; i < sourceCount; ++i)\n                    result[i] = source[i];\n            else\n                Array.Copy(source, 0, result, 0, sourceCount);\n            result[index] = value;\n            return result;\n        }\n\n        \/\/\/ <summary>Updates the item in the copy of the array. The array should be non-empty.<\/summary>\n        public static T[] UpdateNonEmpty<T>(this T[] source, T value, int index)\n        {\n            var sourceCount = source.Length;\n            var result = new T[sourceCount];\n            if (sourceCount < 6)\n                for (var i = 0; i < sourceCount; ++i)\n                    result[i] = source[i];\n            else\n                Array.Copy(source, 0, result, 0, sourceCount);\n            result[index] = value;\n            return result;\n        }\n\n        \/\/\/ <summary>Returns the new array consisting from all items from source array then the all items from added array.\n        \/\/\/ Assumes that both arrays are non-empty to avoid the checks.<\/summary>\n        public static T[] AppendNonEmpty<T>(this T[] source, params T[] added)\n        {\n            var sourceCount = source.Length;\n            var addedCount = added.Length;\n            var result = new T[sourceCount + addedCount];\n            if (sourceCount < 6)\n                for (var i = 0; i < sourceCount; ++i)\n                    result[i] = source[i];\n            else\n                Array.Copy(source, 0, result, 0, sourceCount);\n            if (addedCount < 6)\n                for (var i = 0; i < addedCount; ++i)\n                    result[sourceCount + i] = added[i];\n            else\n                Array.Copy(added, 0, result, sourceCount, addedCount);\n            return result;\n        }\n\n        \/\/\/ <summary>Returns the new array consisting from all items from source array plus the value.<\/summary>\n        public static T[] Append<T>(this T[] source, T value)\n        {\n            if (source == null || source.Length == 0)\n                return new T[] { value };\n            var sourceCount = source.Length;\n            var result = new T[sourceCount + 1];\n            if (sourceCount < 6)\n                for (var i = 0; i < sourceCount; ++i)\n                    result[i] = source[i];\n            else\n                Array.Copy(source, 0, result, 0, sourceCount);\n            result[sourceCount] = value;\n            return result;\n        }\n\n        \/\/\/ <summary>Returns new array with <paramref name=\"value\"\/> appended. Assumes that `source` is not empty to avoid the checks.<\/summary>\n        public static T[] AppendToNonEmpty<T>(this T[] source, T value)\n        {\n            var sourceCount = source.Length;\n            var result = new T[sourceCount + 1];\n            if (sourceCount < 6)\n                for (var i = 0; i < sourceCount; ++i)\n                    result[i] = source[i];\n            else\n                Array.Copy(source, 0, result, 0, sourceCount);\n            result[sourceCount] = value;\n            return result;\n        }\n\n        \/\/\/ <summary>Returns new array with <paramref name=\"value\"\/> prepended. Assumes that `source` is not empty to avoid the checks.<\/summary>\n        public static T[] PrependToNonEmpty<T>(this T[] source, T value)\n        {\n            var sourceCount = source.Length;\n            var result = new T[sourceCount + 1];\n            if (sourceCount < 6)\n                for (var i = 0; i < sourceCount; ++i)\n                    result[i + 1] = source[i];\n            else\n                Array.Copy(source, 0, result, 1, sourceCount);\n            result[0] = value;\n            return result;\n        }\n\n        \/\/\/ <summary>Calls predicate on each item in <paramref name=\"source\"\/> array until predicate returns true,\n        \/\/\/ then method will return this item index, or if predicate returns false for each item, method will return -1.<\/summary>\n        public static int IndexOf<T>(this T[] source, Func<T, bool> predicate)\n        {\n            if (source != null && source.Length != 0)\n                for (var i = 0; i < source.Length; ++i)\n                    if (predicate(source[i]))\n                        return i;\n            return -1;\n        }\n\n        \/\/\/ <summary>Minimizes the allocations for closure in predicate lambda with the provided <paramref name=\"state\"\/><\/summary>\n        public static int IndexOf<T, S>(this T[] source, S state, Func<S, T, bool> predicate)\n        {\n            if (source != null && source.Length != 0)\n                for (var i = 0; i < source.Length; ++i)\n                    if (predicate(state, source[i]))\n                        return i;\n            return -1;\n        }\n\n        \/\/\/ <summary>Looks up for item in source array equal to provided value, and returns its index, or -1 if not found.<\/summary>\n        public static int IndexOf<T>(this T[] source, T value)\n        {\n            if (source != null && source.Length != 0)\n                for (var i = 0; i < source.Length; ++i)\n                {\n                    var item = source[i];\n                    if (Equals(item, value))\n                        return i;\n                }\n\n            return -1;\n        }\n\n        \/\/\/ <summary>The same as `IndexOf` but searching for the item by reference<\/summary>\n        public static int IndexOfReference<T>(this T[] source, T reference) where T : class\n        {\n            if (source != null && source.Length != 0)\n                for (var i = 0; i < source.Length; ++i)\n                    if (ReferenceEquals(source[i], reference))\n                        return i;\n            return -1;\n        }\n\n        \/\/\/ <summary>Produces new array without item at specified <paramref name=\"index\"\/>. \n        \/\/\/ Will return <paramref name=\"source\"\/> array if index is out of bounds, or source is null\/empty.<\/summary>\n        public static T[] RemoveAt<T>(this T[] source, int index)\n        {\n            if (source == null || source.Length == 0 || index < 0 || index >= source.Length)\n                return source;\n            if (index == 0 && source.Length == 1)\n                return new T[0];\n            var result = new T[source.Length - 1];\n            if (index != 0)\n                Array.Copy(source, 0, result, 0, index);\n            if (index != result.Length)\n                Array.Copy(source, index + 1, result, index, result.Length - index);\n            return result;\n        }\n\n        \/\/\/ <summary>Looks for item in array using equality comparison, and returns new array with found item remove, or original array if not item found.<\/summary>\n        public static T[] Remove<T>(this T[] source, T value) =>\n            source.RemoveAt(source.IndexOf(value));\n\n        \/\/\/ <summary>Returns first item matching the <paramref name=\"predicate\"\/>, or default item value.<\/summary>\n        public static T FindFirst<T>(this T[] source, Func<T, bool> predicate)\n        {\n            if (source != null && source.Length != 0)\n                for (var i = 0; i < source.Length; ++i)\n                {\n                    var item = source[i];\n                    if (predicate(item))\n                        return item;\n                }\n\n            return default(T);\n        }\n\n        \/\/\/ <summary>Version of FindFirst with the fixed state used by predicate to prevent allocations by predicate lambda closure<\/summary>\n        public static T FindFirst<T, S>(this T[] source, S state, Func<S, T, bool> predicate)\n        {\n            if (source != null && source.Length != 0)\n                for (var i = 0; i < source.Length; ++i)\n                {\n                    var item = source[i];\n                    if (predicate(state, item))\n                        return item;\n                }\n\n            return default(T);\n        }\n\n        \/\/\/ <summary>Returns first item matching the <paramref name=\"predicate\"\/>, or default item value.<\/summary>\n        public static T FindFirst<T>(this IEnumerable<T> source, Func<T, bool> predicate) =>\n            source is T[] sourceArr ? sourceArr.FindFirst(predicate) : source.FirstOrDefault(predicate);\n\n        \/\/\/ <summary>Returns element if collection consist on single element, otherwise returns default value.\n        \/\/\/ It does not throw for collection with many elements<\/summary>\n        public static T SingleOrDefaultIfMany<T>(this IEnumerable<T> source)\n        {\n            if (source is IList<T> list)\n                return list.Count == 1 ? list[0] : default(T);\n\n            if (source == null)\n                return default(T);\n\n            using (var e = source.GetEnumerator())\n            {\n                if (!e.MoveNext())\n                    return default(T);\n                var it = e.Current;\n                return !e.MoveNext() ? it : default(T);\n            }\n        }\n\n        \/\/\/ <summary>Does <paramref name=\"action\"\/> for each item<\/summary>\n        public static void ForEach<T>(this T[] source, Action<T> action)\n        {\n            if (!source.IsNullOrEmpty())\n                for (var i = 0; i < source.Length; i++)\n                    action(source[i]);\n        }\n\n        \/\/\/ Appends source to results\n        public static T[] AppendTo<T>(T[] source, int sourcePos, int count, T[] results = null)\n        {\n            if (results == null)\n            {\n                var newResults = new T[count];\n                if (count == 1)\n                    newResults[0] = source[sourcePos];\n                else\n                    for (int i = 0, j = sourcePos; i < count; ++i, ++j)\n                        newResults[i] = source[j];\n                return newResults;\n            }\n\n            var matchCount = results.Length;\n            var appendedResults = new T[matchCount + count];\n            if (matchCount == 1)\n                appendedResults[0] = results[0];\n            else\n                Array.Copy(results, 0, appendedResults, 0, matchCount);\n\n            if (count == 1)\n                appendedResults[matchCount] = source[sourcePos];\n            else\n                Array.Copy(source, sourcePos, appendedResults, matchCount, count);\n\n            return appendedResults;\n        }\n\n        private static R[] AppendTo<T, R>(T[] source, int sourcePos, int count, Func<T, R> map, R[] results = null)\n        {\n            if (results == null || results.Length == 0)\n            {\n                var newResults = new R[count];\n                if (count == 1)\n                    newResults[0] = map(source[sourcePos]);\n                else\n                    for (int i = 0, j = sourcePos; i < count; ++i, ++j)\n                        newResults[i] = map(source[j]);\n                return newResults;\n            }\n\n            var oldResultsCount = results.Length;\n            var appendedResults = new R[oldResultsCount + count];\n            if (oldResultsCount == 1)\n                appendedResults[0] = results[0];\n            else\n                Array.Copy(results, 0, appendedResults, 0, oldResultsCount);\n\n            if (count == 1)\n                appendedResults[oldResultsCount] = map(source[sourcePos]);\n            else\n            {\n                for (int i = oldResultsCount, j = sourcePos; i < appendedResults.Length; ++i, ++j)\n                    appendedResults[i] = map(source[j]);\n            }\n\n            return appendedResults;\n        }\n\n        private static R[] AppendTo<S, T, R>(T[] source, S state, int sourcePos, int count, Func<S, T, R> map, R[] results = null)\n        {\n            if (results == null || results.Length == 0)\n            {\n                var newResults = new R[count];\n                if (count == 1)\n                    newResults[0] = map(state, source[sourcePos]);\n                else\n                    for (int i = 0, j = sourcePos; i < count; ++i, ++j)\n                        newResults[i] = map(state, source[j]);\n                return newResults;\n            }\n\n            var oldResultsCount = results.Length;\n            var appendedResults = new R[oldResultsCount + count];\n            if (oldResultsCount == 1)\n                appendedResults[0] = results[0];\n            else\n                Array.Copy(results, 0, appendedResults, 0, oldResultsCount);\n\n            if (count == 1)\n                appendedResults[oldResultsCount] = map(state, source[sourcePos]);\n            else\n            {\n                for (int i = oldResultsCount, j = sourcePos; i < appendedResults.Length; ++i, ++j)\n                    appendedResults[i] = map(state, source[j]);\n            }\n\n            return appendedResults;\n        }\n\n        private static R[] AppendTo<A, B, T, R>(T[] source, A a, B b, int sourcePos, int count, Func<A, B, T, R> map, R[] results = null)\n        {\n            if (results == null || results.Length == 0)\n            {\n                var newResults = new R[count];\n                if (count == 1)\n                    newResults[0] = map(a, b, source[sourcePos]);\n                else\n                    for (int i = 0, j = sourcePos; i < count; ++i, ++j)\n                        newResults[i] = map(a, b, source[j]);\n                return newResults;\n            }\n\n            var oldResultsCount = results.Length;\n            var appendedResults = new R[oldResultsCount + count];\n            if (oldResultsCount == 1)\n                appendedResults[0] = results[0];\n            else\n                Array.Copy(results, 0, appendedResults, 0, oldResultsCount);\n\n            if (count == 1)\n                appendedResults[oldResultsCount] = map(a, b, source[sourcePos]);\n            else\n            {\n                for (int i = oldResultsCount, j = sourcePos; i < appendedResults.Length; ++i, ++j)\n                    appendedResults[i] = map(a, b, source[j]);\n            }\n\n            return appendedResults;\n        }\n\n        \/\/\/ <summary>Where method similar to Enumerable.Where but more performant and non necessary allocating.\n        \/\/\/ It returns source array and does Not create new one if all items match the condition.<\/summary>\n        public static T[] Match<T>(this T[] source, Func<T, bool> condition)\n        {\n            if (source == null || source.Length == 0)\n                return source;\n\n            if (source.Length == 1)\n                return condition(source[0]) ? source : Empty<T>();\n\n            if (source.Length == 2)\n            {\n                var c0 = condition(source[0]);\n                var c1 = condition(source[1]);\n                return c0 && c1 ? source : c0 ? new[] { source[0] } : c1 ? new[] { source[1] } : Empty<T>();\n            }\n\n            if (source.Length == 3)\n            {\n                var condition0 = condition(source[0]);\n                var condition1 = condition(source[1]);\n                var condition2 = condition(source[2]);\n                return condition0 && condition1 && condition2 ? source\n                    : condition0 ? (condition1 ? new[] { source[0], source[1] } : condition2 ? new[] { source[0], source[2] } : new[] { source[0] })\n                    : condition1 ? (condition2 ? new[] { source[1], source[2] } : new[] { source[1] })\n                    : condition2 ? new[] { source[2] }\n                    : Empty<T>();\n            }\n\n            var matchStart = 0;\n            T[] matches = null;\n            var matchFound = false;\n            var i = 0;\n            for (; i < source.Length; ++i)\n                if (!(matchFound = condition(source[i]))) \/\/ todo: @unclear check what will happen if the `matchFound` is set back to false\n                {\n                    \/\/ for accumulated matched items\n                    if (i != 0 && i > matchStart)\n                        matches = AppendTo(source, matchStart, i - matchStart, matches);\n                    matchStart = i + 1; \/\/ guess the next match start will be after the non-matched item\n                }\n\n            \/\/ when last match was found but not all items are matched (hence matchStart != 0)\n            if (matchFound && matchStart != 0)\n                return AppendTo(source, matchStart, i - matchStart, matches);\n\n            return matches ?? (matchStart != 0 ? Empty<T>() : source);\n        }\n\n        \/\/\/ <summary>Match with the additional state to use in <paramref name=\"condition\"\/> to minimize the allocations \n        \/\/\/ in <paramref name=\"condition\"\/> lambda closure<\/summary> \n        public static T[] Match<S, T>(this T[] source, S state, Func<S, T, bool> condition)\n        {\n            if (source == null || source.Length == 0)\n                return source;\n\n            if (source.Length == 1)\n                return condition(state, source[0]) ? source : Empty<T>();\n\n            if (source.Length == 2)\n            {\n                var c0 = condition(state, source[0]);\n                var c1 = condition(state, source[1]);\n                return c0 && c1 ? source : c0 ? new[] { source[0] } : c1 ? new[] { source[1] } : Empty<T>();\n            }\n\n            if (source.Length == 3)\n            {\n                var condition0 = condition(state, source[0]);\n                var condition1 = condition(state, source[1]);\n                var condition2 = condition(state, source[2]);\n                return condition0 && condition1 && condition2 ? source\n                    : condition0 ? (condition1 ? new[] { source[0], source[1] } : condition2 ? new[] { source[0], source[2] } : new[] { source[0] })\n                    : condition1 ? (condition2 ? new[] { source[1], source[2] } : new[] { source[1] })\n                    : condition2 ? new[] { source[2] }\n                    : Empty<T>();\n            }\n\n            var matchStart = 0;\n            T[] matches = null;\n            var matchFound = false;\n            var i = 0;\n            for (; i < source.Length; ++i)\n                if (!(matchFound = condition(state, source[i])))\n                {\n                    \/\/ for accumulated matched items\n                    if (i != 0 && i > matchStart)\n                        matches = AppendTo(source, matchStart, i - matchStart, matches);\n                    matchStart = i + 1; \/\/ guess the next match start will be after the non-matched item\n                }\n\n            \/\/ when last match was found but not all items are matched (hence matchStart != 0)\n            if (matchFound && matchStart != 0)\n                return AppendTo(source, matchStart, i - matchStart, matches);\n\n            return matches ?? (matchStart != 0 ? Empty<T>() : source);\n        }\n\n        \/\/\/ <summary>Match with the additional state to use in <paramref name=\"condition\"\/> to minimize the allocations \n        \/\/\/ in <paramref name=\"condition\"\/> lambda closure<\/summary> \n        public static T[] Match<A, B, T>(this T[] source, A a, B b, Func<A, B, T, bool> condition)\n        {\n            if (source == null || source.Length == 0)\n                return source;\n\n            if (source.Length == 1)\n                return condition(a, b, source[0]) ? source : Empty<T>();\n\n            if (source.Length == 2)\n            {\n                var c0 = condition(a, b, source[0]);\n                var c1 = condition(a, b, source[1]);\n                return c0 && c1 ? source : c0 ? new[] { source[0] } : c1 ? new[] { source[1] } : Empty<T>();\n            }\n\n            var matchStart = 0;\n            T[] matches = null;\n            var matchFound = false;\n            var i = 0;\n            for (; i < source.Length; ++i)\n                if (!(matchFound = condition(a, b, source[i])))\n                {\n                    \/\/ for accumulated matched items\n                    if (i != 0 && i > matchStart)\n                        matches = AppendTo(source, matchStart, i - matchStart, matches);\n                    matchStart = i + 1; \/\/ guess the next match start will be after the non-matched item\n                }\n\n            \/\/ when last match was found but not all items are matched (hence matchStart != 0)\n            if (matchFound && matchStart != 0)\n                return AppendTo(source, matchStart, i - matchStart, matches);\n\n            return matches ?? (matchStart != 0 ? Empty<T>() : source);\n        }\n\n        \/\/\/ <summary>Where method similar to Enumerable.Where but more performant and non necessary allocating.\n        \/\/\/ It returns source array and does Not create new one if all items match the condition.<\/summary>\n        public static R[] Match<T, R>(this T[] source, Func<T, bool> condition, Func<T, R> map)\n        {\n            if (source == null)\n                return null;\n\n            if (source.Length == 0)\n                return Empty<R>();\n\n            if (source.Length == 1)\n            {\n                var item = source[0];\n                return condition(item) ? new[] { map(item) } : Empty<R>();\n            }\n\n            if (source.Length == 2)\n            {\n                var c0 = condition(source[0]);\n                var c1 = condition(source[1]);\n                return c0 && c1 ? new[] { map(source[0]), map(source[1]) } : c0 ? new[] { map(source[0]) } : c1 ? new[] { map(source[1]) } : Empty<R>();\n            }\n\n            if (source.Length == 3)\n            {\n                var condition0 = condition(source[0]);\n                var condition1 = condition(source[1]);\n                var condition2 = condition(source[2]);\n                return condition0 && condition1 && condition2 ? new[] { map(source[0]), map(source[1]), map(source[2]) }\n                    : condition0 ? (condition1 ? new[] { map(source[0]), map(source[1]) } : condition2 ? new[] { map(source[0]), map(source[2]) } : new[] { map(source[0]) })\n                    : condition1 ? (condition2 ? new[] { map(source[1]), map(source[2]) } : new[] { map(source[1]) })\n                    : condition2 ? new[] { map(source[2]) }\n                    : Empty<R>();\n            }\n\n            var matchStart = 0;\n            R[] matches = null;\n            var matchFound = false;\n\n            var i = 0;\n            for (; i < source.Length; ++i)\n                if (!(matchFound = condition(source[i])))\n                {\n                    \/\/ for accumulated matched items\n                    if (i != 0 && i > matchStart)\n                        matches = AppendTo(source, matchStart, i - matchStart, map, matches);\n                    matchStart = i + 1; \/\/ guess the next match start will be after the non-matched item\n                }\n\n            \/\/ when last match was found but not all items are matched (hence matchStart != 0)\n            if (matchFound && matchStart != 0)\n                return AppendTo(source, matchStart, i - matchStart, map, matches);\n\n            return matches ?? (matchStart == 0 ? AppendTo(source, 0, source.Length, map) : Empty<R>());\n        }\n\n        \/\/\/ <summary>Match with the additional state to use in <paramref name=\"condition\"\/> and <paramref name=\"map\"\/> \n        \/\/\/ to minimize the allocations in <paramref name=\"condition\"\/> lambda closure <\/summary>\n        public static R[] Match<S, T, R>(this T[] source, S state, Func<S, T, bool> condition, Func<S, T, R> map)\n        {\n            if (source == null)\n                return null;\n            if (source.Length == 0)\n                return Empty<R>();\n\n            if (source.Length == 1)\n            {\n                var item = source[0];\n                return condition(state, item) ? new[] { map(state, item) } : Empty<R>();\n            }\n\n            if (source.Length == 2)\n            {\n                var condition0 = condition(state, source[0]);\n                var condition1 = condition(state, source[1]);\n                return condition0 && condition1 ? new[] { map(state, source[0]), map(state, source[1]) }\n                    : condition0 ? new[] { map(state, source[0]) }\n                    : condition1 ? new[] { map(state, source[1]) }\n                    : Empty<R>();\n            }\n\n            if (source.Length == 3)\n            {\n                var condition0 = condition(state, source[0]);\n                var condition1 = condition(state, source[1]);\n                var condition2 = condition(state, source[2]);\n                return condition0 && condition1 && condition2 ? new[] { map(state, source[0]), map(state, source[1]), map(state, source[2]) }\n                    : condition0 ? (condition1 ? new[] { map(state, source[0]), map(state, source[1]) } : condition2 ? new[] { map(state, source[0]), map(state, source[2]) } : new[] { map(state, source[0]) })\n                    : condition1 ? (condition2 ? new[] { map(state, source[1]), map(state, source[2]) } : new[] { map(state, source[1]) })\n                    : condition2 ? new[] { map(state, source[2]) }\n                    : Empty<R>();\n            }\n\n            var matchStart = 0;\n            R[] matches = null;\n            var matchFound = false;\n\n            var i = 0;\n            for (; i < source.Length; ++i)\n                if (!(matchFound = condition(state, source[i])))\n                {\n                    \/\/ for accumulated matched items\n                    if (i != 0 && i > matchStart)\n                        matches = AppendTo(source, state, matchStart, i - matchStart, map, matches);\n                    matchStart = i + 1; \/\/ guess the next match start will be after the non-matched item\n                }\n\n            \/\/ when last match was found but not all items are matched (hence matchStart != 0)\n            if (matchFound && matchStart != 0)\n                return AppendTo(source, state, matchStart, i - matchStart, map, matches);\n\n            return matches ?? (matchStart == 0 ? AppendTo(source, state, 0, source.Length, map) : Empty<R>());\n        }\n\n        \/\/\/ <summary>Match with the additional state to use in <paramref name=\"condition\"\/> and <paramref name=\"map\"\/> \n        \/\/\/ to minimize the allocations in <paramref name=\"condition\"\/> lambda closure <\/summary>\n        public static R[] Match<A, B, T, R>(this T[] source, A a, B b, Func<A, B, T, bool> condition, Func<A, B, T, R> map)\n        {\n            if (source == null)\n                return null;\n            if (source.Length == 0)\n                return Empty<R>();\n\n            if (source.Length == 1)\n            {\n                var item = source[0];\n                return condition(a, b, item) ? new[] { map(a, b, item) } : Empty<R>();\n            }\n\n            if (source.Length == 2)\n            {\n                var condition0 = condition(a, b, source[0]);\n                var condition1 = condition(a, b, source[1]);\n                return condition0 && condition1 ? new[] { map(a, b, source[0]), map(a, b, source[1]) }\n                    : condition0 ? new[] { map(a, b, source[0]) }\n                    : condition1 ? new[] { map(a, b, source[1]) }\n                    : Empty<R>();\n            }\n\n            var matchStart = 0;\n            R[] matches = null;\n            var matchFound = false;\n\n            var i = 0;\n            for (; i < source.Length; ++i)\n                if (!(matchFound = condition(a, b, source[i])))\n                {\n                    \/\/ for accumulated matched items\n                    if (i != 0 && i > matchStart)\n                        matches = AppendTo(source, a, b, matchStart, i - matchStart, map, matches);\n                    matchStart = i + 1; \/\/ guess the next match start will be after the non-matched item\n                }\n\n            \/\/ when last match was found but not all items are matched (hence matchStart != 0)\n            if (matchFound && matchStart != 0)\n                return AppendTo(source, a, b, matchStart, i - matchStart, map, matches);\n\n            return matches ?? (matchStart == 0 ? AppendTo(source, a, b, 0, source.Length, map) : Empty<R>());\n        }\n\n        \/\/\/ <summary>Maps all items from source to result array.<\/summary>\n        \/\/\/ <typeparam name=\"T\">Source item type<\/typeparam> <typeparam name=\"R\">Result item type<\/typeparam>\n        \/\/\/ <param name=\"source\">Source items<\/param> <param name=\"map\">Function to convert item from source to result.<\/param>\n        \/\/\/ <returns>Converted items<\/returns>\n        public static R[] Map<T, R>(this T[] source, Func<T, R> map)\n        {\n            if (source == null)\n                return null;\n\n            var sourceCount = source.Length;\n            if (sourceCount == 0)\n                return Empty<R>();\n\n            if (sourceCount == 1)\n                return new[] { map(source[0]) };\n\n            if (sourceCount == 2)\n                return new[] { map(source[0]), map(source[1]) };\n\n            var results = new R[sourceCount];\n            for (var i = 0; i < source.Length; i++)\n                results[i] = map(source[i]);\n            return results;\n        }\n\n        \/\/\/ Map with additional state to use in <paramref name=\"map\"\/> to minimize allocations in <paramref name=\"map\"\/> lambda closure \n        public static R[] Map<T, S, R>(this T[] source, S state, Func<S, T, R> map)\n        {\n            if (source == null)\n                return null;\n\n            var sourceCount = source.Length;\n            if (sourceCount == 0)\n                return Empty<R>();\n\n            if (sourceCount == 1)\n                return new[] { map(state, source[0]) };\n\n            if (sourceCount == 2)\n                return new[] { map(state, source[0]), map(state, source[1]) };\n\n            var results = new R[sourceCount];\n            for (var i = 0; i < source.Length; i++)\n                results[i] = map(state, source[i]);\n            return results;\n        }\n\n        \/\/\/ Map with additional two states to use in <paramref name=\"map\"\/> to minimize allocations in <paramref name=\"map\"\/> lambda closure \n        public static R[] Map<T, A, B, R>(this T[] source, A a, B b, Func<A, B, T, R> map)\n        {\n            if (source == null)\n                return null;\n\n            var sourceCount = source.Length;\n            if (sourceCount == 0)\n                return Empty<R>();\n\n            if (sourceCount == 1)\n                return new[] { map(a, b, source[0]) };\n\n            if (sourceCount == 2)\n                return new[] { map(a, b, source[0]), map(a, b, source[1]) };\n\n            var results = new R[sourceCount];\n            for (var i = 0; i < source.Length; i++)\n                results[i] = map(a, b, source[i]);\n            return results;\n        }\n\n        \/\/\/ <summary>Maps all items from source to result collection. If possible uses fast array Map otherwise Enumerable.Select.<\/summary>\n        \/\/\/ <typeparam name=\"T\">Source item type<\/typeparam> <typeparam name=\"R\">Result item type<\/typeparam>\n        \/\/\/ <param name=\"source\">Source items<\/param> <param name=\"map\">Function to convert item from source to result.<\/param>\n        \/\/\/ <returns>Converted items<\/returns>\n        public static IEnumerable<R> Map<T, R>(this IEnumerable<T> source, Func<T, R> map) =>\n            source is T[] arr ? arr.Map(map) : source?.Select(map);\n\n        \/\/\/ <summary>If <paramref name=\"source\"\/> is array uses more effective Match for array, otherwise just calls Where<\/summary>\n        \/\/\/ <typeparam name=\"T\">Type of source items.<\/typeparam>\n        \/\/\/ <param name=\"source\">If null, the null will be returned.<\/param>\n        \/\/\/ <param name=\"condition\">Condition to keep items.<\/param>\n        \/\/\/ <returns>Result items, may be an array.<\/returns>\n        public static IEnumerable<T> Match<T>(this IEnumerable<T> source, Func<T, bool> condition) =>\n            source is T[] arr ? arr.Match(condition) : source?.Where(condition);\n\n        \/\/\/ <summary>If <paramref name=\"source\"\/> is array uses more effective Match for array,\n        \/\/\/ otherwise just calls Where, Select<\/summary>\n        \/\/\/ <typeparam name=\"T\">Type of source items.<\/typeparam> <typeparam name=\"R\">Type of result items.<\/typeparam>\n        \/\/\/ <param name=\"source\">If null, the null will be returned.<\/param>\n        \/\/\/ <param name=\"condition\">Condition to keep items.<\/param>  <param name=\"map\">Converter from source to result item.<\/param>\n        \/\/\/ <returns>Result items, may be an array.<\/returns>\n        public static IEnumerable<R> Match<T, R>(this IEnumerable<T> source, Func<T, bool> condition, Func<T, R> map) =>\n            source is T[] arr ? arr.Match(condition, map) : source?.Where(condition).Select(map);\n    }\n\n    \/\/\/ <summary>Wrapper that provides optimistic-concurrency Swap operation implemented using <see cref=\"Ref.Swap{T}\"\/>.<\/summary>\n    \/\/\/ <typeparam name=\"T\">Type of object to wrap.<\/typeparam>\n    public sealed class Ref<T> where T : class\n    {\n        \/\/\/ <summary>Gets the wrapped value.<\/summary>\n        public T Value => _value;\n        private T _value;\n\n        \/\/\/ <summary>Creates ref to object, optionally with initial value provided.<\/summary>\n        \/\/\/ <param name=\"initialValue\">(optional) Initial value.<\/param>\n        public Ref(T initialValue = default) => _value = initialValue;\n\n        \/\/\/ <summary>Exchanges currently hold object with <paramref name=\"getNewValue\"\/> - see <see cref=\"Ref.Swap{T}\"\/> for details.<\/summary>\n        \/\/\/ <param name=\"getNewValue\">Delegate to produce new object value from current one passed as parameter.<\/param>\n        \/\/\/ <returns>Returns old object value the same way as <see cref=\"Interlocked.Exchange(ref int,int)\"\/><\/returns>\n        \/\/\/ <remarks>Important: <paramref name=\"getNewValue\"\/> May be called multiple times to retry update with value concurrently changed by other code.<\/remarks>\n        public T Swap(Func<T, T> getNewValue) =>\n            Ref.Swap(ref _value, getNewValue);\n\n        \/\/\/ <summary>Swap with the additional state <paramref name=\"a\"\/> required for the delegate <paramref name=\"getNewValue\"\/>.\n        \/\/\/ May prevent closure creation for the delegate<\/summary>\n        public T Swap<A>(A a, Func<T, A, T> getNewValue, int retryCountUntilThrow = Ref.RETRY_COUNT_UNTIL_THROW) =>\n             Ref.Swap(ref _value, a, getNewValue, retryCountUntilThrow);\n\n        \/\/\/ <summary>Swap with the additional state <paramref name=\"a\"\/>, <paramref name=\"b\"\/> required for the delegate <paramref name=\"getNewValue\"\/>.\n        \/\/\/ May prevent closure creation for the delegate<\/summary>\n        public T Swap<A, B>(A a, B b, Func<T, A, B, T> getNewValue, int retryCountUntilThrow = Ref.RETRY_COUNT_UNTIL_THROW) =>\n             Ref.Swap(ref _value, a, b, getNewValue, retryCountUntilThrow);\n\n        \/\/\/ <summary>Swap with the additional state <paramref name=\"a\"\/> required for the delegate <paramref name=\"getNewValue\"\/>.\n        \/\/\/ May prevent closure creation for the delegate<\/summary>\n        public T SwapAndGetNewValue<A>(A a, Func<T, A, T> getNewValue, int retryCountUntilThrow = Ref.RETRY_COUNT_UNTIL_THROW) =>\n             Ref.SwapAndGetNewValue(ref _value, a, getNewValue, retryCountUntilThrow);\n\n        \/\/\/ <summary>Just sets new value ignoring any intermingled changes and returns the original value<\/summary>\n        \/\/\/ <param name=\"newValue\"><\/param> <returns>old value<\/returns>\n        public T Swap(T newValue) => Interlocked.Exchange(ref _value, newValue);\n\n        \/\/\/ <summary>Directly sets the value and returns the new value<\/summary>\n        public T SetNonAtomic(T newValue) => _value = newValue;\n\n        \/\/\/ <summary>Compares current Referred value with <paramref name=\"currentValue\"\/> and if equal replaces current with <paramref name=\"newValue\"\/><\/summary>\n        \/\/\/ <param name=\"currentValue\"><\/param> <param name=\"newValue\"><\/param>\n        \/\/\/ <returns>True if current value was replaced with new value, and false if current value is outdated (already changed by other party).<\/returns>\n        \/\/\/ <example><c>[!CDATA[\n        \/\/\/ var value = SomeRef.Value;\n        \/\/\/ if (!SomeRef.TrySwapIfStillCurrent(value, Update(value))\n        \/\/\/     SomeRef.Swap(v => Update(v)); \/\/ fallback to normal Swap with delegate allocation\n        \/\/\/ ]]<\/c><\/example>\n        public bool TrySwapIfStillCurrent(T currentValue, T newValue) =>\n            Interlocked.CompareExchange(ref _value, newValue, currentValue) == currentValue;\n\n        \/\/\/ <summary>Just sets the new value<\/summary>\n        public void UnsafeSet(T newValue) => _value = newValue;\n    }\n\n    \/\/\/ <summary>Provides optimistic-concurrency consistent <see cref=\"Swap{T}\"\/> operation.<\/summary>\n    public static class Ref\n    {\n        \/\/\/ The default max retry count - can be overridden by `Swap` optional parameter \n        public const int RETRY_COUNT_UNTIL_THROW = 50;\n\n        \/\/\/ <summary>Factory for <see cref=\"Ref{T}\"\/> with type of value inference.<\/summary>\n        \/\/\/ <typeparam name=\"T\">Type of value to wrap.<\/typeparam>\n        \/\/\/ <param name=\"value\">Initial value to wrap.<\/param>\n        \/\/\/ <returns>New ref.<\/returns>\n        public static Ref<T> Of<T>(T value) where T : class => new Ref<T>(value);\n\n        \/\/\/ <summary>Creates new ref to the value of original ref.<\/summary> <typeparam name=\"T\">Ref value type.<\/typeparam>\n        \/\/\/ <param name=\"original\">Original ref.<\/param> <returns>New ref to original value.<\/returns>\n        public static Ref<T> NewRef<T>(this Ref<T> original) where T : class => Of(original.Value);\n\n        \/\/\/ <summary>First, it evaluates new value using <paramref name=\"getNewValue\"\/> function. \n        \/\/\/ Second, it checks that original value is not changed. \n        \/\/\/ If it is changed it will retry first step, otherwise it assigns new value and returns original (the one used for <paramref name=\"getNewValue\"\/>).<\/summary>\n        \/\/\/ <typeparam name=\"T\">Type of value to swap.<\/typeparam>\n        \/\/\/ <param name=\"value\">Reference to change to new value<\/param>\n        \/\/\/ <param name=\"getNewValue\">Delegate to get value from old one.<\/param>\n        \/\/\/ <param name=\"retryCountUntilThrow\">(optional)<\/param>\n        \/\/\/ <returns>Old\/original value. By analogy with <see cref=\"Interlocked.Exchange(ref int,int)\"\/>.<\/returns>\n        \/\/\/ <remarks>Important: <paramref name=\"getNewValue\"\/> May be called multiple times to retry update with value concurrently changed by other code.<\/remarks>\n        [MethodImpl((MethodImplOptions)256)]\n        public static T Swap<T>(ref T value, Func<T, T> getNewValue,\n            int retryCountUntilThrow = RETRY_COUNT_UNTIL_THROW)\n            where T : class\n        {\n            var spinWait = new SpinWait();\n            var retryCount = 0;\n            while (true)\n            {\n                var oldValue = value;\n                var newValue = getNewValue(oldValue);\n                if (Interlocked.CompareExchange(ref value, newValue, oldValue) == oldValue)\n                    return oldValue;\n\n                if (++retryCount > retryCountUntilThrow)\n                    ThrowRetryCountExceeded(retryCountUntilThrow);\n                spinWait.SpinOnce();\n            }\n        }\n\n        private static void ThrowRetryCountExceeded(int retryCountExceeded) =>\n            throw new InvalidOperationException(\n                $\"Ref retried to Update for {retryCountExceeded} times But there is always someone else intervened.\");\n\n        \/\/\/ <summary>Swap with the additional state <paramref name=\"a\"\/> required for the delegate <paramref name=\"getNewValue\"\/>.\n        \/\/\/ May prevent closure creation for the delegate<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static T Swap<T, A>(ref T value, A a, Func<T, A, T> getNewValue,\n            int retryCountUntilThrow = RETRY_COUNT_UNTIL_THROW)\n            where T : class\n        {\n            var spinWait = new SpinWait();\n            var retryCount = 0;\n            while (true)\n            {\n                var oldValue = value;\n                var newValue = getNewValue(oldValue, a);\n                if (Interlocked.CompareExchange(ref value, newValue, oldValue) == oldValue)\n                    return oldValue;\n                if (++retryCount > retryCountUntilThrow)\n                    ThrowRetryCountExceeded(retryCountUntilThrow);\n                spinWait.SpinOnce();\n            }\n        }\n\n        \/\/\/ <summary>Swap with the additional state a required for the delegate.\n        \/\/\/ Helps to avoid closure creation for the delegate<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static T SwapAndGetNewValue<T, A>(ref T value, A a, Func<T, A, T> getNewValue,\n            int retryCountUntilThrow = RETRY_COUNT_UNTIL_THROW)\n            where T : class\n        {\n            var spinWait = new SpinWait();\n            var retryCount = 0;\n            while (true)\n            {\n                var oldValue = value;\n                var newValue = getNewValue(oldValue, a);\n                if (Interlocked.CompareExchange(ref value, newValue, oldValue) == oldValue)\n                    return newValue;\n                if (++retryCount > retryCountUntilThrow)\n                    ThrowRetryCountExceeded(retryCountUntilThrow);\n                spinWait.SpinOnce();\n            }\n        }\n\n        \/\/\/ <summary>Swap with the additional state a, b required for the delegate.\n        \/\/\/ Helps to avoid closure creation for the delegate<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static T Swap<T, A, B>(ref T value, A a, B b, Func<T, A, B, T> getNewValue,\n            int retryCountUntilThrow = RETRY_COUNT_UNTIL_THROW)\n            where T : class\n        {\n            var spinWait = new SpinWait();\n            var retryCount = 0;\n            while (true)\n            {\n                var oldValue = value;\n                var newValue = getNewValue(oldValue, a, b);\n                if (Interlocked.CompareExchange(ref value, newValue, oldValue) == oldValue)\n                    return oldValue;\n                if (++retryCount > retryCountUntilThrow)\n                    ThrowRetryCountExceeded(retryCountUntilThrow);\n                spinWait.SpinOnce();\n            }\n        }\n\n        \/\/\/ <summary>Swap with the additional state a, b, c required for the delegate.\n        \/\/\/ Helps to avoid closure creation for the delegate<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static T Swap<T, A, B, C>(ref T value, A a, B b, C c, Func<T, A, B, C, T> getNewValue,\n            int retryCountUntilThrow = RETRY_COUNT_UNTIL_THROW)\n            where T : class\n        {\n            var spinWait = new SpinWait();\n            var retryCount = 0;\n            while (true)\n            {\n                var oldValue = value;\n                var newValue = getNewValue(oldValue, a, b, c);\n                if (Interlocked.CompareExchange(ref value, newValue, oldValue) == oldValue)\n                    return oldValue;\n                if (++retryCount > retryCountUntilThrow)\n                    ThrowRetryCountExceeded(retryCountUntilThrow);\n                spinWait.SpinOnce();\n            }\n        }\n\n        \/\/\/ <summary>Swap with the additional state a, b, c, d` required for the delegate.\n        \/\/\/ Helps to avoid closure creation for the delegate<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static T Swap<T, A, B, C, D>(ref T value, A a, B b, C c, D d, Func<T, A, B, C, D, T> getNewValue,\n            int retryCountUntilThrow = RETRY_COUNT_UNTIL_THROW)\n            where T : class\n        {\n            var spinWait = new SpinWait();\n            var retryCount = 0;\n            while (true)\n            {\n                var oldValue = value;\n                var newValue = getNewValue(oldValue, a, b, c, d);\n                if (Interlocked.CompareExchange(ref value, newValue, oldValue) == oldValue)\n                    return oldValue;\n                if (++retryCount > retryCountUntilThrow)\n                    ThrowRetryCountExceeded(retryCountUntilThrow);\n                spinWait.SpinOnce();\n            }\n        }\n    }\n\n    \/\/\/ <summary>Printable thing via provided printer <\/summary>\n    public interface IPrintable\n    {\n        \/\/\/ <summary>Print to the provided string builder via the provided printer.<\/summary>\n        StringBuilder Print(StringBuilder s, Func<StringBuilder, object, StringBuilder> printer);\n    }\n\n    \/\/\/ <summary>Produces good enough hash codes for the fields<\/summary>\n    public static class Hasher\n    {\n        \/\/\/ <summary>Combines hashes of two fields<\/summary>\n        public static int Combine<T1, T2>(T1 a, T2 b)\n        {\n            var bh = b?.GetHashCode() ?? 0;\n            if (ReferenceEquals(a, null))\n                return bh;\n            var ah = a.GetHashCode();\n            if (ah == 0)\n                return bh;\n            return Combine(ah, bh);\n        }\n\n        \/\/\/ <summary>Inspired by System.Tuple.CombineHashCodes<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static int Combine(int h1, int h2)\n        {\n            unchecked\n            {\n                return (h1 << 5) + h1 ^ h2;\n            }\n        }\n    }\n\n    \/\/\/ Simple unbounded object pool\n    public sealed class StackPool<T> where T : class\n    {\n        \/\/\/ <summary>Give me an object<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public T RentOrDefault() =>\n            Interlocked.Exchange(ref _s, _s?.Tail)?.Head;\n\n        \/\/\/ <summary>Give it back<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public void Return(T x) =>\n            Interlocked.Exchange(ref _s, new Stack(x, _s));\n\n        private Stack _s;\n\n        private sealed class Stack\n        {\n            public readonly T Head;\n            public readonly Stack Tail;\n            public Stack(T h, Stack t)\n            {\n                Head = h;\n                Tail = t;\n            }\n        }\n    }\n\n    \/\/\/ <summary>Immutable Key-Value pair. It is reference type (could be check for null), \n    \/\/\/ which is different from System value type <see cref=\"KeyValuePair{TKey,TValue}\"\/>.\n    \/\/\/ In addition provides <see cref=\"Equals\"\/> and <see cref=\"GetHashCode\"\/> implementations.<\/summary>\n    \/\/\/ <typeparam name=\"K\">Type of Key.<\/typeparam><typeparam name=\"V\">Type of Value.<\/typeparam>\n    public class KV<K, V> : IPrintable\n    {\n        \/\/\/ <summary>Key.<\/summary>\n        public readonly K Key;\n\n        \/\/\/ <summary>Value.<\/summary>\n        public readonly V Value;\n\n        \/\/\/ <summary>Creates Key-Value object by providing key and value. Does Not check either one for null.<\/summary>\n        \/\/\/ <param name=\"key\">key.<\/param><param name=\"value\">value.<\/param>\n        public KV(K key, V value)\n        {\n            Key = key;\n            Value = value;\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public StringBuilder Print(StringBuilder s, Func<StringBuilder, object, StringBuilder> printer) =>\n            s.Append(\"(\").To(b => Key == null ? b : printer(b, Key))\n                .Append(\", \").To(b => Value == null ? b : printer(b, Value))\n                .Append(')');\n\n        \/\/\/ <summary>Creates nice string view.<\/summary><returns>String representation.<\/returns>\n        public override string ToString() =>\n            Print(new StringBuilder(), (s, x) => s.Append(x)).ToString();\n\n        \/\/\/ <summary>Returns true if both key and value are equal to corresponding key-value of other object.<\/summary>\n        public override bool Equals(object obj)\n        {\n            var other = obj as KV<K, V>;\n            return other != null\n                   && (ReferenceEquals(other.Key, Key) || Equals(other.Key, Key))\n                   && (ReferenceEquals(other.Value, Value) || Equals(other.Value, Value));\n        }\n\n        \/\/\/ <summary>Combines key and value hash code<\/summary>\n        public override int GetHashCode() => Hasher.Combine(Key, Value);\n    }\n\n    \/\/\/ <summary>Helpers for <see cref=\"KV{K,V}\"\/>.<\/summary>\n    public static class KV\n    {\n        \/\/\/ <summary>Creates the key value pair.<\/summary>\n        public static KV<K, V> Of<K, V>(K key, V value) => new KV<K, V>(key, value);\n\n        \/\/\/ <summary>Creates the pair with the new value<\/summary>\n        public static KV<K, V> WithValue<K, V>(this KV<K, V> kv, V value) => new KV<K, V>(kv.Key, value);\n    }\n\n    \/\/\/ Simple helper for creation of the pair of two parts.\n    public static class KeyValuePair\n    {\n        \/\/\/ Pairs key with value.\n        public static KeyValuePair<K, V> Pair<K, V>(this K key, V value) => new KeyValuePair<K, V>(key, value);\n    }\n\n    \/\/\/ <summary>Helper structure which allows to distinguish null value from the default value for optional parameter.<\/summary>\n    public struct Opt<T>\n    {\n        \/\/\/ <summary>Allows to transparently convert parameter argument to opt structure.<\/summary>\n        public static implicit operator Opt<T>(T value) => new Opt<T>(value);\n\n        \/\/\/ <summary>Argument value.<\/summary>\n        public readonly T Value;\n\n        \/\/\/ <summary>Indicates that value is provided.<\/summary>\n        public readonly bool HasValue;\n\n        \/\/\/ <summary>Wraps passed value in structure. Sets the flag that value is present.<\/summary>\n        public Opt(T value)\n        {\n            HasValue = true;\n            Value = value;\n        }\n\n        \/\/\/ <summary>Helper to get value or default value if value is not present.<\/summary>\n        public T OrDefault(T defaultValue = default) => HasValue ? Value : defaultValue;\n    }\n\n    \/\/\/ <summary>Ever growing list methods<\/summary>\n    public static class GrowingList\n    {\n        \/\/\/ <summary>Default initial capacity <\/summary>\n        public const int DefaultInitialCapacity = 2;\n\n        \/\/\/ Push the new slot and return the ref to it\n        public static ref T PushSlot<T>(ref T[] items, int count)\n        {\n            if (items == null)\n                items = new T[DefaultInitialCapacity];\n            else if (count >= items.Length)\n                Expand(ref items);\n            return ref items[count];\n        }\n\n        \/\/\/ Adds the new item possibly extending the item collection\n        public static void Push<T>(ref T[] items, int count, T item)\n        {\n            if (items == null)\n                items = new T[DefaultInitialCapacity];\n            else if (count >= items.Length)\n                Expand(ref items);\n            items[count] = item;\n        }\n\n        \/\/\/ <summary>Expands the items starting with 2<\/summary>\n        internal static void Expand<T>(ref T[] items)\n        {\n            var count = items.Length;\n            var newItems = new T[count << 1]; \/\/ count x 2\n            if (count < 6)\n                for (var i = 0; i < count; ++i)\n                    newItems[i] = items[i];\n            else\n                Array.Copy(items, 0, newItems, 0, count);\n        }\n\n        \/\/\/<summary>Creates the final array out of the list, so that you cannot use after that!<\/summary>\n        public static T[] ResizeToArray<T>(T[] items, int count)\n        {\n            if (count < items.Length)\n                Array.Resize(ref items, count);\n            return items;\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public static string ToString<T>(T[] items, int count) =>\n            $\"Count {count} of {(count == 0 || items == null || items.Length == 0 ? \"empty\" : \"first (\" + items[0] + \") and last (\" + items[count - 1] + \")\")}\";\n    }\n\n    \/\/\/ <summary>Ever growing list<\/summary>\n    public struct GrowingList<T>\n    {\n        \/\/\/ <summary>Default initial capacity <\/summary>\n        public const int DefaultInitialCapacity = 2;\n\n        \/\/\/ <summary>The items array<\/summary>\n        public T[] Items;\n\n        \/\/\/ <summary>The count<\/summary>\n        public int Count;\n\n        \/\/\/ <summary>Constructs the thing<\/summary>\n        public GrowingList(T[] items, int count = 0)\n        {\n            Items = items;\n            Count = count;\n        }\n\n        \/\/\/ <summary>Push the new slot and return the ref to it<\/summary>\n        public ref T PushSlot()\n        {\n            if (Items == null)\n                Items = new T[DefaultInitialCapacity];\n            else if (Count >= Items.Length)\n                GrowingList.Expand(ref Items);\n            return ref Items[Count++];\n        }\n\n        \/\/\/ <summary>Adds the new item possibly extending the item collection<\/summary>\n        public void Push(T item)\n        {\n            if (Items == null)\n                Items = new T[DefaultInitialCapacity];\n            else if (Count >= Items.Length)\n                GrowingList.Expand(ref Items);\n            Items[Count++] = item;\n        }\n\n        \/\/\/ <summary>Pops the item - just moving the counter back<\/summary>\n        public void Pop() => --Count;\n\n        \/\/\/<summary>Creates the final array out of the list, so that you cannot use after that!<\/summary>\n        public T[] ResizeToArray()\n        {\n            var items = Items;\n            if (Count < items.Length)\n                Array.Resize(ref items, Count);\n            return items;\n        }\n\n        \/\/ todo: @naming think of the better name\n        \/\/\/ <summary>Pops the item - just moving the counter back<\/summary>\n        public T PopItem() => Items[--Count];\n\n        \/\/\/ <inheritdoc \/>\n        public override string ToString() =>\n            $\"Count {Count} of {(Count == 0 || Items == null || Items.Length == 0 ? \"empty\" : \"first (\" + Items[0] + \") and last (\" + Items[Count - 1] + \")\")}\";\n    }\n\n    \/\/\/ <summary>Immutable list - simplest linked list with the Head and the Tail.<\/summary>\n    public sealed class ImList<T>\n    {\n        \/\/\/ <summary>Empty list to Push to.<\/summary>\n        public static readonly ImList<T> Empty = new ImList<T>();\n\n        \/\/\/ <summary>True for empty list.<\/summary>\n        public bool IsEmpty => Tail == null;\n\n        \/\/\/ <summary>First value in a list.<\/summary>\n        public readonly T Head;\n\n        \/\/\/ <summary>The rest of values or Empty if list has a single value.<\/summary>\n        public readonly ImList<T> Tail;\n\n        \/\/\/ <summary>Prepends new value and returns new list.<\/summary>\n        public ImList<T> Push(T head) => new ImList<T>(head, this);\n\n        \/\/\/ <summary>Enumerates the list.<\/summary>\n        public IEnumerable<T> Enumerate()\n        {\n            if (Tail == null)\n                yield break;\n            for (var list = this; list.Tail != null; list = list.Tail)\n                yield return list.Head;\n        }\n\n        \/\/\/ <summary>String representation for debugging purposes<\/summary>\n        public override string ToString() => IsEmpty\n            ? \"[]\" : Tail.IsEmpty\n            ? \"[\" + Head + \"]\" : Tail.Tail.IsEmpty\n            ? \"[\" + Head + \",\" + Tail.Head + \"]\" : Tail.Tail.Tail.IsEmpty\n            ? \"[\" + Head + \",\" + Tail.Head + \",\" + Tail.Tail.Head + \"]\"\n            : \"[\" + Head + \",\" + Tail.Head + \",\" + Tail.Tail.Head + \", ...]\";\n\n        private ImList() { }\n        private ImList(T head, ImList<T> tail)\n        {\n            Head = head;\n            Tail = tail;\n        }\n    }\n\n    \/\/\/ <summary>Extension methods providing basic operations on a list.<\/summary>\n    public static class ImList\n    {\n        \/\/\/ Split list into (Head, Tail, IsEmpty) tuple\n        public static void Deconstruct<T>(this ImList<T> list, out T head, out ImList<T> tail, out bool isEmpty)\n        {\n            head = list.Head;\n            tail = list.Tail;\n            isEmpty = list.IsEmpty;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Constructs the reversed list from the parameter array of items\n        \/\/\/ <\/summary>\n        public static ImList<T> List<T>(params T[] items)\n        {\n            var l = ImList<T>.Empty;\n            if (items != null)\n                for (var i = items.Length - 1; i >= 0; --i)\n                    l = l.Push(items[i]);\n            return l;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Constructs the list as the reversed input list\n        \/\/\/ <\/summary>\n        public static ImList<T> ToImList<T>(this IList<T> source)\n        {\n            var l = ImList<T>.Empty;\n            if (source != null)\n                for (var i = source.Count - 1; i >= 0; --i)\n                    l = l.Push(source[i]);\n            return l;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Constructs the list as the reversed enumerable\n        \/\/\/ <\/summary>\n        public static ImList<T> ToImList<T>(this IEnumerable<T> source)\n        {\n            if (source is IList<T> list)\n                return list.ToImList();\n            var l = ImList<T>.Empty;\n\n            if (source != null)\n                foreach (var item in source)\n                    l = l.Push(item);\n            return l.Reverse();\n        }\n\n        \/\/\/ <summary>Constructs list of one element<\/summary>\n        public static ImList<T> List<T>(this T head) => ImList<T>.Empty.Push(head);\n\n        \/\/\/ <summary>Constructs list from head and tail<\/summary>\n        public static ImList<T> List<T>(this T head, ImList<T> tail) => tail.Push(head);\n\n        \/\/\/ <summary>Apples some effect action to each element<\/summary>\n        public static void ForEach<T>(this ImList<T> list, Action<T> effect)\n        {\n            for (; !list.IsEmpty; list = list.Tail)\n                effect(list.Head);\n        }\n\n        \/\/\/ <summary>Fold list to a single value. The respective name for it in LINQ is Aggregate<\/summary>\n        public static S Fold<T, S>(this ImList<T> list, S state, Func<T, S, S> handler)\n        {\n            if (list.IsEmpty)\n                return state;\n            var result = state;\n            for (; !list.IsEmpty; list = list.Tail)\n                result = handler(list.Head, result);\n            return result;\n        }\n\n        \/\/\/ <summary>Fold list to a single value with index of item. The respective name for it in LINQ is Aggregate.<\/summary>\n        public static S Fold<T, S>(this ImList<T> list, S state, Func<T, int, S, S> handler)\n        {\n            if (list.IsEmpty)\n                return state;\n            var result = state;\n            for (var i = 0; !list.IsEmpty; list = list.Tail, ++i)\n                result = handler(list.Head, i, result);\n            return result;\n        }\n\n        \/\/\/ <summary>Returns new list in reverse order.<\/summary>\n        public static ImList<T> Reverse<T>(this ImList<T> list)\n        {\n            if (list.IsEmpty || list.Tail.IsEmpty)\n                return list;\n            var reversed = ImList<T>.Empty;\n            for (; !list.IsEmpty; list = list.Tail)\n                reversed = reversed.Push(list.Head);\n            return reversed;\n        }\n\n        \/\/\/ <summary>Maps the items from the first list to the result list.<\/summary>\n        public static ImList<R> Map<T, R>(this ImList<T> list, Func<T, R> map) =>\n            list.Fold(ImList<R>.Empty, (x, r) => List(map(x), r)).Reverse();\n\n        \/\/\/ <summary>Maps with index<\/summary>\n        public static ImList<R> Map<T, R>(this ImList<T> list, Func<T, int, R> map) =>\n            list.Fold(ImList<R>.Empty, (x, i, r) => List(map(x, i), r)).Reverse();\n\n        \/\/\/ <summary>Copies list to array.<\/summary>\n        public static T[] ToArray<T>(this ImList<T> source) =>\n            source.IsEmpty ? ArrayTools.Empty<T>()\n            : source.Tail.IsEmpty ? new[] { source.Head } : source.Enumerate().ToArray();\n    }\n\n    \/\/\/ Zipper is an immutable persistent data structure, to represent collection with single focused (selected, active) element.\n    \/\/\/ Consist of REVERSED `Left` immutable list, `Focus` element, and the `Right` immutable list. That's why a Zipper name,\n    \/\/\/ where left and right part are joined \/ zipped in focus item.\n    public sealed class ImZipper<T>\n    {\n        \/\/\/ Empty singleton instance to start building your zipper\n        public static readonly ImZipper<T> Empty = new ImZipper<T>();\n\n        \/\/\/ True is zipper does not contain items\n        public bool IsEmpty => Count == 0;\n\n        \/\/\/ Index of Focus item, from `0` to `Count-1`\n        public readonly int Index;\n\n        \/\/\/ Number of items\n        public readonly int Count;\n\n        \/\/\/ Left REVERSED list, so the Head of the list is just prior the Focus item \n        public readonly ImList<T> Left;\n\n        \/\/\/ Right list, where Head is just after the Focus item\n        public readonly ImList<T> Right;\n\n        \/\/\/ Single focus item\n        public readonly T Focus;\n\n        \/\/\/ <inheritdoc \/>\n        public override string ToString() =>\n            IsEmpty ? \"[||]\" : Count + \":\" + Left.Reverse() + \"|\" + Index + \":\" + Focus + \"|\" + Right;\n\n        \/\/\/ Sets a new focus and pushes the old focus to the Left list. \n        public ImZipper<T> Append(T focus) => PushLeft(focus);\n\n        \/\/\/ Sets a new focus and pushes the old focus to the Left list.\n        public ImZipper<T> PushLeft(T focus) =>\n        IsEmpty ? new ImZipper<T>(ImList<T>.Empty, focus, 0, ImList<T>.Empty, 1)\n                : new ImZipper<T>(Left.Push(Focus), focus, Index + 1, Right, Count + 1);\n\n        \/\/\/ Sets a new focus and pushes the old focus to the right list. \n        public ImZipper<T> Insert(T focus) => PushRight(focus);\n\n        \/\/\/ Sets a new focus and pushes the old focus to the right list. \n        public ImZipper<T> PushRight(T focus) =>\n            IsEmpty ? new ImZipper<T>(ImList<T>.Empty, focus, 0, ImList<T>.Empty, 1)\n                : new ImZipper<T>(Left, focus, Index, Right.Push(Focus), Count + 1);\n\n        \/\/\/ Removes a focus, filling the hole with the item from the left list, or from the right if the left is empty\n        public ImZipper<T> PopLeft() =>\n            IsEmpty ? this\n            : Left.IsEmpty && Right.IsEmpty ? Empty\n            : !Left.IsEmpty ? new ImZipper<T>(Left.Tail, Left.Head, Index - 1, Right, Count - 1)\n            : new ImZipper<T>(Left, Right.Head, Index, Right.Tail, Count - 1);\n\n        \/\/\/ Removes a focus, filling the hole with the item from the right list, or from the left if the right is empty\n        public ImZipper<T> PopRight() =>\n            IsEmpty ? this\n            : Left.IsEmpty && Right.IsEmpty ? Empty\n            : !Right.IsEmpty ? new ImZipper<T>(Left, Right.Head, Index, Right.Tail, Count - 1)\n            : new ImZipper<T>(Left.Tail, Left.Head, Index - 1, Right, Count - 1);\n\n        \/\/\/ Shifts focus one element to the left (decrementing its Index).\n        public ImZipper<T> ShiftLeft() =>\n            IsEmpty || Left.IsEmpty ? this\n            : new ImZipper<T>(Left.Tail, Left.Head, Index - 1, Right.Push(Focus), Count);\n\n        \/\/\/ Shifts focus one element to the right (incrementing its Index).\n        public ImZipper<T> ShiftRight() =>\n            IsEmpty || Right.IsEmpty ? this\n            : new ImZipper<T>(Left.Push(Focus), Right.Head, Index + 1, Right.Tail, Count);\n\n        \/\/\/ Sets a new focus and returns a new zipper with the left and right lists unchanged\n        public ImZipper<T> WithFocus(T focus) =>\n            IsEmpty ? this : new ImZipper<T>(Left, focus, Index, Right, Count);\n\n        \/\/\/ Maps over the zipper items producing a new zipper\n        public ImZipper<R> Map<R>(Func<T, R> map) =>\n            IsEmpty ? ImZipper<R>.Empty\n                : new ImZipper<R>(Left.Reverse().Fold(ImList<R>.Empty, (x, r) => r.Push(map(x))),\n                    map(Focus), Index, Right.Map(map), Count);\n\n        \/\/\/ Maps over the zipper items with item index, producing a new zipper\n        public ImZipper<R> Map<R>(Func<T, int, R> map) =>\n            IsEmpty ? ImZipper<R>.Empty\n                : new ImZipper<R>(\n                    Left.Reverse().Fold(ImList<R>.Empty, (x, i, r) => r.Push(map(x, i))),\n                    map(Focus, Index), Index, Right.Map((x, i) => map(x, Index + 1 + i)), Count);\n\n        private ImZipper() => Index = -1;\n\n        private ImZipper(ImList<T> left, T focus, int index, ImList<T> right, int count)\n        {\n            Left = left;\n            Focus = focus;\n            Index = index;\n            Right = right;\n            Count = count;\n        }\n    }\n\n    \/\/\/ Other ImZipper methods\n    public static class ImZipper\n    {\n        \/\/\/ Appends array items to zipper\n        public static ImZipper<T> Zip<T>(params T[] items)\n        {\n            if (items.IsNullOrEmpty())\n                return ImZipper<T>.Empty;\n            var z = ImZipper<T>.Empty;\n            for (var i = 0; i < items.Length; ++i)\n                z = z.PushLeft(items[i]);\n            return z;\n        }\n\n        \/\/\/ Converts to array.\n        public static T[] ToArray<T>(this ImZipper<T> z)\n        {\n            if (z.IsEmpty)\n                return ArrayTools.Empty<T>();\n            var a = new T[z.Count];\n            z.Fold(a, (x, i, xs) =>\n            {\n                xs[i] = x;\n                return xs;\n            });\n            return a;\n        }\n\n        \/\/\/ Shifts focus to a specified index, e.g. a random access\n        public static ImZipper<T> ShiftTo<T>(this ImZipper<T> z, int i)\n        {\n            if (i < 0 || i >= z.Count || i == z.Index)\n                return z;\n            while (i < z.Index)\n                z = z.ShiftLeft();\n            while (i > z.Index)\n                z = z.ShiftRight();\n            return z;\n        }\n\n        \/\/\/ Updates a focus element if it is present, otherwise does nothing.\n        \/\/\/ If the focus item is the equal one, then returns the same zipper back.\n        public static ImZipper<T> Update<T>(this ImZipper<T> z, Func<T, T> update)\n        {\n            if (z.IsEmpty)\n                return z;\n            var result = update(z.Focus);\n            if (ReferenceEquals(z.Focus, result) || result != null && result.Equals(z.Focus))\n                return z;\n            return z.WithFocus(result);\n        }\n\n        \/\/\/ Update the item at random index, by shifting and updating it\n        public static ImZipper<T> UpdateAt<T>(this ImZipper<T> z, int i, Func<T, T> update) =>\n            i < 0 || i >= z.Count ? z : z.ShiftTo(i).Update(update);\n\n        \/\/\/ Update the item at random index, by shifting and updating it\n        public static ImZipper<T> RemoveAt<T>(this ImZipper<T> z, int i) =>\n            i < 0 || i >= z.Count ? z : z.ShiftTo(i).PopLeft();\n\n        \/\/\/ Folds zipper to a single value\n        public static S Fold<T, S>(this ImZipper<T> z, S state, Func<T, S, S> handler) =>\n            z.IsEmpty ? state :\n            z.Right.Fold(handler(z.Focus, z.Left.Reverse().Fold(state, handler)), handler);\n\n        \/\/\/ Folds zipper to a single value by using an item index\n        public static S Fold<T, S>(this ImZipper<T> z, S state, Func<T, int, S, S> handler)\n        {\n            if (z.IsEmpty)\n                return state;\n            var focusIndex = z.Index;\n            var reducedLeft = z.Left.Reverse().Fold(state, handler);\n            return z.Right.Fold(handler(z.Focus, focusIndex, reducedLeft),\n                (x, i, r) => handler(x, focusIndex + i + 1, r));\n        }\n\n        \/\/\/ <summary>Apply some effect action on each element<\/summary>\n        public static void ForEach<T>(this ImZipper<T> z, Action<T> effect)\n        {\n            if (!z.IsEmpty)\n            {\n                if (!z.Left.IsEmpty)\n                    z.Left.Reverse().ForEach(effect);\n                effect(z.Focus);\n                if (!z.Right.IsEmpty)\n                    z.Right.ForEach(effect);\n            }\n        }\n    }\n\n    \/\/\/ Given the old value should and the new value should return result updated value.\n    public delegate V Update<V>(V oldValue, V newValue);\n\n    \/\/\/ Update handler including the key\n    public delegate V Update<K, V>(K key, V oldValue, V newValue);\n\n    \/\/\/ <summary>Entry containing the Value in addition to the Hash<\/summary>\n    public abstract class ImHashMapEntry<K, V> : ImHashMap<K, V>.Entry\n    {\n        \/\/\/ <summary>The value. Maybe modified if you need the Ref{Value} semantics. \n        \/\/\/ You may add the entry with the default Value to the map, and calculate and set it later (e.g. using the CAS).<\/summary>\n        public V Value;\n\n        \/\/\/ <summary>Constructs the entry with the default value<\/summary>\n        protected ImHashMapEntry(int hash) : base(hash) { }\n        \/\/\/ <summary>Constructs the entry with the value<\/summary>\n        protected ImHashMapEntry(int hash, V value) : base(hash) => Value = value;\n\n        \/\/\/ <inheritdoc \/>\n        public sealed override int Count() => 1;\n\n        internal override int ForEach<S>(S state, int startIndex, Action<ImHashMapEntry<K, V>, int, S> handler)\n        {\n            handler(this, startIndex, state);\n            return startIndex + 1;\n        }\n\n#if !DEBUG\n        \/\/\/ <inheritdoc \/>\n        public override string ToString() => \"{K:\" + Key + \",V:\" + Value + \"}\";\n#endif\n    }\n\n    \/\/\/ <summary>Entry containing the Value in addition to the Hash<\/summary>\n    public class VEntry<V> : ImHashMapEntry<int, V>\n    {\n        \/\/\/ <summary>The Key is actually the Hash for this entry and the vice versa.<\/summary>\n        public override int Key => Hash;\n\n        \/\/\/ <summary>Constructs the entry with the default value<\/summary>\n        public VEntry(int hash) : base(hash) { }\n        \/\/\/ <summary>Constructs the entry with the value<\/summary>\n        public VEntry(int hash, V value) : base(hash, value) { }\n\n        internal override ImHashMapEntry<int, V> GetOrNull(int key) => key == Hash ? this : null;\n        internal override ImHashMapEntry<int, V> GetOrNullWithTheSameHash(int key) => this;\n        internal override ImHashMapEntry<int, V> GetOrNullByReferenceEqualsWithTheSameHash(int key) => this;\n        internal override V GetValueOrDefaultByReferenceEqualsWithTheSameHash(int key) => Value;\n        internal override Entry AddWithTheSameKey(ImHashMapEntry<int, V> newEntry) => this;\n        internal override Entry AddOrUpdateWithTheSameHash(ImHashMapEntry<int, V> newEntry) => newEntry;\n        internal override Entry AddOrUpdateWithTheSameHash(ImHashMapEntry<int, V> newEntry, Update<int, V> update) =>\n            ImHashMap.Entry(Hash, update(Hash, Value, newEntry.Value));\n        internal override Entry AddedOrNullWithTheSameHash(ImHashMapEntry<int, V> newEntry) => null;\n        internal override Entry UpdatedOrNullWithTheSameHash(ImHashMapEntry<int, V> newEntry) => newEntry;\n        internal override Entry UpdatedOrNullWithTheSameHash(int key, V value, Update<int, V> update) =>\n            ImHashMap.Entry(Hash, update(Hash, Value, value));\n        internal override Entry RemovedOrNullWithTheSameHash(int key) => this;\n        \/\/\/ <inheritdoc\/>\n        public override Entry AppendOrUpdateInPlaceOrKeep<S>(S state, ImHashMapEntry<int, V> newEntry, UpdaterInPlaceOrKeeper<S> updateOrKeep) =>\n            updateOrKeep(state, this, newEntry) != this ? newEntry : this;\n    }\n\n    \/\/\/ <summary>Entry containing the Key and Value in addition to the Hash<\/summary>\n    public class KVEntry<K, V> : ImHashMapEntry<K, V>\n    {\n        \/\/\/ <summary>The key<\/summary>\n        public override K Key => _key;\n        private readonly K _key;\n\n        \/\/\/ <summary>Constructs the entry with the key and default value<\/summary>\n        public KVEntry(int hash, K key) : base(hash) => _key = key;\n        \/\/\/ <summary>Constructs the entry with the key and value<\/summary>\n        public KVEntry(int hash, K key, V value) : base(hash, value) => _key = key;\n\n        internal override ImHashMapEntry<K, V> GetOrNull(K key) =>\n            _key.Equals(key) ? this : null;\n\n        internal override ImHashMapEntry<K, V> GetOrNullWithTheSameHash(K key) =>\n            _key.Equals(key) ? this : null;\n\n        internal override ImHashMapEntry<K, V> GetOrNullByReferenceEqualsWithTheSameHash(K key) =>\n            ReferenceEquals(_key, key) ? this : null;\n\n        internal override V GetValueOrDefaultByReferenceEqualsWithTheSameHash(K key) =>\n            ReferenceEquals(_key, key) ? Value : default(V);\n\n        internal override Entry AddWithTheSameKey(ImHashMapEntry<K, V> newEntry) =>\n            new HashConflictingEntry(Hash, this, newEntry);\n\n        internal override Entry AddOrUpdateWithTheSameHash(ImHashMapEntry<K, V> newEntry) =>\n            _key.Equals(newEntry.Key) ? newEntry : new HashConflictingEntry(Hash, this, newEntry);\n\n        internal override Entry AddOrUpdateWithTheSameHash(ImHashMapEntry<K, V> newEntry, Update<K, V> update)\n        {\n            var key = _key;\n            return key.Equals(newEntry.Key)\n                ? ImHashMap.Entry(Hash, key, update(key, Value, newEntry.Value))\n                : new HashConflictingEntry(Hash, this, newEntry);\n        }\n\n        internal override Entry AddedOrNullWithTheSameHash(ImHashMapEntry<K, V> newEntry) =>\n            _key.Equals(newEntry.Key) ? null : new HashConflictingEntry(Hash, this, newEntry);\n\n        internal override Entry UpdatedOrNullWithTheSameHash(ImHashMapEntry<K, V> newEntry) =>\n            _key.Equals(newEntry.Key) ? newEntry : null;\n\n        internal override Entry UpdatedOrNullWithTheSameHash(K key, V value, Update<K, V> update)\n        {\n            if (!_key.Equals(key))\n                return null;\n            value = update(key, Value, value);\n            return ReferenceEquals(Value, value) ? null : ImHashMap.Entry(Hash, key, value);\n        }\n\n        internal override Entry RemovedOrNullWithTheSameHash(K key) => _key.Equals(key) ? this : null;\n\n        \/\/\/ <inheritdoc\/>\n        public override Entry AppendOrUpdateInPlaceOrKeep<S>(S state, ImHashMapEntry<K, V> newEntry, UpdaterInPlaceOrKeeper<S> updateOrKeep) =>\n            !Key.Equals(newEntry.Key)\n                ? new HashConflictingEntry(Hash, this, newEntry)\n                : updateOrKeep(state, this, newEntry) != this ? newEntry : this;\n\n#if !DEBUG\n        \/\/\/ <inheritdoc \/>\n        public override string ToString() => \"{H: \" + Hash + \", K: \" + Key + \", V: \" + Value + \"}\";\n#endif\n    }\n\n    \/\/\/ <summary>The base and the holder class for the map tree leafs and branches, also defines the Empty tree.\n    \/\/\/ The map implementation is based on the \"modified\" 2-3 tree.<\/summary>\n    public class ImHashMap<K, V>\n    {\n        \/\/\/ <summary>Hide the base constructor to prevent the multiple Empty trees creation<\/summary>\n        protected ImHashMap() { }\n\n        \/\/\/ <summary>Empty map to start with. Exists as a single instance.<\/summary>\n        public static readonly ImHashMap<K, V> Empty = new ImHashMap<K, V>();\n\n        \/\/\/ <summary>Prints the map tree in JSON-ish format in release mode and enumerates the keys in DEBUG.<\/summary>\n        public override string ToString()\n        {\n#if DEBUG\n            \/\/ for the debug purposes we just output the first N keys in array\n            const int n = 50;\n            var count = this.Count();\n            var hashes = this.Enumerate().Take(n).Select(x => x.Hash).ToList();\n            return $\"{{hashes: new int[{(count > n ? $\"{n}\/{count}\" : \"\" + count)}] {{{(string.Join(\", \", hashes))}}}}}\";\n#else\n            return \"{}\";\n#endif\n        }\n\n        \/\/\/ <summary>Indicates that the map is empty<\/summary>\n        public bool IsEmpty => this == Empty;\n\n        \/\/\/ <summary>The count of entries in the map<\/summary>\n        public virtual int Count() => 0;\n\n        internal virtual bool MayTurnToBranch2 => false;\n\n        internal virtual Entry GetMinHashEntryOrDefault() => null;\n        internal virtual Entry GetMaxHashEntryOrDefault() => null;\n\n        \/\/\/ <summary>Lookup for the entry by hash. \n        \/\/\/ The returned entry maybe either single entry or the `HashConflictEntry` with multiple key-value entries for the same hash.\n        \/\/\/ If hash does not match the method returns `null`<\/summary>\n        internal virtual Entry GetEntryOrNull(int hash) => null;\n\n        \/\/ todo: @wip remove hash from here for simplicity\n        \/\/\/ <summary>Returns the found entry with the same hash or the new map with added new entry.\n        \/\/\/ Note that the empty map will return the entry the same as if the entry was found - so the consumer should check for the empty map.\n        \/\/\/ Note that the method cannot return the `null` - when the existing entry is not found it will always be the new map with the added entry.<\/summary>\n        internal virtual ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry) => entry;\n\n        \/\/\/ <summary>Returns the new map with old entry replaced by the new entry. \n        \/\/\/ Note that the old entry should be present.<\/summary>\n        internal virtual ImHashMap<K, V> ReplaceEntry(Entry oldEntry, Entry newEntry) => Empty;\n\n        \/\/\/ <summary>Removes the certainly present old entry and returns the new map without it.<\/summary>\n        internal virtual ImHashMap<K, V> RemoveEntry(Entry entry) => Empty;\n\n        \/\/\/ <summary>The delegate is supposed to return entry different from the oldEntry to update, and return the oldEntry to keep it.<\/summary>\n        public delegate ImHashMapEntry<K, V> UpdaterInPlaceOrKeeper<S>(S state, ImHashMapEntry<K, V> oldEntry, ImHashMapEntry<K, V> newEntry);\n\n        \/\/\/ <summary>The base map entry for holding the hash (or int key) and payload (possibly empty)<\/summary>\n        public abstract class Entry : ImHashMap<K, V>\n        {\n            \/\/\/ <summary>The Hash<\/summary>\n            public readonly int Hash;\n\n            \/\/\/ <summary>The Key (possibly the same as Hash)<\/summary>\n            public abstract K Key { get; }\n\n            \/\/\/ <summary>Constructs the entry with the hash<\/summary>\n            protected Entry(int hash) => Hash = hash;\n\n            \/\/\/ <summary>Lookup for the entry by Hash and Key<\/summary>\n            internal abstract ImHashMapEntry<K, V> GetOrNull(K key);\n\n            \/\/\/ <summary>Get entry if it has the equal key, assuming the entry has the same hash already.<\/summary>\n            internal abstract ImHashMapEntry<K, V> GetOrNullWithTheSameHash(K key);\n\n            \/\/\/ <summary>Get entry if it has the reference equal key, assuming the entry has the same hash already.<\/summary>\n            internal abstract ImHashMapEntry<K, V> GetOrNullByReferenceEqualsWithTheSameHash(K key);\n\n            \/\/\/ <summary>Get entry if it has the reference equal key, assuming the entry has the same hash already.<\/summary>\n            internal abstract V GetValueOrDefaultByReferenceEqualsWithTheSameHash(K key);\n\n            \/\/\/ <summary>Appends the new entry to the existing entry, assuming the entry has the same key already.\n            \/\/\/ For `VEntry` returns `this` entry.<\/summary>\n            internal abstract Entry AddWithTheSameKey(ImHashMapEntry<K, V> newEntry);\n\n            \/\/\/ <summary>Always returns updated entry or the updated (hash-conflicting) entry with added `newEntry`.<\/summary>\n            internal abstract Entry AddOrUpdateWithTheSameHash(ImHashMapEntry<K, V> newEntry);\n\n            \/\/\/ <summary>Always returns updated entry with the updated value or the updated (hash-conflicting) entry with added `newEntry`<\/summary>\n            internal abstract Entry AddOrUpdateWithTheSameHash(ImHashMapEntry<K, V> newEntry, Update<K, V> update);\n\n            \/\/\/ <summary>Returns either updated entry or `null` if `newEntry.Key` is not found inside<\/summary>\n            internal abstract Entry UpdatedOrNullWithTheSameHash(ImHashMapEntry<K, V> newEntry);\n\n            \/\/\/ <summary>Returns either updated entry or `null` if `newEntry.Key` is not found inside<\/summary>\n            internal abstract Entry UpdatedOrNullWithTheSameHash(K key, V value, Update<K, V> update);\n\n            \/\/\/ <summary>Returns either added entry or `null` if `newEntry.Key` is not found inside<\/summary>\n            internal abstract Entry AddedOrNullWithTheSameHash(ImHashMapEntry<K, V> newEntry);\n\n            \/\/\/ <summary>Returns the `this` entry if the `key` is equals to its key, otherwise null<\/summary>\n            internal abstract Entry RemovedOrNullWithTheSameHash(K key);\n\n            \/\/\/ <summary>Updating the newEntry in place via the provide delegate based on the current (old) entry or\n            \/\/\/ adding the newEntry to the hash-conflicting entry, or keeping the old one.<\/summary>\n            public abstract Entry AppendOrUpdateInPlaceOrKeep<S>(S state, ImHashMapEntry<K, V> newEntry, UpdaterInPlaceOrKeeper<S> updateOrKeep);\n\n            internal override Entry GetMinHashEntryOrDefault() => this;\n            internal override Entry GetMaxHashEntryOrDefault() => this;\n\n            internal sealed override Entry GetEntryOrNull(int hash) => hash == Hash ? this : null;\n\n            \/\/\/ <inheritdoc \/>\n            internal sealed override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry) =>\n                hash > Hash ? new Leaf2(this, entry) : hash < Hash ? new Leaf2(entry, this) : (ImHashMap<K, V>)this;\n\n            internal sealed override ImHashMap<K, V> ReplaceEntry(Entry oldEntry, Entry newEntry)\n            {\n                Debug.Assert(this == oldEntry, \"When down to the entry, the oldEntry should be present in the entry.\");\n                return newEntry;\n            }\n\n            internal sealed override ImHashMap<K, V> RemoveEntry(Entry removedEntry)\n            {\n                Debug.Assert(this == removedEntry, \"When down to the entry, the removedEntry should be present in the entry.\");\n                return Empty;\n            }\n\n            internal abstract int ForEach<S>(S state, int startIndex, Action<ImHashMapEntry<K, V>, int, S> handler);\n        }\n\n        \/\/\/ <summary>The composite containing the list of entries with the same conflicting Hash.<\/summary>\n        internal sealed class HashConflictingEntry : Entry\n        {\n            public ImHashMapEntry<K, V>[] Conflicts;\n\n            public override K Key => throw new NotSupportedException(\"The Key does not make sense foe multi-key entry: \" + this);\n\n            internal HashConflictingEntry(int hash, params ImHashMapEntry<K, V>[] conflicts) : base(hash) => Conflicts = conflicts;\n\n#if !DEBUG\n            public override string ToString()\n            {\n                var sb = new System.Text.StringBuilder(\"HashConflictingEntry: [\");\n                foreach (var x in Conflicts) \n                    sb.Append(x.ToString()).Append(\", \");\n                return sb.Append(\"]\").ToString();\n            }\n#endif\n\n            public override int Count() => Conflicts.Length;\n\n            internal override ImHashMapEntry<K, V> GetOrNull(K key)\n            {\n                var cs = Conflicts;\n                var i = cs.Length - 1;\n                while (i != -1 && !cs[i].Key.Equals(key)) --i;\n                return i != -1 ? cs[i] : null;\n            }\n\n            internal override ImHashMapEntry<K, V> GetOrNullWithTheSameHash(K key) => GetOrNull(key);\n\n            internal override ImHashMapEntry<K, V> GetOrNullByReferenceEqualsWithTheSameHash(K key)\n            {\n                var cs = Conflicts;\n                var i = cs.Length - 1;\n                while (i != -1 && !ReferenceEquals(cs[i].Key, key)) --i;\n                return i != -1 ? cs[i] : null;\n            }\n\n            internal override V GetValueOrDefaultByReferenceEqualsWithTheSameHash(K key)\n            {\n                var cs = Conflicts;\n                var i = cs.Length - 1;\n                while (i != -1 && !ReferenceEquals(cs[i].Key, key)) --i;\n                return i != -1 ? cs[i].Value : default(V);\n            }\n\n            internal override Entry AddWithTheSameKey(ImHashMapEntry<K, V> newEntry) =>\n                new HashConflictingEntry(Hash, Conflicts.AppendToNonEmpty(newEntry));\n\n            internal override Entry AddOrUpdateWithTheSameHash(ImHashMapEntry<K, V> newEntry) =>\n                AddOrUpdateWithTheSameHash(newEntry, null);\n\n            internal override Entry AddOrUpdateWithTheSameHash(ImHashMapEntry<K, V> newEntry, Update<K, V> update)\n            {\n                var key = newEntry.Key;\n                var cs = Conflicts;\n                var i = cs.Length - 1;\n                while (i != -1 && !cs[i].Key.Equals(key)) --i;\n                if (i == -1)\n                    return new HashConflictingEntry(Hash, cs.AppendToNonEmpty(newEntry));\n                if (update != null)\n                    newEntry = ImHashMap.Entry(Hash, key, update(key, cs[i].Value, newEntry.Value));\n                return new HashConflictingEntry(Hash, cs.UpdateNonEmpty(newEntry, i));\n            }\n\n            internal override Entry UpdatedOrNullWithTheSameHash(ImHashMapEntry<K, V> newEntry)\n            {\n                var key = newEntry.Key;\n                var cs = Conflicts;\n                var i = cs.Length - 1;\n                while (i != -1 && !cs[i].Key.Equals(key)) --i;\n                return i == -1 ? null : new HashConflictingEntry(Hash, cs.UpdateNonEmpty(newEntry, i));\n            }\n\n            internal override Entry UpdatedOrNullWithTheSameHash(K key, V value, Update<K, V> update)\n            {\n                var cs = Conflicts;\n                var i = cs.Length - 1;\n                while (i != -1 && !cs[i].Key.Equals(key)) --i;\n                if (i == -1)\n                    return null;\n                if (update != null)\n                {\n                    var oldValue = cs[i].Value;\n                    value = update(key, oldValue, value);\n                    if (ReferenceEquals(oldValue, value))\n                        return null;\n                }\n                return new HashConflictingEntry(Hash, cs.UpdateNonEmpty(ImHashMap.Entry(Hash, key, value), i));\n            }\n\n            internal override Entry AddedOrNullWithTheSameHash(ImHashMapEntry<K, V> newEntry)\n            {\n                var key = newEntry.Key;\n                var cs = Conflicts;\n                var i = cs.Length - 1;\n                while (i != -1 && !cs[i].Key.Equals(key)) --i;\n                if (i != -1)\n                    return null;\n                return new HashConflictingEntry(Hash, cs.AppendToNonEmpty(newEntry));\n            }\n\n            internal override Entry RemovedOrNullWithTheSameHash(K key)\n            {\n                var cs = Conflicts;\n                var n = cs.Length;\n                var i = n - 1;\n                while (i != -1 && !cs[i].Key.Equals(key)) --i;\n                if (i == -1)\n                    return null;\n                if (n == 2)\n                    return i == 0 ? cs[1] : cs[0];\n                var newConflicts = new KVEntry<K, V>[n -= 1]; \/\/ the new n is less by one\n                if (i > 0) \/\/ copy the 1st part\n                    Array.Copy(cs, 0, newConflicts, 0, i);\n                if (i < n) \/\/ copy the 2nd part\n                    Array.Copy(cs, i + 1, newConflicts, i, n - i);\n                return new HashConflictingEntry(Hash, newConflicts);\n            }\n\n            \/\/\/ <inheritdoc\/>\n            public override Entry AppendOrUpdateInPlaceOrKeep<S>(S state, ImHashMapEntry<K, V> newEntry, UpdaterInPlaceOrKeeper<S> updateOrKeep)\n            {\n                var key = newEntry.Key;\n                var cs = Conflicts;\n                var i = cs.Length - 1;\n                while (i != -1 && !key.Equals(cs[i].Key)) --i;\n                if (i == -1)\n                    return new HashConflictingEntry(Hash, cs.AppendToNonEmpty(newEntry));\n                var oldEntry = cs[i];\n                if (updateOrKeep(state, oldEntry, newEntry) != oldEntry)\n                    return new HashConflictingEntry(Hash, cs.UpdateNonEmpty(newEntry, i));\n                return this;\n            }\n\n            internal override int ForEach<S>(S state, int startIndex, Action<ImHashMapEntry<K, V>, int, S> handler)\n            {\n                var i = startIndex;\n                foreach (var e in Conflicts)\n                    handler(e, i++, state);\n                return i;\n            }\n        }\n\n        \/\/\/ <summary>Leaf with 2 hash-ordered entries. Important: the both or either of entries may be null for the removed entries<\/summary>\n        internal sealed class Leaf2 : ImHashMap<K, V>\n        {\n            public readonly Entry Entry0, Entry1;\n            public Leaf2(Entry e0, Entry e1)\n            {\n                Debug.Assert(e0.Hash < e1.Hash);\n                Entry0 = e0; Entry1 = e1;\n            }\n\n            public override int Count() => Entry0.Count() + Entry1.Count();\n\n#if !DEBUG\n            public override string ToString() => \"{L2:{E0: \" + Entry0 + \",E1:\" + Entry1 + \"}}\";\n#endif\n\n            internal override Entry GetMinHashEntryOrDefault() => Entry0;\n            internal override Entry GetMaxHashEntryOrDefault() => Entry1;\n\n            internal override Entry GetEntryOrNull(int hash) =>\n                Entry0.Hash == hash ? Entry0 : Entry1.Hash == hash ? Entry1 : null;\n\n            internal override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry) =>\n                hash == Entry0.Hash ? Entry0 : hash == Entry1.Hash ? Entry1 : (ImHashMap<K, V>)new Leaf2Plus(entry, this);\n\n            internal override ImHashMap<K, V> ReplaceEntry(Entry oldEntry, Entry newEntry) =>\n                oldEntry == Entry0 ? new Leaf2(newEntry, Entry1) : new Leaf2(Entry0, newEntry);\n\n            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry) =>\n                Entry0 == removedEntry ? Entry1 : Entry0;\n        }\n\n        \/\/\/ <summary>The leaf containing the Leaf2 plus the newest added entry.<\/summary>\n        internal sealed class Leaf2Plus : ImHashMap<K, V>\n        {\n            public readonly Entry Plus;\n            public readonly Leaf2 L;\n            public Leaf2Plus(Entry plus, Leaf2 leaf)\n            {\n                Plus = plus;\n                L = leaf;\n            }\n\n            public override int Count() => Plus.Count() + L.Entry0.Count() + L.Entry1.Count();\n\n#if !DEBUG\n            public override string ToString() => \"{L21: {P: \" + Plus + \", L: \" + L + \"}}\";\n#endif\n\n            internal override Entry GetMinHashEntryOrDefault() => Plus.Hash < L.Entry0.Hash ? Plus : L.Entry0;\n            internal override Entry GetMaxHashEntryOrDefault() => Plus.Hash > L.Entry1.Hash ? Plus : L.Entry1;\n\n            internal override Entry GetEntryOrNull(int hash)\n            {\n                if (hash == Plus.Hash)\n                    return Plus;\n                var l = L;\n                return hash == l.Entry0.Hash ? l.Entry0 : hash == l.Entry1.Hash ? l.Entry1 : null;\n            }\n\n            internal override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry)\n            {\n                var p = Plus;\n                if (hash == p.Hash)\n                    return p;\n                var l = L;\n                return hash == l.Entry0.Hash ? l.Entry0 : hash == l.Entry1.Hash ? l.Entry1 : (ImHashMap<K, V>)new Leaf2PlusPlus(entry, this);\n            }\n\n            internal override ImHashMap<K, V> ReplaceEntry(Entry oldEntry, Entry newEntry) =>\n                oldEntry == Plus ? new Leaf2Plus(newEntry, L) :\n                oldEntry == L.Entry0 ? new Leaf2Plus(Plus, new Leaf2(newEntry, L.Entry1)) :\n                                       new Leaf2Plus(Plus, new Leaf2(L.Entry0, newEntry));\n\n            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry) =>\n                removedEntry == Plus ? L :\n                removedEntry == L.Entry0 ?\n                    (Plus.Hash < L.Entry1.Hash ? new Leaf2(Plus, L.Entry1) : new Leaf2(L.Entry1, Plus)) :\n                    (Plus.Hash < L.Entry0.Hash ? new Leaf2(Plus, L.Entry0) : new Leaf2(L.Entry0, Plus));\n        }\n\n        \/\/\/ <summary>Leaf with the Leaf2 plus added entry, plus added entry<\/summary>\n        internal sealed class Leaf2PlusPlus : ImHashMap<K, V>\n        {\n            public readonly Entry Plus;\n            public readonly Leaf2Plus L;\n\n            public Leaf2PlusPlus(Entry plus, Leaf2Plus l)\n            {\n                Plus = plus;\n                L = l;\n            }\n\n            public override int Count() => Plus.Count() + L.Count();\n\n#if !DEBUG\n            public override string ToString() => \"{L211:{P:\" + Plus + \",L:\" + L + \"}}\";\n#endif\n\n            internal override Entry GetMinHashEntryOrDefault()\n            {\n                Entry p = Plus, pp = L.Plus, e0 = L.L.Entry0;\n                return p.Hash < pp.Hash ? (p.Hash < e0.Hash ? p : e0) : (pp.Hash < e0.Hash ? pp : e0);\n            }\n            internal override Entry GetMaxHashEntryOrDefault()\n            {\n                Entry p = Plus, pp = L.Plus, e1 = L.L.Entry1;\n                return p.Hash > pp.Hash ? (p.Hash > e1.Hash ? p : e1) : (pp.Hash > e1.Hash ? pp : e1);\n            }\n\n            internal override Entry GetEntryOrNull(int hash)\n            {\n                if (hash == Plus.Hash)\n                    return Plus;\n                if (hash == L.Plus.Hash)\n                    return L.Plus;\n                var l = L.L;\n                return l.Entry0.Hash == hash ? l.Entry0 : l.Entry1.Hash == hash ? l.Entry1 : null;\n            }\n\n            internal override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry)\n            {\n                var p = Plus;\n                var ph = p.Hash;\n                if (ph == hash)\n                    return p;\n\n                var pp = L.Plus;\n                var pph = pp.Hash;\n                if (pph == hash)\n                    return pp;\n\n                var l = L.L;\n                Entry e0 = l.Entry0, e1 = l.Entry1;\n\n                if (hash == e0.Hash)\n                    return e0;\n                if (hash == e1.Hash)\n                    return e1;\n\n                ImHashMap.InsertInOrder(pph, ref pp, ref e0, ref e1);\n                ImHashMap.InsertInOrder(ph, ref p, ref e0, ref e1, ref pp);\n                ImHashMap.InsertInOrder(hash, ref entry, ref e0, ref e1, ref pp, ref p);\n\n                return new Leaf5(e0, e1, pp, p, entry);\n            }\n\n            internal override ImHashMap<K, V> ReplaceEntry(Entry oldEntry, Entry newEntry) =>\n                oldEntry == Plus ? new Leaf2PlusPlus(newEntry, L) :\n                oldEntry == L.Plus ? new Leaf2PlusPlus(Plus, new Leaf2Plus(newEntry, L.L)) :\n                oldEntry == L.L.Entry0 ? new Leaf2PlusPlus(Plus, new Leaf2Plus(L.Plus, new Leaf2(newEntry, L.L.Entry1))) :\n                                         new Leaf2PlusPlus(Plus, new Leaf2Plus(L.Plus, new Leaf2(L.L.Entry0, newEntry)));\n\n            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry) =>\n                removedEntry == Plus ? L :\n                removedEntry == L.Plus ? new Leaf2Plus(Plus, L.L) :\n                removedEntry == L.L.Entry0 ?\n                    (L.Plus.Hash < L.L.Entry1.Hash ? new Leaf2Plus(Plus, new Leaf2(L.Plus, L.L.Entry1)) : new Leaf2Plus(Plus, new Leaf2(L.L.Entry1, L.Plus))) :\n                    (L.Plus.Hash < L.L.Entry0.Hash ? new Leaf2Plus(Plus, new Leaf2(L.Plus, L.L.Entry0)) : new Leaf2Plus(Plus, new Leaf2(L.L.Entry0, L.Plus)));\n        }\n\n        \/\/\/ <summary>Leaf with 5 hash-ordered entries<\/summary>\n        internal sealed class Leaf5 : ImHashMap<K, V>\n        {\n            public readonly Entry Entry0, Entry1, Entry2, Entry3, Entry4;\n\n            public Leaf5(Entry e0, Entry e1, Entry e2, Entry e3, Entry e4)\n            {\n                Debug.Assert(e0.Hash < e1.Hash, \"e0 < e1\");\n                Debug.Assert(e1.Hash < e2.Hash, \"e1 < e2\");\n                Debug.Assert(e2.Hash < e3.Hash, \"e2 < e3\");\n                Debug.Assert(e3.Hash < e4.Hash, \"e3 < e4\");\n                Entry0 = e0; Entry1 = e1; Entry2 = e2; Entry3 = e3; Entry4 = e4;\n            }\n\n            public override int Count() => Entry0.Count() + Entry1.Count() + Entry2.Count() + Entry3.Count() + Entry4.Count();\n\n#if !DEBUG\n            public override string ToString() => \n                \"{L2:{E0:\" + Entry0 + \",E1:\" + Entry1 + \",E2:\" + Entry2 + \",E3:\" + Entry3 + \",E4:\" + Entry4 + \"}}\";\n#endif\n\n            internal override Entry GetMinHashEntryOrDefault() => Entry0;\n            internal override Entry GetMaxHashEntryOrDefault() => Entry4;\n\n            internal override Entry GetEntryOrNull(int hash) =>\n                hash == Entry0.Hash ? Entry0 :\n                hash == Entry1.Hash ? Entry1 :\n                hash == Entry2.Hash ? Entry2 :\n                hash == Entry3.Hash ? Entry3 :\n                hash == Entry4.Hash ? Entry4 :\n                null;\n\n            internal override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry) =>\n                hash == Entry0.Hash ? Entry0 :\n                hash == Entry1.Hash ? Entry1 :\n                hash == Entry2.Hash ? Entry2 :\n                hash == Entry3.Hash ? Entry3 :\n                hash == Entry4.Hash ? Entry4 :\n                (ImHashMap<K, V>)new Leaf5Plus(entry, this);\n\n            internal override ImHashMap<K, V> ReplaceEntry(Entry oldEntry, Entry newEntry) =>\n                oldEntry == Entry0 ? new Leaf5(newEntry, Entry1, Entry2, Entry3, Entry4) :\n                oldEntry == Entry1 ? new Leaf5(Entry0, newEntry, Entry2, Entry3, Entry4) :\n                oldEntry == Entry2 ? new Leaf5(Entry0, Entry1, newEntry, Entry3, Entry4) :\n                oldEntry == Entry3 ? new Leaf5(Entry0, Entry1, Entry2, newEntry, Entry4) :\n                                     new Leaf5(Entry0, Entry1, Entry2, Entry3, newEntry);\n\n            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry) =>\n                removedEntry == Entry0 ? new Leaf2PlusPlus(Entry4, new Leaf2Plus(Entry3, new Leaf2(Entry1, Entry2))) :\n                removedEntry == Entry1 ? new Leaf2PlusPlus(Entry4, new Leaf2Plus(Entry3, new Leaf2(Entry0, Entry2))) :\n                removedEntry == Entry2 ? new Leaf2PlusPlus(Entry4, new Leaf2Plus(Entry3, new Leaf2(Entry0, Entry1))) :\n                removedEntry == Entry3 ? new Leaf2PlusPlus(Entry4, new Leaf2Plus(Entry2, new Leaf2(Entry0, Entry1))) :\n                                         new Leaf2PlusPlus(Entry3, new Leaf2Plus(Entry2, new Leaf2(Entry0, Entry1)));\n        }\n\n        \/\/\/ <summary>Leaf with 5 existing ordered entries plus 1 newly added entry.<\/summary>\n        internal sealed class Leaf5Plus : ImHashMap<K, V>\n        {\n            public readonly Entry Plus;\n            public readonly Leaf5 L;\n\n            public Leaf5Plus(Entry plus, Leaf5 l)\n            {\n                Plus = plus;\n                L = l;\n            }\n\n            public override int Count() => Plus.Count() + L.Count();\n\n#if !DEBUG\n            public override string ToString() => \"{L51:{P:\" + Plus + \",L:\" + L + \"}}\";\n#endif\n\n            internal override Entry GetMinHashEntryOrDefault() => Plus.Hash < L.Entry0.Hash ? Plus : L.Entry0;\n            internal override Entry GetMaxHashEntryOrDefault() => Plus.Hash > L.Entry4.Hash ? Plus : L.Entry4;\n\n            internal override Entry GetEntryOrNull(int hash)\n            {\n                if (hash == Plus.Hash)\n                    return Plus;\n                var l = L;\n                return hash == l.Entry0.Hash ? l.Entry0\n                     : hash == l.Entry1.Hash ? l.Entry1\n                     : hash == l.Entry2.Hash ? l.Entry2\n                     : hash == l.Entry3.Hash ? l.Entry3\n                     : hash == l.Entry4.Hash ? l.Entry4\n                     : null;\n            }\n\n            internal override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry)\n            {\n                var p = Plus;\n                var ph = p.Hash;\n                if (ph == hash)\n                    return p;\n                var l = L;\n                return hash == l.Entry0.Hash ? l.Entry0\n                     : hash == l.Entry1.Hash ? l.Entry1\n                     : hash == l.Entry2.Hash ? l.Entry2\n                     : hash == l.Entry3.Hash ? l.Entry3\n                     : hash == l.Entry4.Hash ? l.Entry4\n                     : (ImHashMap<K, V>)new Leaf5PlusPlus(entry, this);\n            }\n\n            internal override ImHashMap<K, V> ReplaceEntry(Entry oldEntry, Entry newEntry)\n            {\n                var p = Plus;\n                if (oldEntry == p)\n                    return new Leaf5Plus(newEntry, L);\n                var l = L;\n                Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4;\n                return oldEntry == e0 ? new Leaf5Plus(p, new Leaf5(newEntry, e1, e2, e3, e4))\n                    : oldEntry == e1 ? new Leaf5Plus(p, new Leaf5(e0, newEntry, e2, e3, e4))\n                    : oldEntry == e2 ? new Leaf5Plus(p, new Leaf5(e0, e1, newEntry, e3, e4))\n                    : oldEntry == e3 ? new Leaf5Plus(p, new Leaf5(e0, e1, e2, newEntry, e4))\n                    : new Leaf5Plus(p, new Leaf5(e0, e1, e2, e3, newEntry));\n            }\n\n            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry)\n            {\n                var p = Plus;\n                if (p == removedEntry)\n                    return L;\n\n                var l = L;\n                Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4;\n                ImHashMap.InsertInOrder(p.Hash, ref p, ref e0, ref e1, ref e2, ref e3, ref e4);\n\n                return removedEntry == e0 ? new Leaf5(e1, e2, e3, e4, p)\n                    : removedEntry == e1 ? new Leaf5(e0, e2, e3, e4, p)\n                    : removedEntry == e2 ? new Leaf5(e0, e1, e3, e4, p)\n                    : removedEntry == e3 ? new Leaf5(e0, e1, e2, e4, p)\n                    : removedEntry == e4 ? new Leaf5(e0, e1, e2, e3, p)\n                    : new Leaf5(e0, e1, e2, e3, e4);\n            }\n        }\n\n        \/\/\/ <summary>Leaf with 5 existing ordered entries plus 1 newly added, plus 1 newly added.<\/summary>\n        internal sealed class Leaf5PlusPlus : ImHashMap<K, V>\n        {\n            public readonly Entry Plus;\n            public readonly Leaf5Plus L;\n            public Leaf5PlusPlus(Entry plus, Leaf5Plus l)\n            {\n                Plus = plus;\n                L = l;\n            }\n\n            public sealed override int Count() => Plus.Count() + L.Count();\n\n            internal override bool MayTurnToBranch2 => true;\n\n#if !DEBUG\n            public override string ToString() => \"{L511:{P:\" + Plus + \",L:\" + L + \"}}\";\n#endif\n\n            internal sealed override Entry GetMinHashEntryOrDefault()\n            {\n                Entry p = Plus, pp = L.Plus, e0 = L.L.Entry0;\n                return p.Hash < pp.Hash ? (p.Hash < e0.Hash ? p : e0) : (pp.Hash < e0.Hash ? pp : e0);\n            }\n            internal sealed override Entry GetMaxHashEntryOrDefault()\n            {\n                Entry p = Plus, pp = L.Plus, e4 = L.L.Entry4;\n                return p.Hash > pp.Hash ? (p.Hash > e4.Hash ? p : e4) : (pp.Hash > e4.Hash ? pp : e4);\n            }\n\n            internal override Entry GetEntryOrNull(int hash)\n            {\n                if (hash == Plus.Hash)\n                    return Plus;\n                if (hash == L.Plus.Hash)\n                    return L.Plus;\n                var l = L.L;\n                return hash == l.Entry0.Hash ? l.Entry0\n                     : hash == l.Entry1.Hash ? l.Entry1\n                     : hash == l.Entry2.Hash ? l.Entry2\n                     : hash == l.Entry3.Hash ? l.Entry3\n                     : hash == l.Entry4.Hash ? l.Entry4\n                     : null;\n            }\n\n            internal override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry)\n            {\n                ImHashMap<K, V> splitRight = null;\n                var entryOrNewMap = AddOrGetEntry(hash, ref entry, ref splitRight);\n                if (splitRight != null)\n                    return new Branch2(entryOrNewMap, entry, splitRight);\n                return entryOrNewMap;\n            }\n\n            internal ImHashMap<K, V> AddOrGetEntry(int hash, ref Entry entry, ref ImHashMap<K, V> splitRight)\n            {\n                var p = Plus;\n                var ph = p.Hash;\n                if (ph == hash)\n                    return p;\n\n                var pp = L.Plus;\n                var pph = pp.Hash;\n                if (pph == hash)\n                    return pp;\n\n                var l = L.L;\n                var e0 = l.Entry0;\n                if (hash == e0.Hash)\n                    return e0;\n                var e1 = l.Entry1;\n                if (hash == e1.Hash)\n                    return e1;\n                var e2 = l.Entry2;\n                if (hash == e2.Hash)\n                    return e2;\n                var e3 = l.Entry3;\n                if (hash == e3.Hash)\n                    return e3;\n                var e4 = l.Entry4;\n                if (hash == e4.Hash)\n                    return e4;\n\n                var right = hash > e4.Hash && ph > e4.Hash && pph > e4.Hash;\n                var left = !right && hash < e0.Hash && ph < e0.Hash && pph < e0.Hash;\n\n                Entry e = entry; \/\/ store the entry original value cause we may change it for the result\n                ImHashMap.InsertInOrder(pph, ref pp, ref e0, ref e1, ref e2, ref e3, ref e4);\n                ImHashMap.InsertInOrder(ph, ref p, ref e0, ref e1, ref e2, ref e3, ref e4, ref pp);\n                ImHashMap.InsertInOrder(hash, ref e, ref e0, ref e1, ref e2, ref e3, ref e4, ref pp, ref p);\n\n                if (left)\n                {\n                    entry = e2;\n                    splitRight = l;\n                    return new Leaf2(e0, e1);\n                }\n\n                entry = pp;\n                splitRight = new Leaf2(p, e);\n                return right ? l : new Leaf5(e0, e1, e2, e3, e4);\n            }\n\n            internal ImHashMap<K, V> AddEntry(int hash, ref Entry entry, ref ImHashMap<K, V> splitRight)\n            {\n                var l = L.L;\n                Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4, pp = L.Plus, p = Plus;\n                int ph = p.Hash, pph = pp.Hash;\n\n                var right = hash > e4.Hash && ph > e4.Hash && pph > e4.Hash;\n                var left = !right && hash < e0.Hash && ph < e0.Hash && pph < e0.Hash;\n\n                var e = entry; \/\/ store the entry original value cause we may change it for the result\n                ImHashMap.InsertInOrder(pph, ref pp, ref e0, ref e1, ref e2, ref e3, ref e4);\n                ImHashMap.InsertInOrder(ph, ref p, ref e0, ref e1, ref e2, ref e3, ref e4, ref pp);\n                ImHashMap.InsertInOrder(hash, ref e, ref e0, ref e1, ref e2, ref e3, ref e4, ref pp, ref p);\n\n                if (left)\n                {\n                    entry = e2;\n                    splitRight = l;\n                    return new Leaf2(e0, e1);\n                }\n\n                entry = pp;\n                splitRight = new Leaf2(p, e);\n                return right ? l : new Leaf5(e0, e1, e2, e3, e4);\n            }\n\n            internal override ImHashMap<K, V> ReplaceEntry(Entry oldEntry, Entry newEntry)\n            {\n                var p = Plus;\n                if (p == oldEntry)\n                    return new Leaf5PlusPlus(newEntry, L);\n\n                var pp = L.Plus;\n                if (pp == oldEntry)\n                    return new Leaf5PlusPlus(p, new Leaf5Plus(newEntry, L.L));\n\n                var l = L.L;\n                Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4;\n                return\n                    oldEntry == e0 ? new Leaf5PlusPlus(p, new Leaf5Plus(pp, new Leaf5(newEntry, e1, e2, e3, e4))) :\n                    oldEntry == e1 ? new Leaf5PlusPlus(p, new Leaf5Plus(pp, new Leaf5(e0, newEntry, e2, e3, e4))) :\n                    oldEntry == e2 ? new Leaf5PlusPlus(p, new Leaf5Plus(pp, new Leaf5(e0, e1, newEntry, e3, e4))) :\n                    oldEntry == e3 ? new Leaf5PlusPlus(p, new Leaf5Plus(pp, new Leaf5(e0, e1, e2, newEntry, e4))) :\n                                     new Leaf5PlusPlus(p, new Leaf5Plus(pp, new Leaf5(e0, e1, e2, e3, newEntry)));\n            }\n\n            internal ImHashMap<K, V> RemoveMinHashEntryAndAddNewEntry(Entry minEntry, Entry newEntry)\n            {\n                var p = Plus;\n                if (p == minEntry)\n                    return new Leaf5PlusPlus(newEntry, L);\n\n                var pp = L.Plus;\n                if (pp == minEntry)\n                    return new Leaf5PlusPlus(p, new Leaf5Plus(newEntry, L.L));\n\n                var l = L.L;\n                Entry e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4;\n                var hash = newEntry.Hash;\n                l = hash < e1.Hash ? new Leaf5(newEntry, e1, e2, e3, e4)\n                : hash < e2.Hash ? new Leaf5(e1, newEntry, e2, e3, e4)\n                : hash < e3.Hash ? new Leaf5(e1, e2, newEntry, e3, e4)\n                : hash < e4.Hash ? new Leaf5(e1, e2, e3, newEntry, e4)\n                : new Leaf5(e1, e2, e3, e4, newEntry);\n\n                return new Leaf5PlusPlus(p, new Leaf5Plus(pp, l));\n            }\n\n            internal ImHashMap<K, V> RemoveMaxHashEntryAndAddNewEntry(Entry maxEntry, Entry newEntry)\n            {\n                var p = Plus;\n                if (p == maxEntry)\n                    return new Leaf5PlusPlus(newEntry, L);\n\n                var pp = L.Plus;\n                if (pp == maxEntry)\n                    return new Leaf5PlusPlus(p, new Leaf5Plus(newEntry, L.L));\n\n                var l = L.L;\n                Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3;\n                var hash = newEntry.Hash;\n                l = hash < e0.Hash ? new Leaf5(newEntry, e0, e1, e2, e3)\n                : hash < e1.Hash ? new Leaf5(e0, newEntry, e1, e2, e3)\n                : hash < e2.Hash ? new Leaf5(e0, e1, newEntry, e2, e3)\n                : hash < e3.Hash ? new Leaf5(e0, e1, e2, newEntry, e3)\n                : new Leaf5(e0, e1, e2, e3, newEntry);\n\n                return new Leaf5PlusPlus(p, new Leaf5Plus(pp, l));\n            }\n\n            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry)\n            {\n                var p = Plus;\n                if (p == removedEntry)\n                    return L;\n\n                var pp = L.Plus;\n                if (pp == removedEntry)\n                    return new Leaf5Plus(p, L.L);\n\n                var l = L.L;\n                Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4;\n                int pph = pp.Hash, ph = p.Hash;\n\n                ImHashMap.InsertInOrder(pph, ref pp, ref e0, ref e1, ref e2, ref e3, ref e4);\n                ImHashMap.InsertInOrder(ph, ref p, ref e0, ref e1, ref e2, ref e3, ref e4, ref pp);\n\n                return removedEntry == e0 ? new Leaf5Plus(p, new Leaf5(e1, e2, e3, e4, pp))\n                    : removedEntry == e1 ? new Leaf5Plus(p, new Leaf5(e0, e2, e3, e4, pp))\n                    : removedEntry == e2 ? new Leaf5Plus(p, new Leaf5(e0, e1, e3, e4, pp))\n                    : removedEntry == e3 ? new Leaf5Plus(p, new Leaf5(e0, e1, e2, e4, pp))\n                    : removedEntry == e4 ? new Leaf5Plus(p, new Leaf5(e0, e1, e2, e3, pp))\n                    : removedEntry == pp ? new Leaf5Plus(p, new Leaf5(e0, e1, e2, e3, e4))\n                    : new Leaf5Plus(pp, new Leaf5(e0, e1, e2, e3, e4));\n            }\n        }\n\n        \/\/\/ <summary>The 2 branches with the node in between<\/summary>\n        internal sealed class Branch2 : ImHashMap<K, V>\n        {\n            public readonly Entry MidEntry;\n            public readonly ImHashMap<K, V> Left, Right;\n            public Branch2(ImHashMap<K, V> left, Entry entry, ImHashMap<K, V> right)\n            {\n                Debug.Assert(left != Empty && right != Empty, $\"left:{left} != Empty && right:{right} != Empty\");\n                MidEntry = entry;\n                Left = left;\n                Right = right;\n            }\n\n            public override int Count() => MidEntry.Count() + Left.Count() + Right.Count();\n\n#if !DEBUG\n            public override string ToString() => \"{B2:{E:\" + MidEntry + \",L:\" + Left + \",R:\" + Right + \"}}\";\n#endif\n\n            internal override Entry GetMinHashEntryOrDefault() => Left.GetMinHashEntryOrDefault();\n            internal override Entry GetMaxHashEntryOrDefault() => Right.GetMaxHashEntryOrDefault();\n\n            internal override Entry GetEntryOrNull(int hash)\n            {\n                var mh = MidEntry.Hash;\n                return hash > mh ? Right.GetEntryOrNull(hash)\n                    : hash < mh ? Left.GetEntryOrNull(hash)\n                    : MidEntry;\n            }\n\n            internal override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry)\n            {\n                var me = MidEntry;\n                ImHashMap<K, V> entryOrNewBranch = null;\n                if (hash > me.Hash)\n                {\n                    var right = Right;\n                    if (right is Leaf5PlusPlus rl511)\n                    {\n                        \/\/ if (Left is Leaf2 l2)\n                        \/\/ {\n                        \/\/     var e = rl511.GetEntryOrNull(hash);\n                        \/\/     if (e != null)\n                        \/\/         return e;\n                        \/\/     var rMin = rl511.GetMinHashEntryOrDefault();\n                        \/\/     if (hash < rMin.Hash)\n                        \/\/         return new Branch2(new Leaf2Plus(me, l2), entry, rl511);\n                        \/\/     if (rMin == rl511.Plus)\n                        \/\/         return new Branch2(new Leaf2Plus(me, l2), rMin, new Leaf5PlusPlus(entry, rl511.L));\n                        \/\/     if (rMin == rl511.L.Plus)\n                        \/\/         return new Branch2(new Leaf2Plus(me, l2), rMin, new Leaf5PlusPlus(entry, new Leaf5Plus(rl511.Plus, rl511.L.L)));\n                        \/\/     return new Branch2Plus1(entry, this);\n                        \/\/ }\n                        \n                        \/\/ if (Left is Leaf2Plus l2p)\n                        \/\/ {\n                        \/\/     var e = rl511.GetEntryOrNull(hash);\n                        \/\/     if (e != null)\n                        \/\/         return e;\n                        \/\/     var rMin = rl511.GetMinHashEntryOrDefault();\n                        \/\/     if (hash < rMin.Hash)\n                        \/\/         return new Branch2(new Leaf2PlusPlus(me, l2p), entry, rl511);\n                        \/\/     if (rMin == rl511.Plus)\n                        \/\/         return new Branch2(new Leaf2PlusPlus(me, l2p), rMin, new Leaf5PlusPlus(entry, rl511.L));\n                        \/\/     if (rMin == rl511.L.Plus)\n                        \/\/         return new Branch2(new Leaf2PlusPlus(me, l2p), rMin, new Leaf5PlusPlus(entry, new Leaf5Plus(rl511.Plus, rl511.L.L)));\n                        \/\/     return new Branch2Plus1(entry, this);\n                        \/\/ }\n\n                        \/\/ optimizing the split by postponing it by introducing the branch 2 plus 1\n                        if (Left is Leaf5PlusPlus == false)\n                            return rl511.GetEntryOrNull(hash) ?? (ImHashMap<K, V>)new Branch2Plus1(entry, this);\n\n                        ImHashMap<K, V> splitRight = null;\n                        entryOrNewBranch = rl511.AddOrGetEntry(hash, ref entry, ref splitRight);\n                        \/\/ if split is `null` then the only reason is that hash is found\n                        return splitRight != null ? new Branch3(Left, me, entryOrNewBranch, entry, splitRight) : entryOrNewBranch;\n                    }\n\n                    if (right is Branch3Base rb3)\n                    {\n                        ImHashMap<K, V> splitRight = null;\n                        entryOrNewBranch = rb3.AddOrGetEntry(hash, ref entry, ref splitRight);\n                        if (splitRight != null)\n                            return new Branch3(Left, me, entryOrNewBranch, entry, splitRight);\n                    }\n                    else entryOrNewBranch = right.AddOrGetEntry(hash, entry);\n\n                    return entryOrNewBranch is Entry ? entryOrNewBranch : new Branch2(Left, me, entryOrNewBranch);\n                }\n\n                if (hash < me.Hash)\n                {\n                    var left = Left;\n                    if (left is Leaf5PlusPlus ll511)\n                    {\n                        \/\/ if (Right is Leaf2 l2)\n                        \/\/ {\n                        \/\/     var e = ll511.GetEntryOrNull(hash);\n                        \/\/     if (e != null)\n                        \/\/         return e;\n                        \/\/     var lMax = ll511.GetMaxHashEntryOrDefault();\n                        \/\/     if (hash > lMax.Hash)\n                        \/\/         return new Branch2(ll511, entry, new Leaf2Plus(me, l2));\n                        \/\/     if (lMax == ll511.Plus)\n                        \/\/         return new Branch2(new Leaf5PlusPlus(entry, ll511.L), lMax, new Leaf2Plus(me, l2));\n                        \/\/     if (lMax == ll511.L.Plus)\n                        \/\/         return new Branch2(new Leaf5PlusPlus(entry, new Leaf5Plus(ll511.Plus, ll511.L.L)), lMax, new Leaf2Plus(me, l2));\n                        \/\/     return new Branch2Plus1(entry, this);\n                        \/\/ }\n\n                        \/\/ if (Right is Leaf2Plus l2p)\n                        \/\/ {\n                        \/\/     var e = ll511.GetEntryOrNull(hash);\n                        \/\/     if (e != null)\n                        \/\/         return e;\n                        \/\/     var lMax = ll511.GetMaxHashEntryOrDefault();\n                        \/\/     if (hash > lMax.Hash)\n                        \/\/         return new Branch2(ll511, entry, new Leaf2PlusPlus(me, l2p));\n                        \/\/     if (lMax == ll511.Plus)\n                        \/\/         return new Branch2(new Leaf5PlusPlus(entry, ll511.L), lMax, new Leaf2PlusPlus(me, l2p));\n                        \/\/     if (lMax == ll511.L.Plus)\n                        \/\/         return new Branch2(new Leaf5PlusPlus(entry, new Leaf5Plus(ll511.Plus, ll511.L.L)), lMax, new Leaf2PlusPlus(me, l2p));\n                        \/\/     return new Branch2Plus1(entry, this);\n                        \/\/ }\n\n                        if (Right is Leaf5PlusPlus == false)\n                            return ll511.GetEntryOrNull(hash) ?? (ImHashMap<K, V>)new Branch2Plus1(entry, this);\n\n                        ImHashMap<K, V> splitRight = null;\n                        entryOrNewBranch = ll511.AddOrGetEntry(hash, ref entry, ref splitRight);\n                        return splitRight != null ? new Branch3(entryOrNewBranch, entry, splitRight, me, Right) : (ImHashMap<K, V>)entryOrNewBranch;\n                    }\n\n                    if (left is Branch3Base lb3)\n                    {\n                        ImHashMap<K, V> splitRight = null;\n                        entryOrNewBranch = lb3.AddOrGetEntry(hash, ref entry, ref splitRight);\n                        if (splitRight != null)\n                            return new Branch3(entryOrNewBranch, entry, splitRight, me, Right);\n                    }\n                    else entryOrNewBranch = left.AddOrGetEntry(hash, entry);\n\n                    return entryOrNewBranch is Entry ? entryOrNewBranch : new Branch2(entryOrNewBranch, me, Right);\n                }\n\n                return me;\n            }\n\n            internal override ImHashMap<K, V> ReplaceEntry(Entry oldEntry, Entry newEntry)\n            {\n                int hash = oldEntry.Hash, h = MidEntry.Hash;\n                return hash > h ? new Branch2(Left, MidEntry, Right.ReplaceEntry(oldEntry, newEntry))\n                    : hash < h ? new Branch2(Left.ReplaceEntry(oldEntry, newEntry), MidEntry, Right)\n                    : new Branch2(Left, newEntry, Right);\n            }\n\n            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry)\n            {\n                \/\/ The downward phase for deleting an element from a 2-3 tree is the same as the downward phase\n                \/\/ for inserting an element except for the case when the element to be deleted is equal to the value in\n                \/\/ a 2-node or a 3-node. In this case, if the value is not part of a terminal node, the value is replaced\n                \/\/ by its in-order predecessor or in-order successor, just as in binary search tree deletion. So in any\n                \/\/ case, deletion leaves a hole in a terminal node.\n                \/\/ The goal of the rest of the deletion algorithm is to remove the hole without violating the other\n                \/\/ invariants of the 2-3 tree.\n\n                var mid = MidEntry;\n                if (removedEntry.Hash > mid.Hash)\n                {\n                    \/\/ if we done to the Entry then we don't even need to call the Remove\n                    if (Right is Entry)\n                    {\n                        \/\/ if the left node is not full yet then merge\n                        if (Left is Leaf5PlusPlus == false)\n                            return Left.AddOrGetEntry(mid.Hash, mid);\n                        removedEntry = Left.GetMaxHashEntryOrDefault(); \/\/ todo: @perf combine `GetMaxHashEntryOrDefault` with `RemoveEntry`\n                        return new Branch2(Left.RemoveEntry(removedEntry), removedEntry, mid); \/\/! the height does not change\n                    }\n\n                    var newRight = Right.RemoveEntry(removedEntry);\n                    \/\/*rebalance needed: the branch was merged from Br2 to Br3 or to the leaf and the height decreased \n                    if (Right is Branch2 && newRight is Branch2 == false)\n                    {\n                        var left = Left;\n                        \/\/ the the hole has a 2-node as a parent and a 3-node as a sibling.\n                        if (left is Branch3Base lb3) \/\/! the height does not change\n                            return new Branch2(new Branch2(lb3.Left, lb3.Entry0, lb3.Middle), lb3.Entry1, new Branch2(lb3.Right, mid, newRight));\n\n                        if (left is Branch2Plus1 lb21)\n                            return new Branch3(lb21.ToSplitBranch2(out var lMid, out var lRight), lMid, lRight, mid, newRight);\n\n                        \/\/ the the hole has a 2-node as a parent and a 2-node as a sibling.\n                        var lb2 = (Branch2)left;\n                        return new Branch3(lb2.Left, lb2.MidEntry, lb2.Right, mid, newRight);\n                    }\n\n                    return new Branch2(Left, mid, newRight);\n                }\n\n                \/\/ case 1, downward: swap the predecessor entry (max left entry) with the mid entry, then proceed to remove the predecessor from the Left branch\n                if (removedEntry == mid)\n                    removedEntry = mid = Left.GetMaxHashEntryOrDefault();\n\n                \/\/ case 1, upward\n                var newLeft = Left.RemoveEntry(removedEntry);\n                if (newLeft == Empty)\n                {\n                    if (Right is Leaf5PlusPlus == false)\n                        return Right.AddOrGetEntry(mid.Hash, mid);\n                    removedEntry = Right.GetMinHashEntryOrDefault();\n                    return new Branch2(mid, removedEntry, Right.RemoveEntry(removedEntry)); \/\/! the height does not change\n                }\n\n                \/\/*rebalance needed: the branch was merged from Br2 to Br3 or to the leaf and the height decreased \n                if (Left is Branch2 && newLeft is Branch2 == false)\n                {\n                    var right = Right;\n                    \/\/ the the hole has a 2-node as a parent and a 3-node as a sibling.\n                    if (right is Branch3Base rb3) \/\/! the height does not change\n                        return new Branch2(new Branch2(newLeft, mid, rb3.Left), rb3.Entry0, new Branch2(rb3.Middle, rb3.Entry1, rb3.Right));\n\n                    if (right is Branch2Plus1 rb21)\n                        return new Branch3(newLeft, mid, rb21.ToSplitBranch2(out var rMid, out var rRight), rMid, rRight);\n\n                    \/\/ the the hole has a 2-node as a parent and a 2-node as a sibling.\n                    var rb2 = (Branch2)right;\n                    return new Branch3(newLeft, mid, rb2.Left, rb2.MidEntry, rb2.Right);\n                }\n\n                return new Branch2(newLeft, mid, Right);\n            }\n        }\n\n        \/\/\/ <summary>The 2 branches with the node in between<\/summary>\n        internal sealed class Branch2Plus1 : ImHashMap<K, V>\n        {\n            public readonly Entry Plus;\n            public readonly Branch2 B;\n            public Branch2Plus1(Entry plus, Branch2 branch)\n            {\n                Plus = plus;\n                B = branch;\n            }\n\n            public override int Count() => Plus.Count() + B.Count();\n\n#if !DEBUG\n            public override string ToString() => \"{B21:{Plus:\" + Plus + \",B:\" + B + \"}}\";\n#endif\n\n            internal ImHashMap<K, V> ToSplitBranch2(out Entry newMid, out ImHashMap<K, V> newRight)\n            {\n                var b = B;\n                var m = b.MidEntry;\n                var l511 = b.Left as Leaf5PlusPlus;\n                if (l511 != null)\n                {\n                    newRight = b.Right.AddOrGetEntry(m.Hash, m); \/\/ @perf replace with the AddEntry method\n                    newMid = l511.GetMaxHashEntryOrDefault();\n                    if (newMid.Hash > Plus.Hash)\n                        return l511.RemoveMaxHashEntryAndAddNewEntry(newMid, Plus);\n                    newMid = Plus;\n                    return l511;\n                }\n\n                newRight = l511 = (Leaf5PlusPlus)b.Right;\n                newMid = l511.GetMinHashEntryOrDefault();\n                if (newMid.Hash < Plus.Hash)\n                    newRight = l511.RemoveMinHashEntryAndAddNewEntry(newMid, Plus);\n                else\n                    newMid = Plus;\n                return b.Left.AddOrGetEntry(m.Hash, m); \/\/ @perf replace with the AddEntry method\n            }\n\n            internal override Entry GetMinHashEntryOrDefault()\n            {\n                var m = B.Left.GetMinHashEntryOrDefault();\n                return m.Hash < Plus.Hash ? m : Plus;\n            }\n\n            internal sealed override Entry GetMaxHashEntryOrDefault()\n            {\n                var m = B.Right.GetMaxHashEntryOrDefault();\n                return m.Hash > Plus.Hash ? m : Plus;\n            }\n\n            internal override Entry GetEntryOrNull(int hash)\n            {\n                if (Plus.Hash == hash)\n                    return Plus;\n                var mh = B.MidEntry.Hash;\n                return hash > mh ? B.Right.GetEntryOrNull(hash)\n                    : hash < mh ? B.Left.GetEntryOrNull(hash)\n                    : B.MidEntry;\n            }\n\n            internal override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry)\n            {\n                var ph = Plus.Hash;\n                if (ph == hash) \/\/ ok, fast return here\n                    return Plus;\n\n                var b = B;\n                var m = b.MidEntry;\n                ImHashMap<K, V> entryOrNewBranch = null;\n                if (hash > m.Hash)\n                {\n                    var right = b.Right;\n                    ImHashMap<K, V> splitRight = null;\n                    if (right is Leaf5PlusPlus rl)\n                    {\n                        entryOrNewBranch = rl.AddOrGetEntry(hash, ref entry, ref splitRight);\n                        if (entryOrNewBranch is Entry)\n                            return entryOrNewBranch;\n\n                        \/\/ we know that the `splitRight` is not null because otherwise it would not be Branch2Plus1 in the first place \n                        Debug.Assert(ph > m.Hash, \"Because right was on the verge of balance and the fact that the other branch is not on the verge was the reason of Branch2Plus1 creation\");\n                        return ph > entry.Hash\n                            ? new Branch3(b.Left, m, entryOrNewBranch, entry, splitRight is Leaf2 l2 ? new Leaf2Plus(Plus, l2) : (ImHashMap<K, V>)new Leaf5Plus(Plus, (Leaf5)splitRight))\n                            : new Branch3(b.Left, m, entryOrNewBranch is Leaf5 l5 ? new Leaf5Plus(Plus, l5) : (ImHashMap<K, V>)new Leaf2Plus(Plus, (Leaf2)entryOrNewBranch), entry, splitRight);\n                    }\n\n                    \/\/ right is not on the verge, then the Plus would be added to the left\n                    entryOrNewBranch = right.AddOrGetEntry(hash, entry);\n                    if (entryOrNewBranch is Entry)\n                        return entryOrNewBranch;\n\n                    entry = Plus;\n                    var newLeft = ((Leaf5PlusPlus)b.Left).AddEntry(ph, ref entry, ref splitRight);\n                    return new Branch3(newLeft, entry, splitRight, m, entryOrNewBranch);\n                }\n\n                if (hash < m.Hash)\n                {\n                    var left = b.Left;\n                    ImHashMap<K, V> splitRight = null;\n                    if (left is Leaf5PlusPlus ll)\n                    {\n                        entryOrNewBranch = ll.AddOrGetEntry(hash, ref entry, ref splitRight);\n                        if (entryOrNewBranch is Entry)\n                            return entryOrNewBranch; \/\/ we know that the `r` is Leaf so the only possibility why `splitRight` is null because the same hash entry is found\n\n                        return ph < entry.Hash\n                            ? new Branch3(entryOrNewBranch is Leaf5 l5 ? new Leaf5Plus(Plus, l5) : (ImHashMap<K, V>)new Leaf2Plus(Plus, (Leaf2)entryOrNewBranch), entry, splitRight, m, b.Right)\n                            : new Branch3(entryOrNewBranch, entry, splitRight is Leaf2 l2 ? new Leaf2Plus(Plus, l2) : (ImHashMap<K, V>)new Leaf5Plus(Plus, (Leaf5)splitRight), m, b.Right);\n                    }\n\n                    entryOrNewBranch = left.AddOrGetEntry(hash, entry);\n                    if (entryOrNewBranch is Entry)\n                        return entryOrNewBranch;\n\n                    entry = Plus;\n                    var newMiddle = ((Leaf5PlusPlus)b.Right).AddEntry(ph, ref entry, ref splitRight);\n                    return new Branch3(entryOrNewBranch, m, newMiddle, entry, splitRight);\n                }\n\n                return m;\n            }\n\n            internal override ImHashMap<K, V> ReplaceEntry(Entry oldEntry, Entry newEntry) =>\n                oldEntry == Plus ? new Branch2Plus1(newEntry, B) : new Branch2Plus1(Plus, (Branch2)B.ReplaceEntry(oldEntry, newEntry));\n\n            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry)\n            {\n                if (removedEntry == Plus)\n                    return B;\n                var b = B;\n                Entry p = Plus, m = b.MidEntry;\n                if (removedEntry == m)\n                {\n                    if (b.Right is Leaf5PlusPlus rl)\n                    {\n                        var rightMin = rl.GetMinHashEntryOrDefault();\n                        return rightMin.Hash > p.Hash\n                            ? new Branch2(b.Left, p, rl)\n                            : new Branch2(b.Left, rightMin, rl.RemoveMinHashEntryAndAddNewEntry(rightMin, p));\n                    }\n                    var ll = (Leaf5PlusPlus)b.Left;\n                    var leftMax = ll.GetMaxHashEntryOrDefault();\n                    return leftMax.Hash < p.Hash\n                        ? new Branch2(ll, p, b.Right)\n                        : new Branch2(ll.RemoveMaxHashEntryAndAddNewEntry(leftMax, p), leftMax, b.Right);\n                }\n\n                if (removedEntry.Hash > m.Hash)\n                {\n                    if (b.Right is Leaf5PlusPlus rl)\n                        return new Branch2(b.Left, m, rl.RemoveEntry(removedEntry).AddOrGetEntry(p.Hash, p));\n                    var newRight = b.Right.RemoveEntry(removedEntry);\n                    if (newRight == Empty)\n                    {\n                        var ll = (Leaf5PlusPlus)b.Left;\n                        var leftMax = ll.GetMaxHashEntryOrDefault();\n                        return leftMax.Hash < p.Hash\n                            ? new Branch2(ll.RemoveEntry(leftMax), leftMax, p)\n                            : new Branch2(ll.RemoveEntry(leftMax), p, leftMax);\n                    }\n                    return new Branch2Plus1(p, new Branch2(b.Left, m, newRight));\n                }\n                {\n                    if (b.Left is Leaf5PlusPlus ll)\n                        return new Branch2(ll.RemoveEntry(removedEntry).AddOrGetEntry(p.Hash, p), m, b.Right);\n                    var newLeft = b.Left.RemoveEntry(removedEntry);\n                    if (newLeft == Empty)\n                    {\n                        var rl = (Leaf5PlusPlus)b.Right;\n                        var rightMin = rl.GetMinHashEntryOrDefault();\n                        return rightMin.Hash > p.Hash\n                            ? new Branch2(p, rightMin, rl.RemoveEntry(rightMin))\n                            : new Branch2(rightMin, p, rl.RemoveEntry(rightMin));\n                    }\n                    return new Branch2Plus1(p, new Branch2(newLeft, m, b.Right));\n                }\n            }\n        }\n\n        internal abstract class Branch3Base : ImHashMap<K, V>\n        {\n            public abstract Entry Entry0 { get; }\n            public abstract Entry Entry1 { get; }\n            public abstract ImHashMap<K, V> Left { get; }\n            public abstract ImHashMap<K, V> Middle { get; }\n            public abstract ImHashMap<K, V> Right { get; }\n            public override int Count() => Left.Count() + Entry0.Count() + Middle.Count() + Entry1.Count() + Right.Count();\n\n            internal override bool MayTurnToBranch2 => true;\n\n#if !DEBUG\n            public override string ToString() => \"{B3:{E0:\" + Entry0 + \",E1:\" + Entry0 + \",L:\" + Left + \",M:\" + Middle + \",R:\" + Right + \"}}\";\n#endif\n\n            internal override Entry GetMinHashEntryOrDefault() => Left.GetMinHashEntryOrDefault();\n            internal override Entry GetMaxHashEntryOrDefault() => Right.GetMaxHashEntryOrDefault();\n\n            internal override ImHashMap<K, V> AddOrGetEntry(int hash, Entry entry)\n            {\n                var h1 = Entry1.Hash;\n                if (hash > h1)\n                {\n                    var right = Right;\n                    var newRight = right.AddOrGetEntry(hash, entry);\n                    if (newRight is Entry)\n                        return newRight;\n\n                    if (right.MayTurnToBranch2 && newRight is Branch2)\n                        return new Branch2(new Branch2(Left, Entry0, Middle), Entry1, newRight);\n\n                    return this is Branch3 b ? new Branch3Right(b, newRight)\n                        : this is Branch3Right br ? new Branch3Right(br.B, newRight)\n                        : new Branch3(Left, Entry0, Middle, Entry1, newRight);\n                }\n\n                var h0 = Entry0.Hash;\n                if (hash < h0)\n                {\n                    var left = Left;\n                    var newLeft = left.AddOrGetEntry(hash, entry);\n                    if (newLeft is Entry)\n                        return newLeft;\n\n                    if (left.MayTurnToBranch2 && newLeft is Branch2)\n                        return new Branch2(newLeft, Entry0, new Branch2(Middle, Entry1, Right));\n\n                    return this is Branch3 b ? new Branch3Left(b, newLeft) : this is Branch3Left br ? new Branch3Left(br.B, newLeft)\n                        : new Branch3(newLeft, Entry0, Middle, Entry1, Right);\n                }\n\n                if (hash > h0 && hash < h1)\n                {\n                    var middle = Middle;\n                    ImHashMap<K, V> splitMiddleRight = null;\n                    var newMiddle =\n                        middle is Branch3Base mb3 ? mb3.AddOrGetEntry(hash, ref entry, ref splitMiddleRight) :\n                        middle is Leaf5PlusPlus ml511 ? ml511.AddOrGetEntry(hash, ref entry, ref splitMiddleRight) :\n                        middle.AddOrGetEntry(hash, entry);\n\n                    if (splitMiddleRight != null)\n                        return new Branch2(new Branch2(Left, Entry0, newMiddle), entry, new Branch2(splitMiddleRight, Entry1, Right));\n\n                    if (newMiddle is Entry)\n                        return newMiddle;\n\n                    return this is Branch3 b ? new Branch3Middle(b, newMiddle)\n                        : this is Branch3Middle br ? new Branch3Middle(br.B, newMiddle)\n                        : new Branch3(Left, Entry0, newMiddle, Entry1, Right);\n                }\n\n                return hash == h0 ? Entry0 : Entry1;\n            }\n\n            internal ImHashMap<K, V> AddOrGetEntry(int hash, ref Entry entry, ref ImHashMap<K, V> splitRight)\n            {\n                var h1 = Entry1.Hash;\n                if (hash > h1)\n                {\n                    var right = Right;\n                    var newRight = right.AddOrGetEntry(hash, entry);\n                    if (newRight is Entry)\n                        return newRight;\n                    if (right.MayTurnToBranch2 && newRight is Branch2)\n                    {\n                        entry = Entry1;\n                        splitRight = newRight;\n                        return new Branch2(Left, Entry0, Middle);\n                    }\n                    return this is Branch3 b ? new Branch3Right(b, newRight)\n                        : this is Branch3Right br ? new Branch3Right(br.B, newRight)\n                        : new Branch3(Left, Entry0, Middle, Entry1, newRight);\n                }\n\n                var h0 = Entry0.Hash;\n                if (hash < h0)\n                {\n                    var left = Left;\n                    var newLeft = left.AddOrGetEntry(hash, entry);\n                    if (newLeft is Entry)\n                        return newLeft;\n                    if (left.MayTurnToBranch2 && newLeft is Branch2)\n                    {\n                        entry = Entry0;\n                        splitRight = new Branch2(Middle, Entry1, Right);\n                        return newLeft;\n                    }\n                    return this is Branch3 b ? new Branch3Left(b, newLeft)\n                        : this is Branch3Left br ? new Branch3Left(br.B, newLeft)\n                        : new Branch3(newLeft, Entry0, Middle, Entry1, Right);\n                }\n\n                if (hash > h0 && hash < h1)\n                {\n                    var middle = Middle;\n                    ImHashMap<K, V> newMiddle = null, splitMiddleRight = null;\n                    if (middle is Leaf5PlusPlus ml511)\n                    {\n                        newMiddle = ml511.AddOrGetEntry(hash, ref entry, ref splitMiddleRight);\n                        if (splitMiddleRight == null)\n                            return newMiddle;\n                        \/\/ entry = entry; we don't need to assign the entry because it is already containing the proper value\n                        splitRight = new Branch2(splitMiddleRight, Entry1, Right);\n                        return new Branch2(Left, Entry0, newMiddle);\n                    }\n\n                    if (middle is Branch3Base mb3)\n                    {\n                        newMiddle = mb3.AddOrGetEntry(hash, ref entry, ref splitMiddleRight);\n                        if (splitMiddleRight != null)\n                        {\n                            splitRight = new Branch2(splitMiddleRight, Entry1, Right);\n                            return new Branch2(Left, Entry0, newMiddle);\n                        }\n                    }\n                    else\n                        newMiddle = middle.AddOrGetEntry(hash, entry);\n                    if (newMiddle is Entry)\n                        return newMiddle;\n                    return this is Branch3 b ? new Branch3Middle(b, newMiddle) : this is Branch3Middle br ? new Branch3Middle(br.B, newMiddle)\n                        : new Branch3(Left, Entry0, newMiddle, Entry1, Right);\n                }\n\n                return hash == h0 ? Entry0 : Entry1;\n            }\n\n            internal override ImHashMap<K, V> ReplaceEntry(Entry oldEntry, Entry newEntry)\n            {\n                int hash = oldEntry.Hash, h0 = Entry0.Hash, h1 = Entry1.Hash;\n                return hash > h1 ? new Branch3(Left, Entry0, Middle, Entry1, Right.ReplaceEntry(oldEntry, newEntry))\n                    : hash < h0 ? new Branch3(Left.ReplaceEntry(oldEntry, newEntry), Entry0, Middle, Entry1, Right)\n                    : hash > h0 && hash < h1 ? new Branch3(Left, Entry0, Middle.ReplaceEntry(oldEntry, newEntry), Entry1, Right)\n                    : hash == h0 ? new Branch3(Left, newEntry, Middle, Entry1, Right) : new Branch3(Left, Entry0, Middle, newEntry, Right);\n            }\n\n            internal override ImHashMap<K, V> RemoveEntry(Entry removedEntry)\n            {\n                Entry midLeft = Entry0, midRight = Entry1;\n                ImHashMap<K, V> middle = Middle, right = Right;\n\n                \/\/ case 1, downward: swap the predecessor entry (max left entry) with the mid entry, then proceed to remove the predecessor from the Left branch\n                if (removedEntry == midLeft)\n                    removedEntry = midLeft = Left.GetMaxHashEntryOrDefault();\n\n                if (removedEntry.Hash <= midLeft.Hash)\n                {\n                    var newLeft = Left.RemoveEntry(removedEntry);\n                    if (newLeft == Empty)\n                    {\n                        if (middle is Leaf5PlusPlus == false)\n                            return new Branch2(middle.AddOrGetEntry(midLeft.Hash, midLeft), midRight, right); \/\/! the height does not change\n                        return new Branch3(midLeft, removedEntry = middle.GetMinHashEntryOrDefault(), middle.RemoveEntry(removedEntry), midRight, right); \/\/! the height does not change\n                    }\n\n                    \/\/ rebalance is needed because the branch was merged from Br2 to Br3 or to Leaf and the height decrease\n                    if (Left is Branch2 && newLeft is Branch2 == false)\n                    {\n                        \/\/ the hole has a 3-node as a parent and a 3-node as a sibling.\n                        if (middle is Branch3Base mb3) \/\/! the height does not change\n                            return new Branch3(new Branch2(newLeft, midLeft, mb3.Left), mb3.Entry0, new Branch2(mb3.Middle, mb3.Entry1, mb3.Right), midRight, right);\n\n                        if (middle is Branch2Plus1 mb21)\n                            return new Branch2(new Branch3(newLeft, midLeft, mb21.ToSplitBranch2(out var mMid, out var mRight), mMid, mRight), midRight, right);\n\n                        \/\/ the hole has a 3-node as a parent and a 2-node as a sibling.\n                        var mb2 = (Branch2)middle;\n                        return new Branch2(new Branch3(newLeft, midLeft, mb2.Left, mb2.MidEntry, mb2.Right), midRight, right);\n                    }\n\n                    return new Branch3(newLeft, midLeft, middle, midRight, right); \/\/ no rebalance needed\n                }\n\n                if (removedEntry == midRight)\n                    removedEntry = midRight = middle.GetMaxHashEntryOrDefault();\n\n                if (removedEntry.Hash <= midRight.Hash)\n                {\n                    var newMiddle = middle.RemoveEntry(removedEntry);\n                    if (newMiddle == Empty)\n                    {\n                        if (right is Leaf5PlusPlus == false)\n                            return new Branch2(Left, midLeft, right.AddOrGetEntry(midRight.Hash, midRight)); \/\/ the Br3 become the Br2 but the height did not change - so no rebalance needed\n                        return new Branch3(Left, midLeft, midRight, removedEntry = right.GetMinHashEntryOrDefault(), right.RemoveEntry(removedEntry)); \/\/! the height does not change\n                    }\n\n                    if (middle is Branch2 && newMiddle is Branch2 == false)\n                    {\n                        \/\/ the hole has a 3-node as a parent and a 3-node as a sibling.\n                        if (right is Branch3Base rb3) \/\/! the height does not change\n                            return new Branch3(Left, midLeft, new Branch2(newMiddle, midRight, rb3.Left), rb3.Entry0, new Branch2(rb3.Middle, rb3.Entry1, rb3.Right));\n\n                        if (right is Branch2Plus1 rb21)\n                            return new Branch2(Left, midLeft, new Branch3(newMiddle, midRight, rb21.ToSplitBranch2(out var rMid, out var rRight), rMid, rRight));\n\n                        \/\/ the hole has a 3-node as a parent and a 2-node as a sibling.\n                        var rb2 = (Branch2)right;\n                        return new Branch2(Left, midLeft, new Branch3(newMiddle, midRight, rb2.Left, rb2.MidEntry, rb2.Right));\n                    }\n\n                    return new Branch3(Left, midLeft, newMiddle, midRight, right);\n                }\n\n                var newRight = right.RemoveEntry(removedEntry);\n                if (newRight == Empty)\n                {\n                    if (middle is Leaf5PlusPlus == false)\n                        return new Branch2(Left, midLeft, middle.AddOrGetEntry(midRight.Hash, midRight));\n                    return new Branch3(Left, midLeft, middle.RemoveEntry(removedEntry = middle.GetMaxHashEntryOrDefault()), removedEntry, midRight);\n                }\n\n                \/\/ right was a Br2 but now is Leaf or Br3 - means the branch height is decrease\n                if (right is Branch2 && newRight is Branch2 == false)\n                {\n                    \/\/ the hole has a 3-node as a parent and a 3-node as a sibling.new\n                    if (middle is Branch3Base mb3) \/\/! the height does not change\n                        return new Branch3(Left, midLeft, new Branch2(mb3.Left, mb3.Entry0, mb3.Middle), mb3.Entry1, new Branch2(mb3.Right, midRight, newRight));\n\n                    if (middle is Branch2Plus1 mb21)\n                        return new Branch2(Left, midLeft, new Branch3(mb21.ToSplitBranch2(out var mMid, out var mRight), mMid, mRight, midRight, newRight));\n\n                    \/\/ the hole has a 3-node as a parent and a 2-node as a sibling.\n                    var mb2 = (Branch2)middle;\n                    return new Branch2(Left, midLeft, new Branch3(mb2.Left, mb2.MidEntry, mb2.Right, midRight, newRight));\n                }\n\n                return new Branch3(Left, midLeft, middle, midRight, newRight);\n            }\n        }\n\n        internal sealed class Branch3Right : Branch3Base\n        {\n            public override Entry Entry0 => B.E0;\n            public override Entry Entry1 => B.E1;\n            public override ImHashMap<K, V> Left => B.L;\n            public override ImHashMap<K, V> Middle => B.M;\n            internal readonly ImHashMap<K, V> R;\n            public override ImHashMap<K, V> Right => R;\n            public readonly Branch3 B;\n            public Branch3Right(Branch3 br3, ImHashMap<K, V> right)\n            {\n                B = br3;\n                R = right;\n            }\n\n            internal override Entry GetEntryOrNull(int hash)\n            {\n                var b = B;\n                var h1 = b.E1.Hash;\n                if (hash > h1)\n                    return R.GetEntryOrNull(hash);\n                var h0 = b.E0.Hash;\n                if (hash < h0)\n                    return b.L.GetEntryOrNull(hash);\n                return h0 == hash ? b.E0 : h1 == hash ? b.E1 : b.M.GetEntryOrNull(hash);\n            }\n        }\n\n        internal sealed class Branch3Left : Branch3Base\n        {\n            public override Entry Entry0 => B.E0;\n            public override Entry Entry1 => B.E1;\n            internal readonly ImHashMap<K, V> L;\n            public override ImHashMap<K, V> Left => L;\n            public override ImHashMap<K, V> Middle => B.M;\n            public override ImHashMap<K, V> Right => B.R;\n            public readonly Branch3 B;\n            public Branch3Left(Branch3 b, ImHashMap<K, V> l)\n            {\n                B = b;\n                L = l;\n            }\n\n            internal override Entry GetEntryOrNull(int hash)\n            {\n                var b = B;\n                var h1 = b.E1.Hash;\n                if (hash > h1)\n                    return B.R.GetEntryOrNull(hash);\n                var h0 = b.E0.Hash;\n                if (hash < h0)\n                    return L.GetEntryOrNull(hash);\n                return h0 == hash ? b.E0 : h1 == hash ? b.E1 : b.M.GetEntryOrNull(hash);\n            }\n        }\n\n        internal sealed class Branch3Middle : Branch3Base\n        {\n            public override Entry Entry0 => B.E0;\n            public override Entry Entry1 => B.E1;\n            public override ImHashMap<K, V> Left => B.L;\n            internal readonly ImHashMap<K, V> M;\n            public override ImHashMap<K, V> Middle => M;\n            public override ImHashMap<K, V> Right => B.R;\n            public readonly Branch3 B;\n            public Branch3Middle(Branch3 b, ImHashMap<K, V> m)\n            {\n                B = b;\n                M = m;\n            }\n            internal override Entry GetEntryOrNull(int hash)\n            {\n                var b = B;\n                var h1 = b.E1.Hash;\n                if (hash > h1)\n                    return B.R.GetEntryOrNull(hash);\n                var h0 = b.E0.Hash;\n                if (hash < h0)\n                    return b.L.GetEntryOrNull(hash);\n                return h0 == hash ? b.E0 : h1 == hash ? b.E1 : M.GetEntryOrNull(hash);\n            }\n        }\n\n        \/\/\/ <summary>The 3 branches with the 2 nodes in between<\/summary>\n        internal sealed class Branch3 : Branch3Base\n        {\n            internal readonly Entry E0, E1;\n            public override Entry Entry0 => E0;\n            public override Entry Entry1 => E1;\n            internal readonly ImHashMap<K, V> L, M, R;\n            public override ImHashMap<K, V> Left => L;\n            public override ImHashMap<K, V> Middle => M;\n            public override ImHashMap<K, V> Right => R;\n            public Branch3(ImHashMap<K, V> left, Entry e0, ImHashMap<K, V> middle, Entry e1, ImHashMap<K, V> right)\n            {\n                Debug.Assert(e0.Hash < e1.Hash, $\"e0.Hash:{e0.Hash} < e1.Hash{e1.Hash}\");\n                L = left;\n                E0 = e0;\n                M = middle;\n                E1 = e1;\n                R = right;\n            }\n            internal override Entry GetEntryOrNull(int hash)\n            {\n                var h1 = E1.Hash;\n                if (hash > h1)\n                    return R.GetEntryOrNull(hash);\n                var h0 = E0.Hash;\n                if (hash < h0)\n                    return L.GetEntryOrNull(hash);\n                return h0 == hash ? E0 : h1 == hash ? E1 : M.GetEntryOrNull(hash);\n            }\n        }\n    }\n\n    \/\/\/ <summary>Helper stack wrapper for the array<\/summary>\n    public sealed class MapParentStack\n    {\n        private const int DefaultInitialCapacity = 4;\n        private object[] _items;\n\n        \/\/\/ <summary>Creates the list of the `DefaultInitialCapacity`<\/summary>\n        public MapParentStack() => _items = new object[DefaultInitialCapacity];\n\n        \/\/\/ <summary>Pushes the item<\/summary>\n        public void Put(object item, int index)\n        {\n            if (index >= _items.Length)\n                _items = Expand(_items);\n            _items[index] = item;\n        }\n\n        \/\/\/ <summary>Gets the item by index<\/summary>\n        public object Get(int index) => _items[index];\n\n        private static object[] Expand(object[] items)\n        {\n            var count = items.Length;\n            var newItems = new object[count << 1]; \/\/ count * 2\n            Array.Copy(items, 0, newItems, 0, count);\n            return newItems;\n        }\n    }\n\n    \/\/\/ <summary>Helper stack wrapper for the array<\/summary>\n    public sealed class ImMapParentStack<K, V>\n    {\n        \/\/\/ <summary>Entry in a stack<\/summary>\n        public struct Entry\n        {\n            \/\/\/ <summary>The next entry to traverse<\/summary>\n            public ImHashMap<K, V>.Entry NextEntry;\n            \/\/\/ <summary>The next branch to traverse<\/summary>\n            public ImHashMap<K, V> NextBranch;\n        }\n\n        private const int DefaultInitialCapacity = 4;\n\n        \/\/\/ <summary>The items<\/summary>\n        public Entry[] Items;\n\n        \/\/\/ <summary>Creates the list of the `DefaultInitialCapacity`<\/summary>\n        public ImMapParentStack(int capacity = DefaultInitialCapacity) => Items = new Entry[capacity];\n\n        \/\/\/ <summary>Pushes the item<\/summary>\n        public void Put(int index, ImHashMap<K, V>.Entry entry, ImHashMap<K, V> branch)\n        {\n            if (index >= Items.Length)\n                Items = Expand(Items);\n            ref var e = ref Items[index];\n            e.NextEntry = entry;\n            e.NextBranch = branch;\n        }\n\n        private static Entry[] Expand(Entry[] items)\n        {\n            var count = items.Length;\n            var newItems = new Entry[count << 1]; \/\/ count * 2\n            Array.Copy(items, 0, newItems, 0, count);\n            return newItems;\n        }\n    }\n\n    \/\/\/ <summary>The map methods<\/summary>\n    public static class ImHashMap\n    {\n        [MethodImpl((MethodImplOptions)256)]\n        internal static void InsertInOrder<K, V>(int ph, ref ImHashMap<K, V>.Entry p,\n            ref ImHashMap<K, V>.Entry e0, ref ImHashMap<K, V>.Entry e1)\n        {\n            var t = default(ImHashMap<K, V>.Entry);\n            if (ph < e1.Hash)\n            {\n                t = e1; e1 = p; p = t;\n                if (ph < e0.Hash)\n                {\n                    t = e0; e0 = e1; e1 = t;\n                }\n            }\n        }\n\n        [MethodImpl((MethodImplOptions)256)]\n        internal static void InsertInOrder<K, V>(int ph, ref ImHashMap<K, V>.Entry p,\n            ref ImHashMap<K, V>.Entry e0, ref ImHashMap<K, V>.Entry e1, ref ImHashMap<K, V>.Entry e2)\n        {\n            var t = default(ImHashMap<K, V>.Entry);\n            if (ph < e2.Hash)\n            {\n                t = e2; e2 = p; p = t;\n                if (ph < e1.Hash)\n                {\n                    t = e1; e1 = e2; e2 = t;\n                    if (ph < e0.Hash)\n                    {\n                        t = e0; e0 = e1; e1 = t;\n                    }\n                }\n            }\n        }\n\n        [MethodImpl((MethodImplOptions)256)]\n        internal static void InsertInOrder<K, V>(int ph, ref ImHashMap<K, V>.Entry p,\n            ref ImHashMap<K, V>.Entry e0, ref ImHashMap<K, V>.Entry e1, ref ImHashMap<K, V>.Entry e2, ref ImHashMap<K, V>.Entry e3)\n        {\n            var t = default(ImHashMap<K, V>.Entry);\n            if (ph < e3.Hash)\n            {\n                t = e3; e3 = p; p = t;\n                if (ph < e2.Hash)\n                {\n                    t = e2; e2 = e3; e3 = t;\n                    if (ph < e1.Hash)\n                    {\n                        t = e1; e1 = e2; e2 = t;\n                        if (ph < e0.Hash)\n                        {\n                            t = e0; e0 = e1; e1 = t;\n                        }\n                    }\n                }\n            }\n        }\n\n        [MethodImpl((MethodImplOptions)256)]\n        internal static void InsertInOrder<K, V>(int ph, ref ImHashMap<K, V>.Entry p,\n            ref ImHashMap<K, V>.Entry e0, ref ImHashMap<K, V>.Entry e1, ref ImHashMap<K, V>.Entry e2, ref ImHashMap<K, V>.Entry e3, ref ImHashMap<K, V>.Entry e4)\n        {\n            var t = default(ImHashMap<K, V>.Entry);\n            if (ph < e4.Hash)\n            {\n                t = e4; e4 = p; p = t;\n                if (ph < e3.Hash)\n                {\n                    t = e3; e3 = e4; e4 = t;\n                    if (ph < e2.Hash)\n                    {\n                        t = e2; e2 = e3; e3 = t;\n                        if (ph < e1.Hash)\n                        {\n                            t = e1; e1 = e2; e2 = t;\n                            if (ph < e0.Hash)\n                            {\n                                t = e0; e0 = e1; e1 = t;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        [MethodImpl((MethodImplOptions)256)]\n        internal static void InsertInOrder<K, V>(int ph, ref ImHashMap<K, V>.Entry p,\n            ref ImHashMap<K, V>.Entry e0, ref ImHashMap<K, V>.Entry e1, ref ImHashMap<K, V>.Entry e2, ref ImHashMap<K, V>.Entry e3, ref ImHashMap<K, V>.Entry e4,\n            ref ImHashMap<K, V>.Entry e5)\n        {\n            var t = default(ImHashMap<K, V>.Entry);\n            if (ph < e5.Hash)\n            {\n                t = e5; e5 = p; p = t;\n                if (ph < e4.Hash)\n                {\n                    t = e4; e4 = e5; e5 = t;\n                    if (ph < e3.Hash)\n                    {\n                        t = e3; e3 = e4; e4 = t;\n                        if (ph < e2.Hash)\n                        {\n                            t = e2; e2 = e3; e3 = t;\n                            if (ph < e1.Hash)\n                            {\n                                t = e1; e1 = e2; e2 = t;\n                                if (ph < e0.Hash)\n                                {\n                                    t = e0; e0 = e1; e1 = t;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        [MethodImpl((MethodImplOptions)256)]\n        internal static void InsertInOrder<K, V>(int ph, ref ImHashMap<K, V>.Entry p,\n            ref ImHashMap<K, V>.Entry e0, ref ImHashMap<K, V>.Entry e1, ref ImHashMap<K, V>.Entry e2, ref ImHashMap<K, V>.Entry e3, ref ImHashMap<K, V>.Entry e4,\n            ref ImHashMap<K, V>.Entry e5, ref ImHashMap<K, V>.Entry e6)\n        {\n            var t = default(ImHashMap<K, V>.Entry);\n            if (ph < e6.Hash)\n            {\n                t = e6; e6 = p; p = t;\n                if (ph < e5.Hash)\n                {\n                    t = e5; e5 = e6; e6 = t;\n                    if (ph < e4.Hash)\n                    {\n                        t = e4; e4 = e5; e5 = t;\n                        if (ph < e3.Hash)\n                        {\n                            t = e3; e3 = e4; e4 = t;\n                            if (ph < e2.Hash)\n                            {\n                                t = e2; e2 = e3; e3 = t;\n                                if (ph < e1.Hash)\n                                {\n                                    t = e1; e1 = e2; e2 = t;\n                                    if (ph < e0.Hash)\n                                    {\n                                        t = e0; e0 = e1; e1 = t;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        private static readonly object _enumerationB3Tombstone = new object();\n\n        internal struct ImMapStack<K, V>\n        {\n            ImHashMap<K, V>.Entry e0, e1, e2, e3, e4, e5, e6, e7;\/\/, e8, e9, e10, e11, e12, e13, e14, e15;\n            ImHashMap<K, V> b0, b1, b2, b3, b4, b5, b6, b7;\/\/, b8, b9, b10, b11, b12, b13, b14, b15;\n            ImMapParentStack<K, V> _deeper;\n            const byte _deeperStartsAtLevel = 8;\n            public void Put(ushort i, ImHashMap<K, V>.Entry e, ImHashMap<K, V> b)\n            {\n                switch (i)\n                {\n                    case 0: e0 = e; b0 = b; break;\n                    case 1: e1 = e; b1 = b; break;\n                    case 2: e2 = e; b2 = b; break;\n                    case 3: e3 = e; b3 = b; break;\n                    case 4: e4 = e; b4 = b; break;\n                    case 5: e5 = e; b5 = b; break;\n                    case 6: e6 = e; b6 = b; break;\n                    case 7: e7 = e; b7 = b; break;\n                    default:\n                        if (_deeper == null)\n                            _deeper = new ImMapParentStack<K, V>(8);\n                        _deeper.Put(i - _deeperStartsAtLevel, e, b);\n                        break;\n                }\n            }\n\n            public void Put(ushort i, ImHashMap<K, V>.Entry e, ImHashMap<K, V> b, ImHashMap<K, V>.Entry eNext, ImHashMap<K, V> bNext)\n            {\n                switch (i)\n                {\n                    case 0: e0 = e; b0 = b; e1 = eNext; b1 = bNext; break;\n                    case 1: e1 = e; b1 = b; e2 = eNext; b2 = bNext; break;\n                    case 2: e2 = e; b2 = b; e3 = eNext; b3 = bNext; break;\n                    case 3: e3 = e; b3 = b; e4 = eNext; b4 = bNext; break;\n                    case 4: e4 = e; b4 = b; e5 = eNext; b5 = bNext; break;\n                    case 5: e5 = e; b5 = b; e6 = eNext; b6 = bNext; break;\n                    case 6: e6 = e; b6 = b; e7 = eNext; b7 = bNext; break;\n                    case 7:\n                        e7 = e; b7 = b;\n                        if (_deeper == null) _deeper = new ImMapParentStack<K, V>(8);\n                        _deeper.Put(0, eNext, bNext);\n                        break;\n                    default:\n                        if (_deeper == null) _deeper = new ImMapParentStack<K, V>(8);\n                        i -= _deeperStartsAtLevel;\n                        _deeper.Put(i, e, b);\n                        _deeper.Put(i + 1, eNext, bNext);\n                        break;\n                }\n            }\n\n            public void Get(ushort i, ref ImHashMap<K, V>.Entry e, ref ImHashMap<K, V> b)\n            {\n                switch (i)\n                {\n                    case 0: e = e0; b = b0; break;\n                    case 1: e = e1; b = b1; break;\n                    case 2: e = e2; b = b2; break;\n                    case 3: e = e3; b = b3; break;\n                    case 4: e = e4; b = b4; break;\n                    case 5: e = e5; b = b5; break;\n                    case 6: e = e6; b = b6; break;\n                    case 7: e = e7; b = b7; break;\n                    default:\n                        Debug.Assert(_deeper != null, \"Expecting the `deeper` parent stack created before accessing it here at level \" + i);\n                        ref var p = ref _deeper.Items[i - _deeperStartsAtLevel];\n                        e = p.NextEntry; b = p.NextBranch;\n                        break;\n                }\n            }\n        }\n\n        \/\/\/ <summary>Non-allocating enumerator<\/summary>\n        public struct ImMapEnumerable<K, V> : IEnumerable<ImHashMapEntry<K, V>>, IEnumerable\n        {\n            private readonly ImHashMap<K, V> _map;\n\n            \/\/\/ <summary>Constructor<\/summary>\n            public ImMapEnumerable(ImHashMap<K, V> map) => _map = map;\n\n            \/\/\/ <summary>Returns non-allocating enumerator<\/summary>\n            public ImMapEnumerator<K, V> GetEnumerator() => new ImMapEnumerator<K, V> { _map = _map };\n\n            IEnumerator<ImHashMapEntry<K, V>> IEnumerable<ImHashMapEntry<K, V>>.GetEnumerator() => new ImMapEnumerator<K, V> { _map = _map };\n            IEnumerator IEnumerable.GetEnumerator() => new ImMapEnumerator<K, V> { _map = _map };\n        }\n\n        \/\/\/ <summary>Enumerator on stack, without allocation<\/summary>\n        public struct ImMapEnumerator<K, V> : IEnumerator<ImHashMapEntry<K, V>>, IDisposable, IEnumerator\n        {\n            internal ImHashMap<K, V> _map;\n            private short _state;\n            private short _conflictIndex;\n            private ushort _index;\n            private ImMapStack<K, V> _ps;\n            private ImHashMap<K, V> _nextBranch;\n            private ImHashMap<K, V>.Branch2Plus1 _b21LeftWasEnumerated;\n\n            private ImHashMap<K, V>.Entry _a, _b, _c, _d, _e, _f, _g, _h;\n            private ImHashMap<K, V>.Entry _hc; \/\/ is for possibly HashConflictingEntry\n            private ImHashMapEntry<K, V> _current;\n\n            \/\/\/ <inheritdoc \/>\n            public ImHashMapEntry<K, V> Current => _current;\n            object IEnumerator.Current => _current;\n\n            private bool SetCurrentAndState(ImHashMap<K, V>.Entry e, short nextState, short prevState)\n            {\n                _state = nextState;\n                if (e is ImHashMapEntry<K, V> kv)\n                    _current = kv;\n                else\n                {\n                    var hc = (ImHashMap<K, V>.HashConflictingEntry)e;\n                    var cs = hc.Conflicts;\n                    _current = cs[_conflictIndex];\n                    \/\/ undo the next state until we are done with conflicts\n                    if (++_conflictIndex < cs.Length)\n                        _state = prevState;\n                    else \/\/ reset the index of conflicts todo: @perf use special value to avoid the type check later\n                        _conflictIndex = 0;\n                }\n                return true;\n            }\n\n            private bool SetCurrentAndState(short nextState, short prevState)\n            {\n                _state = nextState;\n                if (_hc is ImHashMapEntry<K, V> kv)\n                {\n                    _current = kv;\n                    _hc = null;\n                }\n                else\n                {\n                    var hc = (ImHashMap<K, V>.HashConflictingEntry)_hc;\n                    var cs = hc.Conflicts;\n                    _current = cs[_conflictIndex];\n                    \/\/ undo the next state until we are done with conflicts\n                    if (++_conflictIndex < cs.Length)\n                        _state = prevState;\n                    else \/\/ reset the index of conflicts todo: @perf use special value to avoid the type check later\n                    {\n                        _conflictIndex = 0;\n                        _hc = null;\n                    }\n                }\n                return true;\n            }\n\n            \/\/\/ <inheritdoc \/>\n            public bool MoveNext()\n            {\n                ImHashMap<K, V>.Leaf5PlusPlus b21FullLeaf511;\n                switch (_state)\n                {\n                    case 0:\n                        if (_map == ImHashMap<K, V>.Empty)\n                            return false;\n                        if (_map is ImHashMap<K, V>.Entry singleEntryMap)\n                            return SetCurrentAndState(singleEntryMap, 1, 0);\n                        _state = -1; \/\/ todo: @perf optimize just by setting _state = -1 for all\n                        goto Label0;\n                    case 1:\n                        \/\/ end of enumeration\n                        _state = -1;\n                        _current = null;\n                        return false;\n                    case 2:\n                        b21FullLeaf511 = (ImHashMap<K, V>.Leaf5PlusPlus)_b21LeftWasEnumerated.B.Right;\n                        _g = _b21LeftWasEnumerated.Plus;\n                        _b21LeftWasEnumerated = null;\n                        _map = ImHashMap<K, V>.Empty;\n                        _state = -1;\n                        goto SortLeaf511Label;\n                    case 3:\n                        return SetCurrentAndState(_a, 4, 3);\n                    case 4:\n                        return SetCurrentAndState(_b, 5, 4);\n                    case 5:\n                        return SetCurrentAndState(_c, 6, 5);\n                    case 6:\n                        return SetCurrentAndState(_d, 7, 6);\n                    case 7:\n                        return SetCurrentAndState(_e, 8, 7);\n                    case 8:\n                        return SetCurrentAndState(_f, 9, 8);\n                    case 9:\n                        return SetCurrentAndState(_g, 10, 9);\n                    case 10:\n                        if (_h == null)\n                        {\n                            _state = -1;\n                            goto Label2;\n                        }\n                        return SetCurrentAndState(_h, 11, 10);\n                    case 11:\n                        _state = -1;\n                        goto Label2;\n                    case 12:\n                        return SetCurrentAndState(_a, 13, 12);\n                    case 13:\n                        _state = -1;\n                        goto Label3;\n                    case 14:\n                        return SetCurrentAndState(_h, 15, 14);\n                    case 15:\n                        return SetCurrentAndState(_g, 16, 15);\n                    case 16:\n                        _state = -1; _h = null; _g = null;\n                        goto Label3;\n                    case 17:\n                        return SetCurrentAndState(_g, 18, 17);\n                    case 18:\n                        return SetCurrentAndState(_h, 19, 18);\n                    case 19:\n                        return SetCurrentAndState(_e, 20, 19);\n                    case 20:\n                        _state = -1; _g = null; _h = null; _e = null;\n                        goto Label3;\n                    case 21:\n                        return SetCurrentAndState(_a, 22, 21);\n                    case 22:\n                        return SetCurrentAndState(_b, 23, 22);\n                    case 23:\n                        return SetCurrentAndState(_c, 24, 23);\n                    case 24:\n                        return SetCurrentAndState(_d, 25, 24);\n                    case 25:\n                        _state = -1;\n                        break;\n                    case 26:\n                        return SetCurrentAndState(_e, 27, 26);\n                    case 27:\n                        return SetCurrentAndState(_h, 28, 27);\n                    case 28:\n                        return SetCurrentAndState(_g, 29, 28);\n                    case 29:\n                        return SetCurrentAndState(_f, 30, 29);\n                    case 30:\n                        return SetCurrentAndState(_d, 31, 30);\n                    case 31:\n                        _state = -1; _e = null; _h = null; _g = null; _f = null; _d = null;\n                        break;\n                    case 32:\n                        return SetCurrentAndState(_d, 33, 32);\n                    case 33:\n                        return SetCurrentAndState(_f, 34, 33);\n                    case 34:\n                        return SetCurrentAndState(_g, 35, 34);\n                    case 35:\n                        return SetCurrentAndState(_h, 36, 35);\n                    case 36:\n                        return SetCurrentAndState(_c, 37, 36);\n                    case 37:\n                        return SetCurrentAndState(_e, 38, 37);\n                    case 38:\n                        _state = -1; _d = null; _f = null; _g = null; _h = null; _e = null; _c = null;\n                        break;\n                    case 39:\n                        _state = -1;\n                        break;\n                    case 40:\n                        _state = -1;\n                        _map = _nextBranch;\n                        _a = null;\n                        _nextBranch = null;\n                        goto Label0;\n                    case 41:\n                        goto HashConflictingEntryLabel0;\n                    case 42:\n                        goto HashConflictingEntryLabel1;\n                    case 43:\n                        goto HashConflictingEntryLabel2;\n                    case 44:\n                        goto HashConflictingEntryLabel3;\n                    case 45:\n                        goto HashConflictingEntryLabel4;\n                    case 46:\n                        goto HashConflictingEntryLabel5;\n                    case 47:\n                        goto HashConflictingEntryLabel6;\n                    case 48:\n                        goto HashConflictingEntryLabel7;\n                    case 49:\n                        goto HashConflictingEntryLabel8;\n                    default:\n                        return false;\n                }\n            Label6:\n                _a = null; _b = null; _c = null; _d = null;\n            Label3:\n                if (_b21LeftWasEnumerated == null)\n                {\n                    if (_index == 0)\n                        return false;\n                    ImHashMap<K, V>.Entry current = null;\n                    var popIndex = (ushort)(_index - 1);\n                    _ps.Get(popIndex, ref current, ref _nextBranch);\n                    \/\/ Sets the previous state so that we are modifying any fields like _a, _b, etc. and directly goto back to this label\n                    SetCurrentAndState(current, 40, 13);\n                    if (_state == 40)\n                        _index = popIndex; \/\/ proceed\n                    return true;\n                }\n            Label0:\n                while (true)\n                {\n                    if (_map is ImHashMap<K, V>.Branch2 branch2)\n                    {\n                        _ps.Put(_index++, branch2.MidEntry, branch2.Right);\n                        _map = branch2.Left;\n                    }\n                    else if (_map is ImHashMap<K, V>.Branch3Base branch3)\n                    {\n                        _ps.Put(_index, branch3.Entry1, branch3.Right, branch3.Entry0, branch3.Middle);\n                        _index += 2;\n                        _map = branch3.Left;\n                    }\n                    else break;\n                }\n\n                if (_b21LeftWasEnumerated == null && !(_map is ImHashMap<K, V>.Branch2Plus1))\n                    goto AllLeafsAndEntryLabel;\n\n                _g = null; _h = null;\n            HashConflictingEntryLabel0:\n                if (_b21LeftWasEnumerated != null)\n                    return SetCurrentAndState(_b21LeftWasEnumerated.B.MidEntry, 2, 41);\n\n                var branch2Plus1 = (ImHashMap<K, V>.Branch2Plus1)_map;\n                var b21b = branch2Plus1.B;\n                if (b21b.Right is ImHashMap<K, V>.Leaf5PlusPlus)\n                {\n                    _b21LeftWasEnumerated = branch2Plus1;\n                    _map = b21b.Left;\n                    goto B21NotFilledLeftLeafLabel;\n                }\n\n                b21FullLeaf511 = (ImHashMap<K, V>.Leaf5PlusPlus)b21b.Left;\n                _h = b21b.MidEntry;\n                _g = branch2Plus1.Plus;\n                _map = b21b.Right;\n\n            SortLeaf511Label:\n                {\n                    var l = b21FullLeaf511.L.L;\n                    ImHashMap<K, V>.Entry e0 = l.Entry0;\n                    _a = l.Entry1;\n                    _b = l.Entry2;\n                    _c = l.Entry3;\n                    _d = l.Entry4;\n                    _f = b21FullLeaf511.Plus;\n                    _e = b21FullLeaf511.L.Plus;\n                    InsertInOrder(_e.Hash, ref _e, ref e0, ref _a, ref _b, ref _c, ref _d);\n                    InsertInOrder(_f.Hash, ref _f, ref e0, ref _a, ref _b, ref _c, ref _d, ref _e);\n                    InsertInOrder(_g.Hash, ref _g, ref e0, ref _a, ref _b, ref _c, ref _d, ref _e, ref _f);\n                    _hc = e0;\n                }\n            HashConflictingEntryLabel1:\n                return SetCurrentAndState(3, 42);\n\n            Label2:\n                _a = null; _b = null; _c = null; _d = null; _e = null; _f = null;\n\n            B21NotFilledLeftLeafLabel:\n                _g = null; _h = null;\n\n            AllLeafsAndEntryLabel:\n            HashConflictingEntryLabel2:\n                if (_map is ImHashMap<K, V>.Leaf2 l2)\n                {\n                    _a = l2.Entry1;\n                    return SetCurrentAndState(l2.Entry0, 12, 43);\n                }\n\n                if (_map is ImHashMap<K, V>.Leaf2Plus l21)\n                {\n                    var l = l21.L;\n                    ImHashMap<K, V>.Entry e0 = l.Entry0;\n                    _h = l.Entry1;\n                    _g = l21.Plus;\n                    InsertInOrder(_g.Hash, ref _g, ref e0, ref _h);\n                    _hc = e0;\n                }\n            HashConflictingEntryLabel3:\n                if (_hc != null)\n                    return SetCurrentAndState(14, 44);\n\n                if (_map is ImHashMap<K, V>.Leaf2PlusPlus l211)\n                {\n                    var l1 = l211.L.L;\n                    ImHashMap<K, V>.Entry e0 = l1.Entry0;\n                    _g = l1.Entry1;\n                    _h = l211.L.Plus;\n                    _e = l211.Plus;\n                    InsertInOrder(_h.Hash, ref _h, ref e0, ref _g);\n                    InsertInOrder(_e.Hash, ref _e, ref e0, ref _g, ref _h);\n                    _hc = e0;\n                }\n            HashConflictingEntryLabel4:\n                if (_hc != null)\n                    return SetCurrentAndState(17, 45);\n\n                if (_map is ImHashMap<K, V>.Leaf5 l5)\n                {\n                    _a = l5.Entry1;\n                    _b = l5.Entry2;\n                    _c = l5.Entry3;\n                    _d = l5.Entry4;\n                    _hc = l5.Entry0;\n                }\n            HashConflictingEntryLabel5:\n                if (_hc != null)\n                    return SetCurrentAndState(21, 46);\n\n                if (_map is ImHashMap<K, V>.Leaf5Plus l51)\n                {\n                    var leaf5 = l51.L;\n                    ImHashMap<K, V>.Entry e0 = leaf5.Entry0;\n                    _e = leaf5.Entry1;\n                    _h = leaf5.Entry2;\n                    _g = leaf5.Entry3;\n                    _f = leaf5.Entry4;\n                    _d = l51.Plus;\n                    InsertInOrder(_d.Hash, ref _d, ref e0, ref _e, ref _h, ref _g, ref _f);\n                    _hc = e0;\n                }\n            HashConflictingEntryLabel6:\n                if (_hc != null)\n                    return SetCurrentAndState(26, 47);\n\n                if (_map is ImHashMap<K, V>.Leaf5PlusPlus l511)\n                {\n                    var leaf51 = l511.L.L;\n                    ImHashMap<K, V>.Entry e0 = leaf51.Entry0;\n                    _d = leaf51.Entry1;\n                    _f = leaf51.Entry2;\n                    _g = leaf51.Entry3;\n                    _h = leaf51.Entry4;\n                    _c = l511.L.Plus;\n                    _e = l511.Plus;\n                    InsertInOrder(_c.Hash, ref _c, ref e0, ref _d, ref _f, ref _g, ref _h);\n                    InsertInOrder(_e.Hash, ref _e, ref e0, ref _d, ref _f, ref _g, ref _h, ref _c);\n                    _hc = e0;\n                }\n            HashConflictingEntryLabel7:\n                if (_hc != null)\n                    return SetCurrentAndState(32, 48);\n\n                HashConflictingEntryLabel8:\n                if (_map is ImHashMap<K, V>.Entry e)\n                    return SetCurrentAndState(e, 39, 49);\n\n                goto Label6;\n            }\n\n            bool IEnumerator.MoveNext() => MoveNext();\n            void IEnumerator.Reset() => throw new NotSupportedException();\n            void IDisposable.Dispose() { }\n        }\n\n        \/\/\/ <summary>Enumerates all the map entries in the hash order.\n        \/\/\/ `parents` parameter allows to reuse the stack memory used for traversal between multiple enumerates.\n        \/\/\/ So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent `Enumerate` calls<\/summary>\n        public static ImMapEnumerable<K, V> Enumerate<K, V>(this ImHashMap<K, V> map) => new ImMapEnumerable<K, V>(map);\n\n        \/\/\/ <summary>Depth-first in-order of hash traversal as described in http:\/\/en.wikipedia.org\/wiki\/Tree_traversal.\n        \/\/\/ The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.\n        \/\/\/ So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls<\/summary>\n        public static S ForEach<K, V, S>(this ImHashMap<K, V> map, S state, Action<ImHashMapEntry<K, V>, int, S> handler, MapParentStack parents = null)\n        {\n            if (map == ImHashMap<K, V>.Empty)\n                return state;\n            if (map is ImHashMap<K, V>.Entry singleEntry)\n            {\n                singleEntry.ForEach(state, 0, handler);\n                return state;\n            }\n\n            ImHashMap<K, V>.Branch2Plus1 b21LeftWasEnumerated = null;\n            int count = 0, i = 0;\n            while (true)\n            {\n                if (map is ImHashMap<K, V>.Branch2 b2)\n                {\n                    if (parents == null)\n                        parents = new MapParentStack();\n                    parents.Put(map, count++);\n                    map = b2.Left;\n                    continue;\n                }\n\n                if (map is ImHashMap<K, V>.Branch3Base b3)\n                {\n                    if (parents == null)\n                        parents = new MapParentStack();\n                    parents.Put(map, count++);\n                    map = b3.Left;\n                    continue;\n                }\n\n                if (b21LeftWasEnumerated != null || map is ImHashMap<K, V>.Branch2Plus1)\n                {\n                    ImHashMap<K, V>.Leaf5PlusPlus l511 = null;\n                    ImHashMap<K, V>.Entry pl = null, mid = null;\n                    if (b21LeftWasEnumerated != null)\n                    {\n                        i = b21LeftWasEnumerated.B.MidEntry.ForEach(state, i, handler);\n\n                        l511 = (ImHashMap<K, V>.Leaf5PlusPlus)b21LeftWasEnumerated.B.Right;\n                        pl = b21LeftWasEnumerated.Plus;\n                        b21LeftWasEnumerated = null; \/\/ we done with the branch\n                        map = ImHashMap<K, V>.Empty;     \/\/ forcing to skip leaves below\n                    }\n                    else\n                    {\n                        var b21 = (ImHashMap<K, V>.Branch2Plus1)map;\n                        if (b21.B.Right is ImHashMap<K, V>.Leaf5PlusPlus) \/\/ so we need to enumerate the left as a normal branch2 with the code below.\n                        {\n                            b21LeftWasEnumerated = b21;\n                            map = b21.B.Left;\n                        }\n                        else \/\/ we need to sort out the left side with Plus entry\n                        {\n                            l511 = (ImHashMap<K, V>.Leaf5PlusPlus)b21.B.Left;\n                            mid = b21.B.MidEntry;\n                            pl = b21.Plus;\n                            map = b21.B.Right; \/\/ it is a leaf so, no need to continue, just proceed with the leafs below\n                        }\n                    }\n                    if (l511 != null)\n                    {\n                        var l = l511.L.L;\n                        ImHashMap<K, V>.Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4, p = l511.Plus, pp = l511.L.Plus;\n\n                        ImHashMap.InsertInOrder(pp.Hash, ref pp, ref e0, ref e1, ref e2, ref e3, ref e4);\n                        ImHashMap.InsertInOrder(p.Hash, ref p, ref e0, ref e1, ref e2, ref e3, ref e4, ref pp);\n                        ImHashMap.InsertInOrder(pl.Hash, ref pl, ref e0, ref e1, ref e2, ref e3, ref e4, ref pp, ref p);\n\n                        i = e0.ForEach(state, i, handler);\n                        i = e1.ForEach(state, i, handler);\n                        i = e2.ForEach(state, i, handler);\n                        i = e3.ForEach(state, i, handler);\n                        i = e4.ForEach(state, i, handler);\n                        i = pp.ForEach(state, i, handler);\n                        i = p.ForEach(state, i, handler);\n                        i = pl.ForEach(state, i, handler);\n\n                        if (mid != null)\n                            i = mid.ForEach(state, i, handler);\n                    }\n                }\n\n                if (map is ImHashMap<K, V>.Leaf2 l2)\n                {\n                    i = l2.Entry0.ForEach(state, i, handler);\n                    i = l2.Entry1.ForEach(state, i, handler);\n                }\n                else if (map is ImHashMap<K, V>.Leaf2Plus l21)\n                {\n                    var l = l21.L;\n                    ImHashMap<K, V>.Entry e0 = l.Entry0, e1 = l.Entry1, pp = l21.Plus;\n\n                    ImHashMap.InsertInOrder(pp.Hash, ref pp, ref e0, ref e1);\n\n                    i = e0.ForEach(state, i, handler);\n                    i = e1.ForEach(state, i, handler);\n                    i = pp.ForEach(state, i, handler);\n                }\n                else if (map is ImHashMap<K, V>.Leaf2PlusPlus l211)\n                {\n                    var l = l211.L.L;\n                    ImHashMap<K, V>.Entry e0 = l.Entry0, e1 = l.Entry1, pp = l211.L.Plus, p = l211.Plus;\n\n                    ImHashMap.InsertInOrder(pp.Hash, ref pp, ref e0, ref e1);\n                    ImHashMap.InsertInOrder(p.Hash, ref p, ref e0, ref e1, ref pp);\n\n                    i = e0.ForEach(state, i, handler);\n                    i = e1.ForEach(state, i, handler);\n                    i = pp.ForEach(state, i, handler);\n                    i = p.ForEach(state, i, handler);\n                }\n                else if (map is ImHashMap<K, V>.Leaf5 l5)\n                {\n                    i = l5.Entry0.ForEach(state, i, handler);\n                    i = l5.Entry1.ForEach(state, i, handler);\n                    i = l5.Entry2.ForEach(state, i, handler);\n                    i = l5.Entry3.ForEach(state, i, handler);\n                    i = l5.Entry4.ForEach(state, i, handler);\n                }\n                else if (map is ImHashMap<K, V>.Leaf5Plus l51)\n                {\n                    var l = l51.L;\n                    ImHashMap<K, V>.Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4, pp = l51.Plus;\n\n                    ImHashMap.InsertInOrder(pp.Hash, ref pp, ref e0, ref e1, ref e2, ref e3, ref e4);\n\n                    i = e0.ForEach(state, i, handler);\n                    i = e1.ForEach(state, i, handler);\n                    i = e2.ForEach(state, i, handler);\n                    i = e3.ForEach(state, i, handler);\n                    i = e4.ForEach(state, i, handler);\n                    i = pp.ForEach(state, i, handler);\n                }\n                else if (map is ImHashMap<K, V>.Leaf5PlusPlus l511)\n                {\n                    var l = l511.L.L;\n                    ImHashMap<K, V>.Entry e0 = l.Entry0, e1 = l.Entry1, e2 = l.Entry2, e3 = l.Entry3, e4 = l.Entry4, p = l511.Plus, pp = l511.L.Plus;\n\n                    ImHashMap.InsertInOrder(pp.Hash, ref pp, ref e0, ref e1, ref e2, ref e3, ref e4);\n                    ImHashMap.InsertInOrder(p.Hash, ref p, ref e0, ref e1, ref e2, ref e3, ref e4, ref pp);\n\n                    i = e0.ForEach(state, i, handler);\n                    i = e1.ForEach(state, i, handler);\n                    i = e2.ForEach(state, i, handler);\n                    i = e3.ForEach(state, i, handler);\n                    i = e4.ForEach(state, i, handler);\n                    i = pp.ForEach(state, i, handler);\n                    i = p.ForEach(state, i, handler);\n                }\n                else if (map is ImHashMap<K, V>.Entry l1)\n                    i = l1.ForEach(state, i, handler);\n\n                if (b21LeftWasEnumerated != null)\n                    continue;\n\n                if (count == 0)\n                    break; \/\/ we yield the leaf and there is nothing in stack - we are DONE!\n\n                var b = parents.Get(--count); \/\/ otherwise get the parent\n                if (b is ImHashMap<K, V>.Branch2 pb2)\n                {\n                    i = pb2.MidEntry.ForEach(state, i, handler);\n                    map = pb2.Right;\n                }\n                else if (b != _enumerationB3Tombstone)\n                {\n                    var pb3 = (ImHashMap<K, V>.Branch3Base)b;\n                    i = pb3.Entry0.ForEach(state, i, handler);\n                    map = pb3.Middle;\n                    parents.Put(_enumerationB3Tombstone, ++count);\n                    ++count;\n                }\n                else\n                {\n                    var pb3 = (ImHashMap<K, V>.Branch3Base)parents.Get(--count);\n                    i = pb3.Entry1.ForEach(state, i, handler);\n                    map = pb3.Right;\n                }\n            }\n\n            return state;\n        }\n\n        \/\/\/ <summary>Do something for each entry.\n        \/\/\/ The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.\n        \/\/\/ So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls<\/summary>\n        public static void ForEach<K, V>(this ImHashMap<K, V> map, Action<ImHashMapEntry<K, V>, int> handler, MapParentStack parents = null) =>\n            map.ForEach(handler, (e, i, r) => r(e, i), parents);\n\n        \/\/\/ <summary>Collect something for each entry.\n        \/\/\/ The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.\n        \/\/\/ So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls<\/summary>\n        public static S Fold<K, V, S>(this ImHashMap<K, V> map, S state, Func<ImHashMapEntry<K, V>, int, S, S> handler, MapParentStack parents = null) =>\n            map.ForEach(St.Rent(state, handler), (e, i, s) => s.a = s.b(e, i, s.a), parents).ResetButGetA();\n\n        \/\/\/ <summary>Converts the map to an array with the minimum allocations<\/summary>\n        public static S[] ToArray<K, V, S>(this ImHashMap<K, V> map, Func<ImHashMapEntry<K, V>, S> selector) =>\n            map == ImHashMap<K, V>.Empty ? ArrayTools.Empty<S>() :\n                map.ForEach(St.Rent(new S[map.Count()], selector), (e, i, s) => s.a[i] = s.b(e)).ResetButGetA();\n\n        \/\/\/ <summary>Converts the map to an array with the minimum allocations<\/summary>\n        public static ImHashMapEntry<K, V>[] ToArray<K, V>(this ImHashMap<K, V> map) =>\n            map == ImHashMap<K, V>.Empty ? ArrayTools.Empty<ImHashMapEntry<K, V>>() : map.ForEach(new ImHashMapEntry<K, V>[map.Count()], (e, i, a) => a[i] = e);\n\n        \/\/\/ <summary>Converts the map to the dictionary<\/summary>\n        public static Dictionary<K, V> ToDictionary<K, V>(this ImHashMap<K, V> map) =>\n            map == ImHashMap<K, V>.Empty\n                ? new Dictionary<K, V>(0)\n                : map.ForEach(new Dictionary<K, V>(), (e, _, d) => d.Add(e.Key, e.Value));\n\n        \/\/\/ <summary>Returns <see langword=\"true\"\/> if map contains the hash, otherwise returns <see langword=\"false\"\/><\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static bool Contains<V>(this ImHashMap<int, V> map, int key) => map.GetEntryOrNull(key) != null;\n\n        \/\/\/ <summary>Returns <see langword=\"true\"\/> if map contains the hash and key, otherwise returns <see langword=\"false\"\/><\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static bool Contains<K, V>(this ImHashMap<K, V> map, int hash, K key) => map.GetEntryOrDefault(hash, key) != null;\n\n        \/\/\/ <summary>Returns <see langword=\"true\"\/> if map contains the key, otherwise returns <see langword=\"false\"\/><\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static bool Contains<K, V>(this ImHashMap<K, V> map, K key) => map.GetEntryOrDefault(key.GetHashCode(), key) != null;\n\n        \/\/\/ <summary>Returns the entry ASSUMING it is present otherwise its behavior is UNDEFINED.\n        \/\/\/ You can use the method after the Add and Update methods on the same map instance - \n        \/\/\/ because the map is immutable it is for sure contains added or updated entry.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMapEntry<int, V> GetSurePresentEntry<V>(this ImHashMap<int, V> map, int hash) =>\n            (VEntry<V>)map.GetEntryOrNull(hash);\n\n        \/\/\/ <summary>Returns the entry ASSUMING it is present otherwise its behavior is UNDEFINED.\n        \/\/\/ You can use the method after the Add and Update methods on the same map instance - \n        \/\/\/ because the map is immutable it is for sure contains added or updated entry.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMapEntry<K, V> GetSurePresentEntry<K, V>(this ImHashMap<K, V> map, int hash, K key) =>\n            map.GetEntryOrNull(hash).GetOrNull(key);\n\n        \/\/\/ <summary>Lookup for the entry by hash, returns the found entry or `null`.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMapEntry<int, V> GetEntryOrDefault<V>(this ImHashMap<int, V> map, int hash) =>\n            (VEntry<V>)map.GetEntryOrNull(hash);\n\n        \/\/\/ <summary>Lookup for the entry by hash, returns the found entry or `null`.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMapEntry<K, V> GetEntryOrDefault<K, V>(this ImHashMap<K, V> map, int hash, K key) =>\n            map.GetEntryOrNull(hash)?.GetOrNullWithTheSameHash(key);\n\n        \/\/\/ <summary>Lookup for the entry by hash, returns the found entry or `null`.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMapEntry<K, V> GetEntryOrDefault<K, V>(this ImHashMap<K, V> map, K key) =>\n            map.GetEntryOrNull(key.GetHashCode())?.GetOrNullWithTheSameHash(key);\n\n        \/\/\/ <summary>Lookup for the value by hash, returns the default `V` if hash is not found.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static V GetValueOrDefault<V>(this ImHashMap<int, V> map, int hash)\n        {\n            var e = (VEntry<V>)map.GetEntryOrNull(hash);\n            return e != null ? e.Value : default;\n        }\n\n        \/\/\/ <summary>Lookup for the value by hash, returns the default `V` if hash is not found.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static V GetValueOrDefault<V>(this ImHashMap<int, V> map, int hash, V defaultValue)\n        {\n            var e = (VEntry<V>)map.GetEntryOrNull(hash);\n            return e != null ? e.Value : defaultValue;\n        }\n\n        \/\/\/ <summary>Lookup for the value by hash, returns the default `V` if hash is not found.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static V GetValueOrDefault<K, V>(this ImHashMap<K, V> map, int hash, K key) =>\n            map.GetEntryOrNull(hash)?.GetOrNullWithTheSameHash(key) is ImHashMapEntry<K, V> kv ? kv.Value : default(V);\n\n        \/\/\/ <summary>Lookup for the value by hash, returns the default `V` if hash is not found.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static V GetValueOrDefault<K, V>(this ImHashMap<K, V> map, int hash, K key, V defaultValue) =>\n            map.GetEntryOrNull(hash)?.GetOrNullWithTheSameHash(key) is ImHashMapEntry<K, V> kv ? kv.Value : defaultValue;\n\n        \/\/\/ <summary>Lookup for the value by key and its hash, returns the default `V` if hash is not found.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static V GetValueOrDefault<K, V>(this ImHashMap<K, V> map, K key) =>\n            map.GetEntryOrNull(key.GetHashCode())?.GetOrNullWithTheSameHash(key) is ImHashMapEntry<K, V> kv ? kv.Value : default(V);\n\n        \/\/\/ <summary>Lookup for the value by key and its hash, returns the default `V` if hash is not found.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static V GetValueOrDefault<K, V>(this ImHashMap<K, V> map, K key, V defaultValue) =>\n            map.GetEntryOrNull(key.GetHashCode())?.GetOrNullWithTheSameHash(key) is ImHashMapEntry<K, V> kv ? kv.Value : defaultValue;\n\n        \/\/\/ <summary>Lookup for the value by the key using the hash and checking the key with the `object.ReferenceEquals` for equality,\n        \/\/\/  returns found value or the default value if not found<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static V GetValueOrDefaultByReferenceEquals<K, V>(this ImHashMap<K, V> map, int hash, K key) where K : class\n        {\n            var e = map.GetEntryOrNull(hash);\n            return e != null ? e.GetValueOrDefaultByReferenceEqualsWithTheSameHash(key) : default(V);\n        }\n\n        \/\/\/ <summary>Lookup for the value by the key using the hash and checking the key with the `object.ReferenceEquals` for equality,\n        \/\/\/  returns found value or the default value if not found<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static V GetValueOrDefaultByReferenceEquals<K, V>(this ImHashMap<K, V> map, K key) where K : class\n        {\n            var e = map.GetEntryOrNull(key.GetHashCode());\n            return e != null ? e.GetValueOrDefaultByReferenceEqualsWithTheSameHash(key) : default(V);\n        }\n\n        \/\/\/ <summary>Lookup for the value by its hash, returns the `true` and the found value or the `false` otherwise<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static bool TryFind<V>(this ImHashMap<int, V> map, int hash, out V value)\n        {\n            var e = (VEntry<V>)map.GetEntryOrNull(hash);\n            if (e != null)\n            {\n                value = e.Value;\n                return true;\n            }\n            value = default;\n            return false;\n        }\n\n        \/\/\/ <summary>Lookup for the value by its key, returns the `true` and the found value or the `false` otherwise<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static bool TryFind<K, V>(this ImHashMap<K, V> map, int hash, K key, out V value)\n        {\n            var kv = map.GetEntryOrNull(hash)?.GetOrNullWithTheSameHash(key);\n            if (kv != null)\n            {\n                value = kv.Value;\n                return true;\n            }\n            value = default(V);\n            return false;\n        }\n\n        \/\/\/ <summary>Lookup for the value by the key using its hash and checking the key with the `object.Equals` for equality,\n        \/\/\/ returns the `true` and the found value or the `false` otherwise<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static bool TryFind<K, V>(this ImHashMap<K, V> map, K key, out V value) =>\n            map.TryFind(key.GetHashCode(), key, out value);\n\n        \/\/\/ <summary>Lookup for the value by its key, returns the `true` and the found value or the `false` otherwise<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static bool TryFindByReferenceEquals<K, V>(this ImHashMap<K, V> map, int hash, K key, out V value) where K : class\n        {\n            var kv = map.GetEntryOrNull(hash)?.GetOrNullByReferenceEqualsWithTheSameHash(key);\n            if (kv != null)\n            {\n                value = kv.Value;\n                return true;\n            }\n            value = default(V);\n            return false;\n        }\n\n        \/\/\/ <summary>Lookup for the value by its key, returns the `true` and the found value or the `false` otherwise<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static bool TryFindByReferenceEquals<K, V>(this ImHashMap<K, V> map, K key, out V value) where K : class =>\n            map.TryFindByReferenceEquals(key.GetHashCode(), key, out value);\n\n        \/\/\/ <summary>Creates the entry with the `int` key (which will be used as the key)<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMapEntry<int, V> Entry<V>(int key, V value) => new VEntry<V>(key, value);\n\n        \/\/\/ <summary>Creates the entry with the `int` key but without assigning its value yet<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMapEntry<int, V> DefaultEntry<V>(int key) => new VEntry<V>(key);\n\n        \/\/\/ <summary>Copies the entry but without its value<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMapEntry<int, V> WithDefaultValue<V>(this ImHashMapEntry<int, V> e) => new VEntry<V>(e.Hash);\n\n        \/\/\/ <summary>Creates the entry with the custom provided hash<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMapEntry<K, V> Entry<K, V>(int hash, K key, V value) => new KVEntry<K, V>(hash, key, value);\n\n        \/\/\/ <summary>Creates the entry but without assigning its value yet<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMapEntry<K, V> DefaultEntry<K, V>(int hash, K key) => new KVEntry<K, V>(hash, key);\n\n        \/\/\/ <summary>Copies the entry but without its value<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMapEntry<K, V> WithDefaultValue<K, V>(this ImHashMapEntry<K, V> e) => new KVEntry<K, V>(e.Hash, e.Key);\n\n        \/\/\/ <summary>Sugar to set the value and return the entry<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMapEntry<K, V> SetValue<K, V>(this ImHashMapEntry<K, V> e, V value)\n        {\n            e.Value = value;\n            return e;\n        }\n\n        \/\/\/ <summary>Adds the entry and returns the new map or if the hash is present then return the found entry or the newEntry if the map is empty, \n        \/\/\/ so you may check the result like this `if (res is ImMapEntry&lt;V&gt; entry &amp;&amp; entry != newEntry)`<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<int, V> AddOrGetEntry<V>(this ImHashMap<int, V> map, ImHashMapEntry<int, V> newEntry) =>\n            map.AddOrGetEntry(newEntry.Hash, newEntry);\n\n        \/\/\/ <summary>Adds the entry and returns the new map or if the hash is present then return the found entry or the newEntry if the map is empty, \n        \/\/\/ so you may check the result like this `if (res is ImMapEntry&lt;V&gt; entry &amp;&amp; entry != newEntry)`<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<K, V> AddOrGetEntry<K, V>(this ImHashMap<K, V> map, ImHashMapEntry<K, V> newEntry)\n        {\n            var mapOrOldEntry = map.AddOrGetEntry(newEntry.Hash, newEntry);\n            if (mapOrOldEntry is ImHashMap<K, V>.Entry oldEntry && oldEntry != newEntry)\n                return oldEntry.GetOrNullWithTheSameHash(newEntry.Key) ?? map.ReplaceEntry(oldEntry, oldEntry.AddWithTheSameKey(newEntry));\n            return mapOrOldEntry;\n        }\n\n        \/\/\/ <summary>Adds or updates (no in-place mutation) the map with the new entry, always returning the NEW map!<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<int, V> AddOrUpdateEntry<V>(this ImHashMap<int, V> map, ImHashMapEntry<int, V> newEntry)\n        {\n            var mapOrOldEntry = map.AddOrGetEntry(newEntry.Hash, newEntry);\n            if (mapOrOldEntry is ImHashMap<int, V>.Entry oldEntry && oldEntry != newEntry)\n                return map.ReplaceEntry(oldEntry, newEntry);\n            return mapOrOldEntry;\n        }\n\n        \/\/ todo: @perf add ...ByReferenceEquals\n        \/\/\/ <summary>Adds or updates (no in-place mutation) the map with the new entry, always returning the NEW map!<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<K, V> AddOrUpdateEntry<K, V>(this ImHashMap<K, V> map, ImHashMapEntry<K, V> newEntry)\n        {\n            var mapOrOldEntry = map.AddOrGetEntry(newEntry.Hash, newEntry);\n            if (mapOrOldEntry is ImHashMap<K, V>.Entry oldEntry && oldEntry != newEntry)\n                return map.ReplaceEntry(oldEntry, oldEntry.AddOrUpdateWithTheSameHash(newEntry));\n            return mapOrOldEntry;\n        }\n\n        \/\/\/ <summary>Adds or updates (no in-place mutation) the map with value by the passed hash and key, always returning the NEW map!<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<int, V> AddOrUpdate<V>(this ImHashMap<int, V> map, int hash, V value) =>\n            map.AddOrUpdateEntry(Entry(hash, value));\n\n        \/\/\/ <summary>Adds or updates (no in-place mutation) the map with value by the passed hash and key, always returning the NEW map!<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<K, V> AddOrUpdate<K, V>(this ImHashMap<K, V> map, int hash, K key, V value) =>\n            map.AddOrUpdateEntry(Entry(hash, key, value));\n\n        \/\/\/ <summary>Adds or updates (no in-place mutation) the map with value by the passed key, always returning the NEW map!<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<K, V> AddOrUpdate<K, V>(this ImHashMap<K, V> map, K key, V value) =>\n            map.AddOrUpdateEntry(Entry(key.GetHashCode(), key, value));\n\n        \/\/\/ <summary>Adds or updates (no in-place mutation) the map with value by the passed hash and key, always returning the NEW map!<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<int, V> AddOrUpdate<V>(this ImHashMap<int, V> map, int hash, V value, Update<int, V> update)\n        {\n            var newEntry = Entry(hash, value);\n            var mapOrOldEntry = map.AddOrGetEntry(hash, newEntry);\n            if (mapOrOldEntry is ImHashMapEntry<int, V> oldEntry && oldEntry != newEntry)\n                return map.ReplaceEntry(oldEntry, Entry(hash, update(hash, oldEntry.Value, value)));\n            return mapOrOldEntry;\n        }\n\n        \/\/\/ <summary>Adds or updates (no in-place mutation) the map with value by the passed key, always returning the NEW map!<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<K, V> AddOrUpdate<K, V>(this ImHashMap<K, V> map, int hash, K key, V value, Update<K, V> update)\n        {\n            var newEntry = Entry(hash, key, value);\n            var mapOrOldEntry = map.AddOrGetEntry(hash, newEntry);\n            if (mapOrOldEntry is ImHashMap<K, V>.Entry oldEntry && oldEntry != newEntry)\n                return map.ReplaceEntry(oldEntry, oldEntry.AddOrUpdateWithTheSameHash(newEntry, update));\n            return mapOrOldEntry;\n        }\n\n        \/\/\/ <summary>Adds or updates (no in-place mutation) the map with value by the passed key, always returning the NEW map!<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<K, V> AddOrUpdate<K, V>(this ImHashMap<K, V> map, K key, V value, Update<K, V> update) =>\n            map.AddOrUpdate(key.GetHashCode(), key, value, update);\n\n        \/\/\/ <summary>Produces the new map with the new entry or keeps the existing map if the entry with the key is already present<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<int, V> AddOrKeepEntry<V>(this ImHashMap<int, V> map, ImHashMapEntry<int, V> newEntry)\n        {\n            var mapOrOldEntry = map.AddOrGetEntry(newEntry.Hash, newEntry);\n            return mapOrOldEntry is ImHashMapEntry<int, V> oldEntry && oldEntry != newEntry ? map : mapOrOldEntry;\n        }\n\n        \/\/\/ <summary>Produces the new map with the new entry or keeps the existing map if the entry with the hash is already present<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<int, V> AddOrKeep<V>(this ImHashMap<int, V> map, int hash, V value) =>\n            map.AddOrKeepEntry(Entry(hash, value));\n\n        \/\/\/ <summary>Produces the new map with the new entry or keeps the existing map if the entry with the key is already present<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<K, V> AddOrKeepEntry<K, V>(this ImHashMap<K, V> map, ImHashMapEntry<K, V> newEntry)\n        {\n            var hash = newEntry.Hash;\n            var mapOrOldEntry = map.AddOrGetEntry(hash, newEntry);\n            if (mapOrOldEntry is ImHashMap<K, V>.Entry oldEntry && oldEntry != newEntry)\n            {\n                var added = oldEntry.AddedOrNullWithTheSameHash(newEntry);\n                return added == null ? map : map.ReplaceEntry(oldEntry, added);\n            }\n            return mapOrOldEntry;\n        }\n\n        \/\/\/ <summary>Produces the new map with the new entry or keeps the existing map if the entry with the key is already present<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<K, V> AddOrKeep<K, V>(this ImHashMap<K, V> map, int hash, K key, V value) =>\n            map.AddOrKeepEntry(Entry(hash, key, value));\n\n        \/\/\/ <summary>Produces the new map with the new entry or keeps the existing map if the entry with the key is already present<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<K, V> AddOrKeep<K, V>(this ImHashMap<K, V> map, K key, V value) =>\n            map.AddOrKeepEntry(Entry(key.GetHashCode(), key, value));\n\n        \/\/\/ <summary>Updates the map with the new value if the hash is found otherwise returns the same unchanged map.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<int, V> Update<V>(this ImHashMap<int, V> map, int hash, V value)\n        {\n            var entry = map.GetEntryOrNull(hash);\n            return entry == null ? map : map.ReplaceEntry(entry, Entry(hash, value));\n        }\n\n        \/\/\/ <summary>Updates the map with the default value if the hash is found otherwise returns the same unchanged map.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<int, V> UpdateToDefault<V>(this ImHashMap<int, V> map, int hash)\n        {\n            var entry = map.GetEntryOrNull(hash);\n            return entry == null ? map : map.ReplaceEntry(entry, DefaultEntry<V>(hash));\n        }\n\n        \/\/\/ <summary>Updates the map with the new value if the key is found otherwise returns the same unchanged map.<\/summary>\n        public static ImHashMap<K, V> Update<K, V>(this ImHashMap<K, V> map, int hash, K key, V value)\n        {\n            var entry = map.GetEntryOrNull(hash);\n            if (entry == null)\n                return map;\n            var updated = entry.UpdatedOrNullWithTheSameHash(Entry(hash, key, value));\n            return updated == null ? map : map.ReplaceEntry(entry, updated);\n        }\n\n        \/\/\/ <summary>Updates the map with the new value if the key is found otherwise returns the same unchanged map.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<K, V> Update<K, V>(this ImHashMap<K, V> map, K key, V value) =>\n            map.Update(key.GetHashCode(), key, value);\n\n        \/\/\/ <summary>Updates the map with the new value if the key is found otherwise returns the same unchanged map.<\/summary>\n        public static ImHashMap<K, V> UpdateToDefault<K, V>(this ImHashMap<K, V> map, int hash, K key)\n        {\n            var entry = map.GetEntryOrNull(hash);\n            if (entry == null)\n                return map;\n            var updated = entry.UpdatedOrNullWithTheSameHash(DefaultEntry<K, V>(hash, key));\n            return updated == null ? map : map.ReplaceEntry(entry, updated);\n        }\n\n        \/\/\/ <summary>Updates the map with the new value if the key is found otherwise returns the same unchanged map.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<K, V> UpdateToDefault<K, V>(this ImHashMap<K, V> map, K key) =>\n            map.UpdateToDefault(key.GetHashCode(), key);\n\n        \/\/\/ <summary>Updates the map with the new value and the `update` function if the key is found otherwise returns the same unchanged map.\n        \/\/\/ If `update` returns the same map if the updated result is the same<\/summary>\n        public static ImHashMap<K, V> Update<K, V>(this ImHashMap<K, V> map, int hash, K key, V value, Update<K, V> update)\n        {\n            var entry = map.GetEntryOrNull(hash);\n            if (entry == null)\n                return map;\n            var updated = entry.UpdatedOrNullWithTheSameHash(key, value, update);\n            return updated == null ? map : map.ReplaceEntry(entry, updated);\n        }\n\n        \/\/\/ <summary>Updates the map with the new value and the `update` function if the key is found otherwise returns the same unchanged map.\n        \/\/\/ If `update` returns the same map if the updated result is the same<\/summary>\n        public static ImHashMap<K, V> Update<K, V>(this ImHashMap<K, V> map, K key, V value, Update<K, V> update) =>\n            map.Update(key.GetHashCode(), key, value, update);\n\n        \/\/\/ <summary>Returns the new map without the specified hash (if found) or returns the same map otherwise<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<int, V> Remove<V>(this ImHashMap<int, V> map, int hash)\n        {\n            var entryToRemove = map.GetEntryOrNull(hash);\n            return entryToRemove == null ? map : map.RemoveEntry(entryToRemove);\n        }\n\n        \/\/ todo: @perf minimize virtual calls\n        \/\/ todo: @perf or rather what if I move a static method inside the map and override it in VEntry or KVEntry to speedup it for 1 item map, at least\n        \/\/\/ <summary>Returns the new map without the specified hash and key (if found) or returns the same map otherwise<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<K, V> Remove<K, V>(this ImHashMap<K, V> map, int hash, K key)\n        {\n            var entryToRemove = map.GetEntryOrNull(hash);\n            if (entryToRemove != null)\n            {\n                var removed = entryToRemove.RemovedOrNullWithTheSameHash(key);\n                if (removed == entryToRemove)\n                    return map.RemoveEntry(entryToRemove);\n                if (removed != null)\n                    return map.ReplaceEntry(entryToRemove, removed);\n            }\n            return map;\n        }\n\n        \/\/\/ <summary>Returns the new map without the specified hash and key (if found) or returns the same map otherwise<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<K, V> Remove<K, V>(this ImHashMap<K, V> map, K key) =>\n            map == ImHashMap<K, V>.Empty ? map : map.Remove(key.GetHashCode(), key); \/\/ it make sense to have the empty map condition here to prevent the probably costly `GetHashCode()` for the empty map.\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ The fixed array of maps (partitions) where the key first (lower) bits are used to locate the partion to lookup into.\n    \/\/\/ Note: The partition array is NOT immutable and operates by swapping the updated partition with the new one.\n    \/\/\/ The number of partitions may be specified by user or you can use the default number 16.\n    \/\/\/ The default number 16 was selected to be not so big to pay for the few items and not so small to diminish the use of partitions.\n    \/\/\/ <\/summary>\n    public static class PartitionedHashMap\n    {\n        \/\/\/ <summary>The default number of partions<\/summary>\n        public const int PARTITION_COUNT_POWER_OF_TWO = 16;\n\n        \/\/\/ <summary>The default mask to partition the key<\/summary>\n        public const int PARTITION_HASH_MASK = PARTITION_COUNT_POWER_OF_TWO - 1;\n\n        \/\/\/ <summary>Creates the new collection with the empty partions<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<K, V>[] CreateEmpty<K, V>(int partitionCountOfPowerOfTwo = PARTITION_COUNT_POWER_OF_TWO)\n        {\n            var parts = new ImHashMap<K, V>[partitionCountOfPowerOfTwo];\n            for (var i = 0; i < parts.Length; ++i)\n                parts[i] = ImHashMap<K, V>.Empty;\n            return parts;\n        }\n\n        \/\/\/ <summary>Creates the new collection with the empty partions<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static ImHashMap<int, V>[] CreateEmpty<V>(int partitionCountOfPowerOfTwo = PARTITION_COUNT_POWER_OF_TWO)\n        {\n            var parts = new ImHashMap<int, V>[partitionCountOfPowerOfTwo];\n            for (var i = 0; i < parts.Length; ++i)\n                parts[i] = ImHashMap<int, V>.Empty;\n            return parts;\n        }\n\n        \/\/\/ <summary>Lookup for the value by the key using its hash, returns the default `V` if not found.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static V GetValueOrDefault<V>(this ImHashMap<int, V>[] parts, int hash, int partHashMask = PARTITION_HASH_MASK)\n        {\n            var p = parts[hash & partHashMask];\n            return p != null && p.GetEntryOrNull(hash) is ImHashMapEntry<int, V> kv ? kv.Value : default(V);\n        }\n\n        \/\/\/ <summary>Lookup for the value by the key and its hash, returns the default `V` if not found.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static V GetValueOrDefault<K, V>(this ImHashMap<K, V>[] parts, int hash, K key, int partHashMask = PARTITION_HASH_MASK)\n        {\n            var p = parts[hash & partHashMask];\n            return p != null ? p.GetValueOrDefault(hash, key) : default(V);\n        }\n\n        \/\/\/ <summary>Lookup for the value by the key and its hash, returns the default `V` if not found.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static V GetValueOrDefault<K, V>(this ImHashMap<K, V>[] parts, K key, int partHashMask = PARTITION_HASH_MASK) =>\n            parts.GetValueOrDefault(key.GetHashCode(), key, partHashMask);\n\n\n        \/\/\/ <summary>Lookup for the value by the key using the hash and checking the key with the `object.ReferenceEquals` for equality,\n        \/\/\/  returns found value or the default value if not found<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static V GetValueOrDefaultByReferenceEquals<K, V>(this ImHashMap<K, V>[] parts, int hash, K key, int partHashMask = PARTITION_HASH_MASK) where K : class\n        {\n            var p = parts[hash & partHashMask];\n            return p != null ? p.GetValueOrDefaultByReferenceEquals(hash, key) : default(V);\n        }\n\n        \/\/\/ <summary>Lookup for the value by the key using its hash and checking the key with the `object.ReferenceEquals` for equality, \n        \/\/\/ returns the default `V` if hash, key are not found.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static V GetValueOrDefaultByReferenceEquals<K, V>(this ImHashMap<K, V>[] parts, K key, int partHashMask = PARTITION_HASH_MASK) where K : class =>\n            parts.GetValueOrDefaultByReferenceEquals(key.GetHashCode(), key, partHashMask);\n\n        \/\/\/ <summary>Lookup for the value by the key using the hash, returns the `true` and the found value or the `false`<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static bool TryFind<V>(this ImHashMap<int, V>[] parts, int hash, out V value, int partHashMask = PARTITION_HASH_MASK)\n        {\n            var p = parts[hash & partHashMask];\n            if (p != null)\n                return p.TryFind(hash, out value);\n            value = default(V);\n            return false;\n        }\n\n        \/\/\/ <summary>Lookup for the value by the key and the hash, returns the `true` and the found value or the `false`<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static bool TryFind<K, V>(this ImHashMap<K, V>[] parts, int hash, K key, out V value, int partHashMask = PARTITION_HASH_MASK)\n        {\n            var p = parts[hash & partHashMask];\n            if (p != null)\n                return p.TryFind(hash, key, out value);\n            value = default(V);\n            return false;\n        }\n\n        \/\/\/ <summary>Lookup for the value by the key and the hash, returns the `true` and the found value or the `false`<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static bool TryFind<K, V>(this ImHashMap<K, V>[] parts, K key, out V value, int partHashMask = PARTITION_HASH_MASK) =>\n            parts.TryFind(key.GetHashCode(), key, out value, partHashMask);\n\n        \/\/\/ <summary>Lookup for the value by the key using the hash code and checking the key with the `object.ReferenceEquals` for equality,\n        \/\/\/ returns the `true` and the found value or the `false`<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static bool TryFindByReferenceEquals<K, V>(this ImHashMap<K, V>[] parts, int hash, K key, out V value,\n            int partHashMask = PARTITION_HASH_MASK) where K : class\n        {\n            var p = parts[hash & partHashMask];\n            if (p != null)\n                return p.TryFindByReferenceEquals(hash, key, out value);\n            value = default(V);\n            return false;\n        }\n\n        \/\/\/ <summary>Lookup for the value by the key using the hash code and checking the key with the `object.ReferenceEquals` for equality,\n        \/\/\/ returns the `true` and the found value or the `false`<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static bool TryFindByReferenceEquals<K, V>(this ImHashMap<K, V>[] parts, K key, out V value,\n            int partHashMask = PARTITION_HASH_MASK) where K : class =>\n            parts.TryFindByReferenceEquals(key.GetHashCode(), key, out value, partHashMask);\n\n        \/\/\/ <summary>Returns the SAME partitioned maps array instance but with the NEW added or updated partion<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static void AddOrUpdate<V>(this ImHashMap<int, V>[] parts, int hash, V value, int partHashMask = PARTITION_HASH_MASK)\n        {\n            ref var part = ref parts[hash & partHashMask];\n            var p = part;\n            if (Interlocked.CompareExchange(ref part, p.AddOrUpdate(hash, value), p) != p)\n                RefAddOrUpdatePart(ref part, hash, value);\n        }\n\n        private static void RefAddOrUpdatePart<V>(ref ImHashMap<int, V> part, int hash, V value) =>\n            Ref.Swap(ref part, hash, value, (x, h, v) => x.AddOrUpdate(h, v));\n\n        \/\/\/ <summary>Returns the SAME partitioned maps array instance but with the NEW added or updated partion<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static void AddOrUpdate<K, V>(this ImHashMap<K, V>[] parts, int hash, K key, V value, int partHashMask = PARTITION_HASH_MASK)\n        {\n            ref var part = ref parts[hash & partHashMask];\n            var p = part;\n            if (Interlocked.CompareExchange(ref part, p.AddOrUpdate(hash, key, value), p) != p)\n                RefAddOrUpdatePart(ref part, hash, key, value);\n        }\n\n        \/\/\/ <summary>Returns the SAME partitioned maps array instance but with the NEW added or updated partion<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static void AddOrUpdate<K, V>(this ImHashMap<K, V>[] parts, K key, V value, int partHashMask = PARTITION_HASH_MASK) =>\n            parts.AddOrUpdate(key.GetHashCode(), key, value, partHashMask);\n\n        private static void RefAddOrUpdatePart<K, V>(ref ImHashMap<K, V> part, int hash, K key, V value) =>\n            Ref.Swap(ref part, hash, key, value, (x, h, k, v) => x.AddOrUpdate(h, k, v));\n\n        \/\/\/ <summary>Returns the SAME partitioned maps array instance but with the NEW added or updated partion<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static void AddOrUpdate<V>(this ImHashMap<int, V>[] parts, int hash, V value, Update<int, V> update, int partHashMask = PARTITION_HASH_MASK)\n        {\n            ref var part = ref parts[hash & partHashMask];\n            var p = part;\n            if (Interlocked.CompareExchange(ref part, p.AddOrUpdate(hash, value, update), p) != p)\n                Ref.Swap(ref part, hash, value, update, (x, h, k, u) => x.AddOrUpdate(h, k, u));\n        }\n\n        \/\/\/ <summary>Returns the SAME partitioned maps array instance but with the NEW added or updated partion<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static void AddOrUpdate<K, V>(this ImHashMap<K, V>[] parts, int hash, K key, V value, Update<K, V> update, int partHashMask = PARTITION_HASH_MASK)\n        {\n            ref var part = ref parts[hash & partHashMask];\n            var p = part;\n            if (Interlocked.CompareExchange(ref part, p.AddOrUpdate(hash, key, value, update), p) != p)\n                Ref.Swap(ref part, hash, key, value, update, (x, h, k, v, u) => x.AddOrUpdate(h, k, v, u));\n        }\n\n        \/\/\/ <summary>Returns the SAME partitioned maps array instance but with the NEW added or updated partion<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static void AddOrUpdate<K, V>(this ImHashMap<K, V>[] parts, K key, V value, Update<K, V> update, int partHashMask = PARTITION_HASH_MASK) =>\n            parts.AddOrUpdate(key.GetHashCode(), key, value, update);\n\n        \/\/\/ <summary>Returns the SAME partitioned maps array instance but with the NEW added or the same kept partion<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static void AddOrKeep<V>(this ImHashMap<int, V>[] parts, int hash, V value, int partHashMask = PARTITION_HASH_MASK)\n        {\n            ref var part = ref parts[hash & partHashMask];\n            var p = part;\n            if (Interlocked.CompareExchange(ref part, p.AddOrKeep(hash, value), p) != p)\n                RefAddOrKeepPart(ref part, hash, value);\n        }\n\n        private static void RefAddOrKeepPart<V>(ref ImHashMap<int, V> part, int hash, V value) =>\n            Ref.Swap(ref part, hash, value, (x, h, v) => x.AddOrUpdate(h, v));\n\n        \/\/\/ <summary>Returns the SAME partitioned maps array instance but with the NEW added or the same kept partion<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static void AddOrKeep<K, V>(this ImHashMap<K, V>[] parts, int hash, K key, V value, int partHashMask = PARTITION_HASH_MASK)\n        {\n            ref var part = ref parts[hash & partHashMask];\n            var p = part;\n            if (Interlocked.CompareExchange(ref part, p.AddOrKeep(hash, key, value), p) != p)\n                RefAddOrKeepPart(ref part, hash, key, value);\n        }\n\n        private static void RefAddOrKeepPart<K, V>(ref ImHashMap<K, V> part, int hash, K key, V value) =>\n            Ref.Swap(ref part, hash, key, value, (x, h, k, v) => x.AddOrUpdate(h, k, v));\n\n        \/\/\/ <summary>Updates the map with the new value if the hash is found otherwise returns the same unchanged map.<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static void Update<V>(this ImHashMap<int, V>[] parts, int hash, V value, int partHashMask = PARTITION_HASH_MASK)\n        {\n            ref var part = ref parts[hash & partHashMask];\n            var p = part;\n            if (Interlocked.CompareExchange(ref part, p.Update(hash, value), p) != p)\n                RefUpdatePart(ref part, hash, value);\n        }\n\n        private static void RefUpdatePart<V>(ref ImHashMap<int, V> part, int hash, V value) =>\n            Ref.Swap(ref part, hash, value, (x, h, v) => x.Update(h, v));\n\n        \/\/\/ <summary>Do something for each entry.\n        \/\/\/ The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.\n        \/\/\/ So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls<\/summary>\n        [MethodImpl((MethodImplOptions)256)]\n        public static IEnumerable<ImHashMapEntry<K, V>> Enumerate<K, V>(this ImHashMap<K, V>[] parts)\n        {\n            foreach (var map in parts)\n            {\n                if (map == ImHashMap<K, V>.Empty)\n                    continue;\n                foreach (var entry in map.Enumerate())\n                    yield return entry;\n            }\n        }\n\n        \/\/\/ <summary>Do something for each entry.\n        \/\/\/ The `parents` parameter allows to reuse the stack memory used for the traversal between multiple calls.\n        \/\/\/ So you may pass the empty `parents` into the first `Enumerate` and then keep passing the same `parents` into the subsequent calls<\/summary>\n        public static S ForEach<K, V, S>(this ImHashMap<K, V>[] parts, S state, Action<ImHashMapEntry<K, V>, int, S> handler, MapParentStack parents = null)\n        {\n            if (parents == null)\n                parents = new MapParentStack();\n            foreach (var map in parts)\n            {\n                if (map == ImHashMap<K, V>.Empty)\n                    continue;\n                state = map.ForEach(state, handler, parents);\n            }\n            return state;\n        }\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"64f477ce09411a693c0e079fc9ca7c975e051c23","subject":"generation starts from 1","message":"generation starts from 1\n","repos":"DOTNET2016\/GOL","old_file":"GOL\/GOLHandler.cs","new_file":"GOL\/GOLHandler.cs","new_contents":"\ufeffusing System;\r\nusing System.Collections.Generic;\r\nusing System.Data.Entity.Spatial;\r\nusing System.Diagnostics;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nusing System.Windows;\r\nusing System.Windows.Threading;\r\n\r\nnamespace GOL\r\n{\r\n    class GOLHandler\r\n    {\r\n        \/\/Fields\r\n        private Cell[,] ActualGeneration = new Cell[80, 60];\r\n        private Cell[,] NextGeneration = new Cell[80, 60];\r\n        List<Cell> AliveCells = new List<Cell>();\r\n        DispatcherTimer timer;\r\n        PlayerNameIntro Intro = new PlayerNameIntro();\r\n\r\n        \/\/Event\r\n        public event EventHandler Timer_Ticked;\r\n\r\n        \/\/Constructor\r\n        public GOLHandler()\r\n        {\r\n            int value = 300;\r\n            timer = new DispatcherTimer();\r\n            timer.Interval = TimeSpan.FromMilliseconds(value);\r\n            \/\/timer.IsEnabled = true;\r\n            \/\/timer.Stop();\r\n            timer.Tick += Timer_Tick;\r\n        }\r\n\r\n        \/\/Tick handler that raises the timer_ticked event if it has subscribers.\r\n        private void Timer_Tick(object sender, EventArgs e)\r\n        {\r\n            \/\/Check so the event have a subscriber.\r\n            if (Timer_Ticked != null)\r\n            {\r\n                Timer_Ticked.Invoke(this, new EventArgs());\r\n            }\r\n\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Method for adding new cells to the ActualGeneration.\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <param name=\"cell\">Send the cell you want to add.<\/param>\r\n        public void AddCell(Cell cell)\r\n        {\r\n            ActualGeneration.SetValue(cell, cell.X, cell.Y);\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Send the coordinates from the position you click in the canvas and the radius of the square the cells is in.\r\n        \/\/\/ This method will divide the coordinates by 10 and rounds it to nearest even 10.\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <param name=\"X_index\">send The X coordinate.<\/param>\r\n        \/\/\/ <param name=\"Y_index\">Send The Y coordinate<\/param>\r\n        \/\/\/ <param name=\"RadiusOfTheSquare\">Send the Radius of the Square<\/param>\r\n        public void KillOrMakeCell(double X_index, double Y_index,int RadiusOfTheSquare)\r\n        {\r\n            \/\/Casting the values to an int.\r\n            int X = (int)X_index;\r\n            int Y = (int)Y_index;\r\n\r\n            \/\/Substract the radius value so it will be the center point.\r\n            X -= RadiusOfTheSquare;\r\n            Y -= RadiusOfTheSquare;\r\n\r\n            \/\/Rounds it to the nearest 10.\r\n            X = ((int)Math.Round(X \/ 10.0));\r\n            Y = ((int)Math.Round(Y \/ 10.0));\r\n\r\n            \/\/Kill or make the cell alive.\r\n            if (ActualGeneration[X, Y].IsAlive == true)\r\n            {\r\n                ActualGeneration[X, Y].IsAlive = false;\r\n            }\r\n            else\r\n            {\r\n                ActualGeneration[X, Y].IsAlive = true;\r\n            }\r\n        }\r\n      \r\n\r\n        public void UpdateDatabase()\r\n        {\r\n            for (int i = 0; i < ActualGeneration.GetLength(0); i++)\r\n            {\r\n                for (int j = 0; j < ActualGeneration.GetLength(1); j++)\r\n                {\r\n                    if (ActualGeneration[i, j].IsAlive)\r\n                    {\r\n                        var c = ActualGeneration[i, j];\r\n                        AliveCells.Add(new Cell(c.X, c.Y, true));\r\n                    }\r\n                }\r\n            }\r\n\r\n            using (GContext db = new GContext())\r\n            {\r\n                int maxGen;\r\n\r\n                if(db.Generations.Count() != 1)\r\n                {\r\n                maxGen = db.Generations.Max(p => p.GenNumber);\r\n                    maxGen += 1;\r\n                }\r\n                else\r\n                {\r\n                    maxGen = 1;\r\n                }\r\n               \r\n                \r\n                foreach (var item in AliveCells)\r\n                {\r\n                    Generation gen = new Generation();\r\n\r\n                    gen.GenNumber = maxGen;\r\n                    gen.Cell_X = item.X;\r\n                    gen.Cell_Y = item.Y;\r\n                    db.Generations.Add(gen);\r\n                }\r\n                db.SaveChanges();\r\n                AliveCells.Clear();\r\n            }\r\n\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Method that looping through the ActualGenerations MultiDimensionalArray,\r\n        \/\/\/ And Checks how many neighboor every cell has and then make the new generation.\r\n        \/\/\/ <\/summary>\r\n        public void calculateNextGeneration()\r\n        {\r\n            for (int i = 0; i < ActualGeneration.GetLength(0); i++)\r\n            {\r\n                for (int j = 0; j < ActualGeneration.GetLength(1); j++)\r\n                {\r\n                    \/\/Method for count how many neighboor every cell has and then throw it into the switch.\r\n                    int neighboors = CheckLivingNeighboors(i, j);\r\n\r\n                    #region SwitchOnAllTheCells\r\n                    switch (neighboors)\r\n                    {\r\n                        case 0:\r\n                            {\r\n                                NextGeneration.SetValue(new Cell(i, j), i, j);\r\n                                break;\r\n                            }\r\n                        case 1:\r\n                            {\r\n                                NextGeneration.SetValue(new Cell(i, j), i, j);\r\n                                break;\r\n                            }\r\n                        case 2:\r\n                            {\r\n                                if (ActualGeneration[i, j].IsAlive)\r\n                                {\r\n                                    NextGeneration.SetValue(new Cell(i, j), i, j);\r\n                                    NextGeneration[i, j].IsAlive = true;\r\n                                    break;\r\n                                }\r\n                                else\r\n                                {\r\n                                    NextGeneration.SetValue(new Cell(i, j), i, j);\r\n                                }\r\n                                break;\r\n                            }\r\n                        case 3:\r\n                            {\r\n                                NextGeneration.SetValue(new Cell(i, j), i, j);\r\n                                NextGeneration[i, j].IsAlive = true;\r\n                                break;\r\n                            }\r\n                        default:\r\n                            {\r\n                                NextGeneration.SetValue(new Cell(i, j), i, j);\r\n                                break;\r\n                            }\r\n                            #endregion\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Method that returns the actualGeneration. \r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <returns>Actual generation MultiDimensionalArray with the cells.<\/returns>\r\n        public Cell[,] GetActualGeneration()\r\n        {\r\n            return ActualGeneration;\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Start the timer, The interval is 2 seconds by default.\r\n        \/\/\/ <\/summary>\r\n        public void Start_Timer()\r\n        {\r\n            timer.Start();\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Stops the timer.\r\n        \/\/\/ <\/summary>\r\n        public void Stop_Timer()\r\n        {\r\n            timer.Stop();\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Method that returns the NextGeneration MultiDimensionalArrat with the cells.\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <returns><\/returns>\r\n        public Cell[,] GetNextGeneration()\r\n        {\r\n            return NextGeneration;\r\n        }\r\n\r\n        \/\/Checks the surrounding Neighboor-Cells\r\n        public int CheckLivingNeighboors(int x, int y)\r\n        {\r\n            \/\/take the length of X and Y from ActualGeneration.\r\n            int Xlength = ActualGeneration.GetLength(0);\r\n            int Ylength = ActualGeneration.GetLength(1);\r\n\r\n            \/\/Start counting from zero neighboors.\r\n            int neighbours = 0;\r\n\r\n            #region CountingNeighboors\r\n            \/\/Right\r\n            if (x < Xlength - 1)\r\n                if (ActualGeneration[x + 1, y].IsAlive)\r\n                    neighbours++;\r\n            \/\/Bottom Right\r\n            if (x < Xlength - 1 && y < Ylength - 1)\r\n                if (ActualGeneration[x + 1, y + 1].IsAlive)\r\n                    neighbours++;\r\n            \/\/Bottom\r\n            if (y < Ylength - 1)\r\n                if (ActualGeneration[x, y + 1].IsAlive)\r\n                    neighbours++;\r\n            \/\/Bottom Left\r\n            if (x > 0 && y < Ylength - 1)\r\n                if (ActualGeneration[x - 1, y + 1].IsAlive)\r\n                    neighbours++;\r\n            \/\/Left\r\n            if (x > 0)\r\n                if (ActualGeneration[x - 1, y].IsAlive)\r\n                    neighbours++;\r\n            \/\/Top Left\r\n            if (x > 0 && y > 0)\r\n                if (ActualGeneration[x - 1, y - 1].IsAlive)\r\n                    neighbours++;\r\n            \/\/Top\r\n            if (y > 0)\r\n                if (ActualGeneration[x, y - 1].IsAlive)\r\n                    neighbours++;\r\n            \/\/Top Right\r\n            if (x < Xlength - 1 && y != 0)\r\n                if (ActualGeneration[x + 1, y - 1].IsAlive)\r\n                    neighbours++;\r\n            #endregion\r\n\r\n            return neighbours;\r\n        }\r\n    }\r\n}\r\n\r\n\/\/public void SendToGenTable(double X_index, double Y_index)\r\n\/\/{\r\n\/\/    using (GoLContext db = new GoLContext())\r\n\/\/    {\r\n\/\/        Generation gen = new Generation();\r\n\/\/        var coords = GetActualGeneration();\r\n\/\/        int X = (int)X_index;\r\n\/\/        int Y = (int)Y_index;\r\n\r\n\/\/        gen.Cell_X = X;\r\n\/\/        gen.Cell_Y = Y;\r\n\/\/        gen.IsAlive = true;\r\n\r\n\/\/        for (int i = 0; i < coords.GetLength(0); i++)\r\n\/\/        {\r\n\/\/            for (int j = 0; j < coords.GetLength(1); j++)\r\n\/\/            {\r\n\/\/                if (coords[i, j].IsAlive == true)\r\n\/\/                {\r\n\/\/                    db.Generation.Add(gen);\r\n\/\/                }\r\n\/\/            }\r\n\/\/        }\r\n\/\/        db.SaveChanges();\r\n\/\/    }\r\n\/\/}\r\n\r\n\r\n\r\n\/\/    --CREATE TABLE Generation\r\n\/\/--(\r\n\/\/--\tGen_id int IDENTITY(1,1) PRIMARY KEY,\r\n\/\/--\tGenNumber int NOT NULL,\r\n\/\/--\tCell_X int NOT NULL,\r\n\/\/--\tCell_Y int NOT NULL,\r\n\/\/--\tIsAlive bit DEFAULT(0) NOT NULL,\r\n\/\/--\tSavedGame_id int FOREIGN KEY REFERENCES SavedGames(SavedGame_id)\r\n\/\/--)\r\n\r\n\/\/--CREATE TABLE SavedGames\r\n\/\/--(\r\n\/\/--\tSavedGame_id int IDENTITY(1,1) PRIMARY KEY,\r\n\/\/--\tGenNumber int NOT NULL,\r\n\/\/--\tPlayer_id int FOREIGN KEY REFERENCES Player(Player_id)\r\n\/\/--)\r\n\r\n\/\/--CREATE TABLE Player\r\n\/\/--(\r\n\/\/--\tPlayer_id int IDENTITY(1,1) PRIMARY KEY,\r\n\/\/--\tPlayerName varchar(25),\r\n\/\/--\t--SavedGame_id int FOREIGN KEY REFERENCES SavedGames(SavedGame_id)\r\n\/\/--)\r\n\r\n\/\/--ALTER TABLE Player\r\n\/\/--ADD COLUMN SavedGame_id int\r\n\r\n\/\/--ALTER TABLE Player\r\n\/\/--ADD FOREIGN KEY(SavedGame_id) REFERENCES SavedGames(SavedGame_id)\r\n","old_contents":"\ufeffusing System;\r\nusing System.Collections.Generic;\r\nusing System.Data.Entity.Spatial;\r\nusing System.Diagnostics;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nusing System.Windows;\r\nusing System.Windows.Threading;\r\n\r\nnamespace GOL\r\n{\r\n    class GOLHandler\r\n    {\r\n        \/\/Fields\r\n        private Cell[,] ActualGeneration = new Cell[80, 60];\r\n        private Cell[,] NextGeneration = new Cell[80, 60];\r\n        List<Cell> AliveCells = new List<Cell>();\r\n        DispatcherTimer timer;\r\n        PlayerNameIntro Intro = new PlayerNameIntro();\r\n\r\n        \/\/Event\r\n        public event EventHandler Timer_Ticked;\r\n\r\n        \/\/Constructor\r\n        public GOLHandler()\r\n        {\r\n            int value = 300;\r\n            timer = new DispatcherTimer();\r\n            timer.Interval = TimeSpan.FromMilliseconds(value);\r\n            \/\/timer.IsEnabled = true;\r\n            \/\/timer.Stop();\r\n            timer.Tick += Timer_Tick;\r\n        }\r\n\r\n        \/\/Tick handler that raises the timer_ticked event if it has subscribers.\r\n        private void Timer_Tick(object sender, EventArgs e)\r\n        {\r\n            \/\/Check so the event have a subscriber.\r\n            if (Timer_Ticked != null)\r\n            {\r\n                Timer_Ticked.Invoke(this, new EventArgs());\r\n            }\r\n\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Method for adding new cells to the ActualGeneration.\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <param name=\"cell\">Send the cell you want to add.<\/param>\r\n        public void AddCell(Cell cell)\r\n        {\r\n            ActualGeneration.SetValue(cell, cell.X, cell.Y);\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Send the coordinates from the position you click in the canvas and the radius of the square the cells is in.\r\n        \/\/\/ This method will divide the coordinates by 10 and rounds it to nearest even 10.\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <param name=\"X_index\">send The X coordinate.<\/param>\r\n        \/\/\/ <param name=\"Y_index\">Send The Y coordinate<\/param>\r\n        \/\/\/ <param name=\"RadiusOfTheSquare\">Send the Radius of the Square<\/param>\r\n        public void KillOrMakeCell(double X_index, double Y_index,int RadiusOfTheSquare)\r\n        {\r\n            \/\/Casting the values to an int.\r\n            int X = (int)X_index;\r\n            int Y = (int)Y_index;\r\n\r\n            \/\/Substract the radius value so it will be the center point.\r\n            X -= RadiusOfTheSquare;\r\n            Y -= RadiusOfTheSquare;\r\n\r\n            \/\/Rounds it to the nearest 10.\r\n            X = ((int)Math.Round(X \/ 10.0));\r\n            Y = ((int)Math.Round(Y \/ 10.0));\r\n\r\n            \/\/Kill or make the cell alive.\r\n            if (ActualGeneration[X, Y].IsAlive == true)\r\n            {\r\n                ActualGeneration[X, Y].IsAlive = false;\r\n            }\r\n            else\r\n            {\r\n                ActualGeneration[X, Y].IsAlive = true;\r\n            }\r\n        }\r\n      \r\n\r\n        public void UpdateDatabase()\r\n        {\r\n            for (int i = 0; i < ActualGeneration.GetLength(0); i++)\r\n            {\r\n                for (int j = 0; j < ActualGeneration.GetLength(1); j++)\r\n                {\r\n                    if (ActualGeneration[i, j].IsAlive)\r\n                    {\r\n                        var c = ActualGeneration[i, j];\r\n                        AliveCells.Add(new Cell(c.X, c.Y, true));\r\n                    }\r\n                }\r\n            }\r\n\r\n            using (GContext db = new GContext())\r\n            {\r\n                int maxGen;\r\n\r\n                if(db.Generations.Count() != 0)\r\n                {\r\n                maxGen = db.Generations.Max(p => p.GenNumber);\r\n                    maxGen += 1;\r\n                }\r\n                else\r\n                {\r\n                    maxGen = 0;\r\n                }\r\n               \r\n                \r\n                foreach (var item in AliveCells)\r\n                {\r\n                    Generation gen = new Generation();\r\n\r\n                    gen.GenNumber = maxGen;\r\n                    gen.Cell_X = item.X;\r\n                    gen.Cell_Y = item.Y;\r\n                    db.Generations.Add(gen);\r\n                }\r\n                db.SaveChanges();\r\n                AliveCells.Clear();\r\n            }\r\n\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Method that looping through the ActualGenerations MultiDimensionalArray,\r\n        \/\/\/ And Checks how many neighboor every cell has and then make the new generation.\r\n        \/\/\/ <\/summary>\r\n        public void calculateNextGeneration()\r\n        {\r\n            for (int i = 0; i < ActualGeneration.GetLength(0); i++)\r\n            {\r\n                for (int j = 0; j < ActualGeneration.GetLength(1); j++)\r\n                {\r\n                    \/\/Method for count how many neighboor every cell has and then throw it into the switch.\r\n                    int neighboors = CheckLivingNeighboors(i, j);\r\n\r\n                    #region SwitchOnAllTheCells\r\n                    switch (neighboors)\r\n                    {\r\n                        case 0:\r\n                            {\r\n                                NextGeneration.SetValue(new Cell(i, j), i, j);\r\n                                break;\r\n                            }\r\n                        case 1:\r\n                            {\r\n                                NextGeneration.SetValue(new Cell(i, j), i, j);\r\n                                break;\r\n                            }\r\n                        case 2:\r\n                            {\r\n                                if (ActualGeneration[i, j].IsAlive)\r\n                                {\r\n                                    NextGeneration.SetValue(new Cell(i, j), i, j);\r\n                                    NextGeneration[i, j].IsAlive = true;\r\n                                    break;\r\n                                }\r\n                                else\r\n                                {\r\n                                    NextGeneration.SetValue(new Cell(i, j), i, j);\r\n                                }\r\n                                break;\r\n                            }\r\n                        case 3:\r\n                            {\r\n                                NextGeneration.SetValue(new Cell(i, j), i, j);\r\n                                NextGeneration[i, j].IsAlive = true;\r\n                                break;\r\n                            }\r\n                        default:\r\n                            {\r\n                                NextGeneration.SetValue(new Cell(i, j), i, j);\r\n                                break;\r\n                            }\r\n                            #endregion\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Method that returns the actualGeneration. \r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <returns>Actual generation MultiDimensionalArray with the cells.<\/returns>\r\n        public Cell[,] GetActualGeneration()\r\n        {\r\n            return ActualGeneration;\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Start the timer, The interval is 2 seconds by default.\r\n        \/\/\/ <\/summary>\r\n        public void Start_Timer()\r\n        {\r\n            timer.Start();\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Stops the timer.\r\n        \/\/\/ <\/summary>\r\n        public void Stop_Timer()\r\n        {\r\n            timer.Stop();\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Method that returns the NextGeneration MultiDimensionalArrat with the cells.\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <returns><\/returns>\r\n        public Cell[,] GetNextGeneration()\r\n        {\r\n            return NextGeneration;\r\n        }\r\n\r\n        \/\/Checks the surrounding Neighboor-Cells\r\n        public int CheckLivingNeighboors(int x, int y)\r\n        {\r\n            \/\/take the length of X and Y from ActualGeneration.\r\n            int Xlength = ActualGeneration.GetLength(0);\r\n            int Ylength = ActualGeneration.GetLength(1);\r\n\r\n            \/\/Start counting from zero neighboors.\r\n            int neighbours = 0;\r\n\r\n            #region CountingNeighboors\r\n            \/\/Right\r\n            if (x < Xlength - 1)\r\n                if (ActualGeneration[x + 1, y].IsAlive)\r\n                    neighbours++;\r\n            \/\/Bottom Right\r\n            if (x < Xlength - 1 && y < Ylength - 1)\r\n                if (ActualGeneration[x + 1, y + 1].IsAlive)\r\n                    neighbours++;\r\n            \/\/Bottom\r\n            if (y < Ylength - 1)\r\n                if (ActualGeneration[x, y + 1].IsAlive)\r\n                    neighbours++;\r\n            \/\/Bottom Left\r\n            if (x > 0 && y < Ylength - 1)\r\n                if (ActualGeneration[x - 1, y + 1].IsAlive)\r\n                    neighbours++;\r\n            \/\/Left\r\n            if (x > 0)\r\n                if (ActualGeneration[x - 1, y].IsAlive)\r\n                    neighbours++;\r\n            \/\/Top Left\r\n            if (x > 0 && y > 0)\r\n                if (ActualGeneration[x - 1, y - 1].IsAlive)\r\n                    neighbours++;\r\n            \/\/Top\r\n            if (y > 0)\r\n                if (ActualGeneration[x, y - 1].IsAlive)\r\n                    neighbours++;\r\n            \/\/Top Right\r\n            if (x < Xlength - 1 && y != 0)\r\n                if (ActualGeneration[x + 1, y - 1].IsAlive)\r\n                    neighbours++;\r\n            #endregion\r\n\r\n            return neighbours;\r\n        }\r\n    }\r\n}\r\n\r\n\/\/public void SendToGenTable(double X_index, double Y_index)\r\n\/\/{\r\n\/\/    using (GoLContext db = new GoLContext())\r\n\/\/    {\r\n\/\/        Generation gen = new Generation();\r\n\/\/        var coords = GetActualGeneration();\r\n\/\/        int X = (int)X_index;\r\n\/\/        int Y = (int)Y_index;\r\n\r\n\/\/        gen.Cell_X = X;\r\n\/\/        gen.Cell_Y = Y;\r\n\/\/        gen.IsAlive = true;\r\n\r\n\/\/        for (int i = 0; i < coords.GetLength(0); i++)\r\n\/\/        {\r\n\/\/            for (int j = 0; j < coords.GetLength(1); j++)\r\n\/\/            {\r\n\/\/                if (coords[i, j].IsAlive == true)\r\n\/\/                {\r\n\/\/                    db.Generation.Add(gen);\r\n\/\/                }\r\n\/\/            }\r\n\/\/        }\r\n\/\/        db.SaveChanges();\r\n\/\/    }\r\n\/\/}\r\n\r\n\r\n\r\n\/\/    --CREATE TABLE Generation\r\n\/\/--(\r\n\/\/--\tGen_id int IDENTITY(1,1) PRIMARY KEY,\r\n\/\/--\tGenNumber int NOT NULL,\r\n\/\/--\tCell_X int NOT NULL,\r\n\/\/--\tCell_Y int NOT NULL,\r\n\/\/--\tIsAlive bit DEFAULT(0) NOT NULL,\r\n\/\/--\tSavedGame_id int FOREIGN KEY REFERENCES SavedGames(SavedGame_id)\r\n\/\/--)\r\n\r\n\/\/--CREATE TABLE SavedGames\r\n\/\/--(\r\n\/\/--\tSavedGame_id int IDENTITY(1,1) PRIMARY KEY,\r\n\/\/--\tGenNumber int NOT NULL,\r\n\/\/--\tPlayer_id int FOREIGN KEY REFERENCES Player(Player_id)\r\n\/\/--)\r\n\r\n\/\/--CREATE TABLE Player\r\n\/\/--(\r\n\/\/--\tPlayer_id int IDENTITY(1,1) PRIMARY KEY,\r\n\/\/--\tPlayerName varchar(25),\r\n\/\/--\t--SavedGame_id int FOREIGN KEY REFERENCES SavedGames(SavedGame_id)\r\n\/\/--)\r\n\r\n\/\/--ALTER TABLE Player\r\n\/\/--ADD COLUMN SavedGame_id int\r\n\r\n\/\/--ALTER TABLE Player\r\n\/\/--ADD FOREIGN KEY(SavedGame_id) REFERENCES SavedGames(SavedGame_id)\r\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"c67fc8cea0116015e9780a635712d59c319fa1fe","subject":"Add WriteLog method.","message":"Add WriteLog method.\n","repos":"eternnoir\/NLogging","old_file":"src\/NLogging\/Logger.cs","new_file":"src\/NLogging\/Logger.cs","new_contents":"\ufeffnamespace NLogging\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Diagnostics;\n    using System.Linq;\n    using System.Text;\n    using System.Threading.Tasks;\n\n    public class Logger : ILogger\n    {\n        private string loggerName;\n        private LogLevel logLevel;\n        private List<IHandler> handlerList;\n\n        public string Name \n        {\n            get\n            {\n                return this.loggerName;\n            }\n        }\n        \n        \/\/\/ <summary>\n        \/\/\/ Log level property\n        \/\/\/ <\/summary>\n        public LogLevel Level\n        {\n            get\n            {\n                return this.logLevel;\n            }\n            set\n            {\n                this.logLevel = value;\n            }\n        }\n\n        public Logger(string loggerName)\n        {\n            this.init(loggerName, LogLevel.NOTSET);\n        }\n\n        public Logger(string loggerName, LogLevel logLevel)\n        {\n            this.init(loggerName, logLevel);\n        }\n\n        private void init(string loggerName, LogLevel logLevel)\n        {\n            this.loggerName = loggerName;\n            this.logLevel = logLevel;\n            this.handlerList = new List<IHandler>();\n        }\n\n        public void AddHandler(IHandler handler)\n        {\n            if (handler != null)\n            {\n                this.handlerList.Add(handler);\n            }\n        }\n\n        public void WriteLog(LogLevel level, string message)\n        {\n            if (message == null)\n            {\n                \/\/TODO change exception\n                throw new Exception(\"Message can not be null\");\n            }\n            StackTrace stack = new System.Diagnostics.StackTrace(true);\n            string functionName = stack.GetFrame(1).GetMethod().Name;\n            Record record = new Record(this.loggerName, level, stack, message, functionName);\n            foreach (var handler in handlerList)\n            {\n                handler.push(record);\n            }\n        }\n    }\n}\n","old_contents":"\ufeffnamespace NLogging\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n    using System.Text;\n    using System.Threading.Tasks;\n\n    public class Logger : ILogger\n    {\n        private string loggerName;\n        private LogLevel logLevel;\n        private List<IHandler> handlerList;\n\n        public string Name \n        {\n            get\n            {\n                return this.loggerName;\n            }\n        }\n        \n        \/\/\/ <summary>\n        \/\/\/ Log level property\n        \/\/\/ <\/summary>\n        public LogLevel Level\n        {\n            get\n            {\n                return this.logLevel;\n            }\n            set\n            {\n                this.logLevel = value;\n            }\n        }\n\n        public Logger(string loggerName)\n        {\n            this.init(loggerName, LogLevel.NOTSET);\n        }\n\n        public Logger(string loggerName, LogLevel logLevel)\n        {\n            this.init(loggerName, logLevel);\n        }\n\n        private void init(string loggerName, LogLevel logLevel)\n        {\n            this.loggerName = loggerName;\n            this.logLevel = logLevel;\n            this.handlerList = new List<IHandler>();\n        }\n\n        public void AddHandler(IHandler handler)\n        {\n            if (handler != null)\n            {\n                this.handlerList.Add(handler);\n            }\n        }\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"e18ff3ac2ac8f170d305ad6defd7028d4ffcbbd7","subject":"Skip 4 bytes not 2","message":"Skip 4 bytes not 2\n","repos":"0xd4d\/dnlib","old_file":"src\/PE\/PEExtensions.cs","new_file":"src\/PE\/PEExtensions.cs","new_contents":"\/\/ dnlib: See LICENSE.txt for more info\n\nusing System;\nusing System.IO;\n\nnamespace dnlib.PE {\n\t\/\/\/ <summary>\n\t\/\/\/ Extension methods\n\t\/\/\/ <\/summary>\n\tpublic static partial class PEExtensions {\n\t\t\/\/\/ <summary>\n\t\t\/\/\/ Calculates a PE checksum\n\t\t\/\/\/ <\/summary>\n\t\t\/\/\/ <param name=\"stream\">PE image stream positioned at the MZ bytes<\/param>\n\t\t\/\/\/ <param name=\"length\">Length of image<\/param>\n\t\t\/\/\/ <param name=\"checkSumOffset\">Offset of checksum<\/param>\n\t\t\/\/\/ <returns>PE checksum<\/returns>\n\t\tinternal static uint CalculatePECheckSum(this Stream stream, long length, long checkSumOffset) {\n\t\t\tif ((length & 1) != 0)\n\t\t\t\tThrowInvalidOperationException(\"Invalid PE length\");\n\t\t\tvar buffer = new byte[(int)Math.Min(length, 0x2000)];\n\t\t\tuint checkSum = 0;\n\t\t\tcheckSum = CalculatePECheckSum(stream, checkSumOffset, checkSum, buffer);\n\t\t\tconst int ChecksumFieldSize = 4;\n\t\t\tstream.Position += ChecksumFieldSize;\n\t\t\tcheckSum = CalculatePECheckSum(stream, length - checkSumOffset - ChecksumFieldSize, checkSum, buffer);\n\t\t\tulong cks = (ulong)checkSum + (ulong)length;\n\t\t\treturn (uint)cks + (uint)(cks >> 32);\n\t\t}\n\n\t\tstatic uint CalculatePECheckSum(Stream stream, long length, uint checkSum, byte[] buffer) {\n\t\t\tfor (long offset = 0; offset < length;) {\n\t\t\t\tint len = (int)Math.Min(length - offset, buffer.Length);\n\t\t\t\tint count = stream.Read(buffer, 0, len);\n\t\t\t\tif (count != len)\n\t\t\t\t\tThrowInvalidOperationException(\"Couldn't read all bytes\");\n\n\t\t\t\tfor (int i = 0; i < count;) {\n\t\t\t\t\tcheckSum += buffer[i++] | ((uint)buffer[i++] << 8);\n\t\t\t\t\tcheckSum = (ushort)(checkSum + (checkSum >> 16));\n\t\t\t\t}\n\n\t\t\t\toffset += count;\n\t\t\t}\n\t\t\treturn checkSum;\n\t\t}\n\n\t\tstatic void ThrowInvalidOperationException(string message) => throw new InvalidOperationException(message);\n\t}\n}\n","old_contents":"\/\/ dnlib: See LICENSE.txt for more info\n\nusing System;\nusing System.IO;\n\nnamespace dnlib.PE {\n\t\/\/\/ <summary>\n\t\/\/\/ Extension methods\n\t\/\/\/ <\/summary>\n\tpublic static partial class PEExtensions {\n\t\t\/\/\/ <summary>\n\t\t\/\/\/ Calculates a PE checksum\n\t\t\/\/\/ <\/summary>\n\t\t\/\/\/ <param name=\"stream\">PE image stream positioned at the MZ bytes<\/param>\n\t\t\/\/\/ <param name=\"length\">Length of image<\/param>\n\t\t\/\/\/ <param name=\"checkSumOffset\">Offset of checksum<\/param>\n\t\t\/\/\/ <returns>PE checksum<\/returns>\n\t\tinternal static uint CalculatePECheckSum(this Stream stream, long length, long checkSumOffset) {\n\t\t\tif ((length & 1) != 0)\n\t\t\t\tThrowInvalidOperationException(\"Invalid PE length\");\n\t\t\tvar buffer = new byte[(int)Math.Min(length, 0x2000)];\n\t\t\tuint checkSum = 0;\n\t\t\tcheckSum = CalculatePECheckSum(stream, checkSumOffset, checkSum, buffer);\n\t\t\tstream.Position += 2;\n\t\t\tcheckSum = CalculatePECheckSum(stream, length - checkSumOffset - 2, checkSum, buffer);\n\t\t\tulong cks = (ulong)checkSum + (ulong)length;\n\t\t\treturn (uint)cks + (uint)(cks >> 32);\n\t\t}\n\n\t\tstatic uint CalculatePECheckSum(Stream stream, long length, uint checkSum, byte[] buffer) {\n\t\t\tfor (long offset = 0; offset < length;) {\n\t\t\t\tint len = (int)Math.Min(length - offset, buffer.Length);\n\t\t\t\tint count = stream.Read(buffer, 0, len);\n\t\t\t\tif (count != len)\n\t\t\t\t\tThrowInvalidOperationException(\"Couldn't read all bytes\");\n\n\t\t\t\tfor (int i = 0; i < count;) {\n\t\t\t\t\tcheckSum += buffer[i++] | ((uint)buffer[i++] << 8);\n\t\t\t\t\tcheckSum = (ushort)(checkSum + (checkSum >> 16));\n\t\t\t\t}\n\n\t\t\t\toffset += count;\n\t\t\t}\n\t\t\treturn checkSum;\n\t\t}\n\n\t\tstatic void ThrowInvalidOperationException(string message) => throw new InvalidOperationException(message);\n\t}\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"a2e105d8c375c8f55fc231d5dd59d87d37618c09","subject":"Renamed Indention to Indentation.","message":"Renamed Indention to Indentation.\n","repos":"suvjunmd\/ScintillaNET,cqwang\/ScintillaNET,jacobslusser\/ScintillaNET","old_file":"src\/ScintillaNET\/Line.cs","new_file":"src\/ScintillaNET\/Line.cs","new_contents":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ScintillaNET\n{\n    \/\/\/ <summary>\n    \/\/\/ Represents a line of text in a <see cref=\"Scintilla\" \/> control.\n    \/\/\/ <\/summary>\n    public class Line\n    {\n        #region Fields\n\n        private readonly Scintilla scintilla;\n\n        #endregion Fields\n\n        #region Methods\n\n        \/\/\/ <summary>\n        \/\/\/ Expands any parent folds to ensure the line is visible.\n        \/\/\/ <\/summary>\n        public void EnsureVisible()\n        {\n            scintilla.DirectMessage(NativeMethods.SCI_ENSUREVISIBLE, new IntPtr(Index));\n        }\n\n        \/\/public void ExpandChildren(int level)\n        \/\/{\n        \/\/}\n\n        \/\/\/ <summary>\n        \/\/\/ Performs the specified fold action on the current line and all child lines.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"action\">One of the <see cref=\"FoldAction\" \/> enumeration values.<\/param>\n        public void FoldChildren(FoldAction action)\n        {\n            scintilla.DirectMessage(NativeMethods.SCI_FOLDCHILDREN, new IntPtr(Index), new IntPtr((int)action));\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Performs the specified fold action on the current line.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"action\">One of the <see cref=\"FoldAction\" \/> enumeration values.<\/param>\n        public void FoldLine(FoldAction action)\n        {\n            scintilla.DirectMessage(NativeMethods.SCI_FOLDLINE, new IntPtr(Index), new IntPtr((int)action));\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Searches for the next line that has a folding level that is less than or equal to <paramref name=\"level\" \/>\n        \/\/\/ and returns the previous line index.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"level\">The level of the line to search for. A value of -1 will use the current line <see cref=\"FoldLevel\" \/>.<\/param>\n        \/\/\/ <returns>\n        \/\/\/ The zero-based index of the next line that has a <see cref=\"FoldLevel\" \/> less than or equal\n        \/\/\/ to <paramref name=\"level\" \/>. If the current line is a fold point and <paramref name=\"level\"\/> is -1 the\n        \/\/\/ index returned is the last line that would be made visible or hidden by toggling the fold state.\n        \/\/\/ <\/returns>\n        public int GetLastChild(int level)\n        {\n            return scintilla.DirectMessage(NativeMethods.SCI_GETLASTCHILD, new IntPtr(Index), new IntPtr(level)).ToInt32();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Navigates the caret to the start of the line.\n        \/\/\/ <\/summary>\n        \/\/\/ <remarks>Any selection is discarded.<\/remarks>\n        public void Goto()\n        {\n            scintilla.DirectMessage(NativeMethods.SCI_GOTOLINE, new IntPtr(Index));\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Adds the specified <see cref=\"Marker\" \/> to the line.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"marker\">The zero-based index of the marker to add to the line.<\/param>\n        \/\/\/ <returns>A <see cref=\"MarkerHandle\" \/> which can be used to track the line.<\/returns>\n        \/\/\/ <remarks>This method does not check if the line already contains the <paramref name=\"marker\" \/>.<\/remarks>\n        public MarkerHandle MarkerAdd(int marker)\n        {\n            marker = Helpers.Clamp(marker, 0, scintilla.Markers.Count - 1);\n            var handle = scintilla.DirectMessage(NativeMethods.SCI_MARKERADD, new IntPtr(Index), new IntPtr(marker));\n            return new MarkerHandle { Value = handle };\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Adds one or more markers to the line in a single call using a bit mask.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"markerMask\">An unsigned 32-bit value with each bit cooresponding to one of the 32 zero-based <see cref=\"Margin\" \/> indexes to add.<\/param>\n        public void MarkerAddSet(uint markerMask)\n        {\n            var mask = unchecked((int)markerMask);\n            scintilla.DirectMessage(NativeMethods.SCI_MARKERADDSET, new IntPtr(Index), new IntPtr(mask));\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Removes the specified <see cref=\"Marker\" \/> from the line.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"marker\">The zero-based index of the marker to remove from the line or -1 to delete all markers from the line.<\/param>\n        \/\/\/ <remarks>If the same marker has been added to the line more than once, this will delete one copy each time it is used.<\/remarks>\n        public void MarkerDelete(int marker)\n        {\n            marker = Helpers.Clamp(marker, -1, scintilla.Markers.Count - 1);\n            scintilla.DirectMessage(NativeMethods.SCI_MARKERDELETE, new IntPtr(Index), new IntPtr(marker));\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Returns a bit mask indicating which markers are present on the line.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>An unsigned 32-bit value with each bit cooresponding to one of the 32 zero-based <see cref=\"Margin\" \/> indexes.<\/returns>\n        public uint MarkerGet()\n        {\n            var mask = scintilla.DirectMessage(NativeMethods.SCI_MARKERGET, new IntPtr(Index)).ToInt32();\n            return unchecked((uint)mask);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Efficiently searches from the current line forward to the end of the document for the specified markers.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"markerMask\">An unsigned 32-bit value with each bit cooresponding to one of the 32 zero-based <see cref=\"Margin\" \/> indexes.<\/param>\n        \/\/\/ <returns>If found, the zero-based line index containing one of the markers in <paramref name=\"markerMask\" \/>; otherwise, -1.<\/returns>\n        \/\/\/ <remarks>For example, the mask for marker index 10 is 1 shifted left 10 times (1 &lt;&lt; 10).<\/remarks>\n        public int MarkerNext(uint markerMask)\n        {\n            var mask = unchecked((int)markerMask);\n            return scintilla.DirectMessage(NativeMethods.SCI_MARKERNEXT, new IntPtr(Index), new IntPtr(mask)).ToInt32();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Efficiently searches from the current line backward to the start of the document for the specified markers.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"markerMask\">An unsigned 32-bit value with each bit cooresponding to one of the 32 zero-based <see cref=\"Margin\" \/> indexes.<\/param>\n        \/\/\/ <returns>If found, the zero-based line index containing one of the markers in <paramref name=\"markerMask\" \/>; otherwise, -1.<\/returns>\n        \/\/\/ <remarks>For example, the mask for marker index 10 is 1 shifted left 10 times (1 &lt;&lt; 10).<\/remarks>\n        public int MarkerPrevious(uint markerMask)\n        {\n            var mask = unchecked((int)markerMask);\n            return scintilla.DirectMessage(NativeMethods.SCI_MARKERPREVIOUS, new IntPtr(Index), new IntPtr(mask)).ToInt32();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Toggles the folding state of the line; expanding or contracting all child lines.\n        \/\/\/ <\/summary>\n        \/\/\/ <remarks>The line must be set as a <see cref=\"ScintillaNET.FoldLevelFlags.Header\" \/>.<\/remarks>\n        public void ToggleFold()\n        {\n            scintilla.DirectMessage(NativeMethods.SCI_TOGGLEFOLD, new IntPtr(Index));\n        }\n\n        #endregion Methods\n\n        #region Properties\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the number of annotation lines of text.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The number of annotation lines.<\/returns>\n        public int AnnotationLines\n        {\n            get\n            {\n                return scintilla.DirectMessage(NativeMethods.SCI_ANNOTATIONGETLINES, new IntPtr(Index)).ToInt32();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the style of the annotation text.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>\n        \/\/\/ The zero-based index of the annotation text <see cref=\"Style\" \/> or 256 when <see cref=\"AnnotationStyles\" \/>\n        \/\/\/ has been used to set individual character styles.\n        \/\/\/ <\/returns>\n        \/\/\/ <seealso cref=\"AnnotationStyles\" \/>\n        public int AnnotationStyle\n        {\n            get\n            {\n                return scintilla.DirectMessage(NativeMethods.SCI_ANNOTATIONGETSTYLE, new IntPtr(Index)).ToInt32();\n            }\n            set\n            {\n                value = Helpers.Clamp(value, 0, scintilla.Styles.Count - 1);\n                scintilla.DirectMessage(NativeMethods.SCI_ANNOTATIONSETSTYLE, new IntPtr(Index), new IntPtr(value));\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets an array of style indexes corresponding to each charcter in the <see cref=\"AnnotationText\" \/>\n        \/\/\/ so that each character may be individually styled.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>\n        \/\/\/ An array of <see cref=\"Style\" \/> indexes corresponding with each annotation text character or an uninitialized\n        \/\/\/ array when <see cref=\"AnnotationStyle\" \/> has been used to set a single style for all characters.\n        \/\/\/ <\/returns>\n        \/\/\/ <remarks>\n        \/\/\/ <see cref=\"AnnotationText\" \/> must be set prior to setting this property.\n        \/\/\/ The <paramref name=\"value\" \/> specified should have a length equal to the <see cref=\"AnnotationText\" \/> length to properly style all characters.\n        \/\/\/ <\/remarks>\n        \/\/\/ <seealso cref=\"AnnotationStyle\" \/>\n        public unsafe byte[] AnnotationStyles\n        {\n            get\n            {\n                var length = scintilla.DirectMessage(NativeMethods.SCI_ANNOTATIONGETTEXT, new IntPtr(Index)).ToInt32();\n                if (length == 0)\n                    return new byte[0];\n\n                var text = new byte[length + 1];\n                var styles = new byte[length + 1];\n\n                fixed (byte* textPtr = text)\n                fixed (byte* stylePtr = styles)\n                {\n                    scintilla.DirectMessage(NativeMethods.SCI_ANNOTATIONGETTEXT, new IntPtr(Index), new IntPtr(textPtr));\n                    scintilla.DirectMessage(NativeMethods.SCI_ANNOTATIONGETSTYLES, new IntPtr(Index), new IntPtr(stylePtr));\n\n                    return Helpers.ByteToCharStyles(stylePtr, textPtr, length, scintilla.Encoding);\n                }\n            }\n            set\n            {\n                var length = scintilla.DirectMessage(NativeMethods.SCI_ANNOTATIONGETTEXT, new IntPtr(Index)).ToInt32();\n                if (length == 0)\n                    return;\n\n                var text = new byte[length + 1];\n                fixed (byte* textPtr = text)\n                {\n                    scintilla.DirectMessage(NativeMethods.SCI_ANNOTATIONGETTEXT, new IntPtr(Index), new IntPtr(textPtr));\n\n                    var styles = Helpers.CharToByteStyles(value ?? new byte[0], textPtr, length, scintilla.Encoding);\n                    fixed (byte* stylePtr = styles)\n                        scintilla.DirectMessage(NativeMethods.SCI_ANNOTATIONSETSTYLES, new IntPtr(Index), new IntPtr(stylePtr));\n                }\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the line annotation text.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>A String representing the line annotation text.<\/returns>\n        public unsafe string AnnotationText\n        {\n            get\n            {\n                var length = scintilla.DirectMessage(NativeMethods.SCI_ANNOTATIONGETTEXT, new IntPtr(Index)).ToInt32();\n                if (length == 0)\n                    return string.Empty;\n\n                var bytes = new byte[length + 1];\n                fixed (byte* bp = bytes)\n                {\n                    scintilla.DirectMessage(NativeMethods.SCI_ANNOTATIONGETTEXT, new IntPtr(Index), new IntPtr(bp));\n                    return Helpers.GetString(new IntPtr(bp), length, scintilla.Encoding);\n                }\n            }\n            set\n            {\n                if (string.IsNullOrEmpty(value))\n                {\n                    \/\/ Scintilla docs suggest that setting to NULL rather than an empty string will free memory\n                    scintilla.DirectMessage(NativeMethods.SCI_ANNOTATIONGETTEXT, new IntPtr(Index), IntPtr.Zero);\n                }\n                else\n                {\n                    var bytes = Helpers.GetBytes(value, scintilla.Encoding, zeroTerminated: true);\n                    fixed (byte* bp = bytes)\n                        scintilla.DirectMessage(NativeMethods.SCI_ANNOTATIONSETTEXT, new IntPtr(Index), new IntPtr(bp));\n                }\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Searches from the current line to find the index of the next contracted fold header.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The zero-based line index of the next contracted folder header.<\/returns>\n        \/\/\/ <remarks>If the current line is contracted the current line index is returned.<\/remarks>\n        public int ContractedFoldNext\n        {\n            get\n            {\n                return scintilla.DirectMessage(NativeMethods.SCI_CONTRACTEDFOLDNEXT, new IntPtr(Index)).ToInt32();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the zero-based index of the line as displayed in a <see cref=\"Scintilla\" \/> control\n        \/\/\/ taking into consideration folded (hidden) lines.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The zero-based display line index.<\/returns>\n        \/\/\/ <seealso cref=\"Scintilla.DocLineFromVisible\" \/>\n        public int DisplayIndex\n        {\n            get\n            {\n                return scintilla.DirectMessage(NativeMethods.SCI_VISIBLEFROMDOCLINE, new IntPtr(Index)).ToInt32();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the zero-based character position in the document where the line ends (exclusive).\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The equivalent of <see cref=\"Position\" \/> + <see cref=\"Length\" \/>.<\/returns>\n        public int EndPosition\n        {\n            get\n            {\n                return Position + Length;\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the expanded state (not the visible state) of the line.\n        \/\/\/ <\/summary>\n        \/\/\/ <remarks>\n        \/\/\/ For toggling the fold state of a single line the <see cref=\"ToggleFold\" \/> method should be used.\n        \/\/\/ This property is useful for toggling the state of many folds without updating the display until finished.\n        \/\/\/ <\/remarks>\n        \/\/\/ <seealso cref=\"ToggleFold\" \/>\n        public bool Expanded\n        {\n            get\n            {\n                return (scintilla.DirectMessage(NativeMethods.SCI_GETFOLDEXPANDED, new IntPtr(Index)) != IntPtr.Zero);\n            }\n            set\n            {\n                var expanded = (value ? new IntPtr(1) : IntPtr.Zero);\n                scintilla.DirectMessage(NativeMethods.SCI_SETFOLDEXPANDED, new IntPtr(Index), expanded);\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the fold level of the line.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The fold level ranging from 0 to 4095. The default is 1024.<\/returns>\n        public int FoldLevel\n        {\n            get\n            {\n                var level = scintilla.DirectMessage(NativeMethods.SCI_GETFOLDLEVEL, new IntPtr(Index)).ToInt32();\n                return (level & NativeMethods.SC_FOLDLEVELNUMBERMASK);\n            }\n            set\n            {\n                var bits = (int)FoldLevelFlags;\n                bits |= value;\n\n                scintilla.DirectMessage(NativeMethods.SCI_SETFOLDLEVEL, new IntPtr(Index), new IntPtr(bits));\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the fold level flags.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>A bitwise combination of the <see cref=\"FoldLevelFlags\" \/> enumeration.<\/returns>\n        public FoldLevelFlags FoldLevelFlags\n        {\n            get\n            {\n                var flags = scintilla.DirectMessage(NativeMethods.SCI_GETFOLDLEVEL, new IntPtr(Index)).ToInt32();\n                return (FoldLevelFlags)(flags & ~NativeMethods.SC_FOLDLEVELNUMBERMASK);\n            }\n            set\n            {\n                var bits = FoldLevel;\n                bits |= (int)value;\n\n                scintilla.DirectMessage(NativeMethods.SCI_SETFOLDLEVEL, new IntPtr(Index), new IntPtr(bits));\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the zero-based line index of the first line before the current line that is marked as\n        \/\/\/ <see cref=\"ScintillaNET.FoldLevelFlags.Header\" \/> and has a <see cref=\"FoldLevel\" \/> less than the current line.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The zero-based line index of the fold parent if present; otherwise, -1.<\/returns>\n        public int FoldParent\n        {\n            get\n            {\n                return scintilla.DirectMessage(NativeMethods.SCI_GETFOLDPARENT, new IntPtr(Index)).ToInt32();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the line index.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The zero-based line index within the <see cref=\"LineCollection\" \/> that created it.<\/returns>\n        public int Index { get; private set; }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the length of the line.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The number of characters in the line including any end of line characters.<\/returns>\n        public int Length\n        {\n            get\n            {\n                return scintilla.Lines.CharLineLength(Index);\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the style of the margin text in a <see cref=\"MarginType.Text\" \/> or <see cref=\"MarginType.RightText\" \/> margin.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>\n        \/\/\/ The zero-based index of the margin text <see cref=\"Style\" \/> or 256 when <see cref=\"MarginStyles\" \/>\n        \/\/\/ has been used to set individual character styles.\n        \/\/\/ <\/returns>\n        \/\/\/ <seealso cref=\"MarginStyles\" \/>\n        public int MarginStyle\n        {\n            get\n            {\n                return scintilla.DirectMessage(NativeMethods.SCI_MARGINGETSTYLE, new IntPtr(Index)).ToInt32();\n            }\n            set\n            {\n                value = Helpers.Clamp(value, 0, scintilla.Styles.Count - 1);\n                scintilla.DirectMessage(NativeMethods.SCI_MARGINSETSTYLE, new IntPtr(Index), new IntPtr(value));\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets an array of style indexes corresponding to each charcter in the <see cref=\"MarginText\" \/>\n        \/\/\/ so that each character may be individually styled.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>\n        \/\/\/ An array of <see cref=\"Style\" \/> indexes corresponding with each margin text character or an uninitialized\n        \/\/\/ array when <see cref=\"MarginStyle\" \/> has been used to set a single style for all characters.\n        \/\/\/ <\/returns>\n        \/\/\/ <remarks>\n        \/\/\/ <see cref=\"MarginText\" \/> must be set prior to setting this property.\n        \/\/\/ The <paramref name=\"value\" \/> specified should have a length equal to the <see cref=\"MarginText\" \/> length to properly style all characters.\n        \/\/\/ <\/remarks>\n        \/\/\/ <seealso cref=\"MarginStyle\" \/>\n        public unsafe byte[] MarginStyles\n        {\n            get\n            {\n                var length = scintilla.DirectMessage(NativeMethods.SCI_MARGINGETTEXT, new IntPtr(Index)).ToInt32();\n                if (length == 0)\n                    return new byte[0];\n\n                var text = new byte[length + 1];\n                var styles = new byte[length + 1];\n\n                fixed (byte* textPtr = text)\n                fixed (byte* stylePtr = styles)\n                {\n                    scintilla.DirectMessage(NativeMethods.SCI_MARGINGETTEXT, new IntPtr(Index), new IntPtr(textPtr));\n                    scintilla.DirectMessage(NativeMethods.SCI_MARGINGETSTYLES, new IntPtr(Index), new IntPtr(stylePtr));\n\n                    return Helpers.ByteToCharStyles(stylePtr, textPtr, length, scintilla.Encoding);\n                }\n            }\n            set\n            {\n                var length = scintilla.DirectMessage(NativeMethods.SCI_MARGINGETTEXT, new IntPtr(Index)).ToInt32();\n                if (length == 0)\n                    return;\n\n                var text = new byte[length + 1];\n                fixed (byte* textPtr = text)\n                {\n                    scintilla.DirectMessage(NativeMethods.SCI_MARGINGETTEXT, new IntPtr(Index), new IntPtr(textPtr));\n\n                    var styles = Helpers.CharToByteStyles(value ?? new byte[0], textPtr, length, scintilla.Encoding);\n                    fixed (byte* stylePtr = styles)\n                        scintilla.DirectMessage(NativeMethods.SCI_MARGINSETSTYLES, new IntPtr(Index), new IntPtr(stylePtr));\n                }\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the text displayed in the line margin when the margin type is\n        \/\/\/ <see cref=\"MarginType.Text\" \/> or <see cref=\"MarginType.RightText\" \/>.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The text displayed in the line margin.<\/returns>\n        public unsafe string MarginText\n        {\n            get\n            {\n                var length = scintilla.DirectMessage(NativeMethods.SCI_MARGINGETTEXT, new IntPtr(Index)).ToInt32();\n                if (length == 0)\n                    return string.Empty;\n\n                var bytes = new byte[length + 1];\n                fixed (byte* bp = bytes)\n                {\n                    scintilla.DirectMessage(NativeMethods.SCI_MARGINGETTEXT, new IntPtr(Index), new IntPtr(bp));\n                    return Helpers.GetString(new IntPtr(bp), length, scintilla.Encoding);\n                }\n            }\n            set\n            {\n                if (string.IsNullOrEmpty(value))\n                {\n                    \/\/ Scintilla docs suggest that setting to NULL rather than an empty string will free memory\n                    scintilla.DirectMessage(NativeMethods.SCI_MARGINSETTEXT, new IntPtr(Index), IntPtr.Zero);\n                }\n                else\n                {\n                    var bytes = Helpers.GetBytes(value, scintilla.Encoding, zeroTerminated: true);\n                    fixed (byte* bp = bytes)\n                        scintilla.DirectMessage(NativeMethods.SCI_MARGINSETTEXT, new IntPtr(Index), new IntPtr(bp));\n                }\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the zero-based character position in the document where the line begins.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The document position of the first character in the line.<\/returns>\n        public int Position\n        {\n            get\n            {\n                return scintilla.Lines.CharPositionFromLine(Index);\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the line text.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>A string representing the document line.<\/returns>\n        \/\/\/ <remarks>The returned text includes any end of line characters.<\/remarks>\n        public unsafe string Text\n        {\n            get\n            {\n                var start = scintilla.DirectMessage(NativeMethods.SCI_POSITIONFROMLINE, new IntPtr(Index));\n                var length = scintilla.DirectMessage(NativeMethods.SCI_LINELENGTH, new IntPtr(Index));\n                var ptr = scintilla.DirectMessage(NativeMethods.SCI_GETRANGEPOINTER, start, length);\n                if (ptr == IntPtr.Zero)\n                    return string.Empty;\n\n                var text = new string((sbyte*)ptr, 0, length.ToInt32(), scintilla.Encoding);\n                return text;\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Sets or gets the line indentation.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The indentation measured in character columns, which corresponds to the width of space characters.<\/returns>\n        public int Indentation\n        {\n            get\n            {\n                return (scintilla.DirectMessage(NativeMethods.SCI_GETLINEINDENTATION, new IntPtr(Index)).ToInt32());\n            }\n            set\n            {\n                scintilla.DirectMessage(NativeMethods.SCI_SETLINEINDENTATION, new IntPtr(Index), new IntPtr(value));\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets a value indicating whether the line is visible.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>true if the line is visible; otherwise, false.<\/returns>\n        \/\/\/ <seealso cref=\"Scintilla.ShowLines\" \/>\n        \/\/\/ <seealso cref=\"Scintilla.HideLines\" \/>\n        public bool Visible\n        {\n            get\n            {\n                return (scintilla.DirectMessage(NativeMethods.SCI_GETLINEVISIBLE, new IntPtr(Index)) != IntPtr.Zero);\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the number of display lines this line would occupy when wrapping is enabled.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The number of display lines needed to wrap the current document line.<\/returns>\n        public int WrapCount\n        {\n            get\n            {\n                return scintilla.DirectMessage(NativeMethods.SCI_WRAPCOUNT, new IntPtr(Index)).ToInt32();\n            }\n        }\n\n        #endregion Properties\n\n        #region Constructors\n\n        \/\/\/ <summary>\n        \/\/\/ Initializes a new instance of the <see cref=\"Line\" \/> class.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"scintilla\">The <see cref=\"Scintilla\" \/> control that created this line.<\/param>\n        \/\/\/ <param name=\"index\">The index of this line within the <see cref=\"LineCollection\" \/> that created it.<\/param>\n        public Line(Scintilla scintilla, int index)\n        {\n            this.scintilla = scintilla;\n            Index = index;\n        }\n\n        #endregion Constructors\n    }\n}\n","old_contents":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ScintillaNET\n{\n    \/\/\/ <summary>\n    \/\/\/ Represents a line of text in a <see cref=\"Scintilla\" \/> control.\n    \/\/\/ <\/summary>\n    public class Line\n    {\n        #region Fields\n\n        private readonly Scintilla scintilla;\n\n        #endregion Fields\n\n        #region Methods\n\n        \/\/\/ <summary>\n        \/\/\/ Expands any parent folds to ensure the line is visible.\n        \/\/\/ <\/summary>\n        public void EnsureVisible()\n        {\n            scintilla.DirectMessage(NativeMethods.SCI_ENSUREVISIBLE, new IntPtr(Index));\n        }\n\n        \/\/public void ExpandChildren(int level)\n        \/\/{\n        \/\/}\n\n        \/\/\/ <summary>\n        \/\/\/ Performs the specified fold action on the current line and all child lines.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"action\">One of the <see cref=\"FoldAction\" \/> enumeration values.<\/param>\n        public void FoldChildren(FoldAction action)\n        {\n            scintilla.DirectMessage(NativeMethods.SCI_FOLDCHILDREN, new IntPtr(Index), new IntPtr((int)action));\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Performs the specified fold action on the current line.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"action\">One of the <see cref=\"FoldAction\" \/> enumeration values.<\/param>\n        public void FoldLine(FoldAction action)\n        {\n            scintilla.DirectMessage(NativeMethods.SCI_FOLDLINE, new IntPtr(Index), new IntPtr((int)action));\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Searches for the next line that has a folding level that is less than or equal to <paramref name=\"level\" \/>\n        \/\/\/ and returns the previous line index.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"level\">The level of the line to search for. A value of -1 will use the current line <see cref=\"FoldLevel\" \/>.<\/param>\n        \/\/\/ <returns>\n        \/\/\/ The zero-based index of the next line that has a <see cref=\"FoldLevel\" \/> less than or equal\n        \/\/\/ to <paramref name=\"level\" \/>. If the current line is a fold point and <paramref name=\"level\"\/> is -1 the\n        \/\/\/ index returned is the last line that would be made visible or hidden by toggling the fold state.\n        \/\/\/ <\/returns>\n        public int GetLastChild(int level)\n        {\n            return scintilla.DirectMessage(NativeMethods.SCI_GETLASTCHILD, new IntPtr(Index), new IntPtr(level)).ToInt32();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Navigates the caret to the start of the line.\n        \/\/\/ <\/summary>\n        \/\/\/ <remarks>Any selection is discarded.<\/remarks>\n        public void Goto()\n        {\n            scintilla.DirectMessage(NativeMethods.SCI_GOTOLINE, new IntPtr(Index));\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Adds the specified <see cref=\"Marker\" \/> to the line.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"marker\">The zero-based index of the marker to add to the line.<\/param>\n        \/\/\/ <returns>A <see cref=\"MarkerHandle\" \/> which can be used to track the line.<\/returns>\n        \/\/\/ <remarks>This method does not check if the line already contains the <paramref name=\"marker\" \/>.<\/remarks>\n        public MarkerHandle MarkerAdd(int marker)\n        {\n            marker = Helpers.Clamp(marker, 0, scintilla.Markers.Count - 1);\n            var handle = scintilla.DirectMessage(NativeMethods.SCI_MARKERADD, new IntPtr(Index), new IntPtr(marker));\n            return new MarkerHandle { Value = handle };\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Adds one or more markers to the line in a single call using a bit mask.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"markerMask\">An unsigned 32-bit value with each bit cooresponding to one of the 32 zero-based <see cref=\"Margin\" \/> indexes to add.<\/param>\n        public void MarkerAddSet(uint markerMask)\n        {\n            var mask = unchecked((int)markerMask);\n            scintilla.DirectMessage(NativeMethods.SCI_MARKERADDSET, new IntPtr(Index), new IntPtr(mask));\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Removes the specified <see cref=\"Marker\" \/> from the line.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"marker\">The zero-based index of the marker to remove from the line or -1 to delete all markers from the line.<\/param>\n        \/\/\/ <remarks>If the same marker has been added to the line more than once, this will delete one copy each time it is used.<\/remarks>\n        public void MarkerDelete(int marker)\n        {\n            marker = Helpers.Clamp(marker, -1, scintilla.Markers.Count - 1);\n            scintilla.DirectMessage(NativeMethods.SCI_MARKERDELETE, new IntPtr(Index), new IntPtr(marker));\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Returns a bit mask indicating which markers are present on the line.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>An unsigned 32-bit value with each bit cooresponding to one of the 32 zero-based <see cref=\"Margin\" \/> indexes.<\/returns>\n        public uint MarkerGet()\n        {\n            var mask = scintilla.DirectMessage(NativeMethods.SCI_MARKERGET, new IntPtr(Index)).ToInt32();\n            return unchecked((uint)mask);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Efficiently searches from the current line forward to the end of the document for the specified markers.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"markerMask\">An unsigned 32-bit value with each bit cooresponding to one of the 32 zero-based <see cref=\"Margin\" \/> indexes.<\/param>\n        \/\/\/ <returns>If found, the zero-based line index containing one of the markers in <paramref name=\"markerMask\" \/>; otherwise, -1.<\/returns>\n        \/\/\/ <remarks>For example, the mask for marker index 10 is 1 shifted left 10 times (1 &lt;&lt; 10).<\/remarks>\n        public int MarkerNext(uint markerMask)\n        {\n            var mask = unchecked((int)markerMask);\n            return scintilla.DirectMessage(NativeMethods.SCI_MARKERNEXT, new IntPtr(Index), new IntPtr(mask)).ToInt32();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Efficiently searches from the current line backward to the start of the document for the specified markers.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"markerMask\">An unsigned 32-bit value with each bit cooresponding to one of the 32 zero-based <see cref=\"Margin\" \/> indexes.<\/param>\n        \/\/\/ <returns>If found, the zero-based line index containing one of the markers in <paramref name=\"markerMask\" \/>; otherwise, -1.<\/returns>\n        \/\/\/ <remarks>For example, the mask for marker index 10 is 1 shifted left 10 times (1 &lt;&lt; 10).<\/remarks>\n        public int MarkerPrevious(uint markerMask)\n        {\n            var mask = unchecked((int)markerMask);\n            return scintilla.DirectMessage(NativeMethods.SCI_MARKERPREVIOUS, new IntPtr(Index), new IntPtr(mask)).ToInt32();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Toggles the folding state of the line; expanding or contracting all child lines.\n        \/\/\/ <\/summary>\n        \/\/\/ <remarks>The line must be set as a <see cref=\"ScintillaNET.FoldLevelFlags.Header\" \/>.<\/remarks>\n        public void ToggleFold()\n        {\n            scintilla.DirectMessage(NativeMethods.SCI_TOGGLEFOLD, new IntPtr(Index));\n        }\n\n        #endregion Methods\n\n        #region Properties\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the number of annotation lines of text.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The number of annotation lines.<\/returns>\n        public int AnnotationLines\n        {\n            get\n            {\n                return scintilla.DirectMessage(NativeMethods.SCI_ANNOTATIONGETLINES, new IntPtr(Index)).ToInt32();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the style of the annotation text.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>\n        \/\/\/ The zero-based index of the annotation text <see cref=\"Style\" \/> or 256 when <see cref=\"AnnotationStyles\" \/>\n        \/\/\/ has been used to set individual character styles.\n        \/\/\/ <\/returns>\n        \/\/\/ <seealso cref=\"AnnotationStyles\" \/>\n        public int AnnotationStyle\n        {\n            get\n            {\n                return scintilla.DirectMessage(NativeMethods.SCI_ANNOTATIONGETSTYLE, new IntPtr(Index)).ToInt32();\n            }\n            set\n            {\n                value = Helpers.Clamp(value, 0, scintilla.Styles.Count - 1);\n                scintilla.DirectMessage(NativeMethods.SCI_ANNOTATIONSETSTYLE, new IntPtr(Index), new IntPtr(value));\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets an array of style indexes corresponding to each charcter in the <see cref=\"AnnotationText\" \/>\n        \/\/\/ so that each character may be individually styled.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>\n        \/\/\/ An array of <see cref=\"Style\" \/> indexes corresponding with each annotation text character or an uninitialized\n        \/\/\/ array when <see cref=\"AnnotationStyle\" \/> has been used to set a single style for all characters.\n        \/\/\/ <\/returns>\n        \/\/\/ <remarks>\n        \/\/\/ <see cref=\"AnnotationText\" \/> must be set prior to setting this property.\n        \/\/\/ The <paramref name=\"value\" \/> specified should have a length equal to the <see cref=\"AnnotationText\" \/> length to properly style all characters.\n        \/\/\/ <\/remarks>\n        \/\/\/ <seealso cref=\"AnnotationStyle\" \/>\n        public unsafe byte[] AnnotationStyles\n        {\n            get\n            {\n                var length = scintilla.DirectMessage(NativeMethods.SCI_ANNOTATIONGETTEXT, new IntPtr(Index)).ToInt32();\n                if (length == 0)\n                    return new byte[0];\n\n                var text = new byte[length + 1];\n                var styles = new byte[length + 1];\n\n                fixed (byte* textPtr = text)\n                fixed (byte* stylePtr = styles)\n                {\n                    scintilla.DirectMessage(NativeMethods.SCI_ANNOTATIONGETTEXT, new IntPtr(Index), new IntPtr(textPtr));\n                    scintilla.DirectMessage(NativeMethods.SCI_ANNOTATIONGETSTYLES, new IntPtr(Index), new IntPtr(stylePtr));\n\n                    return Helpers.ByteToCharStyles(stylePtr, textPtr, length, scintilla.Encoding);\n                }\n            }\n            set\n            {\n                var length = scintilla.DirectMessage(NativeMethods.SCI_ANNOTATIONGETTEXT, new IntPtr(Index)).ToInt32();\n                if (length == 0)\n                    return;\n\n                var text = new byte[length + 1];\n                fixed (byte* textPtr = text)\n                {\n                    scintilla.DirectMessage(NativeMethods.SCI_ANNOTATIONGETTEXT, new IntPtr(Index), new IntPtr(textPtr));\n\n                    var styles = Helpers.CharToByteStyles(value ?? new byte[0], textPtr, length, scintilla.Encoding);\n                    fixed (byte* stylePtr = styles)\n                        scintilla.DirectMessage(NativeMethods.SCI_ANNOTATIONSETSTYLES, new IntPtr(Index), new IntPtr(stylePtr));\n                }\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the line annotation text.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>A String representing the line annotation text.<\/returns>\n        public unsafe string AnnotationText\n        {\n            get\n            {\n                var length = scintilla.DirectMessage(NativeMethods.SCI_ANNOTATIONGETTEXT, new IntPtr(Index)).ToInt32();\n                if (length == 0)\n                    return string.Empty;\n\n                var bytes = new byte[length + 1];\n                fixed (byte* bp = bytes)\n                {\n                    scintilla.DirectMessage(NativeMethods.SCI_ANNOTATIONGETTEXT, new IntPtr(Index), new IntPtr(bp));\n                    return Helpers.GetString(new IntPtr(bp), length, scintilla.Encoding);\n                }\n            }\n            set\n            {\n                if (string.IsNullOrEmpty(value))\n                {\n                    \/\/ Scintilla docs suggest that setting to NULL rather than an empty string will free memory\n                    scintilla.DirectMessage(NativeMethods.SCI_ANNOTATIONGETTEXT, new IntPtr(Index), IntPtr.Zero);\n                }\n                else\n                {\n                    var bytes = Helpers.GetBytes(value, scintilla.Encoding, zeroTerminated: true);\n                    fixed (byte* bp = bytes)\n                        scintilla.DirectMessage(NativeMethods.SCI_ANNOTATIONSETTEXT, new IntPtr(Index), new IntPtr(bp));\n                }\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Searches from the current line to find the index of the next contracted fold header.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The zero-based line index of the next contracted folder header.<\/returns>\n        \/\/\/ <remarks>If the current line is contracted the current line index is returned.<\/remarks>\n        public int ContractedFoldNext\n        {\n            get\n            {\n                return scintilla.DirectMessage(NativeMethods.SCI_CONTRACTEDFOLDNEXT, new IntPtr(Index)).ToInt32();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the zero-based index of the line as displayed in a <see cref=\"Scintilla\" \/> control\n        \/\/\/ taking into consideration folded (hidden) lines.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The zero-based display line index.<\/returns>\n        \/\/\/ <seealso cref=\"Scintilla.DocLineFromVisible\" \/>\n        public int DisplayIndex\n        {\n            get\n            {\n                return scintilla.DirectMessage(NativeMethods.SCI_VISIBLEFROMDOCLINE, new IntPtr(Index)).ToInt32();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the zero-based character position in the document where the line ends (exclusive).\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The equivalent of <see cref=\"Position\" \/> + <see cref=\"Length\" \/>.<\/returns>\n        public int EndPosition\n        {\n            get\n            {\n                return Position + Length;\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the expanded state (not the visible state) of the line.\n        \/\/\/ <\/summary>\n        \/\/\/ <remarks>\n        \/\/\/ For toggling the fold state of a single line the <see cref=\"ToggleFold\" \/> method should be used.\n        \/\/\/ This property is useful for toggling the state of many folds without updating the display until finished.\n        \/\/\/ <\/remarks>\n        \/\/\/ <seealso cref=\"ToggleFold\" \/>\n        public bool Expanded\n        {\n            get\n            {\n                return (scintilla.DirectMessage(NativeMethods.SCI_GETFOLDEXPANDED, new IntPtr(Index)) != IntPtr.Zero);\n            }\n            set\n            {\n                var expanded = (value ? new IntPtr(1) : IntPtr.Zero);\n                scintilla.DirectMessage(NativeMethods.SCI_SETFOLDEXPANDED, new IntPtr(Index), expanded);\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the fold level of the line.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The fold level ranging from 0 to 4095. The default is 1024.<\/returns>\n        public int FoldLevel\n        {\n            get\n            {\n                var level = scintilla.DirectMessage(NativeMethods.SCI_GETFOLDLEVEL, new IntPtr(Index)).ToInt32();\n                return (level & NativeMethods.SC_FOLDLEVELNUMBERMASK);\n            }\n            set\n            {\n                var bits = (int)FoldLevelFlags;\n                bits |= value;\n\n                scintilla.DirectMessage(NativeMethods.SCI_SETFOLDLEVEL, new IntPtr(Index), new IntPtr(bits));\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the fold level flags.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>A bitwise combination of the <see cref=\"FoldLevelFlags\" \/> enumeration.<\/returns>\n        public FoldLevelFlags FoldLevelFlags\n        {\n            get\n            {\n                var flags = scintilla.DirectMessage(NativeMethods.SCI_GETFOLDLEVEL, new IntPtr(Index)).ToInt32();\n                return (FoldLevelFlags)(flags & ~NativeMethods.SC_FOLDLEVELNUMBERMASK);\n            }\n            set\n            {\n                var bits = FoldLevel;\n                bits |= (int)value;\n\n                scintilla.DirectMessage(NativeMethods.SCI_SETFOLDLEVEL, new IntPtr(Index), new IntPtr(bits));\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the zero-based line index of the first line before the current line that is marked as\n        \/\/\/ <see cref=\"ScintillaNET.FoldLevelFlags.Header\" \/> and has a <see cref=\"FoldLevel\" \/> less than the current line.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The zero-based line index of the fold parent if present; otherwise, -1.<\/returns>\n        public int FoldParent\n        {\n            get\n            {\n                return scintilla.DirectMessage(NativeMethods.SCI_GETFOLDPARENT, new IntPtr(Index)).ToInt32();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the line index.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The zero-based line index within the <see cref=\"LineCollection\" \/> that created it.<\/returns>\n        public int Index { get; private set; }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the length of the line.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The number of characters in the line including any end of line characters.<\/returns>\n        public int Length\n        {\n            get\n            {\n                return scintilla.Lines.CharLineLength(Index);\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the style of the margin text in a <see cref=\"MarginType.Text\" \/> or <see cref=\"MarginType.RightText\" \/> margin.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>\n        \/\/\/ The zero-based index of the margin text <see cref=\"Style\" \/> or 256 when <see cref=\"MarginStyles\" \/>\n        \/\/\/ has been used to set individual character styles.\n        \/\/\/ <\/returns>\n        \/\/\/ <seealso cref=\"MarginStyles\" \/>\n        public int MarginStyle\n        {\n            get\n            {\n                return scintilla.DirectMessage(NativeMethods.SCI_MARGINGETSTYLE, new IntPtr(Index)).ToInt32();\n            }\n            set\n            {\n                value = Helpers.Clamp(value, 0, scintilla.Styles.Count - 1);\n                scintilla.DirectMessage(NativeMethods.SCI_MARGINSETSTYLE, new IntPtr(Index), new IntPtr(value));\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets an array of style indexes corresponding to each charcter in the <see cref=\"MarginText\" \/>\n        \/\/\/ so that each character may be individually styled.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>\n        \/\/\/ An array of <see cref=\"Style\" \/> indexes corresponding with each margin text character or an uninitialized\n        \/\/\/ array when <see cref=\"MarginStyle\" \/> has been used to set a single style for all characters.\n        \/\/\/ <\/returns>\n        \/\/\/ <remarks>\n        \/\/\/ <see cref=\"MarginText\" \/> must be set prior to setting this property.\n        \/\/\/ The <paramref name=\"value\" \/> specified should have a length equal to the <see cref=\"MarginText\" \/> length to properly style all characters.\n        \/\/\/ <\/remarks>\n        \/\/\/ <seealso cref=\"MarginStyle\" \/>\n        public unsafe byte[] MarginStyles\n        {\n            get\n            {\n                var length = scintilla.DirectMessage(NativeMethods.SCI_MARGINGETTEXT, new IntPtr(Index)).ToInt32();\n                if (length == 0)\n                    return new byte[0];\n\n                var text = new byte[length + 1];\n                var styles = new byte[length + 1];\n\n                fixed (byte* textPtr = text)\n                fixed (byte* stylePtr = styles)\n                {\n                    scintilla.DirectMessage(NativeMethods.SCI_MARGINGETTEXT, new IntPtr(Index), new IntPtr(textPtr));\n                    scintilla.DirectMessage(NativeMethods.SCI_MARGINGETSTYLES, new IntPtr(Index), new IntPtr(stylePtr));\n\n                    return Helpers.ByteToCharStyles(stylePtr, textPtr, length, scintilla.Encoding);\n                }\n            }\n            set\n            {\n                var length = scintilla.DirectMessage(NativeMethods.SCI_MARGINGETTEXT, new IntPtr(Index)).ToInt32();\n                if (length == 0)\n                    return;\n\n                var text = new byte[length + 1];\n                fixed (byte* textPtr = text)\n                {\n                    scintilla.DirectMessage(NativeMethods.SCI_MARGINGETTEXT, new IntPtr(Index), new IntPtr(textPtr));\n\n                    var styles = Helpers.CharToByteStyles(value ?? new byte[0], textPtr, length, scintilla.Encoding);\n                    fixed (byte* stylePtr = styles)\n                        scintilla.DirectMessage(NativeMethods.SCI_MARGINSETSTYLES, new IntPtr(Index), new IntPtr(stylePtr));\n                }\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the text displayed in the line margin when the margin type is\n        \/\/\/ <see cref=\"MarginType.Text\" \/> or <see cref=\"MarginType.RightText\" \/>.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The text displayed in the line margin.<\/returns>\n        public unsafe string MarginText\n        {\n            get\n            {\n                var length = scintilla.DirectMessage(NativeMethods.SCI_MARGINGETTEXT, new IntPtr(Index)).ToInt32();\n                if (length == 0)\n                    return string.Empty;\n\n                var bytes = new byte[length + 1];\n                fixed (byte* bp = bytes)\n                {\n                    scintilla.DirectMessage(NativeMethods.SCI_MARGINGETTEXT, new IntPtr(Index), new IntPtr(bp));\n                    return Helpers.GetString(new IntPtr(bp), length, scintilla.Encoding);\n                }\n            }\n            set\n            {\n                if (string.IsNullOrEmpty(value))\n                {\n                    \/\/ Scintilla docs suggest that setting to NULL rather than an empty string will free memory\n                    scintilla.DirectMessage(NativeMethods.SCI_MARGINSETTEXT, new IntPtr(Index), IntPtr.Zero);\n                }\n                else\n                {\n                    var bytes = Helpers.GetBytes(value, scintilla.Encoding, zeroTerminated: true);\n                    fixed (byte* bp = bytes)\n                        scintilla.DirectMessage(NativeMethods.SCI_MARGINSETTEXT, new IntPtr(Index), new IntPtr(bp));\n                }\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the zero-based character position in the document where the line begins.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The document position of the first character in the line.<\/returns>\n        public int Position\n        {\n            get\n            {\n                return scintilla.Lines.CharPositionFromLine(Index);\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the line text.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>A string representing the document line.<\/returns>\n        \/\/\/ <remarks>The returned text includes any end of line characters.<\/remarks>\n        public unsafe string Text\n        {\n            get\n            {\n                var start = scintilla.DirectMessage(NativeMethods.SCI_POSITIONFROMLINE, new IntPtr(Index));\n                var length = scintilla.DirectMessage(NativeMethods.SCI_LINELENGTH, new IntPtr(Index));\n                var ptr = scintilla.DirectMessage(NativeMethods.SCI_GETRANGEPOINTER, start, length);\n                if (ptr == IntPtr.Zero)\n                    return string.Empty;\n\n                var text = new string((sbyte*)ptr, 0, length.ToInt32(), scintilla.Encoding);\n                return text;\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Sets or gets the line indention.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The indentation measured in character columns, which corresponds to the width of space characters.<\/returns>\n        public int Indention\n        {\n            get\n            {\n                return (scintilla.DirectMessage(NativeMethods.SCI_GETLINEINDENTATION, new IntPtr(Index)).ToInt32());\n            }\n            set\n            {\n                scintilla.DirectMessage(NativeMethods.SCI_SETLINEINDENTATION, new IntPtr(Index), new IntPtr(value));\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets a value indicating whether the line is visible.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>true if the line is visible; otherwise, false.<\/returns>\n        \/\/\/ <seealso cref=\"Scintilla.ShowLines\" \/>\n        \/\/\/ <seealso cref=\"Scintilla.HideLines\" \/>\n        public bool Visible\n        {\n            get\n            {\n                return (scintilla.DirectMessage(NativeMethods.SCI_GETLINEVISIBLE, new IntPtr(Index)) != IntPtr.Zero);\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the number of display lines this line would occupy when wrapping is enabled.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The number of display lines needed to wrap the current document line.<\/returns>\n        public int WrapCount\n        {\n            get\n            {\n                return scintilla.DirectMessage(NativeMethods.SCI_WRAPCOUNT, new IntPtr(Index)).ToInt32();\n            }\n        }\n\n        #endregion Properties\n\n        #region Constructors\n\n        \/\/\/ <summary>\n        \/\/\/ Initializes a new instance of the <see cref=\"Line\" \/> class.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"scintilla\">The <see cref=\"Scintilla\" \/> control that created this line.<\/param>\n        \/\/\/ <param name=\"index\">The index of this line within the <see cref=\"LineCollection\" \/> that created it.<\/param>\n        public Line(Scintilla scintilla, int index)\n        {\n            this.scintilla = scintilla;\n            Index = index;\n        }\n\n        #endregion Constructors\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"20b49504b231c8e591515c438b697af80a32b8b4","subject":"Add exception info into summary.","message":"Add exception info into summary.\n","repos":"Si13n7\/SilDev.CSharpLib","old_file":"src\/SilDev\/Comparison.cs","new_file":"src\/SilDev\/Comparison.cs","new_contents":"\ufeff#region auto-generated FILE INFORMATION\n\n\/\/ ==============================================\n\/\/ This file is distributed under the MIT License\n\/\/ ==============================================\n\/\/ \n\/\/ Filename: Comparison.cs\n\/\/ Version:  2017-05-12 11:54\n\/\/ \n\/\/ Copyright (c) 2017, Si13n7 Developments (r)\n\/\/ All rights reserved.\n\/\/ ______________________________________________\n\n#endregion\n\nnamespace SilDev\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n\n    \/\/\/ <summary>\n    \/\/\/     Provides static methods and base classes used for the comparison of two or more objects.\n    \/\/\/ <\/summary>\n    public static class Comparison\n    {\n        \/\/\/ <summary>\n        \/\/\/     Searches for the specified one-dimensional array and returns the index of its first\n        \/\/\/     occurrence in another one-dimensional array.\n        \/\/\/ <\/summary>\n        \/\/\/ <typeparam name=\"T\">\n        \/\/\/     The type of the elements of the array.\n        \/\/\/ <\/typeparam>\n        \/\/\/ <param name=\"source\">\n        \/\/\/     The one-dimensional array to search.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"target\">\n        \/\/\/     The one-dimensional array to locate.\n        \/\/\/ <\/param>\n        \/\/\/ <exception cref=\"ArgumentNullException\">\n        \/\/\/ <\/exception>\n        \/\/\/ <exception cref=\"OverflowException\">\n        \/\/\/ <\/exception>\n        public static IEnumerable<int> IndexOf<T>(T[] source, T[] target)\n        {\n            if (target == null || source.Length < target.Length)\n                yield break;\n            for (var i = 0; i < source.Length - target.Length + 1; i++)\n                if (!target.Where((data, index) => !source[i + index].Equals(data)).Any())\n                    yield return i;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Determines whether the value of this object instance is between two specified values.\n        \/\/\/ <\/summary>\n        \/\/\/ <typeparam name=\"T\">\n        \/\/\/     The type of the object.\n        \/\/\/ <\/typeparam>\n        \/\/\/ <param name=\"item\">\n        \/\/\/     The object value to compare.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"start\">\n        \/\/\/     The start index value.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"end\">\n        \/\/\/     The end index value.\n        \/\/\/ <\/param>\n        public static bool IsBetween<T>(this T item, T start, T end) where T : IComparable, IComparable<T>\n        {\n            try\n            {\n                var c = Comparer<T>.Default;\n                var a = c.Compare(item, start);\n                var b = c.Compare(item, end);\n                return a >= 0 && b <= 0;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Determines whether a specified sequence of elements occurs within this sequence of\n        \/\/\/     elements.\n        \/\/\/ <\/summary>\n        \/\/\/ <typeparam name=\"T\">\n        \/\/\/     The type of the elements of the array.\n        \/\/\/ <\/typeparam>\n        \/\/\/ <param name=\"source\">\n        \/\/\/     The sequence of elements to browse.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"targets\">\n        \/\/\/     The sequence of elements to seek.\n        \/\/\/ <\/param>\n        public static bool ContainsEx<T>(this IEnumerable<T> source, params T[][] targets)\n        {\n            try\n            {\n                var r = targets.Any(x => IndexOf(source.ToArray(), x).Any(y => y >= 0));\n                return r;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Determines whether a specified string occurs within this sequence of strings. A\n        \/\/\/     parameter specifies the culture, case, and sort rules used in the comparison.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"source\">\n        \/\/\/     The sequence to browse.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"comparisonType\">\n        \/\/\/     One of the enumeration values that specifies the rules for the search.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"targets\">\n        \/\/\/     The sequence of strings to seek.\n        \/\/\/ <\/param>\n        public static bool ContainsEx(this IEnumerable<string> source, StringComparison comparisonType, params string[] targets)\n        {\n            try\n            {\n                var r = source.Any(x => targets.Any(y => string.Equals(x, y, comparisonType)));\n                return r;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Determines whether a specified string occurs within this sequence of strings. The\n        \/\/\/     <see cref=\"StringComparison.OrdinalIgnoreCase\"\/> parameter is used for this\n        \/\/\/     comparison.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"source\">\n        \/\/\/     The sequence to browse.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"targets\">\n        \/\/\/     The sequence of strings to seek.\n        \/\/\/ <\/param>\n        public static bool ContainsEx(this IEnumerable<string> source, params string[] targets) =>\n            source.ContainsEx(StringComparison.OrdinalIgnoreCase, targets);\n\n        \/\/\/ <summary>\n        \/\/\/     Determines whether a specified substring occurs within this string. A parameter\n        \/\/\/     specifies the culture, case, and sort rules used in the comparison.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"source\">\n        \/\/\/     The string to browse.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"comparisonType\">\n        \/\/\/     One of the enumeration values that specifies the rules for the search.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"targets\">\n        \/\/\/     The sequence of strings to seek.\n        \/\/\/ <\/param>\n        public static bool ContainsEx(this string source, StringComparison comparisonType, params string[] targets)\n        {\n            try\n            {\n                var r = targets.Any(x => source.IndexOf(x, 0, comparisonType) != -1);\n                return r;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Determines whether a specified substring occurs within this string. The\n        \/\/\/     <see cref=\"StringComparison.OrdinalIgnoreCase\"\/> parameter is used for this\n        \/\/\/     comparison.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"source\">\n        \/\/\/     The string to browse.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"targets\">\n        \/\/\/     The sequence of strings to seek.\n        \/\/\/ <\/param>\n        public static bool ContainsEx(this string source, params string[] targets) =>\n            source.ContainsEx(StringComparison.OrdinalIgnoreCase, targets);\n\n        \/\/\/ <summary>\n        \/\/\/     Determines whether a specified characters occurs within this string. A parameter\n        \/\/\/     specifies the culture, case, and sort rules used in the comparison.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"source\">\n        \/\/\/     The string to browse.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"comparisonType\">\n        \/\/\/     One of the enumeration values that specifies the rules for the search.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"targets\">\n        \/\/\/     The sequence of characters to seek.\n        \/\/\/ <\/param>\n        public static bool ContainsEx(this string source, StringComparison comparisonType, params char[] targets)\n        {\n            try\n            {\n                var r = targets.Any(x => source.IndexOf(x.ToString(), 0, comparisonType) != -1);\n                return r;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Determines whether a specified characters occurs within this string. The\n        \/\/\/     <see cref=\"StringComparison.OrdinalIgnoreCase\"\/> parameter is used for this\n        \/\/\/     comparison.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"source\">\n        \/\/\/     The string to browse.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"targets\">\n        \/\/\/     The sequence of characters to seek.\n        \/\/\/ <\/param>\n        public static bool ContainsEx(this string source, params char[] targets) =>\n            source.ContainsEx(StringComparison.OrdinalIgnoreCase, targets);\n\n        \/\/\/ <summary>\n        \/\/\/     Determines whether the beginning of this string matches a string. A parameter\n        \/\/\/     specifies the culture, case, and sort rules used in the comparison.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"source\">\n        \/\/\/     The string to check.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"comparisonType\">\n        \/\/\/     One of the enumeration values that specifies the rules for the search.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"targets\">\n        \/\/\/     The sequence of strings to compare seek.\n        \/\/\/ <\/param>\n        public static bool StartsWithEx(this string source, StringComparison comparisonType, params string[] targets)\n        {\n            try\n            {\n                var r = targets.Any(b => source.StartsWith(b, comparisonType));\n                return r;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Determines whether the beginning of this string matches a string. The\n        \/\/\/     <see cref=\"StringComparison.OrdinalIgnoreCase\"\/> parameter is used for this\n        \/\/\/     comparison.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"source\">\n        \/\/\/     The string to check.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"targets\">\n        \/\/\/     The sequence of strings to compare seek.\n        \/\/\/ <\/param>\n        public static bool StartsWithEx(this string source, params string[] targets) =>\n            source.StartsWithEx(StringComparison.OrdinalIgnoreCase, targets);\n\n        \/\/\/ <summary>\n        \/\/\/     Determines whether the end of this string matches a string. A parameter\n        \/\/\/     specifies the culture, case, and sort rules used in the comparison.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"source\">\n        \/\/\/     The string to check.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"comparisonType\">\n        \/\/\/     One of the enumeration values that specifies the rules for the search.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"targets\">\n        \/\/\/     The sequence of strings to compare seek.\n        \/\/\/ <\/param>\n        public static bool EndsWithEx(this string source, StringComparison comparisonType, params string[] targets)\n        {\n            try\n            {\n                var r = targets.Any(b => source.EndsWith(b, comparisonType));\n                return r;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Determines whether the end of this string matches a string. The\n        \/\/\/     <see cref=\"StringComparison.OrdinalIgnoreCase\"\/> parameter is used for this comparison.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"source\">\n        \/\/\/     The string to check.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"targets\">\n        \/\/\/     The sequence of strings to compare seek.\n        \/\/\/ <\/param>\n        public static bool EndsWithEx(this string source, params string[] targets) =>\n            source.EndsWithEx(StringComparison.OrdinalIgnoreCase, targets);\n\n        \/\/\/ <summary>\n        \/\/\/     Determines whether this string instance is the same as a string of the specified string\n        \/\/\/     array. A parameter specifies the culture, case, and sort rules used in the comparison.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"source\">\n        \/\/\/     The first string to compare.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"targets\">\n        \/\/\/     The sequence of strings to compare with the first.\n        \/\/\/ <\/param>\n        public static bool EqualsEx(this string source, StringComparison comparisonType, params string[] targets)\n        {\n            try\n            {\n                var r = targets.Any(b => string.Equals(source, b, comparisonType));\n                return r;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Determines whether this string instance is the same as a string of the specified string\n        \/\/\/     array. The <see cref=\"StringComparison.OrdinalIgnoreCase\"\/> parameter is used for this\n        \/\/\/     comparison.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"source\">\n        \/\/\/     The first string to compare.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"targets\">\n        \/\/\/     The sequence of strings to compare with the first.\n        \/\/\/ <\/param>\n        public static bool EqualsEx(this string source, params string[] targets) =>\n            source.EqualsEx(StringComparison.OrdinalIgnoreCase, targets);\n\n        \/\/\/ <summary>\n        \/\/\/     Provides a base class for comparison.\n        \/\/\/ <\/summary>\n        public class AlphanumericComparer : IComparer<object>\n        {\n            private readonly bool _d;\n\n            \/\/\/ <summary>\n            \/\/\/     Initilazies a new instance of the <see cref=\"AlphanumericComparer\"\/> class. A\n            \/\/\/     parameter specifies whether the order is descended.\n            \/\/\/ <\/summary>\n            \/\/\/ <param name=\"descendent\">\n            \/\/\/     true to enable the descending order; otherwise, false.\n            \/\/\/ <\/param>\n            public AlphanumericComparer(bool descendent = false)\n            {\n                _d = descendent;\n            }\n\n            \/\/\/ <summary>\n            \/\/\/     Compare two specified objects and returns an integer that indicates their relative\n            \/\/\/     position in the sort order.\n            \/\/\/ <\/summary>\n            \/\/\/ <param name=\"a\">\n            \/\/\/     The first object to compare.\n            \/\/\/ <\/param>\n            \/\/\/ <param name=\"b\">\n            \/\/\/     The second object to compare.\n            \/\/\/ <\/param>\n            public int Compare(object a, object b)\n            {\n                var s1 = !_d ? a as string : b as string;\n                if (s1 == null)\n                    return 0;\n                var s2 = !_d ? b as string : a as string;\n                if (s2 == null)\n                    return 0;\n                try\n                {\n                    var i1 = 0;\n                    var i2 = 0;\n                    while (i1 < s1.Length && i2 < s2.Length)\n                    {\n                        var c1 = s1[i1];\n                        var ca1 = new char[s1.Length];\n                        var l1 = 0;\n                        do\n                        {\n                            ca1[l1++] = c1;\n                            i1++;\n                            if (i1 >= s1.Length)\n                                break;\n                            c1 = s1[i1];\n                        }\n                        while (char.IsDigit(c1) == char.IsDigit(ca1[0]));\n                        var c2 = s2[i2];\n                        var ca2 = new char[s2.Length];\n                        var l2 = 0;\n                        do\n                        {\n                            ca2[l2++] = c2;\n                            i2++;\n                            if (i2 >= s2.Length)\n                                break;\n                            c2 = s2[i2];\n                        }\n                        while (char.IsDigit(c2) == char.IsDigit(ca2[0]));\n                        var str1 = new string(ca1);\n                        var str2 = new string(ca2);\n                        int r;\n                        if (char.IsDigit(ca1[0]) && char.IsDigit(ca2[0]))\n                        {\n                            var ch1 = int.Parse(str1);\n                            var ch2 = int.Parse(str2);\n                            r = ch1.CompareTo(ch2);\n                        }\n                        else\n                            r = string.Compare(str1, str2, StringComparison.InvariantCulture);\n                        if (r != 0)\n                            return r;\n                    }\n                    return s1.Length - s2.Length;\n                }\n                catch\n                {\n                    return string.Compare(s1, s2, StringComparison.InvariantCulture);\n                }\n            }\n        }\n    }\n}\n","old_contents":"\ufeff#region auto-generated FILE INFORMATION\n\n\/\/ ==============================================\n\/\/ This file is distributed under the MIT License\n\/\/ ==============================================\n\/\/ \n\/\/ Filename: Comparison.cs\n\/\/ Version:  2017-05-12 11:39\n\/\/ \n\/\/ Copyright (c) 2017, Si13n7 Developments (r)\n\/\/ All rights reserved.\n\/\/ ______________________________________________\n\n#endregion\n\nnamespace SilDev\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n\n    \/\/\/ <summary>\n    \/\/\/     Provides static methods and base classes used for the comparison of two or more objects.\n    \/\/\/ <\/summary>\n    public static class Comparison\n    {\n        \/\/\/ <summary>\n        \/\/\/     Searches for the specified one-dimensional array and returns the index of its first\n        \/\/\/     occurrence in another one-dimensional array.\n        \/\/\/ <\/summary>\n        \/\/\/ <typeparam name=\"T\">\n        \/\/\/     The type of the elements of the array.\n        \/\/\/ <\/typeparam>\n        \/\/\/ <param name=\"source\">\n        \/\/\/     The one-dimensional array to search.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"target\">\n        \/\/\/     The one-dimensional array to locate.\n        \/\/\/ <\/param>\n        public static IEnumerable<int> IndexOf<T>(T[] source, T[] target)\n        {\n            if (target == null || source.Length < target.Length)\n                yield break;\n            for (var i = 0; i < source.Length - target.Length + 1; i++)\n                if (!target.Where((data, index) => !source[i + index].Equals(data)).Any())\n                    yield return i;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Determines whether the value of this object instance is between two specified values.\n        \/\/\/ <\/summary>\n        \/\/\/ <typeparam name=\"T\">\n        \/\/\/     The type of the object.\n        \/\/\/ <\/typeparam>\n        \/\/\/ <param name=\"item\">\n        \/\/\/     The object value to compare.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"start\">\n        \/\/\/     The start index value.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"end\">\n        \/\/\/     The end index value.\n        \/\/\/ <\/param>\n        public static bool IsBetween<T>(this T item, T start, T end) where T : IComparable, IComparable<T>\n        {\n            try\n            {\n                var c = Comparer<T>.Default;\n                var a = c.Compare(item, start);\n                var b = c.Compare(item, end);\n                return a >= 0 && b <= 0;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Determines whether a specified sequence of elements occurs within this sequence of\n        \/\/\/     elements.\n        \/\/\/ <\/summary>\n        \/\/\/ <typeparam name=\"T\">\n        \/\/\/     The type of the elements of the array.\n        \/\/\/ <\/typeparam>\n        \/\/\/ <param name=\"source\">\n        \/\/\/     The sequence of elements to browse.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"targets\">\n        \/\/\/     The sequence of elements to seek.\n        \/\/\/ <\/param>\n        public static bool ContainsEx<T>(this IEnumerable<T> source, params T[][] targets)\n        {\n            try\n            {\n                var r = targets.Any(x => IndexOf(source.ToArray(), x).Any(y => y >= 0));\n                return r;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Determines whether a specified string occurs within this sequence of strings. A\n        \/\/\/     parameter specifies the culture, case, and sort rules used in the comparison.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"source\">\n        \/\/\/     The sequence to browse.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"comparisonType\">\n        \/\/\/     One of the enumeration values that specifies the rules for the search.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"targets\">\n        \/\/\/     The sequence of strings to seek.\n        \/\/\/ <\/param>\n        public static bool ContainsEx(this IEnumerable<string> source, StringComparison comparisonType, params string[] targets)\n        {\n            try\n            {\n                var r = source.Any(x => targets.Any(y => string.Equals(x, y, comparisonType)));\n                return r;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Determines whether a specified string occurs within this sequence of strings. The\n        \/\/\/     <see cref=\"StringComparison.OrdinalIgnoreCase\"\/> parameter is used for this\n        \/\/\/     comparison.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"source\">\n        \/\/\/     The sequence to browse.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"targets\">\n        \/\/\/     The sequence of strings to seek.\n        \/\/\/ <\/param>\n        public static bool ContainsEx(this IEnumerable<string> source, params string[] targets) =>\n            source.ContainsEx(StringComparison.OrdinalIgnoreCase, targets);\n\n        \/\/\/ <summary>\n        \/\/\/     Determines whether a specified substring occurs within this string. A parameter\n        \/\/\/     specifies the culture, case, and sort rules used in the comparison.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"source\">\n        \/\/\/     The string to browse.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"comparisonType\">\n        \/\/\/     One of the enumeration values that specifies the rules for the search.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"targets\">\n        \/\/\/     The sequence of strings to seek.\n        \/\/\/ <\/param>\n        public static bool ContainsEx(this string source, StringComparison comparisonType, params string[] targets)\n        {\n            try\n            {\n                var r = targets.Any(x => source.IndexOf(x, 0, comparisonType) != -1);\n                return r;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Determines whether a specified substring occurs within this string. The\n        \/\/\/     <see cref=\"StringComparison.OrdinalIgnoreCase\"\/> parameter is used for this\n        \/\/\/     comparison.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"source\">\n        \/\/\/     The string to browse.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"targets\">\n        \/\/\/     The sequence of strings to seek.\n        \/\/\/ <\/param>\n        public static bool ContainsEx(this string source, params string[] targets) =>\n            source.ContainsEx(StringComparison.OrdinalIgnoreCase, targets);\n\n        \/\/\/ <summary>\n        \/\/\/     Determines whether a specified characters occurs within this string. A parameter\n        \/\/\/     specifies the culture, case, and sort rules used in the comparison.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"source\">\n        \/\/\/     The string to browse.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"comparisonType\">\n        \/\/\/     One of the enumeration values that specifies the rules for the search.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"targets\">\n        \/\/\/     The sequence of characters to seek.\n        \/\/\/ <\/param>\n        public static bool ContainsEx(this string source, StringComparison comparisonType, params char[] targets)\n        {\n            try\n            {\n                var r = targets.Any(x => source.IndexOf(x.ToString(), 0, comparisonType) != -1);\n                return r;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Determines whether a specified characters occurs within this string. The\n        \/\/\/     <see cref=\"StringComparison.OrdinalIgnoreCase\"\/> parameter is used for this\n        \/\/\/     comparison.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"source\">\n        \/\/\/     The string to browse.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"targets\">\n        \/\/\/     The sequence of characters to seek.\n        \/\/\/ <\/param>\n        public static bool ContainsEx(this string source, params char[] targets) =>\n            source.ContainsEx(StringComparison.OrdinalIgnoreCase, targets);\n\n        \/\/\/ <summary>\n        \/\/\/     Determines whether the beginning of this string matches a string. A parameter\n        \/\/\/     specifies the culture, case, and sort rules used in the comparison.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"source\">\n        \/\/\/     The string to check.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"comparisonType\">\n        \/\/\/     One of the enumeration values that specifies the rules for the search.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"targets\">\n        \/\/\/     The sequence of strings to compare seek.\n        \/\/\/ <\/param>\n        public static bool StartsWithEx(this string source, StringComparison comparisonType, params string[] targets)\n        {\n            try\n            {\n                var r = targets.Any(b => source.StartsWith(b, comparisonType));\n                return r;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Determines whether the beginning of this string matches a string. The\n        \/\/\/     <see cref=\"StringComparison.OrdinalIgnoreCase\"\/> parameter is used for this\n        \/\/\/     comparison.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"source\">\n        \/\/\/     The string to check.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"targets\">\n        \/\/\/     The sequence of strings to compare seek.\n        \/\/\/ <\/param>\n        public static bool StartsWithEx(this string source, params string[] targets) =>\n            source.StartsWithEx(StringComparison.OrdinalIgnoreCase, targets);\n\n        \/\/\/ <summary>\n        \/\/\/     Determines whether the end of this string matches a string. A parameter\n        \/\/\/     specifies the culture, case, and sort rules used in the comparison.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"source\">\n        \/\/\/     The string to check.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"comparisonType\">\n        \/\/\/     One of the enumeration values that specifies the rules for the search.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"targets\">\n        \/\/\/     The sequence of strings to compare seek.\n        \/\/\/ <\/param>\n        public static bool EndsWithEx(this string source, StringComparison comparisonType, params string[] targets)\n        {\n            try\n            {\n                var r = targets.Any(b => source.EndsWith(b, comparisonType));\n                return r;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Determines whether the end of this string matches a string. The\n        \/\/\/     <see cref=\"StringComparison.OrdinalIgnoreCase\"\/> parameter is used for this comparison.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"source\">\n        \/\/\/     The string to check.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"targets\">\n        \/\/\/     The sequence of strings to compare seek.\n        \/\/\/ <\/param>\n        public static bool EndsWithEx(this string source, params string[] targets) =>\n            source.EndsWithEx(StringComparison.OrdinalIgnoreCase, targets);\n\n        \/\/\/ <summary>\n        \/\/\/     Determines whether this string instance is the same as a string of the specified string\n        \/\/\/     array. A parameter specifies the culture, case, and sort rules used in the comparison.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"source\">\n        \/\/\/     The first string to compare.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"targets\">\n        \/\/\/     The sequence of strings to compare with the first.\n        \/\/\/ <\/param>\n        public static bool EqualsEx(this string source, StringComparison comparisonType, params string[] targets)\n        {\n            try\n            {\n                var r = targets.Any(b => string.Equals(source, b, comparisonType));\n                return r;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Determines whether this string instance is the same as a string of the specified string\n        \/\/\/     array. The <see cref=\"StringComparison.OrdinalIgnoreCase\"\/> parameter is used for this\n        \/\/\/     comparison.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"source\">\n        \/\/\/     The first string to compare.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"targets\">\n        \/\/\/     The sequence of strings to compare with the first.\n        \/\/\/ <\/param>\n        public static bool EqualsEx(this string source, params string[] targets) =>\n            source.EqualsEx(StringComparison.OrdinalIgnoreCase, targets);\n\n        \/\/\/ <summary>\n        \/\/\/     Provides a base class for comparison.\n        \/\/\/ <\/summary>\n        public class AlphanumericComparer : IComparer<object>\n        {\n            private readonly bool _d;\n\n            \/\/\/ <summary>\n            \/\/\/     Initilazies a new instance of the <see cref=\"AlphanumericComparer\"\/> class. A\n            \/\/\/     parameter specifies whether the order is descended.\n            \/\/\/ <\/summary>\n            \/\/\/ <param name=\"descendent\">\n            \/\/\/     true to enable the descending order; otherwise, false.\n            \/\/\/ <\/param>\n            public AlphanumericComparer(bool descendent = false)\n            {\n                _d = descendent;\n            }\n\n            \/\/\/ <summary>\n            \/\/\/     Compare two specified objects and returns an integer that indicates their relative\n            \/\/\/     position in the sort order.\n            \/\/\/ <\/summary>\n            \/\/\/ <param name=\"a\">\n            \/\/\/     The first object to compare.\n            \/\/\/ <\/param>\n            \/\/\/ <param name=\"b\">\n            \/\/\/     The second object to compare.\n            \/\/\/ <\/param>\n            public int Compare(object a, object b)\n            {\n                var s1 = !_d ? a as string : b as string;\n                if (s1 == null)\n                    return 0;\n                var s2 = !_d ? b as string : a as string;\n                if (s2 == null)\n                    return 0;\n                try\n                {\n                    var i1 = 0;\n                    var i2 = 0;\n                    while (i1 < s1.Length && i2 < s2.Length)\n                    {\n                        var c1 = s1[i1];\n                        var ca1 = new char[s1.Length];\n                        var l1 = 0;\n                        do\n                        {\n                            ca1[l1++] = c1;\n                            i1++;\n                            if (i1 >= s1.Length)\n                                break;\n                            c1 = s1[i1];\n                        }\n                        while (char.IsDigit(c1) == char.IsDigit(ca1[0]));\n                        var c2 = s2[i2];\n                        var ca2 = new char[s2.Length];\n                        var l2 = 0;\n                        do\n                        {\n                            ca2[l2++] = c2;\n                            i2++;\n                            if (i2 >= s2.Length)\n                                break;\n                            c2 = s2[i2];\n                        }\n                        while (char.IsDigit(c2) == char.IsDigit(ca2[0]));\n                        var str1 = new string(ca1);\n                        var str2 = new string(ca2);\n                        int r;\n                        if (char.IsDigit(ca1[0]) && char.IsDigit(ca2[0]))\n                        {\n                            var ch1 = int.Parse(str1);\n                            var ch2 = int.Parse(str2);\n                            r = ch1.CompareTo(ch2);\n                        }\n                        else\n                            r = string.Compare(str1, str2, StringComparison.InvariantCulture);\n                        if (r != 0)\n                            return r;\n                    }\n                    return s1.Length - s2.Length;\n                }\n                catch\n                {\n                    return string.Compare(s1, s2, StringComparison.InvariantCulture);\n                }\n            }\n        }\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"1b41e10973030f4fc12a674b9dbbc70bf6d2805c","subject":"Use ICommand....","message":"Use ICommand....\n","repos":"migrap\/Reap","old_file":"src\/Sandbox\/Program.cs","new_file":"src\/Sandbox\/Program.cs","new_contents":"\ufeffusing System;\nusing Newtonsoft.Json;\nusing Reap;\nusing Reap.Extensions.Authentication;\nusing Reap.Extensions.Authorization;\nusing Reap.Extensions.Claims;\nusing Reap.Extensions.Headers;\nusing Reap.Extensions.Mood;\n\/\/using Reap.Extensions.Resource;\nusing Reap.Extensions.Objects;\nusing Reap.Newtonsoft.Json;\n\nnamespace Sandbox {\n    public class Program {\n        public void Main(string[] args) {\n            var settings = new MessageSerializerSettings();\n            settings.Converters.Add(new MessageConverter());\n            settings.Converters.Add(new VersionConverter());\n\n            var message = new Message();\n\n            \/\/var authorization = message.Extension(x => x.Authorization, x => {\n            \/\/});\n\n            \/\/var headers = message.Extension(x => x.Headers, x => {\n            \/\/    x.Headers.Add(\"\", \"\");\n            \/\/});\n\n            \/\/var claims = message.Extension(x => x.Claims, x => {\n            \/\/    x.Claims.Add(\"issuer\", \"type\", \"value\");\n            \/\/});\n\n            \/\/var authentication = message.Extension(x => x.Authentication, x => {\n            \/\/    x.Token = \"Bearer 0xABCDEF0123456789\";\n            \/\/});\n\n            \/\/var version = message.Extension(x => x.Version, x => {\n            \/\/    x.Version = \"1.0.0\";\n            \/\/});\n\n            \/\/var mood = message.Extension(x => x.Mood, x => {\n            \/\/    x.Mood = Mood.Happy;\n            \/\/});            \n\n            \/\/var uri = message.Extension(x => x.Resource, x => {\n            \/\/    x.Resource = \"http:\/\/www.google.com\";\n            \/\/});\n\n            \/\/var obj = message.Extension(x => x.Object, x => {\n            \/\/    x.Class = \"Person\";\n            \/\/    x.Properties = new {\n            \/\/        name = \"Michael\",\n            \/\/        age = 10,\n            \/\/    };\n            \/\/    x.Links.Add(Link.About(\"http:\/\/www.about.com\"));\n            \/\/    x.Title = \"Person Description\";\n            \/\/});\n\n            \/\/var urn = message.Extension(x => x.Resource, \"urn:here@home.com\");\n\n            \/\/var urh = message.Extension(x => x.Resource, x => x.Home);\n\n            \/\/var cmd = message.Extension(x => x.Command, x => {\n            \/\/    x = x.CreateAccount(name: \"Michael\");\n            \/\/});\n\n            message.xExtension(x => x.Command, x => x.Command = Account.Create(create => {\n                create.Name = Guid.Empty.ToString();\n            }));\n                \n\n            \/\/message.xExtension(x => x.Command, x => x.Account.Create(\"\"));\n\n            var json = (string)null;\n            json = JsonConvert.SerializeObject(message, settings);\n\n            \/\/var egassem = JsonConvert.DeserializeObject<Message>(json, settings);\n            \/\/authorization = egassem.Extension(x => x.Authorization);\n            \/\/version = egassem.Extension(x => x.Version);\n\n            \/\/var contains = egassem.Extensions.Contains(x => x.Authentication, x => x.Jello);\n        }\n    }\n\n    public interface ICommandExtension {\n        ICommand Command { get; set; }\n    }\n\n    public interface ICommand { }\n\n    public class CommandExtension : ICommandExtension {\n        public CommandExtension() {\n        }\n\n        public CommandExtension(ICommandExtension extension) {\n            Command = extension.Command;\n        }\n\n        public CommandExtension(ICommand command) {\n            Command = command;\n        }\n\n        public ICommand Command { get; set; }\n    }  \n\n    public delegate Func<T> CommandSelector<T>(ICommandExtension extension = null) where T : ICommandExtension;\n\n    public static class CommnadExtensions {\n        public static ICommandExtension Extension(this Message message, ExtensionSelector<ICommandExtension> extension, Action<ICommandExtension> callback = null) {\n            return message.Extension<ICommandExtension>(extension, callback);\n        }    \n        \n        public static ICommandExtension Command(this Message message) {\n            return message.Extension<ICommandExtension>(new CommandExtension());\n        }\n\n        public static ICommandExtension xExtension(this Message message, ExtensionSelector<ICommandExtension> extension, Action<ICommandExtension> callback = null) {\n            return message.Extension<ICommandExtension>(extension, callback);\n        }\n    }\n\n    \n    public static class Account {\n        public static Func<Action<CreateCommand>,ICommand> Create => (callback) => {\n            var command = new CreateCommand();\n            callback(command);\n            return command;\n        };\n\n        public abstract class AccountCommand : ICommand {\n            public string Uri { get; } = \"\/account\";\n        }\n\n        public class CreateCommand : AccountCommand {\n            public string Name { get; set; }\n        }\n    }    \n    \n\n    public class VersionConverter : JsonConverter {\n        public override bool CanConvert(Type objectType) {\n            return typeof(IVersionExtension).IsAssignableFrom(objectType);\n        }\n\n        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) {\n            if(reader.TokenType == JsonToken.String) {\n                return new VersionExtension { Version = reader.Value.ToString() };\n            }\n            throw new InvalidOperationException(\"VersionConverter.ReadJson\");\n        }\n\n        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) {\n            WriteJson(writer, value as IVersionExtension, serializer);\n        }\n\n        private void WriteJson(JsonWriter writer, IVersionExtension value, JsonSerializer serializer) {\n            serializer.Serialize(writer, value.Version);\n        }\n    }\n\n    public interface IVersionExtension {\n        string Version { get; set; }\n    }\n\n    public class VersionExtension : IVersionExtension {\n        public string Version { get; set; }\n    }\n\n    public static partial class VersionExtensions {\n        public static IVersionExtension Extension(this Message message, ExtensionSelector<IVersionExtension> extension, Action<IVersionExtension> callback = null) {\n            return message.Extension<IVersionExtension>(extension, callback);\n        }\n\n        public static IVersionExtension Version(this Message message) {\n            return message.Extension<IVersionExtension>();\n        }\n    }\n}","old_contents":"\ufeffusing System;\nusing Newtonsoft.Json;\nusing Reap;\nusing Reap.Extensions.Authentication;\nusing Reap.Extensions.Authorization;\nusing Reap.Extensions.Claims;\nusing Reap.Extensions.Headers;\nusing Reap.Extensions.Mood;\n\/\/using Reap.Extensions.Resource;\nusing Reap.Extensions.Objects;\nusing Reap.Newtonsoft.Json;\n\nnamespace Sandbox {\n    public class Program {\n        public void Main(string[] args) {\n            var settings = new MessageSerializerSettings();\n            settings.Converters.Add(new MessageConverter());\n            settings.Converters.Add(new VersionConverter());\n\n            var message = new Message();\n\n            \/\/var authorization = message.Extension(x => x.Authorization, x => {\n            \/\/});\n\n            \/\/var headers = message.Extension(x => x.Headers, x => {\n            \/\/    x.Headers.Add(\"\", \"\");\n            \/\/});\n\n            \/\/var claims = message.Extension(x => x.Claims, x => {\n            \/\/    x.Claims.Add(\"issuer\", \"type\", \"value\");\n            \/\/});\n\n            \/\/var authentication = message.Extension(x => x.Authentication, x => {\n            \/\/    x.Token = \"Bearer 0xABCDEF0123456789\";\n            \/\/});\n\n            \/\/var version = message.Extension(x => x.Version, x => {\n            \/\/    x.Version = \"1.0.0\";\n            \/\/});\n\n            \/\/var mood = message.Extension(x => x.Mood, x => {\n            \/\/    x.Mood = Mood.Happy;\n            \/\/});            \n\n            \/\/var uri = message.Extension(x => x.Resource, x => {\n            \/\/    x.Resource = \"http:\/\/www.google.com\";\n            \/\/});\n\n            \/\/var obj = message.Extension(x => x.Object, x => {\n            \/\/    x.Class = \"Person\";\n            \/\/    x.Properties = new {\n            \/\/        name = \"Michael\",\n            \/\/        age = 10,\n            \/\/    };\n            \/\/    x.Links.Add(Link.About(\"http:\/\/www.about.com\"));\n            \/\/    x.Title = \"Person Description\";\n            \/\/});\n\n            \/\/var urn = message.Extension(x => x.Resource, \"urn:here@home.com\");\n\n            \/\/var urh = message.Extension(x => x.Resource, x => x.Home);\n\n            var cmd = message.Extension(x => x.Command, x => {\n                x = x.CreateAccount(name: \"Michael\");\n            });\n\n            message.xExtension(x => x.Command, x => x.Account, x => x.Create(\"\"));\n\n            var json = (string)null;\n            json = JsonConvert.SerializeObject(message, settings);\n\n            \/\/var egassem = JsonConvert.DeserializeObject<Message>(json, settings);\n            \/\/authorization = egassem.Extension(x => x.Authorization);\n            \/\/version = egassem.Extension(x => x.Version);\n\n            \/\/var contains = egassem.Extensions.Contains(x => x.Authentication, x => x.Jello);\n        }\n    }\n\n    public interface ICommandExtension {\n\n    }\n\n    public abstract class CommandExtension : ICommandExtension {\n        public CommandExtension(string uri) {\n            Uri = uri;  \n        }\n\n        public string Uri { get; }\n    }\n\n    public abstract class AccountCommandExtension : CommandExtension {\n        public AccountCommandExtension() : base(\"\/account\") {\n        }\n    }\n\n    public class CreateAccountCommandExtension : AccountCommandExtension {\n        public CreateAccountCommandExtension(string name) {\n            Name = name;\n        }\n\n        public string Name { get; }\n    }\n\n    public delegate Func<T> CommandSelector<T>(ICommandExtension extension = null) where T : ICommandExtension;\n\n    public static class CommnadExtensions {\n        public static ICommandExtension Extension(this Message message, ExtensionSelector<ICommandExtension> extension, Action<ICommandExtension> callback = null) {\n            return message.Extension<ICommandExtension>(extension, callback);\n        }    \n        \n        public static ICommandExtension Command(this Message message) {\n            return default(ICommandExtension);\n        }\n\n        public static ICommandExtension CreateAccount(this ICommandExtension extension, string name) {\n            return new CreateAccountCommand(name);\n        }\n\n        \/\/public static ICommandExtension xExtension(this Message message, ExtensionSelector<ICommandExtension> extension, CommandSelector<AccountCommandExtension> account, Func<AccountCommandExtension,Func<ICommandExtension>> command) {\n        \/\/    return command(account(null)());\n        \/\/}\n\n        public static ICommandExtension xExtension(this Message message, ExtensionSelector<ICommandExtension> extension, Func<ICommandExtension, Func<AccountCommandExtension>> account, Func<AccountCommandExtension, ICommandExtension> command) {\n            return message.Extension<ICommandExtension>(command(null));\n        }\n\n        public static AccountCommandExtension Account(this ICommandExtension extension) {\n            return default(AccountCommandExtension);\n        }\n\n        public static CreateAccountCommandExtension Create(this AccountCommandExtension extension, string name) {\n            return new CreateAccountCommandExtension(name);\n        }\n    }\n\n    public class CreateAccountCommand : CommandExtension {\n        public CreateAccountCommand(string name) : base(\"\/account\") {\n            Name = name;\n        }\n\n        public string Name { get; }\n    }\n\n\n    public class VersionConverter : JsonConverter {\n        public override bool CanConvert(Type objectType) {\n            return typeof(IVersionExtension).IsAssignableFrom(objectType);\n        }\n\n        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer) {\n            if(reader.TokenType == JsonToken.String) {\n                return new VersionExtension { Version = reader.Value.ToString() };\n            }\n            throw new InvalidOperationException(\"VersionConverter.ReadJson\");\n        }\n\n        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer) {\n            WriteJson(writer, value as IVersionExtension, serializer);\n        }\n\n        private void WriteJson(JsonWriter writer, IVersionExtension value, JsonSerializer serializer) {\n            serializer.Serialize(writer, value.Version);\n        }\n    }\n\n    public interface IVersionExtension {\n        string Version { get; set; }\n    }\n\n    public class VersionExtension : IVersionExtension {\n        public string Version { get; set; }\n    }\n\n    public static partial class VersionExtensions {\n        public static IVersionExtension Extension(this Message message, ExtensionSelector<IVersionExtension> extension, Action<IVersionExtension> callback = null) {\n            return message.Extension<IVersionExtension>(extension, callback);\n        }\n\n        public static IVersionExtension Version(this Message message) {\n            return message.Extension<IVersionExtension>();\n        }\n    }\n}","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"e040871a1441fb04668ecdf4d475c4b215a39321","subject":"added status messages","message":"added status messages\n\ngit-svn-id: 55ea488da616a60e70f234b559e901c5e15b5508@6 49102ff3-e64e-284a-8f61-b7e53b302e95\n","repos":"sethreno\/schemazen,sethreno\/schemazen,Zocdoc\/schemazen,ruediger-stevens\/schemazen,keith-hall\/schemazen","old_file":"console\/Program.cs","new_file":"console\/Program.cs","new_contents":"\ufeffusing System;\r\nusing System.IO;\r\nusing System.Text;\r\nusing System.Collections.Generic;\r\nusing System.Collections.Specialized;\r\nusing Microsoft.SqlServer.Management.Smo;\r\n\r\nnamespace console\r\n{\r\n\tclass Program\r\n\t{\r\n\t\tstatic void Main(string[] args)\r\n\t\t{\r\n\t\t\tServer srv = new Server(args[0]);\r\n\t\t\tDatabase db = default(Database);\r\n\t\t\tforeach (Database d in srv.Databases){\r\n\t\t\t\tif (d.Name == args[1]) {\r\n\t\t\t\t\tdb = d;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\/\/ create dir tree\r\n            Console.WriteLine(\"creating directory tree\");\r\n\t\t\tstring[] dirs = { \"data\", \"foreign_keys\", \"functions\", \r\n                              \"indexes\", \"procs\", \"tables\", \"triggers\" };\r\n\t\t\tforeach (string dir in dirs) {\r\n\t\t\t\tif (!Directory.Exists(args[2] + \"\/\" + dir)) {\r\n\t\t\t\t\tDirectory.CreateDirectory(args[2] + \"\/\" + dir);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tScripter scr = new Scripter(srv);\r\n\t\t\tscr.Options.ScriptDrops = false;\r\n\t\t\tList<Urn> urns = new List<Urn>();\r\n\r\n\t\t\t\/\/ tables\r\n            Console.WriteLine(\"scripting tables\");\r\n\t\t\tforeach (Table t in db.Tables){\r\n\t\t\t\tif (t.IsSystemObject) continue;\r\n\r\n\t\t\t\turns.Clear();\r\n\t\t\t\turns.Add(t.Urn);\r\n\t\t\t\tscr.Options.WithDependencies = false;\r\n\t\t\t\tscr.Options.DriPrimaryKey = false;\r\n\t\t\t\tscr.Options.NoCollation = true;\r\n\t\t\t\tscr.Options.DriIndexes = false;\r\n\t\t\t\tscr.Options.DriDefaults = true;\r\n\t\t\t\tScriptToFile(scr, urns.ToArray(), \r\n                    String.Format(\"{0}\/tables\/{1}.sql\", args[2], t.Name));\r\n\r\n\t\t\t\t\/\/ foreign keys in seperate dir\r\n\t\t\t\turns.Clear();\r\n\t\t\t\tforeach (ForeignKey fk in t.ForeignKeys) {\r\n\t\t\t\t\turns.Add(fk.Urn);\r\n\t\t\t\t}\r\n\t\t\t\tif (urns.Count > 0) {\r\n\t\t\t\t\tscr.Options.DriAll = true;\r\n\t\t\t\t\tScriptToFile(scr,urns.ToArray(), \r\n                        String.Format(\"{0}\/foreign_keys\/{1}.sql\", args[2], t.Name));\r\n\t\t\t\t}\r\n\r\n\t\t\t\t\/\/ triggers in seperate dir\r\n\t\t\t\turns.Clear();\r\n\t\t\t\tforeach (Trigger tr in t.Triggers) {\r\n\t\t\t\t\turns.Add(tr.Urn);\r\n\t\t\t\t}\r\n\t\t\t\tif (urns.Count > 0) {\r\n\t\t\t\t\tscr.Options.DriAll = true;\r\n\t\t\t\t\tScriptToFile(scr, urns.ToArray(), \r\n                        String.Format(\"{0}\/triggers\/{1}.sql\", args[2], t.Name));\r\n\t\t\t\t}\r\n\r\n\t\t\t\t\/\/ indexes in seperate dir\r\n\t\t\t\turns.Clear();\r\n\t\t\t\tforeach (Index idx in t.Indexes) {\r\n\t\t\t\t\turns.Add(idx.Urn);\r\n\t\t\t\t}\r\n\t\t\t\tif (urns.Count > 0) {\r\n                    scr.Options.DriAll = true;\r\n\t\t\t\t\tScriptToFile(scr, urns.ToArray(), \r\n                        String.Format(\"{0}\/indexes\/{1}.sql\", args[2], t.Name));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t\/\/ functions\r\n            Console.WriteLine(\"scripting functions\");\r\n\t\t\tforeach (UserDefinedFunction f in db.UserDefinedFunctions) {\r\n\t\t\t\tif (f.IsSystemObject) continue;\r\n\t\t\t\turns.Clear();\t\t\t\t\r\n\t\t\t\turns.Add(f.Urn);\r\n\t\t\t\tscr.Options.DriAll = true;\r\n\t\t\t\tScriptToFile(scr, urns.ToArray(), \r\n                    String.Format(\"{0}\/functions\/{1}.sql\", args[2], f.Name));\r\n\t\t\t}\t\t\t\r\n\t\t\t\r\n\t\t\t\/\/ procs\r\n            Console.WriteLine(\"scripting stored procedures\");\r\n\t\t\tforeach (StoredProcedure p in db.StoredProcedures) {\r\n\t\t\t\tif (p.IsSystemObject) continue;\r\n\t\t\t\turns.Clear();\r\n\t\t\t\turns.Add(p.Urn);\r\n\t\t\t\tscr.Options.DriAll = true;\r\n\t\t\t\tScriptToFile(scr, urns.ToArray(), \r\n                    String.Format(\"{0}\/procs\/{1}.sql\", args[2], p.Name));\r\n\t\t\t}\r\n\r\n\t\t\t\/\/ TODO data\r\n\r\n            Console.WriteLine(\"success\");\r\n\t\t}\r\n\r\n\t\tstatic void ScriptToFile(Scripter scr, Urn[] urns, string fileName) {\r\n\t\t\tusing (TextWriter tw = File.CreateText(fileName)) {\r\n\t\t\t\tforeach (string line in scr.Script(urns)) {\r\n\t\t\t\t\ttw.WriteLine(line);\r\n\t\t\t\t}\r\n\t\t\t\ttw.WriteLine(\"GO\");\r\n\t\t\t\ttw.Close();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n","old_contents":"\ufeffusing System;\r\nusing System.IO;\r\nusing System.Text;\r\nusing System.Collections.Generic;\r\nusing System.Collections.Specialized;\r\nusing Microsoft.SqlServer.Management.Smo;\r\n\r\nnamespace console\r\n{\r\n\tclass Program\r\n\t{\r\n\t\tstatic void Main(string[] args)\r\n\t\t{\r\n\t\t\tServer srv = new Server(args[0]);\r\n\t\t\tDatabase db = default(Database);\r\n\t\t\tforeach (Database d in srv.Databases){\r\n\t\t\t\tif (d.Name == args[1]) {\r\n\t\t\t\t\tdb = d;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\/\/ create dir tree\r\n\t\t\tstring[] dirs = { \"data\", \"foreign_keys\", \"functions\", \r\n                              \"indexes\", \"procs\", \"tables\", \"triggers\" };\r\n\t\t\tforeach (string dir in dirs) {\r\n\t\t\t\tif (!Directory.Exists(args[2] + \"\/\" + dir)) {\r\n\t\t\t\t\tDirectory.CreateDirectory(args[2] + \"\/\" + dir);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tScripter scr = new Scripter(srv);\r\n\t\t\tscr.Options.ScriptDrops = false;\r\n\t\t\tList<Urn> urns = new List<Urn>();\r\n\r\n\t\t\t\/\/ tables\t\t\r\n\t\t\tforeach (Table t in db.Tables){\r\n\t\t\t\tif (t.IsSystemObject) continue;\r\n\r\n\t\t\t\turns.Clear();\r\n\t\t\t\turns.Add(t.Urn);\r\n\t\t\t\tscr.Options.WithDependencies = false;\r\n\t\t\t\tscr.Options.DriPrimaryKey = false;\r\n\t\t\t\tscr.Options.NoCollation = true;\r\n\t\t\t\tscr.Options.DriIndexes = false;\r\n\t\t\t\tscr.Options.DriDefaults = true;\r\n\t\t\t\tScriptToFile(scr, urns.ToArray(), \r\n                    String.Format(\"{0}\/tables\/{1}.sql\", args[2], t.Name));\r\n\r\n\t\t\t\t\/\/ foreign keys in seperate dir\r\n\t\t\t\turns.Clear();\r\n\t\t\t\tforeach (ForeignKey fk in t.ForeignKeys) {\r\n\t\t\t\t\turns.Add(fk.Urn);\r\n\t\t\t\t}\r\n\t\t\t\tif (urns.Count > 0) {\r\n\t\t\t\t\tscr.Options.DriAll = true;\r\n\t\t\t\t\tScriptToFile(scr,urns.ToArray(), \r\n                        String.Format(\"{0}\/foreign_keys\/{1}.sql\", args[2], t.Name));\r\n\t\t\t\t}\r\n\r\n\t\t\t\t\/\/ triggers in seperate dir\r\n\t\t\t\turns.Clear();\r\n\t\t\t\tforeach (Trigger tr in t.Triggers) {\r\n\t\t\t\t\turns.Add(tr.Urn);\r\n\t\t\t\t}\r\n\t\t\t\tif (urns.Count > 0) {\r\n\t\t\t\t\tscr.Options.DriAll = true;\r\n\t\t\t\t\tScriptToFile(scr, urns.ToArray(), \r\n                        String.Format(\"{0}\/triggers\/{1}.sql\", args[2], t.Name));\r\n\t\t\t\t}\r\n\r\n\t\t\t\t\/\/ indexes in seperate dir\r\n\t\t\t\turns.Clear();\r\n\t\t\t\tforeach (Index idx in t.Indexes) {\r\n\t\t\t\t\turns.Add(idx.Urn);\r\n\t\t\t\t}\r\n\t\t\t\tif (urns.Count > 0) {\r\n                    scr.Options.DriAll = true;\r\n\t\t\t\t\tScriptToFile(scr, urns.ToArray(), \r\n                        String.Format(\"{0}\/indexes\/{1}.sql\", args[2], t.Name));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t\/\/ functions\t\t\t\r\n\t\t\tforeach (UserDefinedFunction f in db.UserDefinedFunctions) {\r\n\t\t\t\tif (f.IsSystemObject) continue;\r\n\t\t\t\turns.Clear();\t\t\t\t\r\n\t\t\t\turns.Add(f.Urn);\r\n\t\t\t\tscr.Options.DriAll = true;\r\n\t\t\t\tScriptToFile(scr, urns.ToArray(), \r\n                    String.Format(\"{0}\/functions\/{1}.sql\", args[2], f.Name));\r\n\t\t\t}\t\t\t\r\n\t\t\t\r\n\t\t\t\/\/ procs\r\n\t\t\tforeach (StoredProcedure p in db.StoredProcedures) {\r\n\t\t\t\tif (p.IsSystemObject) continue;\r\n\t\t\t\turns.Clear();\r\n\t\t\t\turns.Add(p.Urn);\r\n\t\t\t\tscr.Options.DriAll = true;\r\n\t\t\t\tScriptToFile(scr, urns.ToArray(), \r\n                    String.Format(\"{0}\/procs\/{1}.sql\", args[2], p.Name));\r\n\t\t\t}\r\n\r\n\t\t\t\/\/ TODO data\r\n\r\n\t\t}\r\n\r\n\t\tstatic void ScriptToFile(Scripter scr, Urn[] urns, string fileName) {\r\n\t\t\tusing (TextWriter tw = File.CreateText(fileName)) {\r\n\t\t\t\tforeach (string line in scr.Script(urns)) {\r\n\t\t\t\t\ttw.WriteLine(line);\r\n\t\t\t\t}\r\n\t\t\t\ttw.WriteLine(\"GO\");\r\n\t\t\t\ttw.Close();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"95b3431c149bf280aab2344428abf76d3a79dca8","subject":"Support case for case-sensitive file systems","message":"Support case for case-sensitive file systems\n","repos":"mono\/SkiaSharp,mono\/SkiaSharp,mono\/SkiaSharp,mono\/SkiaSharp,mono\/SkiaSharp,mono\/SkiaSharp,mono\/SkiaSharp","old_file":"cake\/UtilsManaged.cake","new_file":"cake\/UtilsManaged.cake","new_contents":"using System.Runtime.InteropServices;\n\nvar VERBOSITY_NUGET = NuGetVerbosity.Detailed;\nvar VERBOSITY_NUGETCORE = DotNetCoreRestoreVerbosity.Verbose;\nswitch (VERBOSITY) {\n    case Verbosity.Quiet:\n    case Verbosity.Minimal:\n        VERBOSITY_NUGET = NuGetVerbosity.Quiet;\n        VERBOSITY_NUGETCORE = DotNetCoreRestoreVerbosity.Minimal;\n        break;\n    case Verbosity.Normal:\n        VERBOSITY_NUGET = NuGetVerbosity.Normal;\n        VERBOSITY_NUGETCORE = DotNetCoreRestoreVerbosity.Warning;\n        break;\n    case Verbosity.Verbose:\n    case Verbosity.Diagnostic:\n        VERBOSITY_NUGET = NuGetVerbosity.Detailed;\n        VERBOSITY_NUGETCORE = DotNetCoreRestoreVerbosity.Verbose;\n        break;\n};\n\nvar RunNuGetRestore = new Action<FilePath> ((solution) =>\n{\n    NuGetRestore (solution, new NuGetRestoreSettings { \n        ToolPath = NugetToolPath,\n        Source = NuGetSources,\n        Verbosity = VERBOSITY_NUGET\n    });\n});\n\nvar RunDotNetCoreRestore = new Action<string> ((solution) =>\n{\n    DotNetCoreRestore (solution, new DotNetCoreRestoreSettings { \n        Sources = NuGetSources,\n        \/\/ Verbosity = VERBOSITY_NUGETCORE \/\/ TODO: v1.1.1 has different values ???\n    });\n});\n\nvar PackageNuGet = new Action<FilePath, DirectoryPath> ((nuspecPath, outputPath) =>\n{\n    if (!DirectoryExists (outputPath)) {\n        CreateDirectory (outputPath);\n    }\n\n    NuGetPack (nuspecPath, new NuGetPackSettings { \n        Verbosity = VERBOSITY_NUGET,\n        OutputDirectory = outputPath,        \n        BasePath = \".\/\",\n        ToolPath = NugetToolPath\n    });                \n});\n\nvar RunProcess = new Action<FilePath, ProcessSettings> ((process, settings) =>\n{\n    var result = StartProcess (process, settings);\n    if (result != 0) {\n        throw new Exception (\"Process '\" + process + \"' failed with error: \" + result);\n    }\n});\n\nvar RunTests = new Action<FilePath> ((testAssembly) =>\n{\n    var dir = testAssembly.GetDirectory ();\n    RunProcess (NUnitConsoleToolPath, new ProcessSettings {\n        Arguments = string.Format (\"\\\"{0}\\\" --work=\\\"{1}\\\"\", testAssembly, dir),\n    });\n});\n\nvar RunMdocUpdate = new Action<FilePath[], DirectoryPath, DirectoryPath[]> ((assemblies, docsRoot, refs) =>\n{\n    var refArgs = string.Empty;\n    if (refs != null) {\n        refArgs = string.Join (\" \", refs.Select (r => string.Format (\"--lib=\\\"{0}\\\"\", r)));\n    }\n    var assemblyArgs = string.Join (\" \", assemblies.Select (a => string.Format (\"\\\"{0}\\\"\", a)));\n    RunProcess (MDocPath, new ProcessSettings {\n        Arguments = string.Format (\"update --preserve --out=\\\"{0}\\\" {1} {2}\", docsRoot, refArgs, assemblyArgs),\n    });\n});\n\nvar RunMdocMSXml = new Action<DirectoryPath, DirectoryPath> ((docsRoot, outputDir) =>\n{\n    RunProcess (MDocPath, new ProcessSettings {\n        Arguments = string.Format (\"export-msxdoc \\\"{0}\\\" --debug\", MakeAbsolute (docsRoot)),\n        WorkingDirectory = MakeAbsolute (outputDir).ToString ()\n    });\n});\n\nvar RunMdocAssemble = new Action<DirectoryPath, FilePath> ((docsRoot, output) =>\n{\n    RunProcess (MDocPath, new ProcessSettings {\n        Arguments = string.Format (\"assemble --out=\\\"{0}\\\" \\\"{1}\\\" --debug\", output, docsRoot),\n    });\n});\n\nvar ClearSkiaSharpNuGetCache = new Action (() => {\n    \/\/ first we need to add our new nuget to the cache so we can restore\n    \/\/ we first need to delete the old stuff\n    DirectoryPath home = EnvironmentVariable (\"USERPROFILE\") ?? EnvironmentVariable (\"HOME\");\n    var installedNuGet = home.Combine (\".nuget\").Combine (\"packages\").FullPath + \"\/*\";\n    var packages = VERSION_PACKAGES.Keys;\n    var dirs = GetDirectories (installedNuGet);\n    foreach (var dir in dirs) {\n        var dirName = dir.GetDirectoryName ();\n        foreach (var pkg in packages) {\n            if (string.Equals (pkg, dirName, StringComparison.OrdinalIgnoreCase)) {\n                Warning (\"SkiaSharp nugets were installed at '{0}', removing...\", dir);\n                CleanDirectory (dir);\n            }\n        }\n    }\n});\n","old_contents":"using System.Runtime.InteropServices;\n\nvar VERBOSITY_NUGET = NuGetVerbosity.Detailed;\nvar VERBOSITY_NUGETCORE = DotNetCoreRestoreVerbosity.Verbose;\nswitch (VERBOSITY) {\n    case Verbosity.Quiet:\n    case Verbosity.Minimal:\n        VERBOSITY_NUGET = NuGetVerbosity.Quiet;\n        VERBOSITY_NUGETCORE = DotNetCoreRestoreVerbosity.Minimal;\n        break;\n    case Verbosity.Normal:\n        VERBOSITY_NUGET = NuGetVerbosity.Normal;\n        VERBOSITY_NUGETCORE = DotNetCoreRestoreVerbosity.Warning;\n        break;\n    case Verbosity.Verbose:\n    case Verbosity.Diagnostic:\n        VERBOSITY_NUGET = NuGetVerbosity.Detailed;\n        VERBOSITY_NUGETCORE = DotNetCoreRestoreVerbosity.Verbose;\n        break;\n};\n\nvar RunNuGetRestore = new Action<FilePath> ((solution) =>\n{\n    NuGetRestore (solution, new NuGetRestoreSettings { \n        ToolPath = NugetToolPath,\n        Source = NuGetSources,\n        Verbosity = VERBOSITY_NUGET\n    });\n});\n\nvar RunDotNetCoreRestore = new Action<string> ((solution) =>\n{\n    DotNetCoreRestore (solution, new DotNetCoreRestoreSettings { \n        Sources = NuGetSources,\n        \/\/ Verbosity = VERBOSITY_NUGETCORE \/\/ TODO: v1.1.1 has different values ???\n    });\n});\n\nvar PackageNuGet = new Action<FilePath, DirectoryPath> ((nuspecPath, outputPath) =>\n{\n    if (!DirectoryExists (outputPath)) {\n        CreateDirectory (outputPath);\n    }\n\n    NuGetPack (nuspecPath, new NuGetPackSettings { \n        Verbosity = VERBOSITY_NUGET,\n        OutputDirectory = outputPath,        \n        BasePath = \".\/\",\n        ToolPath = NugetToolPath\n    });                \n});\n\nvar RunProcess = new Action<FilePath, ProcessSettings> ((process, settings) =>\n{\n    var result = StartProcess (process, settings);\n    if (result != 0) {\n        throw new Exception (\"Process '\" + process + \"' failed with error: \" + result);\n    }\n});\n\nvar RunTests = new Action<FilePath> ((testAssembly) =>\n{\n    var dir = testAssembly.GetDirectory ();\n    RunProcess (NUnitConsoleToolPath, new ProcessSettings {\n        Arguments = string.Format (\"\\\"{0}\\\" --work=\\\"{1}\\\"\", testAssembly, dir),\n    });\n});\n\nvar RunMdocUpdate = new Action<FilePath[], DirectoryPath, DirectoryPath[]> ((assemblies, docsRoot, refs) =>\n{\n    var refArgs = string.Empty;\n    if (refs != null) {\n        refArgs = string.Join (\" \", refs.Select (r => string.Format (\"--lib=\\\"{0}\\\"\", r)));\n    }\n    var assemblyArgs = string.Join (\" \", assemblies.Select (a => string.Format (\"\\\"{0}\\\"\", a)));\n    RunProcess (MDocPath, new ProcessSettings {\n        Arguments = string.Format (\"update --preserve --out=\\\"{0}\\\" {1} {2}\", docsRoot, refArgs, assemblyArgs),\n    });\n});\n\nvar RunMdocMSXml = new Action<DirectoryPath, DirectoryPath> ((docsRoot, outputDir) =>\n{\n    RunProcess (MDocPath, new ProcessSettings {\n        Arguments = string.Format (\"export-msxdoc \\\"{0}\\\" --debug\", MakeAbsolute (docsRoot)),\n        WorkingDirectory = MakeAbsolute (outputDir).ToString ()\n    });\n});\n\nvar RunMdocAssemble = new Action<DirectoryPath, FilePath> ((docsRoot, output) =>\n{\n    RunProcess (MDocPath, new ProcessSettings {\n        Arguments = string.Format (\"assemble --out=\\\"{0}\\\" \\\"{1}\\\" --debug\", output, docsRoot),\n    });\n});\n\nvar ClearSkiaSharpNuGetCache = new Action (() => {\n    \/\/ first we need to add our new nuget to the cache so we can restore\n    \/\/ we first need to delete the old stuff\n    DirectoryPath home = EnvironmentVariable (\"USERPROFILE\") ?? EnvironmentVariable (\"HOME\");\n    var installedNuGet = home.Combine (\".nuget\").Combine (\"packages\").Combine (\"SkiaSharp\");\n    if (DirectoryExists (installedNuGet)) {\n        Warning (\"SkiaSharp nugets were installed at '{0}', removing...\", installedNuGet);\n        CleanDirectory (installedNuGet);\n    }\n    installedNuGet = home.Combine (\".nuget\").Combine (\"packages\").Combine (\"SkiaSharp.Views\");\n    if (DirectoryExists (installedNuGet)) {\n        Warning (\"SkiaSharp nugets were installed at '{0}', removing...\", installedNuGet);\n        CleanDirectory (installedNuGet);\n    }\n    installedNuGet = home.Combine (\".nuget\").Combine (\"packages\").Combine (\"SkiaSharp.Views.Forms\");\n    if (DirectoryExists (installedNuGet)) {\n        Warning (\"SkiaSharp nugets were installed at '{0}', removing...\", installedNuGet);\n        CleanDirectory (installedNuGet);\n    }\n});\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"3a05e25833fbf103e427ecee26dd175859e4a3bd","subject":"Updates the legacy program to add the opponent win percentage to the output, like what was done for the non-legacy program.","message":"Updates the legacy program to add the opponent win percentage to the output, like what was done for the non-legacy program.\n","repos":"mikee385\/CollegeFbsRankings","old_file":"Legacy\/Program.cs","new_file":"Legacy\/Program.cs","new_contents":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nnamespace CollegeFbsRankings_Legacy\n{\n    public class Program\n    {\n        private const string Year = \"2015\";\n\n        #region Input Directories and Files\n\n        private const string DataFolder = @\"..\\..\\..\\Data\";\n\n        private static readonly string FbsTeamFileName = Path.Combine(DataFolder, Year, \"FBS Teams.txt\");\n        private static readonly string FcsTeamFileName = Path.Combine(DataFolder, Year, \"FCS Teams.txt\");\n        private static readonly string GameFileName = Path.Combine(DataFolder, Year, \"FBS Scores.txt\");\n\n        #endregion\n\n        private const string RankedTeamPattern = @\"^\\(([0-9+]+)\\) (.*)$\";\n\n        public static void Main(string[] args)\n        {\n            var fbsTeamFile = new StreamReader(FbsTeamFileName);\n            var fbsTeamData = new List<TeamData>();\n            var skippedTeamLines = new List<String>();\n\n            String line;\n            while ((line = fbsTeamFile.ReadLine()) != null)\n            {\n                if (Char.IsDigit(line[0]))\n                {\n                    var lineSplit = line.Split(',');\n\n                    var key = Convert.ToInt32(lineSplit[0]);\n                    var name = lineSplit[1];\n                    var conference = lineSplit[2];\n\n                    fbsTeamData.Add(new TeamData(key, name, conference));\n                }\n                else\n                {\n                    skippedTeamLines.Add(line);\n                }\n            }\n\n            \/\/foreach (var team in fbsTeamData)\n            \/\/{\n            \/\/    Console.WriteLine(String.Join(\",\",\n            \/\/        team.Key.ToString(),\n            \/\/        team.Name,\n            \/\/        team.Conference));\n            \/\/}\n            \/\/Console.WriteLine();\n\n            \/\/foreach (var skippedLine in skippedTeamLines)\n            \/\/{\n            \/\/    Console.WriteLine(skippedLine);\n            \/\/}\n            \/\/Console.WriteLine();\n\n            var fcsTeamFile = new StreamReader(FcsTeamFileName);\n            var fcsTeamData = new List<String>();\n            while ((line = fcsTeamFile.ReadLine()) != null)\n            {\n                fcsTeamData.Add(line);\n            }\n\n            Console.WriteLine(\"Number of FBS Teams = {0}\", fbsTeamData.Count);\n            Console.WriteLine(\"Number of FCS Teams = {0}\", fcsTeamData.Count);\n            Console.WriteLine();\n\n            var gameFile = new StreamReader(GameFileName);\n            \n            var rankedTeamRegex = new Regex(RankedTeamPattern);\n\n            var gameData = new List<GameData>();\n            var skippedGameLines = new List<String>();\n            var futureGames = new List<String>();\n            while ((line = gameFile.ReadLine()) != null)\n            {\n                if (Char.IsDigit(line[0]))\n                {\n                    var lineSplit = line.Split(',');\n                    \n                    int winningTeamScore, losingTeamScore;\n                    if (Int32.TryParse(lineSplit[6], out winningTeamScore) &&\n                        Int32.TryParse(lineSplit[9], out losingTeamScore))\n                    {\n                        var key = Convert.ToInt32(lineSplit[0]);\n                        var week = Convert.ToInt32(lineSplit[1]);\n                        var date = DateTime.Parse(lineSplit[2] + \" \" + lineSplit[3]);\n\n                        String winningTeamName;\n                        var winningTeamMatch = rankedTeamRegex.Match(lineSplit[5]);\n                        if (winningTeamMatch.Success)\n                        {\n                            var rank = winningTeamMatch.Groups[1].Captures[0].Value;\n                            winningTeamName = winningTeamMatch.Groups[2].Captures[0].Value;\n                        }\n                        else\n                            winningTeamName = lineSplit[5];\n\n                        String losingTeamName;\n                        var losingTeamMatch = rankedTeamRegex.Match(lineSplit[8]);\n                        if (losingTeamMatch.Success)\n                        {\n                            var rank = losingTeamMatch.Groups[1].Captures[0].Value;\n                            losingTeamName = losingTeamMatch.Groups[2].Captures[0].Value;\n                        }\n                        else\n                            losingTeamName = lineSplit[8];\n\n                        var tv = lineSplit[10];\n                        var notes = lineSplit[11];\n\n                        gameData.Add(new GameData(key, week, date,\n                            winningTeamName, winningTeamScore, \n                            losingTeamName, losingTeamScore,\n                            tv, notes));\n                    }\n                    else\n                    {\n                        futureGames.Add(line);\n                    }\n                }\n                else\n                {\n                    skippedGameLines.Add(line);\n                }\n            }\n\n            \/\/foreach (var game in gameData)\n            \/\/{\n            \/\/    Console.WriteLine(String.Join(\",\", \n            \/\/        game.Key.ToString(),\n            \/\/        game.Week.ToString(),\n            \/\/        game.Date.ToString(),\n            \/\/        game.WinningTeamName,\n            \/\/        game.WinningTeamScore.ToString(),\n            \/\/        game.LosingTeamName,\n            \/\/        game.LosingTeamScore.ToString(),\n            \/\/        game.TV,\n            \/\/        game.Notes));\n            \/\/}\n            \/\/Console.WriteLine();\n\n            \/\/foreach (var skippedLine in skippedGameLines)\n            \/\/{\n            \/\/    Console.WriteLine(skippedLine);\n            \/\/}\n            \/\/Console.WriteLine();\n\n            \/\/foreach (var futureGame in futureGames)\n            \/\/{\n            \/\/    Console.WriteLine(futureGame);\n            \/\/}\n            \/\/Console.WriteLine();\n\n            var fbsTeams = new Dictionary<string, List<GameData>>();\n            var fcsGames = new List<GameData>();\n            var nonFbsTeams = new List<String>();\n            foreach (var game in gameData)\n            {\n                var winningTeamData = fbsTeamData.SingleOrDefault(team => team.Name == game.WinningTeamName);\n                var losingTeamData = fbsTeamData.SingleOrDefault(team => team.Name == game.LosingTeamName);\n\n                if (winningTeamData != null && losingTeamData != null)\n                {\n                    List<GameData> winningTeamGames;\n                    if (fbsTeams.TryGetValue(winningTeamData.Name, out winningTeamGames))\n                        winningTeamGames.Add(game);\n                    else\n                        fbsTeams.Add(winningTeamData.Name, new List<GameData> { game });\n\n                    List<GameData> losingTeamGames;\n                    if (fbsTeams.TryGetValue(losingTeamData.Name, out losingTeamGames))\n                        losingTeamGames.Add(game);\n                    else\n                        fbsTeams.Add(losingTeamData.Name, new List<GameData> { game });\n                }\n                else\n                {\n                    fcsGames.Add(game);\n\n                    if (winningTeamData == null)\n                        nonFbsTeams.Add(game.WinningTeamName);\n                    if (losingTeamData == null)\n                        nonFbsTeams.Add(game.LosingTeamName);\n                }\n            }\n\n            Console.WriteLine(\"Number of Completed Games = {0}\", gameData.Count);\n            Console.WriteLine(\"Number of Future Games = {0}\", futureGames.Count);\n            Console.WriteLine();\n\n            Console.WriteLine(\"Number of FBS Games = {0}\", gameData.Count - fcsGames.Count);\n            Console.WriteLine(\"Number of FCS Games = {0}\", fcsGames.Count);\n            Console.WriteLine();\n\n            \/\/foreach (var game in fcsGames)\n            \/\/{\n            \/\/    Console.WriteLine(String.Join(\",\",\n            \/\/        game.Key.ToString(),\n            \/\/        game.Week.ToString(),\n            \/\/        game.Date.ToString(),\n            \/\/        game.WinningTeamName,\n            \/\/        game.WinningTeamScore.ToString(),\n            \/\/        game.LosingTeamName,\n            \/\/        game.LosingTeamScore.ToString(),\n            \/\/        game.TV,\n            \/\/        game.Notes));\n            \/\/}\n            \/\/Console.WriteLine();\n\n            \/\/nonFbsTeams.Sort();\n            \/\/foreach (var team in nonFbsTeams)\n            \/\/{\n            \/\/    var fcsTeam = fcsTeamData.SingleOrDefault(fcsData => fcsData == team);\n            \/\/    if (fcsTeam == null)\n            \/\/        Console.WriteLine(team);\n            \/\/}\n\n            \/\/Console.WriteLine(\"Number of FBS Teams = {0}\", fbsTeams.Count);\n            \/\/Console.WriteLine(\"Number of FCS Games = {0}\", fcsGames.Count);\n            \/\/Console.WriteLine();\n\n            var fbsData = new Dictionary<String, FBSData>();\n            foreach (var team in fbsTeams)\n            {\n                var fbsWins = team.Value.Count(game => game.WinningTeamName == team.Key);\n                var fbsGames = team.Value.Count();\n\n                fbsData.Add(team.Key, new FBSData(team.Value, fbsWins, fbsGames));\n            }\n\n            \/\/var sortedTeams = fbsData.OrderByDescending(team => team.Value.WinPercentage).ToList();\n            \/\/for (int i = 0; i < sortedTeams.Count; ++i)\n            \/\/{\n            \/\/    var team = sortedTeams[i];\n            \/\/    Console.WriteLine(\"{0}. {1} = {2}\",\n            \/\/        i + 1,\n            \/\/        team.Key,\n            \/\/        team.Value.WinPercentage);\n            \/\/}\n            \/\/Console.WriteLine();\n\n            var opponentData = new Dictionary<String, OpponentData>();\n            foreach (var team in fbsData)\n            {\n                var opponentFbsWins = 0;\n                var opponentFbsGames = 0;\n\n                foreach(var game in team.Value.Games)\n                {\n                    string opponentTeamName;\n                    bool isWin;\n                    if (game.WinningTeamName == team.Key)\n                    {\n                        opponentTeamName = game.LosingTeamName;\n                        isWin = true;\n                    }\n                    else\n                    {\n                        opponentTeamName = game.WinningTeamName;\n                        isWin = false;\n                    }\n\n                    FBSData opponentFbsData;\n                    if (fbsData.TryGetValue(opponentTeamName, out opponentFbsData))\n                    {\n                        opponentFbsGames += opponentFbsData.FbsGames;\n                        if (isWin)\n                            opponentFbsWins += opponentFbsData.FbsWins;\n                    }\n                }\n\n                opponentData.Add(team.Key, new OpponentData(team.Value.Games,\n                    team.Value.FbsWins, team.Value.FbsGames,\n                    opponentFbsWins, opponentFbsGames));\n            }\n\n            var rankedTeams = opponentData\n                .OrderByDescending(team => team.Value.RankingValue)\n                .ThenByDescending(team => team.Value.WinPercentage)\n                .ThenBy(team => team.Key)\n                .ToList();\n            PrintRanking(\"Performance Rankings (FBS)\", rankedTeams);\n\n            foreach (var team in rankedTeams.Take(5))\n            {\n                PrintTeamData(team.Key, opponentData);\n            }\n        }\n\n        private static void PrintTeamData(string teamName, Dictionary<string, OpponentData> data)\n        {\n            var teamFbsData = data[teamName];\n\n            Console.WriteLine(teamName + \" Games:\");\n            foreach (var game in teamFbsData.Games)\n            {\n                var isWin = (game.WinningTeamName == teamName);\n                var opponentTeamName = isWin ? game.LosingTeamName : game.WinningTeamName;\n                var opponentFbsData = data[opponentTeamName];\n\n                Console.WriteLine(\"Week {0} {1} beat {3} = {2}-{4} ({5} \/ {6})\",\n                    game.Week,\n                    game.WinningTeamName,\n                    game.WinningTeamScore,\n                    game.LosingTeamName,\n                    game.LosingTeamScore,\n                    (isWin) ? opponentFbsData.FbsWins : 0,\n                    opponentFbsData.FbsGames);\n            }\n            Console.WriteLine();\n\n            Console.WriteLine(\"Team Wins    : {0} \/ {1} ({2})\", teamFbsData.FbsWins, teamFbsData.FbsGames, teamFbsData.WinPercentage);\n            Console.WriteLine(\"Opponent Wins: {0} \/ {1} ({2})\", teamFbsData.OpponentFbsWins, teamFbsData.OpponentFbsGames, teamFbsData.OpponentWinPercentage);\n            Console.WriteLine(\"Performance  : {0}\", teamFbsData.WinPercentage * teamFbsData.OpponentWinPercentage);\n            Console.WriteLine();\n        }\n\n        private static void PrintRanking(string title, IReadOnlyList<KeyValuePair<string, OpponentData>> ranking)\n        {\n            Console.WriteLine(title);\n            Console.WriteLine(\"--------------------\");\n\n            \/\/ Calculate the formatting information for the teams.\n            var maxTeamNameLength = ranking.Max(rank => rank.Key.Length);\n\n            \/\/ Output the team rankings.\n            int index = 1, outputIndex = 1;\n            double[] previousValues = null;\n\n            foreach (var rank in ranking)\n            {\n                var currentValues = new[] {rank.Value.RankingValue, rank.Value.WinPercentage, rank.Value.OpponentWinPercentage};\n                if (index != 1)\n                {\n                    if (!currentValues.SequenceEqual(previousValues))\n                        outputIndex = index;\n                }\n\n                Console.WriteLine(\"{0,-4} {1,-\" + (maxTeamNameLength + 3) + \"} {2:F8}   {3:F8}   {4:F8}\",\n                    outputIndex, rank.Key, currentValues[0], currentValues[1], currentValues[2]);\n\n                ++index;\n                previousValues = currentValues;\n            }\n            Console.WriteLine();\n        }\n\n        private class TeamData\n        {\n            public readonly int Key;\n            public readonly string Name;\n            public readonly string Conference;\n\n            public TeamData(int key, string name, string conference)\n            {\n                Key = key;\n                Name = name;\n                Conference = conference;\n            }\n        }\n\n        private class GameData\n        {\n            public readonly int Key;\n            public readonly int Week;\n            public readonly DateTime Date;\n            public readonly string WinningTeamName;\n            public readonly int WinningTeamScore;\n            public readonly string LosingTeamName;\n            public readonly int LosingTeamScore;\n            public readonly string Tv;\n            public readonly string Notes;\n\n            public GameData(int key, int week, DateTime date,\n                string winningTeamName, int winningTeamScore,\n                string losingTeamName, int losingTeamScore,\n                string tv, string notes)\n            {\n                Key = key;\n                Week = week;\n                Date = date;\n                WinningTeamName = winningTeamName;\n                WinningTeamScore = winningTeamScore;\n                LosingTeamName = losingTeamName;\n                LosingTeamScore = losingTeamScore;\n                Tv = tv;\n                Notes = notes;\n            }\n        }\n\n        private class FBSData\n        {\n            public readonly IReadOnlyList<GameData> Games;\n            public readonly int FbsWins;\n            public readonly int FbsGames;\n\n            public FBSData(IReadOnlyList<GameData> games, int fbsWins, int fbsGames)\n            {\n                Games = games;\n                FbsWins = fbsWins;\n                FbsGames = fbsGames;\n            }\n\n            public double WinPercentage\n            {\n                get { return ((double)FbsWins) \/ FbsGames; }\n            }\n        }\n\n        private class OpponentData\n        {\n            public readonly IReadOnlyList<GameData> Games;\n            public readonly int FbsWins;\n            public readonly int FbsGames;\n\n            public readonly int OpponentFbsWins;\n            public readonly int OpponentFbsGames;\n\n            public OpponentData(IReadOnlyList<GameData> games, \n                int fbsWins, int fbsGames, \n                int opponentFbsWins, int opponentFbsGames)\n            {\n                Games = games;\n                FbsWins = fbsWins;\n                FbsGames = fbsGames;\n                OpponentFbsWins = opponentFbsWins;\n                OpponentFbsGames = opponentFbsGames;\n            }\n\n            public double WinPercentage\n            {\n                get { return ((double)FbsWins) \/ FbsGames; }\n            }\n\n            public double OpponentWinPercentage\n            {\n                get { return ((double)OpponentFbsWins) \/ OpponentFbsGames; }\n            }\n\n            public double RankingValue\n            {\n                get { return WinPercentage * OpponentWinPercentage; }\n                \/\/get { return OpponentWinPercentage; }\n            }\n        }\n\n        private static void PrintRegexMatch(Match m)\n        {\n            var matchCount = 0;\n            while (m.Success)\n            {\n                Console.WriteLine(\"Match\" + (++matchCount));\n                for (int i = 1; i <= 2; i++)\n                {\n                    var g = m.Groups[i];\n                    Console.WriteLine(\"Group\" + i + \"='\" + g + \"'\");\n\n                    var cc = g.Captures;\n                    for (int j = 0; j < cc.Count; j++)\n                    {\n                        var c = cc[j];\n                        Console.WriteLine(\"Capture\" + j + \"='\" + c + \"', Position=\" + c.Index);\n                    }\n                }\n                m = m.NextMatch();\n            }\n        }\n    }\n}\n","old_contents":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nnamespace CollegeFbsRankings_Legacy\n{\n    public class Program\n    {\n        private const string Year = \"2015\";\n\n        #region Input Directories and Files\n\n        private const string DataFolder = @\"..\\..\\..\\Data\";\n\n        private static readonly string FbsTeamFileName = Path.Combine(DataFolder, Year, \"FBS Teams.txt\");\n        private static readonly string FcsTeamFileName = Path.Combine(DataFolder, Year, \"FCS Teams.txt\");\n        private static readonly string GameFileName = Path.Combine(DataFolder, Year, \"FBS Scores.txt\");\n\n        #endregion\n\n        private const string RankedTeamPattern = @\"^\\(([0-9+]+)\\) (.*)$\";\n\n        public static void Main(string[] args)\n        {\n            var fbsTeamFile = new StreamReader(FbsTeamFileName);\n            var fbsTeamData = new List<TeamData>();\n            var skippedTeamLines = new List<String>();\n\n            String line;\n            while ((line = fbsTeamFile.ReadLine()) != null)\n            {\n                if (Char.IsDigit(line[0]))\n                {\n                    var lineSplit = line.Split(',');\n\n                    var key = Convert.ToInt32(lineSplit[0]);\n                    var name = lineSplit[1];\n                    var conference = lineSplit[2];\n\n                    fbsTeamData.Add(new TeamData(key, name, conference));\n                }\n                else\n                {\n                    skippedTeamLines.Add(line);\n                }\n            }\n\n            \/\/foreach (var team in fbsTeamData)\n            \/\/{\n            \/\/    Console.WriteLine(String.Join(\",\",\n            \/\/        team.Key.ToString(),\n            \/\/        team.Name,\n            \/\/        team.Conference));\n            \/\/}\n            \/\/Console.WriteLine();\n\n            \/\/foreach (var skippedLine in skippedTeamLines)\n            \/\/{\n            \/\/    Console.WriteLine(skippedLine);\n            \/\/}\n            \/\/Console.WriteLine();\n\n            var fcsTeamFile = new StreamReader(FcsTeamFileName);\n            var fcsTeamData = new List<String>();\n            while ((line = fcsTeamFile.ReadLine()) != null)\n            {\n                fcsTeamData.Add(line);\n            }\n\n            Console.WriteLine(\"Number of FBS Teams = {0}\", fbsTeamData.Count);\n            Console.WriteLine(\"Number of FCS Teams = {0}\", fcsTeamData.Count);\n            Console.WriteLine();\n\n            var gameFile = new StreamReader(GameFileName);\n            \n            var rankedTeamRegex = new Regex(RankedTeamPattern);\n\n            var gameData = new List<GameData>();\n            var skippedGameLines = new List<String>();\n            var futureGames = new List<String>();\n            while ((line = gameFile.ReadLine()) != null)\n            {\n                if (Char.IsDigit(line[0]))\n                {\n                    var lineSplit = line.Split(',');\n                    \n                    int winningTeamScore, losingTeamScore;\n                    if (Int32.TryParse(lineSplit[6], out winningTeamScore) &&\n                        Int32.TryParse(lineSplit[9], out losingTeamScore))\n                    {\n                        var key = Convert.ToInt32(lineSplit[0]);\n                        var week = Convert.ToInt32(lineSplit[1]);\n                        var date = DateTime.Parse(lineSplit[2] + \" \" + lineSplit[3]);\n\n                        String winningTeamName;\n                        var winningTeamMatch = rankedTeamRegex.Match(lineSplit[5]);\n                        if (winningTeamMatch.Success)\n                        {\n                            var rank = winningTeamMatch.Groups[1].Captures[0].Value;\n                            winningTeamName = winningTeamMatch.Groups[2].Captures[0].Value;\n                        }\n                        else\n                            winningTeamName = lineSplit[5];\n\n                        String losingTeamName;\n                        var losingTeamMatch = rankedTeamRegex.Match(lineSplit[8]);\n                        if (losingTeamMatch.Success)\n                        {\n                            var rank = losingTeamMatch.Groups[1].Captures[0].Value;\n                            losingTeamName = losingTeamMatch.Groups[2].Captures[0].Value;\n                        }\n                        else\n                            losingTeamName = lineSplit[8];\n\n                        var tv = lineSplit[10];\n                        var notes = lineSplit[11];\n\n                        gameData.Add(new GameData(key, week, date,\n                            winningTeamName, winningTeamScore, \n                            losingTeamName, losingTeamScore,\n                            tv, notes));\n                    }\n                    else\n                    {\n                        futureGames.Add(line);\n                    }\n                }\n                else\n                {\n                    skippedGameLines.Add(line);\n                }\n            }\n\n            \/\/foreach (var game in gameData)\n            \/\/{\n            \/\/    Console.WriteLine(String.Join(\",\", \n            \/\/        game.Key.ToString(),\n            \/\/        game.Week.ToString(),\n            \/\/        game.Date.ToString(),\n            \/\/        game.WinningTeamName,\n            \/\/        game.WinningTeamScore.ToString(),\n            \/\/        game.LosingTeamName,\n            \/\/        game.LosingTeamScore.ToString(),\n            \/\/        game.TV,\n            \/\/        game.Notes));\n            \/\/}\n            \/\/Console.WriteLine();\n\n            \/\/foreach (var skippedLine in skippedGameLines)\n            \/\/{\n            \/\/    Console.WriteLine(skippedLine);\n            \/\/}\n            \/\/Console.WriteLine();\n\n            \/\/foreach (var futureGame in futureGames)\n            \/\/{\n            \/\/    Console.WriteLine(futureGame);\n            \/\/}\n            \/\/Console.WriteLine();\n\n            var fbsTeams = new Dictionary<string, List<GameData>>();\n            var fcsGames = new List<GameData>();\n            var nonFbsTeams = new List<String>();\n            foreach (var game in gameData)\n            {\n                var winningTeamData = fbsTeamData.SingleOrDefault(team => team.Name == game.WinningTeamName);\n                var losingTeamData = fbsTeamData.SingleOrDefault(team => team.Name == game.LosingTeamName);\n\n                if (winningTeamData != null && losingTeamData != null)\n                {\n                    List<GameData> winningTeamGames;\n                    if (fbsTeams.TryGetValue(winningTeamData.Name, out winningTeamGames))\n                        winningTeamGames.Add(game);\n                    else\n                        fbsTeams.Add(winningTeamData.Name, new List<GameData> { game });\n\n                    List<GameData> losingTeamGames;\n                    if (fbsTeams.TryGetValue(losingTeamData.Name, out losingTeamGames))\n                        losingTeamGames.Add(game);\n                    else\n                        fbsTeams.Add(losingTeamData.Name, new List<GameData> { game });\n                }\n                else\n                {\n                    fcsGames.Add(game);\n\n                    if (winningTeamData == null)\n                        nonFbsTeams.Add(game.WinningTeamName);\n                    if (losingTeamData == null)\n                        nonFbsTeams.Add(game.LosingTeamName);\n                }\n            }\n\n            Console.WriteLine(\"Number of Completed Games = {0}\", gameData.Count);\n            Console.WriteLine(\"Number of Future Games = {0}\", futureGames.Count);\n            Console.WriteLine();\n\n            Console.WriteLine(\"Number of FBS Games = {0}\", gameData.Count - fcsGames.Count);\n            Console.WriteLine(\"Number of FCS Games = {0}\", fcsGames.Count);\n            Console.WriteLine();\n\n            \/\/foreach (var game in fcsGames)\n            \/\/{\n            \/\/    Console.WriteLine(String.Join(\",\",\n            \/\/        game.Key.ToString(),\n            \/\/        game.Week.ToString(),\n            \/\/        game.Date.ToString(),\n            \/\/        game.WinningTeamName,\n            \/\/        game.WinningTeamScore.ToString(),\n            \/\/        game.LosingTeamName,\n            \/\/        game.LosingTeamScore.ToString(),\n            \/\/        game.TV,\n            \/\/        game.Notes));\n            \/\/}\n            \/\/Console.WriteLine();\n\n            \/\/nonFbsTeams.Sort();\n            \/\/foreach (var team in nonFbsTeams)\n            \/\/{\n            \/\/    var fcsTeam = fcsTeamData.SingleOrDefault(fcsData => fcsData == team);\n            \/\/    if (fcsTeam == null)\n            \/\/        Console.WriteLine(team);\n            \/\/}\n\n            \/\/Console.WriteLine(\"Number of FBS Teams = {0}\", fbsTeams.Count);\n            \/\/Console.WriteLine(\"Number of FCS Games = {0}\", fcsGames.Count);\n            \/\/Console.WriteLine();\n\n            var fbsData = new Dictionary<String, FBSData>();\n            foreach (var team in fbsTeams)\n            {\n                var fbsWins = team.Value.Count(game => game.WinningTeamName == team.Key);\n                var fbsGames = team.Value.Count();\n\n                fbsData.Add(team.Key, new FBSData(team.Value, fbsWins, fbsGames));\n            }\n\n            \/\/var sortedTeams = fbsData.OrderByDescending(team => team.Value.WinPercentage).ToList();\n            \/\/for (int i = 0; i < sortedTeams.Count; ++i)\n            \/\/{\n            \/\/    var team = sortedTeams[i];\n            \/\/    Console.WriteLine(\"{0}. {1} = {2}\",\n            \/\/        i + 1,\n            \/\/        team.Key,\n            \/\/        team.Value.WinPercentage);\n            \/\/}\n            \/\/Console.WriteLine();\n\n            var opponentData = new Dictionary<String, OpponentData>();\n            foreach (var team in fbsData)\n            {\n                var opponentFbsWins = 0;\n                var opponentFbsGames = 0;\n\n                foreach(var game in team.Value.Games)\n                {\n                    string opponentTeamName;\n                    bool isWin;\n                    if (game.WinningTeamName == team.Key)\n                    {\n                        opponentTeamName = game.LosingTeamName;\n                        isWin = true;\n                    }\n                    else\n                    {\n                        opponentTeamName = game.WinningTeamName;\n                        isWin = false;\n                    }\n\n                    FBSData opponentFbsData;\n                    if (fbsData.TryGetValue(opponentTeamName, out opponentFbsData))\n                    {\n                        opponentFbsGames += opponentFbsData.FbsGames;\n                        if (isWin)\n                            opponentFbsWins += opponentFbsData.FbsWins;\n                    }\n                }\n\n                opponentData.Add(team.Key, new OpponentData(team.Value.Games,\n                    team.Value.FbsWins, team.Value.FbsGames,\n                    opponentFbsWins, opponentFbsGames));\n            }\n\n            var rankedTeams = opponentData\n                .OrderByDescending(team => team.Value.RankingValue)\n                .ThenByDescending(team => team.Value.WinPercentage)\n                .ThenBy(team => team.Key)\n                .ToList();\n            PrintRanking(\"Performance Rankings (FBS)\", rankedTeams);\n\n            foreach (var team in rankedTeams.Take(5))\n            {\n                PrintTeamData(team.Key, opponentData);\n            }\n        }\n\n        private static void PrintTeamData(string teamName, Dictionary<string, OpponentData> data)\n        {\n            var teamFbsData = data[teamName];\n\n            Console.WriteLine(teamName + \" Games:\");\n            foreach (var game in teamFbsData.Games)\n            {\n                var isWin = (game.WinningTeamName == teamName);\n                var opponentTeamName = isWin ? game.LosingTeamName : game.WinningTeamName;\n                var opponentFbsData = data[opponentTeamName];\n\n                Console.WriteLine(\"Week {0} {1} beat {3} = {2}-{4} ({5} \/ {6})\",\n                    game.Week,\n                    game.WinningTeamName,\n                    game.WinningTeamScore,\n                    game.LosingTeamName,\n                    game.LosingTeamScore,\n                    (isWin) ? opponentFbsData.FbsWins : 0,\n                    opponentFbsData.FbsGames);\n            }\n            Console.WriteLine();\n\n            Console.WriteLine(\"Team Wins    : {0} \/ {1} ({2})\", teamFbsData.FbsWins, teamFbsData.FbsGames, teamFbsData.WinPercentage);\n            Console.WriteLine(\"Opponent Wins: {0} \/ {1} ({2})\", teamFbsData.OpponentFbsWins, teamFbsData.OpponentFbsGames, teamFbsData.OpponentWinPercentage);\n            Console.WriteLine(\"Performance  : {0}\", teamFbsData.WinPercentage * teamFbsData.OpponentWinPercentage);\n            Console.WriteLine();\n        }\n\n        private static void PrintRanking(string title, IReadOnlyList<KeyValuePair<string, OpponentData>> ranking)\n        {\n            Console.WriteLine(title);\n            Console.WriteLine(\"--------------------\");\n\n            \/\/ Calculate the formatting information for the teams.\n            var maxTeamNameLength = ranking.Max(rank => rank.Key.Length);\n\n            \/\/ Output the team rankings.\n            int index = 1, outputIndex = 1;\n            double[] previousValues = null;\n\n            foreach (var rank in ranking)\n            {\n                var currentValues = new[] {rank.Value.RankingValue, rank.Value.WinPercentage};\n                if (index != 1)\n                {\n                    if (!currentValues.SequenceEqual(previousValues))\n                        outputIndex = index;\n                }\n\n                Console.WriteLine(\"{0,-4} {1,-\" + (maxTeamNameLength + 3) + \"} {2:F8}   {3:F8}\",\n                    outputIndex, rank.Key, currentValues[0], currentValues[1]);\n\n                ++index;\n                previousValues = currentValues;\n            }\n            Console.WriteLine();\n        }\n\n        private class TeamData\n        {\n            public readonly int Key;\n            public readonly string Name;\n            public readonly string Conference;\n\n            public TeamData(int key, string name, string conference)\n            {\n                Key = key;\n                Name = name;\n                Conference = conference;\n            }\n        }\n\n        private class GameData\n        {\n            public readonly int Key;\n            public readonly int Week;\n            public readonly DateTime Date;\n            public readonly string WinningTeamName;\n            public readonly int WinningTeamScore;\n            public readonly string LosingTeamName;\n            public readonly int LosingTeamScore;\n            public readonly string Tv;\n            public readonly string Notes;\n\n            public GameData(int key, int week, DateTime date,\n                string winningTeamName, int winningTeamScore,\n                string losingTeamName, int losingTeamScore,\n                string tv, string notes)\n            {\n                Key = key;\n                Week = week;\n                Date = date;\n                WinningTeamName = winningTeamName;\n                WinningTeamScore = winningTeamScore;\n                LosingTeamName = losingTeamName;\n                LosingTeamScore = losingTeamScore;\n                Tv = tv;\n                Notes = notes;\n            }\n        }\n\n        private class FBSData\n        {\n            public readonly IReadOnlyList<GameData> Games;\n            public readonly int FbsWins;\n            public readonly int FbsGames;\n\n            public FBSData(IReadOnlyList<GameData> games, int fbsWins, int fbsGames)\n            {\n                Games = games;\n                FbsWins = fbsWins;\n                FbsGames = fbsGames;\n            }\n\n            public double WinPercentage\n            {\n                get { return ((double)FbsWins) \/ FbsGames; }\n            }\n        }\n\n        private class OpponentData\n        {\n            public readonly IReadOnlyList<GameData> Games;\n            public readonly int FbsWins;\n            public readonly int FbsGames;\n\n            public readonly int OpponentFbsWins;\n            public readonly int OpponentFbsGames;\n\n            public OpponentData(IReadOnlyList<GameData> games, \n                int fbsWins, int fbsGames, \n                int opponentFbsWins, int opponentFbsGames)\n            {\n                Games = games;\n                FbsWins = fbsWins;\n                FbsGames = fbsGames;\n                OpponentFbsWins = opponentFbsWins;\n                OpponentFbsGames = opponentFbsGames;\n            }\n\n            public double WinPercentage\n            {\n                get { return ((double)FbsWins) \/ FbsGames; }\n            }\n\n            public double OpponentWinPercentage\n            {\n                get { return ((double)OpponentFbsWins) \/ OpponentFbsGames; }\n            }\n\n            public double RankingValue\n            {\n                get { return WinPercentage * OpponentWinPercentage; }\n                \/\/get { return OpponentWinPercentage; }\n            }\n        }\n\n        private static void PrintRegexMatch(Match m)\n        {\n            var matchCount = 0;\n            while (m.Success)\n            {\n                Console.WriteLine(\"Match\" + (++matchCount));\n                for (int i = 1; i <= 2; i++)\n                {\n                    var g = m.Groups[i];\n                    Console.WriteLine(\"Group\" + i + \"='\" + g + \"'\");\n\n                    var cc = g.Captures;\n                    for (int j = 0; j < cc.Count; j++)\n                    {\n                        var c = cc[j];\n                        Console.WriteLine(\"Capture\" + j + \"='\" + c + \"', Position=\" + c.Index);\n                    }\n                }\n                m = m.NextMatch();\n            }\n        }\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"061a26315c3dfdcb6fa6b94cfaf8f8856f2407fe","subject":"Add (No Edits) to the disabled version combo to not confuse the user","message":"Add (No Edits) to the disabled version combo to not confuse the user\n","repos":"NguyenMatthieu\/f-spot,Yetangitu\/f-spot,Yetangitu\/f-spot,dkoeb\/f-spot,mono\/f-spot,GNOME\/f-spot,NguyenMatthieu\/f-spot,Sanva\/f-spot,Sanva\/f-spot,GNOME\/f-spot,dkoeb\/f-spot,mono\/f-spot,nathansamson\/F-Spot-Album-Exporter,NguyenMatthieu\/f-spot,Yetangitu\/f-spot,mans0954\/f-spot,GNOME\/f-spot,mans0954\/f-spot,Yetangitu\/f-spot,GNOME\/f-spot,GNOME\/f-spot,mans0954\/f-spot,NguyenMatthieu\/f-spot,Sanva\/f-spot,mono\/f-spot,Sanva\/f-spot,mans0954\/f-spot,dkoeb\/f-spot,nathansamson\/F-Spot-Album-Exporter,mono\/f-spot,mans0954\/f-spot,dkoeb\/f-spot,dkoeb\/f-spot,nathansamson\/F-Spot-Album-Exporter,Yetangitu\/f-spot,dkoeb\/f-spot,mono\/f-spot,NguyenMatthieu\/f-spot,nathansamson\/F-Spot-Album-Exporter,Sanva\/f-spot,mono\/f-spot,mans0954\/f-spot","old_file":"src\/Widgets\/InfoBox.cs","new_file":"src\/Widgets\/InfoBox.cs","new_contents":"\/*\n * FSpot.Widgets.InfoBox\n *\n * Author(s)\n * \tEttore Perazzoli\n * \tLarry Ewing  <lewing@novell.com>\n * \tGabriel Burt\n *\tStephane Delcroix  <stephane@delcroix.org>\n *\tRuben Vermeersch <ruben@savanne.be>\n *  Mike Gemuende <mike@gemuende.de>\n *\n * This is free software. See COPYING for details.\n *\/\n\n\nusing Gtk;\nusing System;\nusing System.IO;\nusing FSpot;\nusing SemWeb;\nusing Mono.Unix;\nusing FSpot.Utils;\nusing GLib;\nusing GFile = GLib.File;\nusing GFileInfo = GLib.FileInfo;\n\n\/\/ FIXME TODO: We want to use something like EClippedLabel here throughout so it handles small sizes\n\/\/ gracefully using ellipsis.\n\nnamespace FSpot.Widgets\n{\n\tpublic class InfoBox : VBox {\n\t\tDelay update_delay;\n\t\n\t\tprivate Photo [] photos = new Photo[0];\n\t\tpublic Photo [] Photos {\n\t\t\tset {\n\t\t\t\tphotos = value;\n\t\t\t\tupdate_delay.Start ();\n\t\t\t}\n\t\t\tprivate get {\n\t\t\t\treturn photos;\n\t\t\t}\n\t\t}\n\n\t\tpublic Photo Photo {\n\t\t\tset {\n\t\t\t\tif (value != null) {\n\t\t\t\t\tPhotos = new Photo[] { value };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tprivate bool show_tags = false;\n\t\tpublic bool ShowTags {\n\t\t\tget { return show_tags; }\n\t\t\tset {\n\t\t\t\tif (show_tags == value)\n\t\t\t\t\treturn;\n\n\t\t\t\tshow_tags = value;\n\t\t\t\ttag_view.Visible = show_tags;\n\t\t\t}\n\t\t}\n\t\n\t\tprivate bool show_rating = false;\n\t\tpublic bool ShowRating {\n\t\t\tget { return show_rating; }\n\t\t\tset {\n\t\t\t\tif (show_rating == value)\n\t\t\t\t\treturn;\n\n\t\t\t\tshow_rating = value;\n\t\t\t\trating_label.Visible = show_rating;\n\t\t\t\trating_view.Visible = show_rating;\n\t\t\t}\n\t\t}\n\n\t\tpublic delegate void VersionIdChangedHandler (InfoBox info_box, uint version_id);\n\t\tpublic event VersionIdChangedHandler VersionIdChanged;\n\t\n\t\tprivate Expander info_expander;\n\t\tprivate Expander histogram_expander;\n\n\t\tprivate Gtk.Image histogram_image;\n\t\tprivate Histogram histogram;\n\n\t\tprivate Delay histogram_delay;\n\n\t\t\/\/ Context switching (toggles visibility).\n\t\tpublic event EventHandler ContextChanged;\n\n\t\tprivate ViewContext view_context = ViewContext.Unknown;\n\t\tpublic ViewContext Context {\n\t\t\tget { return view_context; }\n\t\t\tset {\n\t\t\t\tview_context = value;\n\t\t\t\tif (ContextChanged != null)\n\t\t\t\t\tContextChanged (this, null);\n\t\t\t}\n\t\t}\n\n\t\tprivate readonly InfoBoxContextSwitchStrategy ContextSwitchStrategy;\n\t\n\t\t\/\/ Widgetry.\t\n\t\tprivate Label name_label;\n\t\tprivate Label name_value_label;\n\n\t\tprivate Label version_label;\n\t\tprivate ListStore version_list;\n\t\tprivate ComboBox version_combo;\n\n\t\tprivate Label date_label;\n\t\tprivate Label date_value_label;\n\n\t\tprivate Label size_label;\n\t\tprivate Label size_value_label;\n\n\t\tprivate Label exposure_label;\n\t\tprivate Label exposure_value_label;\n\t\t\n\t\tprivate Label focal_length_label;\n\t\tprivate Label focal_length_value_label;\n\t\t\n\t\tprivate Label camera_label;\n\t\tprivate Label camera_value_label;\n\t\t\n\t\tprivate Label file_size_label;\n\t\tprivate Label file_size_value_label;\n\n\t\tprivate Label rating_label;\n\t\tprivate RatingSmall rating_view;\n\n\t\tprivate TagView tag_view;\n\t\tprivate string default_exposure_string;\n\t\t\n\t\tprivate bool show_name;\n\t\tprivate bool show_date;\n\t\tprivate bool show_size;\n\t\tprivate bool show_exposure;\n\t\tprivate bool show_focal_length;\n\t\tprivate bool show_camera;\n\t\tprivate bool show_file_size;\n\n\t\tprivate void HandleRatingChanged (object o, EventArgs e)\n\t\t{\n\t\t\tMainWindow.Toplevel.HandleRatingMenuSelected ((o as Widgets.Rating).Value);\n\t \t}\n\t\n\t\tprivate Label CreateRightAlignedLabel (string text)\n\t\t{\n\t\t\tLabel label = new Label ();\n\t\t\tlabel.UseMarkup = true;\n\t\t\tlabel.Markup = text;\n\t\t\tlabel.Xalign = 1;\n\n\t\t\treturn label;\n\t\t}\n\t\n\t\tconst int TABLE_XPADDING = 3;\n\t\tconst int TABLE_YPADDING = 3;\n\t\tprivate Label AttachLabel (Table table, int row_num, Widget entry)\n\t\t{\n\t\t\tLabel label = new Label (String.Empty);\n\t\t\tlabel.Xalign = 0;\n\t\t\tlabel.Selectable = true;\n\t\t\tlabel.Ellipsize = Pango.EllipsizeMode.End;\n\t\t\tlabel.Show ();\n\n\t\t\tlabel.PopulatePopup += HandlePopulatePopup;\n\t\t\t\n\t\t\ttable.Attach (label, 1, 2, (uint) row_num, (uint) row_num + 1,\n\t\t\t\t      AttachOptions.Expand | AttachOptions.Fill, AttachOptions.Expand | AttachOptions.Fill,\n\t\t\t\t      (uint) entry.Style.XThickness + TABLE_XPADDING, (uint) entry.Style.YThickness);\n\t\n\t\t\treturn label;\n\t\t}\n\t\n\t\tprivate void SetupWidgets ()\n\t\t{\n\n\t\t\thistogram_expander = new Expander (Catalog.GetString (\"Histogram\"));\n\t\t\thistogram_expander.Activated += delegate (object sender, EventArgs e) { \n\t\t\t\tContextSwitchStrategy.SetHistogramVisible (Context, histogram_expander.Expanded);\n\t\t\t\tUpdateHistogram ();\n\t\t\t};\n\t\t\thistogram_image = new Gtk.Image ();\n\t\t\thistogram = new Histogram ();\n\t\t\thistogram_expander.Add (histogram_image);\n\n\t\t\tWindow window = MainWindow.Toplevel.Window;\n\t\t\tGdk.Color c = window.Style.Backgrounds [(int)Gtk.StateType.Active];\n\t\t\thistogram.RedColorHint = (byte) (c.Red \/ 0xff);\n\t\t\thistogram.GreenColorHint = (byte) (c.Green \/ 0xff);\n\t\t\thistogram.BlueColorHint = (byte) (c.Blue \/ 0xff);\n\t\t\thistogram.BackgroundColorHint = 0xff;\n\n\t\t\tAdd (histogram_expander);\n\n\t\t\tinfo_expander = new Expander (Catalog.GetString (\"Image Information\"));\n\t\t\tinfo_expander.Activated += delegate (object sender, EventArgs e) {\n\t\t\t\tContextSwitchStrategy.SetInfoBoxVisible (Context, info_expander.Expanded);\n\t\t\t};\n\t\t\t\n\t\t\tTable info_table = new Table (10, 2, false);\n\t\t\tinfo_table.BorderWidth = 0;\n\t\n\t\t\tstring name_pre = \"<b>\";\n\t\t\tstring name_post = \"<\/b>\";\n\n\t\t\tname_label = CreateRightAlignedLabel (name_pre + Catalog.GetString (\"Name\") + name_post);\n\t\t\tinfo_table.Attach (name_label, 0, 1, 0, 1, AttachOptions.Fill, AttachOptions.Fill, TABLE_XPADDING, TABLE_YPADDING);\n\n\t\t\tversion_label = CreateRightAlignedLabel (name_pre + Catalog.GetString (\"Version\") + name_post); \n\t\t\tinfo_table.Attach (version_label, 0, 1, 1, 2, AttachOptions.Fill, AttachOptions.Fill, TABLE_XPADDING, TABLE_YPADDING);\n\n\t\t\tdate_label = CreateRightAlignedLabel (name_pre + Catalog.GetString (\"Date\") + name_post + Environment.NewLine);\n\t\t\tinfo_table.Attach (date_label, 0, 1, 2, 3, AttachOptions.Fill, AttachOptions.Fill, TABLE_XPADDING, TABLE_YPADDING);\n\n\t\t\tsize_label = CreateRightAlignedLabel (name_pre + Catalog.GetString (\"Size\") + name_post);\n\t\t\tinfo_table.Attach (size_label, 0, 1, 3, 4, AttachOptions.Fill, AttachOptions.Fill, TABLE_XPADDING, TABLE_YPADDING);\n\n\t\t\tdefault_exposure_string = name_pre + Catalog.GetString (\"Exposure\") + name_post;\n\t\t\texposure_label = CreateRightAlignedLabel (default_exposure_string);\n\t\t\tinfo_table.Attach (exposure_label, 0, 1, 4, 5, AttachOptions.Fill, AttachOptions.Fill, TABLE_XPADDING, TABLE_YPADDING);\n\t\t\t\n\t\t\tfocal_length_label = CreateRightAlignedLabel (name_pre + Catalog.GetString (\"Focal Length\") + name_post);\n\t\t\tinfo_table.Attach (focal_length_label, 0, 1, 5, 6, AttachOptions.Fill, AttachOptions.Fill, TABLE_XPADDING, TABLE_YPADDING);\n\t\t\t\n\t\t\tcamera_label = CreateRightAlignedLabel (name_pre + Catalog.GetString (\"Camera\") + name_post);\n\t\t\tinfo_table.Attach (camera_label, 0, 1, 6, 7, AttachOptions.Fill, AttachOptions.Fill, TABLE_XPADDING, TABLE_YPADDING);\n\t\t\t\n\t\t\tfile_size_label = CreateRightAlignedLabel (name_pre + Catalog.GetString (\"File Size\") + name_post);\n\t\t\tinfo_table.Attach (file_size_label, 0, 1, 7, 8, AttachOptions.Fill, AttachOptions.Fill, TABLE_XPADDING, TABLE_YPADDING);\n\t\t\t\n\t\t\trating_label = CreateRightAlignedLabel (name_pre + Catalog.GetString (\"Rating\") + name_post);\n\t\t\tinfo_table.Attach (rating_label, 0, 1, 8, 9, AttachOptions.Fill, AttachOptions.Fill, TABLE_XPADDING, TABLE_YPADDING);\n\t\t\trating_label.Visible = false;\n\n\t\t\tname_value_label = new Label ();\n\t\t\tname_value_label.Ellipsize = Pango.EllipsizeMode.Middle;\n\t\t\tname_value_label.Justify = Gtk.Justification.Left;\n\t\t\tname_value_label.Selectable = true;\n\t\t\tname_value_label.Xalign = 0;\n\t\t\tname_value_label.PopulatePopup += HandlePopulatePopup;\n\t\t\t\n\t\t\tinfo_table.Attach (name_value_label, 1, 2, 0, 1, AttachOptions.Fill | AttachOptions.Expand, AttachOptions.Fill, 3, 0);\n\t\t\t\n\t\t\tdate_value_label = AttachLabel (info_table, 2, name_value_label);\n\t\t\tsize_value_label = AttachLabel (info_table, 3, name_value_label);\n\t\t\texposure_value_label = AttachLabel (info_table, 4, name_value_label);\n\t\t\t\n\t\t\tversion_list = new ListStore (typeof (uint), typeof (string), typeof (bool));\n\t\t\tversion_combo = new ComboBox ();\n\t\t\tCellRendererText version_name_cell = new CellRendererText ();\n\t\t\tversion_name_cell.Ellipsize = Pango.EllipsizeMode.End;\n\t\t\tversion_combo.PackStart (version_name_cell, true);\n\t\t\tversion_combo.SetCellDataFunc (version_name_cell, new CellLayoutDataFunc (VersionNameCellFunc));\n\t\t\tversion_combo.Model = version_list;\n\t\t\tversion_combo.Changed += OnVersionComboChanged;\n\t\t\tinfo_table.Attach (version_combo, 1, 2, 1, 2, AttachOptions.Fill, AttachOptions.Fill, TABLE_XPADDING, TABLE_YPADDING);\n\t\n\t\t\tdate_value_label.Text = Environment.NewLine;\n\t\t\texposure_value_label.Text = Environment.NewLine;\n\t\t\tfocal_length_value_label = AttachLabel (info_table, 5, name_value_label);\n\t\t\tcamera_value_label = AttachLabel (info_table, 6, name_value_label);\n\t\t\tfile_size_value_label = AttachLabel (info_table, 7, name_value_label);\n\n\t\t\tGtk.Alignment rating_align = new Gtk.Alignment( 0, 0, 0, 0);\n\t\t\tinfo_table.Attach (rating_align, 1, 2, 8, 9, AttachOptions.Fill, AttachOptions.Fill, TABLE_XPADDING, TABLE_YPADDING);\n\t\t\t\n\t\t\trating_view = new RatingSmall ();\n\t\t\trating_view.Visible = false;\n\t\t\trating_view.Changed += HandleRatingChanged;\n\t\t\trating_align.Add (rating_view);\n\n\t\t\ttag_view = new TagView (MainWindow.ToolTips);\n\t\t\tinfo_table.Attach (tag_view, 0, 2, 9, 10, AttachOptions.Fill, AttachOptions.Fill, TABLE_XPADDING, TABLE_YPADDING);\n\n\t\t\tinfo_table.ShowAll ();\n\n\t\t\tEventBox eb = new EventBox ();\n\t\t\teb.Add (info_table);\n\t\t\tinfo_expander.Add (eb);\n\t\t\teb.ButtonPressEvent += HandleButtonPressEvent;\n\n\t\t\tAdd (info_expander);\n\t\t\trating_label.Visible = show_rating;\n\t\t\trating_view.Visible = show_rating;\n\t\t}\n\t\n\t\tprivate class ImageInfo : StatementSink {\n\t\t\tstring width;\n\t\t\tstring height;\n\t\t\tstring aperture;\n\t\t\tstring fnumber;\n\t\t\tstring exposure;\n\t\t\tstring iso_speed;\n\t\t\tstring focal_length;\n\t\t\tstring camera_model;\n\t\t\tbool add = true;\n\t\t\tResource iso_anon;\n\t\n\t\t\tMemoryStore store;\n\t\t\t\n\t#if USE_EXIF_DATE\n\t\t\tDateTime date;\n\t#endif\n\t\t\tpublic ImageInfo (ImageFile img) \n\t\t\t{\n\t\t\t\t\/\/ FIXME We use the memory store to hold the anonymous statements\n\t\t\t\t\/\/ as they are added so that we can query for them later to \n\t\t\t\t\/\/ resolve anonymous nodes.\n\t\t\t\tstore = new MemoryStore ();\n\t\n\t\t\t\tif (img == null) \n\t\t\t\t\treturn;\n\t\n\t\t\t\tif (img is StatementSource) {\n\t\t\t\t\tSemWeb.StatementSource source = (SemWeb.StatementSource)img;\n\t\t\t\t\tsource.Select (this);\n\t\n\t\t\t\t\t\/\/ If we couldn't find the ISO speed because of the ordering\n\t\t\t\t\t\/\/ search the memory store for the values\n\t\t\t\t\tif (iso_speed == null && iso_anon != null) {\n\t\t\t\t\t\tadd = false;\n\t\t\t\t\t\tstore.Select (this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif (img is JpegFile) {\n\t\t\t\t\tint real_width;\n\t\t\t\t\tint real_height;\n\t\n\t\t\t\t\tJpegUtils.GetSize (img.Uri.LocalPath, out real_width, out real_height);\n\t\t\t\t\twidth = real_width.ToString ();\n\t\t\t\t\theight = real_height.ToString ();\n\t\t\t\t}\n\t#if USE_EXIF_DATE\n\t\t\t\tdate = img.Date.ToLocalTime ();\n\t#endif\n\t\t\t}\n\t\n\t\t\tpublic bool Add (SemWeb.Statement stmt)\n\t\t\t{\n\t\t\t\tif (stmt.Predicate == MetadataStore.Namespaces.Resolve (\"tiff:ImageWidth\")) {\n\t\t\t\t\tif (width == null)\n\t\t\t\t\t\twidth = ((SemWeb.Literal)stmt.Object).Value;\n\t\t\t\t\t} else if (stmt.Predicate == MetadataStore.Namespaces.Resolve (\"tiff:ImageLength\")) {\n\t\t\t\t\tif (height == null)\n\t\t\t\t\t\theight = ((SemWeb.Literal)stmt.Object).Value;\n\t\t\t\t} else if (stmt.Predicate == MetadataStore.Namespaces.Resolve (\"exif:PixelXDimension\"))\n\t\t\t\t\twidth = ((SemWeb.Literal)stmt.Object).Value;\t\t\t\t\t\t      \n\t\t\t\telse if (stmt.Predicate == MetadataStore.Namespaces.Resolve (\"exif:PixelYDimension\"))\n\t\t\t\t\theight = ((SemWeb.Literal)stmt.Object).Value;\n\t\t\t\telse if (stmt.Predicate == MetadataStore.Namespaces.Resolve (\"exif:ExposureTime\"))\n\t\t\t\t\texposure = ((SemWeb.Literal)stmt.Object).Value;\n\t\t\t\telse if (stmt.Predicate == MetadataStore.Namespaces.Resolve (\"exif:ApertureValue\"))\n\t\t\t\t\taperture = ((SemWeb.Literal)stmt.Object).Value;\n\t\t\t\telse if (stmt.Predicate == MetadataStore.Namespaces.Resolve (\"exif:FNumber\"))\n\t\t\t\t\tfnumber = ((SemWeb.Literal)stmt.Object).Value;\n\t\t\t\telse if (stmt.Predicate == MetadataStore.Namespaces.Resolve (\"exif:ISOSpeedRatings\"))\n\t\t\t\t\tiso_anon = stmt.Object;\n\t\t\t\telse if (stmt.Predicate == MetadataStore.Namespaces.Resolve (\"exif:FocalLength\"))\n\t\t\t\t\tfocal_length = ((SemWeb.Literal)stmt.Object).Value;\n\t\t\t\telse if (stmt.Predicate == MetadataStore.Namespaces.Resolve (\"tiff:Model\"))\n\t\t\t\t\tcamera_model = ((SemWeb.Literal)stmt.Object).Value;\n\t\t\t\telse if (stmt.Subject == iso_anon && stmt.Predicate == MetadataStore.Namespaces.Resolve (\"rdf:li\"))\n\t\t\t\t\tiso_speed = ((SemWeb.Literal)stmt.Object).Value;\n\t\t\t\telse if (add && stmt.Subject.Uri == null)\n\t\t\t\t\tstore.Add (stmt);\n\n\t\t\t\tif (width == null || height == null || exposure == null || aperture == null \n\t\t\t\t    || iso_speed == null || focal_length == null || camera_model == null)\n\t\t\t\t\treturn true;\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\tpublic string ExposureInfo {\n\t\t\t\tget {\n\t\t\t\t\tstring info = String.Empty;\n\t\n\t\t\t\t\tif  (fnumber != null && fnumber != String.Empty) {\n\t\t\t\t\t\tFSpot.Tiff.Rational rat = new FSpot.Tiff.Rational (fnumber);\n\t\t\t\t\t\tinfo += String.Format (\"f\/{0:.0} \", rat.Value);\n\t\t\t\t\t} else if (aperture != null && aperture != String.Empty) {\n\t\t\t\t\t\t\/\/ Convert from APEX to fnumber\n\t\t\t\t\t\tFSpot.Tiff.Rational rat = new FSpot.Tiff.Rational (aperture);\n\t\t\t\t\t\tinfo += String.Format (\"f\/{0:.0} \", Math.Pow (2, rat.Value \/ 2));\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (exposure != null && exposure != String.Empty)\n\t\t\t\t\t\tinfo += exposure + \" sec \";\n\t\n\t\t\t\t\tif (iso_speed != null && iso_speed != String.Empty)\n\t\t\t\t\t\tinfo += Environment.NewLine + \"ISO \" + iso_speed;\n\t\t\t\t\t\n\t\t\t\t\tif (info == String.Empty)\n\t\t\t\t\t\treturn Catalog.GetString (\"(None)\");\n\t\t\t\t\t\n\t\t\t\t\treturn info;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tpublic string FocalLength {\n\t\t\t\tget {\n\t\t\t\t\tif (focal_length == null)\n\t\t\t\t\t\treturn Catalog.GetString (\"(Unknown)\");\n\n\t\t\t\t\tstring fl = focal_length;\n\n\t\t\t\t\tif (focal_length.Contains(\"\/\")) {\n\t\t\t\t\t\tstring[] strings = focal_length.Split('\/');\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (strings.Length == 2)\n\t\t\t\t\t\t\t\tfl = (double.Parse (strings[0]) \/ double.Parse (strings[1])).ToString ();\n\t\t\t\t\t\t} catch (FormatException) {\n\t\t\t\t\t\t\treturn Catalog.GetString (\"(wrong format)\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn fl + \" mm\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic string CameraModel {\n\t\t\t\tget {\n\t\t\t\t\tif (focal_length != null)\n\t\t\t\t\t\treturn camera_model;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn Catalog.GetString (\"(Unknown)\");\n\t\t\t\t}\n\t\t\t}\n\n\t\n\t\t\tpublic string Dimensions {\n\t\t\t\tget {\n\t\t\t\t\tif (width != null && height != null)\n\t\t\t\t\t\treturn String.Format (\"{0}x{1}\", width, height);\n\t\t\t\t\telse \n\t\t\t\t\t\treturn Catalog.GetString (\"(Unknown)\");\n\t\t\t\t}\n\t\t\t}\n\t#if USE_EXIF_DATE\n\t\t\tpublic string Date {\n\t\t\t\tget {\n\t\t\t\t\tif (date > DateTime.MinValue && date < DateTime.MaxValue)\n\t\t\t\t\t\treturn date.ToShortDateString () + Environment.NewLine + date.ToShortTimeString ();\n\t\t\t\t\telse \n\t\t\t\t\t\treturn Catalog.GetString (\"(Unknown)\");\n\t\t\t\t}\n\t\t\t}\n\t#endif\n\t\t}\n\t\t\t\n\t\n\t\tpublic bool Update ()\n\t\t{\n\t\t\tif (Photos == null || Photos.Length == 0) {\n\t\t\t\tHide ();\n\t\t\t} else if (Photos.Length == 1) {\n\t\t\t\tUpdateSingle ();\n\t\t\t} else if (Photos.Length > 1) {\n\t\t\t\tUpdateMultiple ();\n\t\t\t}\n\t\t\treturn false;\n\t\t}\t\n\t\n\t\tprivate void UpdateSingle () \n\t\t{\n\t\t\tImageInfo info;\n\n\t\t\tPhoto photo = Photos[0];\n\n\t\t\thistogram_expander.Visible = true;\n\t\t\tUpdateHistogram ();\n\n\t\t\tif (show_name) {\n\t\t\t\tname_value_label.Text = photo.Name != null ? photo.Name : String.Empty;\n\t\t\t}\n\t\t\tname_label.Visible = show_name;\t\n\t\t\tname_value_label.Visible = show_name;\n\t\t\t\n\t\t\ttry {\n\t\t\t\t\/\/using (new Timer (\"building info\")) {\n\t\t\t\t\tusing (ImageFile img = ImageFile.Create (photo.DefaultVersionUri))\n\t\t\t\t\t{\n\t\t\t\t\t\tinfo = new ImageInfo (img);\n\t\t\t\t\t}\n\t\t\t\t\t\/\/}\n\t\t\t} catch (System.Exception e) {\n\t\t\t\tFSpot.Utils.Log.Debug (e.StackTrace);\n\t\t\t\tinfo = new ImageInfo (null);\t\t\t\n\t\t\t}\n\n\t\t\tif (show_exposure) {\n\t\t\t\texposure_value_label.Text = info.ExposureInfo;\n\t\t\t\tif (exposure_value_label.Text.IndexOf (Environment.NewLine) != -1)\n\t\t\t\t\texposure_label.Markup = default_exposure_string + Environment.NewLine;\n\t\t\t\telse\n\t\t\t\t\texposure_label.Markup = default_exposure_string;\n\t\t\t}\n\t\t\texposure_label.Visible = show_exposure;\n\t\t\texposure_value_label.Visible = show_exposure;\n\n\t\t\tif (show_size)\n\t\t\t\tsize_value_label.Text = info.Dimensions;\n\t\t\tsize_label.Visible = show_size;\n\t\t\tsize_value_label.Visible = show_size;\n\n\t\t\tif (show_date) {\n\t#if USE_EXIF_DATE\n\t\t\t\tdate_value_label.Text = info.Date;\n\t#else\n\t\t\t\tDateTime local_time = photo.Time.ToLocalTime ();\n\t\t\t\tdate_value_label.Text = String.Format (\"{0}{2}{1}\",\n\t\t\t\t                                       local_time.ToShortDateString (),\n\t\t\t\t                                       local_time.ToShortTimeString (),\n\t\t\t\t                                       Environment.NewLine\n\t\t\t\t                                       );\n\t#endif\n\t\t\t}\n\t\t\tdate_label.Visible = show_date;\n\t\t\tdate_value_label.Visible = show_date;\n\t\t\t\n\t\t\tif (show_focal_length)\n\t\t\t\tfocal_length_value_label.Text = info.FocalLength;\n\t\t\tfocal_length_label.Visible = show_focal_length;\n\t\t\tfocal_length_value_label.Visible = show_focal_length;\n\t\t\t\n\t\t\tif (show_camera)\n\t\t\t\tcamera_value_label.Text = info.CameraModel;\n\t\t\tcamera_label.Visible = show_camera;\n\t\t\tcamera_value_label.Visible = show_camera;\n\n\t\t\tversion_label.Visible = true;\n\t\t\tversion_combo.Visible = true;\n\t\t\tversion_list.Clear ();\n\t\t\tversion_combo.Changed -= OnVersionComboChanged;\n\t\t\t\n\t\t\tbool hasVersions = photo.VersionIds.Length > 1;\n\t\t\tversion_combo.Sensitive = hasVersions;\n\t\t\tif (hasVersions) {\n\t\t\t\tint i = 0;\n\t\t\t\tforeach (uint version_id in photo.VersionIds) {\n\t\t\t\t\tversion_list.AppendValues (version_id, (photo.GetVersion (version_id) as PhotoVersion).Name, true);\n\t\t\t\t\tif (version_id == photo.DefaultVersionId)\n\t\t\t\t\t\tversion_combo.Active = i;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tversion_list.AppendValues (photo.DefaultVersionId, photo.DefaultVersion.Name + \" \" + Catalog.GetString (\"(No Edits)\"), true);\n\t\t\t\tversion_combo.Active = 0;\n\t\t\t\tversion_combo.TooltipText = Catalog.GetString (\"(No Edits)\");\n\t\t\t}\n\t\t\tversion_combo.Changed += OnVersionComboChanged;\n\n\t\t\tif (show_file_size) {\n\t\t\t\ttry {\n\t\t\t\t\tGFile file = FileFactory.NewForUri (photo.DefaultVersionUri);\n\t\t\t\t\tGFileInfo file_info = file.QueryInfo (\"standard::size\", FileQueryInfoFlags.None, null);\n\t\t\t\t\tfile_size_value_label.Text = Format.SizeForDisplay (file_info.Size);\n\t\t\t\t} catch (GLib.GException e) {\n\t\t\t\t\tfile_size_value_label.Text = Catalog.GetString(\"(File read error)\");\n\t\t\t\t\tFSpot.Utils.Log.DebugException (e);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfile_size_label.Visible = show_file_size;\n\t\t\tfile_size_value_label.Visible = show_file_size;\t\t\t\n\t\t\t\n\t\t\tif (show_tags)\n\t\t\t\ttag_view.Current = photo;\n\t\t\trating_label.Visible = show_rating;\n\t\t\trating_view.Visible = show_rating;\n\t\t\tif (show_rating) {\n\t\t\t\trating_view.Value = (int) photo.Rating;\n\t\t\t}\n\t\n\t\t\tShow ();\n\t\t}\n\n\t\tvoid VersionNameCellFunc (CellLayout cell_layout, CellRenderer cell, TreeModel tree_model, TreeIter iter)\n\t\t{\n\t\t\tstring name = (string)tree_model.GetValue (iter, 1);\n\t\t\t(cell as CellRendererText).Text = name;\n\n\t\t\tcell.Sensitive = (bool)tree_model.GetValue (iter, 2);\n\t\t}\n\n\n\t\tvoid OnVersionComboChanged (object o, EventArgs e)\n\t\t{\n\t\t\tComboBox combo = o as ComboBox;\n\t\t\tif (combo == null)\n\t\t\t\treturn;\n\n\t\t\tTreeIter iter;\n\n\t\t\tif (combo.GetActiveIter (out iter))\n\t\t\t\tVersionIdChanged (this, (uint)version_list.GetValue (iter, 0));\n\t\t}\n\n\t\tprivate void UpdateMultiple ()\n\t\t{\n\t\t\thistogram_expander.Visible = false;\n\n\t\t\tname_label.Visible = false;\n\t\t\tname_value_label.Text = String.Format(Catalog.GetString(\"{0} Photos\"), Photos.Length);\n\t\t\tname_value_label.Visible = true;\n\t\t\t\n\t\t\tversion_label.Visible = false;\n\t\t\tversion_combo.Visible = false;\n\n\t\t\texposure_label.Visible = false;\n\t\t\texposure_value_label.Visible = false;\n\t\t\t\n\t\t\tfocal_length_label.Visible = false;\n\t\t\tfocal_length_value_label.Visible = false;\n\t\t\t\n\t\t\tcamera_label.Visible = false;\n\t\t\tcamera_value_label.Visible = false;\n\n\t\t\tif (show_date) {\n\t\t\t\tPhoto first = Photos[Photos.Length-1];\n\t\t\t\tPhoto last = Photos[0];\n\t\t\t\tif (first.Time.Date == last.Time.Date) {\n\t\t\t\t\t\/\/Note for translators: {0} is a date, {1} and {2} are times.\n\t\t\t\t\tdate_value_label.Text = String.Format(Catalog.GetString(\"On {0} between \\n{1} and {2}\"), \n\t\t\t\t\t                                      first.Time.ToLocalTime ().ToShortDateString (),\n\t\t\t\t\t                                      first.Time.ToLocalTime ().ToShortTimeString (),\n\t\t\t\t\t                                      last.Time.ToLocalTime ().ToShortTimeString ());\n\t\t\t\t} else {\n\t\t\t\t\tdate_value_label.Text = String.Format(Catalog.GetString(\"Between {0} \\nand {1}\"),\n\t\t\t\t\t                                      first.Time.ToLocalTime ().ToShortDateString (),\n\t\t\t\t\t                                      last.Time.ToLocalTime ().ToShortDateString ());\n\t\t\t\t}\n\t\t\t}\n\t\t\tdate_label.Visible = show_date;\n\t\t\tdate_value_label.Visible = show_date;\n\t\t\t\n\t\t\tif (show_file_size) {\n\t\t\t\tlong file_size = 0;\n\t\t\t\tforeach (Photo photo in Photos) {\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tGFile file = FileFactory.NewForUri (photo.DefaultVersionUri);\n\t\t\t\t\t\tGFileInfo file_info = file.QueryInfo (\"standard::size\", FileQueryInfoFlags.None, null);\n\t\t\t\t\t\tfile_size += file_info.Size;\n\t\t\t\t\t} catch (GLib.GException e) {\n\t\t\t\t\t\tfile_size = -1;\n\t\t\t\t\t\tFSpot.Utils.Log.DebugException (e);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (file_size != -1)\n\t\t\t\t\tfile_size_value_label.Text = Format.SizeForDisplay (file_size);\n\n\t\t\t\telse\n\t\t\t\t\tfile_size_value_label.Text = Catalog.GetString(\"(At least one File not found)\");\n\t\t\t}\n\t\t\tfile_size_label.Visible = show_file_size;\n\t\t\tfile_size_value_label.Visible = show_file_size;\t\n\n\t\t\tsize_label.Visible = false;\n\t\t\tsize_value_label.Visible = false;\n\n\t\t\trating_label.Visible = false;\n\t\t\trating_view.Visible = false;\n\t\t}\n\n\t\tprivate Gdk.Pixbuf histogram_hint;\n\n\t\tprivate void UpdateHistogram ()\n\t\t{\n\t\t\tif (histogram_expander.Expanded)\n\t\t\t\thistogram_delay.Start ();\n\t\t}\n\n\t\tpublic void UpdateHistogram (Gdk.Pixbuf pixbuf) {\n\t\t\thistogram_hint = pixbuf;\n\t\t\tUpdateHistogram ();\n\t\t}\n\n\t\tprivate bool DelayedUpdateHistogram () {\n\t\t\tif (Photos.Length == 0)\n\t\t\t\treturn false;\n\n\t\t\tPhoto photo = Photos[0];\n\n\t\t\tGdk.Pixbuf hint = histogram_hint;\n\t\t\thistogram_hint = null;\n\t\t\tint max = histogram_expander.Allocation.Width;\n\n\t\t\ttry {\n\t\t\t\tif (hint == null)\n\t\t\t\t\tusing (ImageFile img = ImageFile.Create (photo.DefaultVersionUri))\n\t\t\t\t\t\thint = img.Load (256, 256);\n\t\t\t\t\n\t\t\t\thistogram_image.Pixbuf = histogram.Generate (hint, max);\n\t\t\t\t\n\t\t\t\thint.Dispose ();\n\t\t\t} catch (System.Exception e) {\n\t\t\t\tFSpot.Utils.Log.Debug (e.StackTrace);\n\t\t\t\tusing (Gdk.Pixbuf empty = new Gdk.Pixbuf (Gdk.Colorspace.Rgb, true, 8, 256, 256)) {\n\t\t\t\t\tempty.Fill (0x0);\n\t\t\t\t\thistogram_image.Pixbuf = histogram.Generate (empty, max);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\t\/\/ Context switching\n\n\t\tprivate void HandleContextChanged (object sender, EventArgs args)\n\t\t{\n\t\t\tbool infobox_visible = ContextSwitchStrategy.InfoBoxVisible (Context);\n\t\t\tinfo_expander.Expanded = infobox_visible;\n\n\t\t\tbool histogram_visible = ContextSwitchStrategy.HistogramVisible (Context);\n\t\t\thistogram_expander.Expanded = histogram_visible;\n\t\t\t\n\t\t\tshow_name = ContextSwitchStrategy.InfoBoxNameVisible (Context);\n\t\t\tshow_date = ContextSwitchStrategy.InfoBoxDateVisible (Context);\n\t\t\tshow_size = ContextSwitchStrategy.InfoBoxSizeVisible (Context);\n\t\t\tshow_exposure = ContextSwitchStrategy.InfoBoxExposureVisible (Context);\n\t\t\tshow_focal_length = ContextSwitchStrategy.InfoBoxFocalLengthVisible (Context);\n\t\t\tshow_camera = ContextSwitchStrategy.InfoBoxCameraVisible (Context);\n\t\t\tshow_file_size = ContextSwitchStrategy.InfoBoxFileSizeVisible (Context);\n\t\t\t\n\t\t\tif (infobox_visible)\n\t\t\t\tupdate_delay.Start ();\n\t\t}\n\t\n\t\tpublic void HandleMainWindowViewModeChanged (object o, EventArgs args)\n\t\t{\n\t\t\tMainWindow.ModeType mode = MainWindow.Toplevel.ViewMode;\n\t\t\tif (mode == MainWindow.ModeType.IconView)\n\t\t\t\tContext = ViewContext.Library;\n\t\t\telse if (mode == MainWindow.ModeType.PhotoView)\n\t\t\t\tContext = ViewContext.Edit;\n\t\t}\n\t\t\n\t\tvoid HandleButtonPressEvent (object sender, ButtonPressEventArgs args)\n\t\t{\n\t\t\tif (args.Event.Button == 3) {\n\t\t\t\tMenu popup_menu = new Menu ();\n\t\t\t\t\n\t\t\t\tAddMenuItems (popup_menu);\n\t\t\t\t\n\t\t\t\tif (args.Event != null)\n\t\t\t\t\tpopup_menu.Popup (null, null, null, args.Event.Button, args.Event.Time);\n\t\t\t\telse\n\t\t\t\t\tpopup_menu.Popup (null, null, null, 0, Gtk.Global.CurrentEventTime);\n\t\t\t\n\t\t\t\targs.RetVal = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid HandlePopulatePopup (object sender, PopulatePopupArgs args)\n\t\t{\t\t\t\n\t\t\tAddMenuItems (args.Menu);\n\t\t\t\n\t\t\targs.RetVal = true;\n\t\t}\n\t\t\n\t\tprivate void AddMenuItems (Menu popup_menu) {\n\t\t\t\n\t\t\tif (popup_menu.Children.Length > 0) {\n\t\t\t\tGtkUtil.MakeMenuSeparator (popup_menu);\n\t\t\t}\n\t\t\t\n\t\t\tMenuItem item;\n\t\t\t\n\t\t\titem = GtkUtil.MakeCheckMenuItem (popup_menu,\n\t\t\t                                  Catalog.GetString (\"Show Photo Name\"),\n\t\t\t                                  HandleMenuItemSelected,\n\t\t\t                                  true,\n\t\t\t                                  show_name,\n\t\t\t                                  false);\n\t\t\t\n\t\t\titem.SetData (\"cb\", name_label.Handle);\n\t\t\t\t\n\t\t\titem = GtkUtil.MakeCheckMenuItem (popup_menu,\n\t\t\t                           Catalog.GetString (\"Show Date\"),\n\t\t\t                           HandleMenuItemSelected,\n\t\t\t                           true,\n\t\t\t                           show_date,\n\t\t\t                           false);\n\t\t\t\n\t\t\titem.SetData (\"cb\", date_label.Handle);\t\t\t\n\t\t\t\n\t\t\titem = GtkUtil.MakeCheckMenuItem (popup_menu,\n\t\t\t                           Catalog.GetString (\"Show Size\"),\n\t\t\t                           HandleMenuItemSelected,\n\t\t\t                           true,\n\t\t\t                           show_size,\n\t\t\t                           false);\n\t\t\t\n\t\t\titem.SetData (\"cb\", size_label.Handle);\n\t\t\t\n\t\t\titem = GtkUtil.MakeCheckMenuItem (popup_menu,\n\t\t\t                           Catalog.GetString (\"Show Exposure\"),\n\t\t\t                           HandleMenuItemSelected,\n\t\t\t                           true,\n\t\t\t                           show_exposure,\n\t\t\t                           false);\n\t\t\t\n\t\t\titem.SetData (\"cb\", exposure_label.Handle);\n\t\t\t\n\t\t\titem = GtkUtil.MakeCheckMenuItem (popup_menu,\n\t\t\t                           Catalog.GetString (\"Show Focal Length\"),\n\t\t\t                           HandleMenuItemSelected,\n\t\t\t                           true,\n\t\t\t                           show_focal_length,\n\t\t\t                           false);\n\t\t\t\n\t\t\titem.SetData (\"cb\", focal_length_label.Handle);\n\t\t\t\n\t\t\titem = GtkUtil.MakeCheckMenuItem (popup_menu,\n\t\t\t                           Catalog.GetString (\"Show Camera\"),\n\t\t\t                           HandleMenuItemSelected,\n\t\t\t                           true,\n\t\t\t                           show_camera,\n\t\t\t                           false);\n\t\t\t\n\t\t\titem.SetData (\"cb\", camera_label.Handle);\n\t\t\t\n\t\t\titem = GtkUtil.MakeCheckMenuItem (popup_menu,\n\t\t\t                           Catalog.GetString (\"Show File Size\"),\n\t\t\t                           HandleMenuItemSelected,\n\t\t\t                           true,\n\t\t\t                           show_file_size,\n\t\t\t                           false);\n\t\t\t\n\t\t\titem.SetData (\"cb\", file_size_label.Handle);\n\t\t}\n\t\t\n\t\tprivate void HandleMenuItemSelected (object sender, EventArgs args)\n\t\t{\n\t\t\tIntPtr handle = (sender as CheckMenuItem).GetData (\"cb\");\n\t\t\t\n\t\t\tif (handle == name_label.Handle) {\n\t\t\t\tshow_name = (sender as CheckMenuItem).Active;\n\t\t\t\tContextSwitchStrategy.SetInfoBoxNameVisible (Context, show_name);\n\t\t\t} else if (handle == date_label.Handle) {\n\t\t\t\tshow_date = (sender as CheckMenuItem).Active;\n\t\t\t\tContextSwitchStrategy.SetInfoBoxDateVisible (Context, show_date);\n\t\t\t} else if (handle == size_label.Handle) {\n\t\t\t\tshow_size = (sender as CheckMenuItem).Active;\n\t\t\t\tContextSwitchStrategy.SetInfoBoxSizeVisible (Context, show_size);\n\t\t\t} else if (handle == exposure_label.Handle) {\n\t\t\t\tshow_exposure = (sender as CheckMenuItem).Active;\n\t\t\t\tContextSwitchStrategy.SetInfoBoxExposureVisible (Context, show_exposure);\n\t\t\t} else if (handle == focal_length_label.Handle) {\n\t\t\t\tshow_focal_length = (sender as CheckMenuItem).Active;\n\t\t\t\tContextSwitchStrategy.SetInfoBoxFocalLengthVisible (Context, show_focal_length);\n\t\t\t} else if (handle == camera_label.Handle) {\n\t\t\t\tshow_camera = (sender as CheckMenuItem).Active;\n\t\t\t\tContextSwitchStrategy.SetInfoBoxCameraVisible (Context, show_camera);\n\t\t\t} else if (handle == file_size_label.Handle) {\n\t\t\t\tshow_file_size = (sender as CheckMenuItem).Active;\n\t\t\t\tContextSwitchStrategy.SetInfoBoxFileSizeVisible (Context, show_file_size);\n\t\t\t}\n\t\t\t\n\t\t\tupdate_delay.Start ();\n\t\t}\n\t\n\t\t\/\/ Constructor.\n\t\n\t\tpublic InfoBox () : base (false, 0)\n\t\t{\n\t\t\tContextSwitchStrategy = new MRUInfoBoxContextSwitchStrategy ();\n\t\t\tContextChanged += HandleContextChanged;\n\n\t\t\tSetupWidgets ();\n\n\t\t\tupdate_delay = new Delay (Update);\n\t\t\tupdate_delay.Start ();\n\n\t\t\thistogram_delay = new Delay (DelayedUpdateHistogram);\n\t\t\t\n\t\t\tBorderWidth = 2;\n\t\t\tHide ();\n\t\t}\n\t}\n\n\t\/\/ Decides whether infobox \/ histogram should be shown for each context. Implemented\n\t\/\/ using the Strategy pattern, to make it swappable easily, in case the\n\t\/\/ default MRUInfoBoxContextSwitchStrategy is not sufficiently usable.\n\tpublic abstract class InfoBoxContextSwitchStrategy {\n\t\tpublic abstract bool InfoBoxVisible (ViewContext context);\n\t\tpublic abstract bool HistogramVisible (ViewContext context);\n\t\tpublic abstract bool InfoBoxNameVisible (ViewContext context);\n\t\tpublic abstract bool InfoBoxDateVisible (ViewContext context);\n\t\tpublic abstract bool InfoBoxSizeVisible (ViewContext context);\n\t\tpublic abstract bool InfoBoxExposureVisible (ViewContext context);\n\t\tpublic abstract bool InfoBoxFocalLengthVisible (ViewContext context);\n\t\tpublic abstract bool InfoBoxCameraVisible (ViewContext context);\n\t\tpublic abstract bool InfoBoxFileSizeVisible (ViewContext context);\n\n\t\tpublic abstract void SetInfoBoxVisible (ViewContext context, bool visible);\n\t\tpublic abstract void SetHistogramVisible (ViewContext context, bool visible);\n\t\tpublic abstract void SetInfoBoxNameVisible (ViewContext context, bool visible);\n\t\tpublic abstract void SetInfoBoxDateVisible (ViewContext context, bool visible);\n\t\tpublic abstract void SetInfoBoxSizeVisible (ViewContext context, bool visible);\n\t\tpublic abstract void SetInfoBoxExposureVisible (ViewContext context, bool visible);\n\t\tpublic abstract void SetInfoBoxFocalLengthVisible (ViewContext context, bool visible);\n\t\tpublic abstract void SetInfoBoxCameraVisible (ViewContext context, bool visible);\n\t\tpublic abstract void SetInfoBoxFileSizeVisible (ViewContext context, bool visible);\n\t}\n\n\t\/\/ Values are stored as strings, because bool is not nullable through Preferences.\n\tpublic class MRUInfoBoxContextSwitchStrategy : InfoBoxContextSwitchStrategy {\n\t\tpublic const string PREF_PREFIX = Preferences.APP_FSPOT + \"ui\";\n\n\t\tprivate string PrefKeyForContext (ViewContext context, string item) {\n\t\t\treturn String.Format (\"{0}\/{1}_visible\/{2}\", PREF_PREFIX, item, context);\n\t\t}\n\t\t\n\t\tprivate string PrefKeyForContext (ViewContext context, string parent, string item) {\n\t\t\treturn String.Format (\"{0}\/{1}_visible\/{2}\/{3}\", PREF_PREFIX, parent, item, context);\n\t\t}\n\n\t\tprivate bool VisibilityForContext (ViewContext context, string item, bool default_value) {\n\t\t\tstring visible = Preferences.Get<string> (PrefKeyForContext (context, item));\n\t\t\tif (visible == null)\n\t\t\t\treturn default_value;\n\t\t\telse\n\t\t\t\treturn visible == \"1\";\n\t\t}\n\t\t\n\t\tprivate bool VisibilityForContext (ViewContext context, string parent, string item, bool default_value) {\n\t\t\tstring visible = Preferences.Get<string> (PrefKeyForContext (context, parent, item));\n\t\t\tif (visible == null)\n\t\t\t\treturn default_value;\n\t\t\telse\n\t\t\t\treturn visible == \"1\";\n\t\t}\n\n\t\tprivate void SetVisibilityForContext (ViewContext context, string item, bool visible) {\n\t\t\tPreferences.Set (PrefKeyForContext (context, item), visible ? \"1\" : \"0\");\n\t\t}\n\t\t\n\t\tprivate void SetVisibilityForContext (ViewContext context, string parent, string item, bool visible) {\n\t\t\tPreferences.Set (PrefKeyForContext (context, parent, item), visible ? \"1\" : \"0\");\n\t\t}\n\n\t\tpublic override bool InfoBoxVisible (ViewContext context) {\n\t\t\treturn VisibilityForContext (context, \"infobox\", true);\n\t\t}\n\n\t\tpublic override bool HistogramVisible (ViewContext context) {\n\t\t\treturn VisibilityForContext (context, \"histogram\", true);\n\t\t}\n\t\t\n\t\tpublic override bool InfoBoxNameVisible (ViewContext context) {\n\t\t\treturn VisibilityForContext (context, \"infobox\", \"name\", true);\n\t\t}\n\t\t\n\t\tpublic override bool InfoBoxDateVisible (ViewContext context) {\n\t\t\treturn VisibilityForContext (context, \"infobox\", \"date\", true);\n\t\t}\n\t\t\n\t\tpublic override bool InfoBoxSizeVisible (ViewContext context) {\n\t\t\treturn VisibilityForContext (context, \"infobox\", \"size\", true);\n\t\t}\n\t\t\n\t\tpublic override bool InfoBoxExposureVisible (ViewContext context) {\n\t\t\treturn VisibilityForContext (context, \"infobox\", \"exposure\", true);\n\t\t}\n\t\t\n\t\tpublic override bool InfoBoxFocalLengthVisible (ViewContext context) {\n\t\t\treturn VisibilityForContext (context, \"infobox\", \"focal_length\", false);\n\t\t}\n\t\t\n\t\tpublic override bool InfoBoxCameraVisible (ViewContext context)  {\n\t\t\treturn VisibilityForContext (context, \"infobox\", \"camera\", false);\n\t\t}\n\t\t\n\t\tpublic override bool InfoBoxFileSizeVisible (ViewContext context) {\n\t\t\treturn VisibilityForContext (context, \"infobox\", \"file_size\", false);\n\t\t}\n\n\t\tpublic override void SetInfoBoxVisible (ViewContext context, bool visible) {\n\t\t\tSetVisibilityForContext (context, \"infobox\", visible);\n\t\t}\n\n\t\tpublic override void SetHistogramVisible (ViewContext context, bool visible) {\n\t\t\tSetVisibilityForContext (context, \"histogram\", visible);\n\t\t}\n\t\t\n\t\tpublic override void SetInfoBoxNameVisible (ViewContext context, bool visible) {\n\t\t\tSetVisibilityForContext (context, \"infobox\", \"name\", visible);\n\t\t}\n\t\t\n\t\tpublic override void SetInfoBoxDateVisible (ViewContext context, bool visible) {\n\t\t\tSetVisibilityForContext (context, \"infobox\", \"date\", visible);\n\t\t}\n\t\t\n\t\tpublic override void SetInfoBoxSizeVisible (ViewContext context, bool visible) {\n\t\t\tSetVisibilityForContext (context, \"infobox\", \"size\", visible);\n\t\t}\n\t\t\n\t\tpublic override void SetInfoBoxExposureVisible (ViewContext context, bool visible) {\n\t\t\tSetVisibilityForContext (context, \"infobox\", \"exposure\", visible);\n\t\t}\n\t\t\n\t\tpublic override void SetInfoBoxFocalLengthVisible (ViewContext context, bool visible) {\n\t\t\tSetVisibilityForContext (context, \"infobox\", \"focal_length\", visible);\n\t\t}\n\t\t\n\t\tpublic override void SetInfoBoxCameraVisible (ViewContext context, bool visible) {\n\t\t\tSetVisibilityForContext (context, \"infobox\", \"camera\", visible);\n\t\t}\n\t\t\n\t\tpublic override void SetInfoBoxFileSizeVisible (ViewContext context, bool visible) {\n\t\t\tSetVisibilityForContext (context, \"infobox\", \"file_size\", visible);\n\t\t}\n\t}\n}\n","old_contents":"\/*\n * FSpot.Widgets.InfoBox\n *\n * Author(s)\n * \tEttore Perazzoli\n * \tLarry Ewing  <lewing@novell.com>\n * \tGabriel Burt\n *\tStephane Delcroix  <stephane@delcroix.org>\n *\tRuben Vermeersch <ruben@savanne.be>\n *  Mike Gemuende <mike@gemuende.de>\n *\n * This is free software. See COPYING for details.\n *\/\n\n\nusing Gtk;\nusing System;\nusing System.IO;\nusing FSpot;\nusing SemWeb;\nusing Mono.Unix;\nusing FSpot.Utils;\nusing GLib;\nusing GFile = GLib.File;\nusing GFileInfo = GLib.FileInfo;\n\n\/\/ FIXME TODO: We want to use something like EClippedLabel here throughout so it handles small sizes\n\/\/ gracefully using ellipsis.\n\nnamespace FSpot.Widgets\n{\n\tpublic class InfoBox : VBox {\n\t\tDelay update_delay;\n\t\n\t\tprivate Photo [] photos = new Photo[0];\n\t\tpublic Photo [] Photos {\n\t\t\tset {\n\t\t\t\tphotos = value;\n\t\t\t\tupdate_delay.Start ();\n\t\t\t}\n\t\t\tprivate get {\n\t\t\t\treturn photos;\n\t\t\t}\n\t\t}\n\n\t\tpublic Photo Photo {\n\t\t\tset {\n\t\t\t\tif (value != null) {\n\t\t\t\t\tPhotos = new Photo[] { value };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tprivate bool show_tags = false;\n\t\tpublic bool ShowTags {\n\t\t\tget { return show_tags; }\n\t\t\tset {\n\t\t\t\tif (show_tags == value)\n\t\t\t\t\treturn;\n\n\t\t\t\tshow_tags = value;\n\t\t\t\ttag_view.Visible = show_tags;\n\t\t\t}\n\t\t}\n\t\n\t\tprivate bool show_rating = false;\n\t\tpublic bool ShowRating {\n\t\t\tget { return show_rating; }\n\t\t\tset {\n\t\t\t\tif (show_rating == value)\n\t\t\t\t\treturn;\n\n\t\t\t\tshow_rating = value;\n\t\t\t\trating_label.Visible = show_rating;\n\t\t\t\trating_view.Visible = show_rating;\n\t\t\t}\n\t\t}\n\n\t\tpublic delegate void VersionIdChangedHandler (InfoBox info_box, uint version_id);\n\t\tpublic event VersionIdChangedHandler VersionIdChanged;\n\t\n\t\tprivate Expander info_expander;\n\t\tprivate Expander histogram_expander;\n\n\t\tprivate Gtk.Image histogram_image;\n\t\tprivate Histogram histogram;\n\n\t\tprivate Delay histogram_delay;\n\n\t\t\/\/ Context switching (toggles visibility).\n\t\tpublic event EventHandler ContextChanged;\n\n\t\tprivate ViewContext view_context = ViewContext.Unknown;\n\t\tpublic ViewContext Context {\n\t\t\tget { return view_context; }\n\t\t\tset {\n\t\t\t\tview_context = value;\n\t\t\t\tif (ContextChanged != null)\n\t\t\t\t\tContextChanged (this, null);\n\t\t\t}\n\t\t}\n\n\t\tprivate readonly InfoBoxContextSwitchStrategy ContextSwitchStrategy;\n\t\n\t\t\/\/ Widgetry.\t\n\t\tprivate Label name_label;\n\t\tprivate Label name_value_label;\n\n\t\tprivate Label version_label;\n\t\tprivate ListStore version_list;\n\t\tprivate ComboBox version_combo;\n\n\t\tprivate Label date_label;\n\t\tprivate Label date_value_label;\n\n\t\tprivate Label size_label;\n\t\tprivate Label size_value_label;\n\n\t\tprivate Label exposure_label;\n\t\tprivate Label exposure_value_label;\n\t\t\n\t\tprivate Label focal_length_label;\n\t\tprivate Label focal_length_value_label;\n\t\t\n\t\tprivate Label camera_label;\n\t\tprivate Label camera_value_label;\n\t\t\n\t\tprivate Label file_size_label;\n\t\tprivate Label file_size_value_label;\n\n\t\tprivate Label rating_label;\n\t\tprivate RatingSmall rating_view;\n\n\t\tprivate TagView tag_view;\n\t\tprivate string default_exposure_string;\n\t\t\n\t\tprivate bool show_name;\n\t\tprivate bool show_date;\n\t\tprivate bool show_size;\n\t\tprivate bool show_exposure;\n\t\tprivate bool show_focal_length;\n\t\tprivate bool show_camera;\n\t\tprivate bool show_file_size;\n\n\t\tprivate void HandleRatingChanged (object o, EventArgs e)\n\t\t{\n\t\t\tMainWindow.Toplevel.HandleRatingMenuSelected ((o as Widgets.Rating).Value);\n\t \t}\n\t\n\t\tprivate Label CreateRightAlignedLabel (string text)\n\t\t{\n\t\t\tLabel label = new Label ();\n\t\t\tlabel.UseMarkup = true;\n\t\t\tlabel.Markup = text;\n\t\t\tlabel.Xalign = 1;\n\n\t\t\treturn label;\n\t\t}\n\t\n\t\tconst int TABLE_XPADDING = 3;\n\t\tconst int TABLE_YPADDING = 3;\n\t\tprivate Label AttachLabel (Table table, int row_num, Widget entry)\n\t\t{\n\t\t\tLabel label = new Label (String.Empty);\n\t\t\tlabel.Xalign = 0;\n\t\t\tlabel.Selectable = true;\n\t\t\tlabel.Ellipsize = Pango.EllipsizeMode.End;\n\t\t\tlabel.Show ();\n\n\t\t\tlabel.PopulatePopup += HandlePopulatePopup;\n\t\t\t\n\t\t\ttable.Attach (label, 1, 2, (uint) row_num, (uint) row_num + 1,\n\t\t\t\t      AttachOptions.Expand | AttachOptions.Fill, AttachOptions.Expand | AttachOptions.Fill,\n\t\t\t\t      (uint) entry.Style.XThickness + TABLE_XPADDING, (uint) entry.Style.YThickness);\n\t\n\t\t\treturn label;\n\t\t}\n\t\n\t\tprivate void SetupWidgets ()\n\t\t{\n\n\t\t\thistogram_expander = new Expander (Catalog.GetString (\"Histogram\"));\n\t\t\thistogram_expander.Activated += delegate (object sender, EventArgs e) { \n\t\t\t\tContextSwitchStrategy.SetHistogramVisible (Context, histogram_expander.Expanded);\n\t\t\t\tUpdateHistogram ();\n\t\t\t};\n\t\t\thistogram_image = new Gtk.Image ();\n\t\t\thistogram = new Histogram ();\n\t\t\thistogram_expander.Add (histogram_image);\n\n\t\t\tWindow window = MainWindow.Toplevel.Window;\n\t\t\tGdk.Color c = window.Style.Backgrounds [(int)Gtk.StateType.Active];\n\t\t\thistogram.RedColorHint = (byte) (c.Red \/ 0xff);\n\t\t\thistogram.GreenColorHint = (byte) (c.Green \/ 0xff);\n\t\t\thistogram.BlueColorHint = (byte) (c.Blue \/ 0xff);\n\t\t\thistogram.BackgroundColorHint = 0xff;\n\n\t\t\tAdd (histogram_expander);\n\n\t\t\tinfo_expander = new Expander (Catalog.GetString (\"Image Information\"));\n\t\t\tinfo_expander.Activated += delegate (object sender, EventArgs e) {\n\t\t\t\tContextSwitchStrategy.SetInfoBoxVisible (Context, info_expander.Expanded);\n\t\t\t};\n\t\t\t\n\t\t\tTable info_table = new Table (10, 2, false);\n\t\t\tinfo_table.BorderWidth = 0;\n\t\n\t\t\tstring name_pre = \"<b>\";\n\t\t\tstring name_post = \"<\/b>\";\n\n\t\t\tname_label = CreateRightAlignedLabel (name_pre + Catalog.GetString (\"Name\") + name_post);\n\t\t\tinfo_table.Attach (name_label, 0, 1, 0, 1, AttachOptions.Fill, AttachOptions.Fill, TABLE_XPADDING, TABLE_YPADDING);\n\n\t\t\tversion_label = CreateRightAlignedLabel (name_pre + Catalog.GetString (\"Version\") + name_post); \n\t\t\tinfo_table.Attach (version_label, 0, 1, 1, 2, AttachOptions.Fill, AttachOptions.Fill, TABLE_XPADDING, TABLE_YPADDING);\n\n\t\t\tdate_label = CreateRightAlignedLabel (name_pre + Catalog.GetString (\"Date\") + name_post + Environment.NewLine);\n\t\t\tinfo_table.Attach (date_label, 0, 1, 2, 3, AttachOptions.Fill, AttachOptions.Fill, TABLE_XPADDING, TABLE_YPADDING);\n\n\t\t\tsize_label = CreateRightAlignedLabel (name_pre + Catalog.GetString (\"Size\") + name_post);\n\t\t\tinfo_table.Attach (size_label, 0, 1, 3, 4, AttachOptions.Fill, AttachOptions.Fill, TABLE_XPADDING, TABLE_YPADDING);\n\n\t\t\tdefault_exposure_string = name_pre + Catalog.GetString (\"Exposure\") + name_post;\n\t\t\texposure_label = CreateRightAlignedLabel (default_exposure_string);\n\t\t\tinfo_table.Attach (exposure_label, 0, 1, 4, 5, AttachOptions.Fill, AttachOptions.Fill, TABLE_XPADDING, TABLE_YPADDING);\n\t\t\t\n\t\t\tfocal_length_label = CreateRightAlignedLabel (name_pre + Catalog.GetString (\"Focal Length\") + name_post);\n\t\t\tinfo_table.Attach (focal_length_label, 0, 1, 5, 6, AttachOptions.Fill, AttachOptions.Fill, TABLE_XPADDING, TABLE_YPADDING);\n\t\t\t\n\t\t\tcamera_label = CreateRightAlignedLabel (name_pre + Catalog.GetString (\"Camera\") + name_post);\n\t\t\tinfo_table.Attach (camera_label, 0, 1, 6, 7, AttachOptions.Fill, AttachOptions.Fill, TABLE_XPADDING, TABLE_YPADDING);\n\t\t\t\n\t\t\tfile_size_label = CreateRightAlignedLabel (name_pre + Catalog.GetString (\"File Size\") + name_post);\n\t\t\tinfo_table.Attach (file_size_label, 0, 1, 7, 8, AttachOptions.Fill, AttachOptions.Fill, TABLE_XPADDING, TABLE_YPADDING);\n\t\t\t\n\t\t\trating_label = CreateRightAlignedLabel (name_pre + Catalog.GetString (\"Rating\") + name_post);\n\t\t\tinfo_table.Attach (rating_label, 0, 1, 8, 9, AttachOptions.Fill, AttachOptions.Fill, TABLE_XPADDING, TABLE_YPADDING);\n\t\t\trating_label.Visible = false;\n\n\t\t\tname_value_label = new Label ();\n\t\t\tname_value_label.Ellipsize = Pango.EllipsizeMode.Middle;\n\t\t\tname_value_label.Justify = Gtk.Justification.Left;\n\t\t\tname_value_label.Selectable = true;\n\t\t\tname_value_label.Xalign = 0;\n\t\t\tname_value_label.PopulatePopup += HandlePopulatePopup;\n\t\t\t\n\t\t\tinfo_table.Attach (name_value_label, 1, 2, 0, 1, AttachOptions.Fill | AttachOptions.Expand, AttachOptions.Fill, 3, 0);\n\t\t\t\n\t\t\tdate_value_label = AttachLabel (info_table, 2, name_value_label);\n\t\t\tsize_value_label = AttachLabel (info_table, 3, name_value_label);\n\t\t\texposure_value_label = AttachLabel (info_table, 4, name_value_label);\n\t\t\t\n\t\t\tversion_list = new ListStore (typeof (uint), typeof (string), typeof (bool));\n\t\t\tversion_combo = new ComboBox ();\n\t\t\tCellRendererText version_name_cell = new CellRendererText ();\n\t\t\tversion_name_cell.Ellipsize = Pango.EllipsizeMode.End;\n\t\t\tversion_combo.PackStart (version_name_cell, true);\n\t\t\tversion_combo.SetCellDataFunc (version_name_cell, new CellLayoutDataFunc (VersionNameCellFunc));\n\t\t\tversion_combo.Model = version_list;\n\t\t\tversion_combo.Changed += OnVersionComboChanged;\n\t\t\tinfo_table.Attach (version_combo, 1, 2, 1, 2, AttachOptions.Fill, AttachOptions.Fill, TABLE_XPADDING, TABLE_YPADDING);\n\t\n\t\t\tdate_value_label.Text = Environment.NewLine;\n\t\t\texposure_value_label.Text = Environment.NewLine;\n\t\t\tfocal_length_value_label = AttachLabel (info_table, 5, name_value_label);\n\t\t\tcamera_value_label = AttachLabel (info_table, 6, name_value_label);\n\t\t\tfile_size_value_label = AttachLabel (info_table, 7, name_value_label);\n\n\t\t\tGtk.Alignment rating_align = new Gtk.Alignment( 0, 0, 0, 0);\n\t\t\tinfo_table.Attach (rating_align, 1, 2, 8, 9, AttachOptions.Fill, AttachOptions.Fill, TABLE_XPADDING, TABLE_YPADDING);\n\t\t\t\n\t\t\trating_view = new RatingSmall ();\n\t\t\trating_view.Visible = false;\n\t\t\trating_view.Changed += HandleRatingChanged;\n\t\t\trating_align.Add (rating_view);\n\n\t\t\ttag_view = new TagView (MainWindow.ToolTips);\n\t\t\tinfo_table.Attach (tag_view, 0, 2, 9, 10, AttachOptions.Fill, AttachOptions.Fill, TABLE_XPADDING, TABLE_YPADDING);\n\n\t\t\tinfo_table.ShowAll ();\n\n\t\t\tEventBox eb = new EventBox ();\n\t\t\teb.Add (info_table);\n\t\t\tinfo_expander.Add (eb);\n\t\t\teb.ButtonPressEvent += HandleButtonPressEvent;\n\n\t\t\tAdd (info_expander);\n\t\t\trating_label.Visible = show_rating;\n\t\t\trating_view.Visible = show_rating;\n\t\t}\n\t\n\t\tprivate class ImageInfo : StatementSink {\n\t\t\tstring width;\n\t\t\tstring height;\n\t\t\tstring aperture;\n\t\t\tstring fnumber;\n\t\t\tstring exposure;\n\t\t\tstring iso_speed;\n\t\t\tstring focal_length;\n\t\t\tstring camera_model;\n\t\t\tbool add = true;\n\t\t\tResource iso_anon;\n\t\n\t\t\tMemoryStore store;\n\t\t\t\n\t#if USE_EXIF_DATE\n\t\t\tDateTime date;\n\t#endif\n\t\t\tpublic ImageInfo (ImageFile img) \n\t\t\t{\n\t\t\t\t\/\/ FIXME We use the memory store to hold the anonymous statements\n\t\t\t\t\/\/ as they are added so that we can query for them later to \n\t\t\t\t\/\/ resolve anonymous nodes.\n\t\t\t\tstore = new MemoryStore ();\n\t\n\t\t\t\tif (img == null) \n\t\t\t\t\treturn;\n\t\n\t\t\t\tif (img is StatementSource) {\n\t\t\t\t\tSemWeb.StatementSource source = (SemWeb.StatementSource)img;\n\t\t\t\t\tsource.Select (this);\n\t\n\t\t\t\t\t\/\/ If we couldn't find the ISO speed because of the ordering\n\t\t\t\t\t\/\/ search the memory store for the values\n\t\t\t\t\tif (iso_speed == null && iso_anon != null) {\n\t\t\t\t\t\tadd = false;\n\t\t\t\t\t\tstore.Select (this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif (img is JpegFile) {\n\t\t\t\t\tint real_width;\n\t\t\t\t\tint real_height;\n\t\n\t\t\t\t\tJpegUtils.GetSize (img.Uri.LocalPath, out real_width, out real_height);\n\t\t\t\t\twidth = real_width.ToString ();\n\t\t\t\t\theight = real_height.ToString ();\n\t\t\t\t}\n\t#if USE_EXIF_DATE\n\t\t\t\tdate = img.Date.ToLocalTime ();\n\t#endif\n\t\t\t}\n\t\n\t\t\tpublic bool Add (SemWeb.Statement stmt)\n\t\t\t{\n\t\t\t\tif (stmt.Predicate == MetadataStore.Namespaces.Resolve (\"tiff:ImageWidth\")) {\n\t\t\t\t\tif (width == null)\n\t\t\t\t\t\twidth = ((SemWeb.Literal)stmt.Object).Value;\n\t\t\t\t\t} else if (stmt.Predicate == MetadataStore.Namespaces.Resolve (\"tiff:ImageLength\")) {\n\t\t\t\t\tif (height == null)\n\t\t\t\t\t\theight = ((SemWeb.Literal)stmt.Object).Value;\n\t\t\t\t} else if (stmt.Predicate == MetadataStore.Namespaces.Resolve (\"exif:PixelXDimension\"))\n\t\t\t\t\twidth = ((SemWeb.Literal)stmt.Object).Value;\t\t\t\t\t\t      \n\t\t\t\telse if (stmt.Predicate == MetadataStore.Namespaces.Resolve (\"exif:PixelYDimension\"))\n\t\t\t\t\theight = ((SemWeb.Literal)stmt.Object).Value;\n\t\t\t\telse if (stmt.Predicate == MetadataStore.Namespaces.Resolve (\"exif:ExposureTime\"))\n\t\t\t\t\texposure = ((SemWeb.Literal)stmt.Object).Value;\n\t\t\t\telse if (stmt.Predicate == MetadataStore.Namespaces.Resolve (\"exif:ApertureValue\"))\n\t\t\t\t\taperture = ((SemWeb.Literal)stmt.Object).Value;\n\t\t\t\telse if (stmt.Predicate == MetadataStore.Namespaces.Resolve (\"exif:FNumber\"))\n\t\t\t\t\tfnumber = ((SemWeb.Literal)stmt.Object).Value;\n\t\t\t\telse if (stmt.Predicate == MetadataStore.Namespaces.Resolve (\"exif:ISOSpeedRatings\"))\n\t\t\t\t\tiso_anon = stmt.Object;\n\t\t\t\telse if (stmt.Predicate == MetadataStore.Namespaces.Resolve (\"exif:FocalLength\"))\n\t\t\t\t\tfocal_length = ((SemWeb.Literal)stmt.Object).Value;\n\t\t\t\telse if (stmt.Predicate == MetadataStore.Namespaces.Resolve (\"tiff:Model\"))\n\t\t\t\t\tcamera_model = ((SemWeb.Literal)stmt.Object).Value;\n\t\t\t\telse if (stmt.Subject == iso_anon && stmt.Predicate == MetadataStore.Namespaces.Resolve (\"rdf:li\"))\n\t\t\t\t\tiso_speed = ((SemWeb.Literal)stmt.Object).Value;\n\t\t\t\telse if (add && stmt.Subject.Uri == null)\n\t\t\t\t\tstore.Add (stmt);\n\n\t\t\t\tif (width == null || height == null || exposure == null || aperture == null \n\t\t\t\t    || iso_speed == null || focal_length == null || camera_model == null)\n\t\t\t\t\treturn true;\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\n\t\t\tpublic string ExposureInfo {\n\t\t\t\tget {\n\t\t\t\t\tstring info = String.Empty;\n\t\n\t\t\t\t\tif  (fnumber != null && fnumber != String.Empty) {\n\t\t\t\t\t\tFSpot.Tiff.Rational rat = new FSpot.Tiff.Rational (fnumber);\n\t\t\t\t\t\tinfo += String.Format (\"f\/{0:.0} \", rat.Value);\n\t\t\t\t\t} else if (aperture != null && aperture != String.Empty) {\n\t\t\t\t\t\t\/\/ Convert from APEX to fnumber\n\t\t\t\t\t\tFSpot.Tiff.Rational rat = new FSpot.Tiff.Rational (aperture);\n\t\t\t\t\t\tinfo += String.Format (\"f\/{0:.0} \", Math.Pow (2, rat.Value \/ 2));\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (exposure != null && exposure != String.Empty)\n\t\t\t\t\t\tinfo += exposure + \" sec \";\n\t\n\t\t\t\t\tif (iso_speed != null && iso_speed != String.Empty)\n\t\t\t\t\t\tinfo += Environment.NewLine + \"ISO \" + iso_speed;\n\t\t\t\t\t\n\t\t\t\t\tif (info == String.Empty)\n\t\t\t\t\t\treturn Catalog.GetString (\"(None)\");\n\t\t\t\t\t\n\t\t\t\t\treturn info;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tpublic string FocalLength {\n\t\t\t\tget {\n\t\t\t\t\tif (focal_length == null)\n\t\t\t\t\t\treturn Catalog.GetString (\"(Unknown)\");\n\n\t\t\t\t\tstring fl = focal_length;\n\n\t\t\t\t\tif (focal_length.Contains(\"\/\")) {\n\t\t\t\t\t\tstring[] strings = focal_length.Split('\/');\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (strings.Length == 2)\n\t\t\t\t\t\t\t\tfl = (double.Parse (strings[0]) \/ double.Parse (strings[1])).ToString ();\n\t\t\t\t\t\t} catch (FormatException) {\n\t\t\t\t\t\t\treturn Catalog.GetString (\"(wrong format)\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn fl + \" mm\";\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic string CameraModel {\n\t\t\t\tget {\n\t\t\t\t\tif (focal_length != null)\n\t\t\t\t\t\treturn camera_model;\n\t\t\t\t\telse\n\t\t\t\t\t\treturn Catalog.GetString (\"(Unknown)\");\n\t\t\t\t}\n\t\t\t}\n\n\t\n\t\t\tpublic string Dimensions {\n\t\t\t\tget {\n\t\t\t\t\tif (width != null && height != null)\n\t\t\t\t\t\treturn String.Format (\"{0}x{1}\", width, height);\n\t\t\t\t\telse \n\t\t\t\t\t\treturn Catalog.GetString (\"(Unknown)\");\n\t\t\t\t}\n\t\t\t}\n\t#if USE_EXIF_DATE\n\t\t\tpublic string Date {\n\t\t\t\tget {\n\t\t\t\t\tif (date > DateTime.MinValue && date < DateTime.MaxValue)\n\t\t\t\t\t\treturn date.ToShortDateString () + Environment.NewLine + date.ToShortTimeString ();\n\t\t\t\t\telse \n\t\t\t\t\t\treturn Catalog.GetString (\"(Unknown)\");\n\t\t\t\t}\n\t\t\t}\n\t#endif\n\t\t}\n\t\t\t\n\t\n\t\tpublic bool Update ()\n\t\t{\n\t\t\tif (Photos == null || Photos.Length == 0) {\n\t\t\t\tHide ();\n\t\t\t} else if (Photos.Length == 1) {\n\t\t\t\tUpdateSingle ();\n\t\t\t} else if (Photos.Length > 1) {\n\t\t\t\tUpdateMultiple ();\n\t\t\t}\n\t\t\treturn false;\n\t\t}\t\n\t\n\t\tprivate void UpdateSingle () \n\t\t{\n\t\t\tImageInfo info;\n\n\t\t\tPhoto photo = Photos[0];\n\n\t\t\thistogram_expander.Visible = true;\n\t\t\tUpdateHistogram ();\n\n\t\t\tif (show_name) {\n\t\t\t\tname_value_label.Text = photo.Name != null ? photo.Name : String.Empty;\n\t\t\t}\n\t\t\tname_label.Visible = show_name;\t\n\t\t\tname_value_label.Visible = show_name;\n\t\t\t\n\t\t\ttry {\n\t\t\t\t\/\/using (new Timer (\"building info\")) {\n\t\t\t\t\tusing (ImageFile img = ImageFile.Create (photo.DefaultVersionUri))\n\t\t\t\t\t{\n\t\t\t\t\t\tinfo = new ImageInfo (img);\n\t\t\t\t\t}\n\t\t\t\t\t\/\/}\n\t\t\t} catch (System.Exception e) {\n\t\t\t\tFSpot.Utils.Log.Debug (e.StackTrace);\n\t\t\t\tinfo = new ImageInfo (null);\t\t\t\n\t\t\t}\n\n\t\t\tif (show_exposure) {\n\t\t\t\texposure_value_label.Text = info.ExposureInfo;\n\t\t\t\tif (exposure_value_label.Text.IndexOf (Environment.NewLine) != -1)\n\t\t\t\t\texposure_label.Markup = default_exposure_string + Environment.NewLine;\n\t\t\t\telse\n\t\t\t\t\texposure_label.Markup = default_exposure_string;\n\t\t\t}\n\t\t\texposure_label.Visible = show_exposure;\n\t\t\texposure_value_label.Visible = show_exposure;\n\n\t\t\tif (show_size)\n\t\t\t\tsize_value_label.Text = info.Dimensions;\n\t\t\tsize_label.Visible = show_size;\n\t\t\tsize_value_label.Visible = show_size;\n\n\t\t\tif (show_date) {\n\t#if USE_EXIF_DATE\n\t\t\t\tdate_value_label.Text = info.Date;\n\t#else\n\t\t\t\tDateTime local_time = photo.Time.ToLocalTime ();\n\t\t\t\tdate_value_label.Text = String.Format (\"{0}{2}{1}\",\n\t\t\t\t                                       local_time.ToShortDateString (),\n\t\t\t\t                                       local_time.ToShortTimeString (),\n\t\t\t\t                                       Environment.NewLine\n\t\t\t\t                                       );\n\t#endif\n\t\t\t}\n\t\t\tdate_label.Visible = show_date;\n\t\t\tdate_value_label.Visible = show_date;\n\t\t\t\n\t\t\tif (show_focal_length)\n\t\t\t\tfocal_length_value_label.Text = info.FocalLength;\n\t\t\tfocal_length_label.Visible = show_focal_length;\n\t\t\tfocal_length_value_label.Visible = show_focal_length;\n\t\t\t\n\t\t\tif (show_camera)\n\t\t\t\tcamera_value_label.Text = info.CameraModel;\n\t\t\tcamera_label.Visible = show_camera;\n\t\t\tcamera_value_label.Visible = show_camera;\n\n\t\t\tversion_label.Visible = true;\n\t\t\tversion_combo.Visible = true;\n\t\t\tversion_list.Clear ();\n\t\t\tversion_combo.Changed -= OnVersionComboChanged;\n\t\t\tint i = 0;\n\t\t\tforeach (uint version_id in photo.VersionIds) {\n\t\t\t\tversion_list.AppendValues (version_id, (photo.GetVersion (version_id) as PhotoVersion).Name, true);\n\t\t\t\tif (version_id == photo.DefaultVersionId)\n\t\t\t\t\tversion_combo.Active = i;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tversion_combo.Sensitive = photo.VersionIds.Length > 1;\n\t\t\tversion_combo.Changed += OnVersionComboChanged;\n\n\t\t\tif (show_file_size) {\n\t\t\t\ttry {\n\t\t\t\t\tGFile file = FileFactory.NewForUri (photo.DefaultVersionUri);\n\t\t\t\t\tGFileInfo file_info = file.QueryInfo (\"standard::size\", FileQueryInfoFlags.None, null);\n\t\t\t\t\tfile_size_value_label.Text = Format.SizeForDisplay (file_info.Size);\n\t\t\t\t} catch (GLib.GException e) {\n\t\t\t\t\tfile_size_value_label.Text = Catalog.GetString(\"(File read error)\");\n\t\t\t\t\tFSpot.Utils.Log.DebugException (e);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfile_size_label.Visible = show_file_size;\n\t\t\tfile_size_value_label.Visible = show_file_size;\t\t\t\n\t\t\t\n\t\t\tif (show_tags)\n\t\t\t\ttag_view.Current = photo;\n\t\t\trating_label.Visible = show_rating;\n\t\t\trating_view.Visible = show_rating;\n\t\t\tif (show_rating) {\n\t\t\t\trating_view.Value = (int) photo.Rating;\n\t\t\t}\n\t\n\t\t\tShow ();\n\t\t}\n\n\t\tvoid VersionNameCellFunc (CellLayout cell_layout, CellRenderer cell, TreeModel tree_model, TreeIter iter)\n\t\t{\n\t\t\tstring name = (string)tree_model.GetValue (iter, 1);\n\t\t\t(cell as CellRendererText).Text = name;\n\n\t\t\tcell.Sensitive = (bool)tree_model.GetValue (iter, 2);\n\t\t}\n\n\n\t\tvoid OnVersionComboChanged (object o, EventArgs e)\n\t\t{\n\t\t\tComboBox combo = o as ComboBox;\n\t\t\tif (combo == null)\n\t\t\t\treturn;\n\n\t\t\tTreeIter iter;\n\n\t\t\tif (combo.GetActiveIter (out iter))\n\t\t\t\tVersionIdChanged (this, (uint)version_list.GetValue (iter, 0));\n\t\t}\n\n\t\tprivate void UpdateMultiple ()\n\t\t{\n\t\t\thistogram_expander.Visible = false;\n\n\t\t\tname_label.Visible = false;\n\t\t\tname_value_label.Text = String.Format(Catalog.GetString(\"{0} Photos\"), Photos.Length);\n\t\t\tname_value_label.Visible = true;\n\t\t\t\n\t\t\tversion_label.Visible = false;\n\t\t\tversion_combo.Visible = false;\n\n\t\t\texposure_label.Visible = false;\n\t\t\texposure_value_label.Visible = false;\n\t\t\t\n\t\t\tfocal_length_label.Visible = false;\n\t\t\tfocal_length_value_label.Visible = false;\n\t\t\t\n\t\t\tcamera_label.Visible = false;\n\t\t\tcamera_value_label.Visible = false;\n\n\t\t\tif (show_date) {\n\t\t\t\tPhoto first = Photos[Photos.Length-1];\n\t\t\t\tPhoto last = Photos[0];\n\t\t\t\tif (first.Time.Date == last.Time.Date) {\n\t\t\t\t\t\/\/Note for translators: {0} is a date, {1} and {2} are times.\n\t\t\t\t\tdate_value_label.Text = String.Format(Catalog.GetString(\"On {0} between \\n{1} and {2}\"), \n\t\t\t\t\t                                      first.Time.ToLocalTime ().ToShortDateString (),\n\t\t\t\t\t                                      first.Time.ToLocalTime ().ToShortTimeString (),\n\t\t\t\t\t                                      last.Time.ToLocalTime ().ToShortTimeString ());\n\t\t\t\t} else {\n\t\t\t\t\tdate_value_label.Text = String.Format(Catalog.GetString(\"Between {0} \\nand {1}\"),\n\t\t\t\t\t                                      first.Time.ToLocalTime ().ToShortDateString (),\n\t\t\t\t\t                                      last.Time.ToLocalTime ().ToShortDateString ());\n\t\t\t\t}\n\t\t\t}\n\t\t\tdate_label.Visible = show_date;\n\t\t\tdate_value_label.Visible = show_date;\n\t\t\t\n\t\t\tif (show_file_size) {\n\t\t\t\tlong file_size = 0;\n\t\t\t\tforeach (Photo photo in Photos) {\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tGFile file = FileFactory.NewForUri (photo.DefaultVersionUri);\n\t\t\t\t\t\tGFileInfo file_info = file.QueryInfo (\"standard::size\", FileQueryInfoFlags.None, null);\n\t\t\t\t\t\tfile_size += file_info.Size;\n\t\t\t\t\t} catch (GLib.GException e) {\n\t\t\t\t\t\tfile_size = -1;\n\t\t\t\t\t\tFSpot.Utils.Log.DebugException (e);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (file_size != -1)\n\t\t\t\t\tfile_size_value_label.Text = Format.SizeForDisplay (file_size);\n\n\t\t\t\telse\n\t\t\t\t\tfile_size_value_label.Text = Catalog.GetString(\"(At least one File not found)\");\n\t\t\t}\n\t\t\tfile_size_label.Visible = show_file_size;\n\t\t\tfile_size_value_label.Visible = show_file_size;\t\n\n\t\t\tsize_label.Visible = false;\n\t\t\tsize_value_label.Visible = false;\n\n\t\t\trating_label.Visible = false;\n\t\t\trating_view.Visible = false;\n\t\t}\n\n\t\tprivate Gdk.Pixbuf histogram_hint;\n\n\t\tprivate void UpdateHistogram ()\n\t\t{\n\t\t\tif (histogram_expander.Expanded)\n\t\t\t\thistogram_delay.Start ();\n\t\t}\n\n\t\tpublic void UpdateHistogram (Gdk.Pixbuf pixbuf) {\n\t\t\thistogram_hint = pixbuf;\n\t\t\tUpdateHistogram ();\n\t\t}\n\n\t\tprivate bool DelayedUpdateHistogram () {\n\t\t\tif (Photos.Length == 0)\n\t\t\t\treturn false;\n\n\t\t\tPhoto photo = Photos[0];\n\n\t\t\tGdk.Pixbuf hint = histogram_hint;\n\t\t\thistogram_hint = null;\n\t\t\tint max = histogram_expander.Allocation.Width;\n\n\t\t\ttry {\n\t\t\t\tif (hint == null)\n\t\t\t\t\tusing (ImageFile img = ImageFile.Create (photo.DefaultVersionUri))\n\t\t\t\t\t\thint = img.Load (256, 256);\n\t\t\t\t\n\t\t\t\thistogram_image.Pixbuf = histogram.Generate (hint, max);\n\t\t\t\t\n\t\t\t\thint.Dispose ();\n\t\t\t} catch (System.Exception e) {\n\t\t\t\tFSpot.Utils.Log.Debug (e.StackTrace);\n\t\t\t\tusing (Gdk.Pixbuf empty = new Gdk.Pixbuf (Gdk.Colorspace.Rgb, true, 8, 256, 256)) {\n\t\t\t\t\tempty.Fill (0x0);\n\t\t\t\t\thistogram_image.Pixbuf = histogram.Generate (empty, max);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\t\/\/ Context switching\n\n\t\tprivate void HandleContextChanged (object sender, EventArgs args)\n\t\t{\n\t\t\tbool infobox_visible = ContextSwitchStrategy.InfoBoxVisible (Context);\n\t\t\tinfo_expander.Expanded = infobox_visible;\n\n\t\t\tbool histogram_visible = ContextSwitchStrategy.HistogramVisible (Context);\n\t\t\thistogram_expander.Expanded = histogram_visible;\n\t\t\t\n\t\t\tshow_name = ContextSwitchStrategy.InfoBoxNameVisible (Context);\n\t\t\tshow_date = ContextSwitchStrategy.InfoBoxDateVisible (Context);\n\t\t\tshow_size = ContextSwitchStrategy.InfoBoxSizeVisible (Context);\n\t\t\tshow_exposure = ContextSwitchStrategy.InfoBoxExposureVisible (Context);\n\t\t\tshow_focal_length = ContextSwitchStrategy.InfoBoxFocalLengthVisible (Context);\n\t\t\tshow_camera = ContextSwitchStrategy.InfoBoxCameraVisible (Context);\n\t\t\tshow_file_size = ContextSwitchStrategy.InfoBoxFileSizeVisible (Context);\n\t\t\t\n\t\t\tif (infobox_visible)\n\t\t\t\tupdate_delay.Start ();\n\t\t}\n\t\n\t\tpublic void HandleMainWindowViewModeChanged (object o, EventArgs args)\n\t\t{\n\t\t\tMainWindow.ModeType mode = MainWindow.Toplevel.ViewMode;\n\t\t\tif (mode == MainWindow.ModeType.IconView)\n\t\t\t\tContext = ViewContext.Library;\n\t\t\telse if (mode == MainWindow.ModeType.PhotoView)\n\t\t\t\tContext = ViewContext.Edit;\n\t\t}\n\t\t\n\t\tvoid HandleButtonPressEvent (object sender, ButtonPressEventArgs args)\n\t\t{\n\t\t\tif (args.Event.Button == 3) {\n\t\t\t\tMenu popup_menu = new Menu ();\n\t\t\t\t\n\t\t\t\tAddMenuItems (popup_menu);\n\t\t\t\t\n\t\t\t\tif (args.Event != null)\n\t\t\t\t\tpopup_menu.Popup (null, null, null, args.Event.Button, args.Event.Time);\n\t\t\t\telse\n\t\t\t\t\tpopup_menu.Popup (null, null, null, 0, Gtk.Global.CurrentEventTime);\n\t\t\t\n\t\t\t\targs.RetVal = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid HandlePopulatePopup (object sender, PopulatePopupArgs args)\n\t\t{\t\t\t\n\t\t\tAddMenuItems (args.Menu);\n\t\t\t\n\t\t\targs.RetVal = true;\n\t\t}\n\t\t\n\t\tprivate void AddMenuItems (Menu popup_menu) {\n\t\t\t\n\t\t\tif (popup_menu.Children.Length > 0) {\n\t\t\t\tGtkUtil.MakeMenuSeparator (popup_menu);\n\t\t\t}\n\t\t\t\n\t\t\tMenuItem item;\n\t\t\t\n\t\t\titem = GtkUtil.MakeCheckMenuItem (popup_menu,\n\t\t\t                                  Catalog.GetString (\"Show Photo Name\"),\n\t\t\t                                  HandleMenuItemSelected,\n\t\t\t                                  true,\n\t\t\t                                  show_name,\n\t\t\t                                  false);\n\t\t\t\n\t\t\titem.SetData (\"cb\", name_label.Handle);\n\t\t\t\t\n\t\t\titem = GtkUtil.MakeCheckMenuItem (popup_menu,\n\t\t\t                           Catalog.GetString (\"Show Date\"),\n\t\t\t                           HandleMenuItemSelected,\n\t\t\t                           true,\n\t\t\t                           show_date,\n\t\t\t                           false);\n\t\t\t\n\t\t\titem.SetData (\"cb\", date_label.Handle);\t\t\t\n\t\t\t\n\t\t\titem = GtkUtil.MakeCheckMenuItem (popup_menu,\n\t\t\t                           Catalog.GetString (\"Show Size\"),\n\t\t\t                           HandleMenuItemSelected,\n\t\t\t                           true,\n\t\t\t                           show_size,\n\t\t\t                           false);\n\t\t\t\n\t\t\titem.SetData (\"cb\", size_label.Handle);\n\t\t\t\n\t\t\titem = GtkUtil.MakeCheckMenuItem (popup_menu,\n\t\t\t                           Catalog.GetString (\"Show Exposure\"),\n\t\t\t                           HandleMenuItemSelected,\n\t\t\t                           true,\n\t\t\t                           show_exposure,\n\t\t\t                           false);\n\t\t\t\n\t\t\titem.SetData (\"cb\", exposure_label.Handle);\n\t\t\t\n\t\t\titem = GtkUtil.MakeCheckMenuItem (popup_menu,\n\t\t\t                           Catalog.GetString (\"Show Focal Length\"),\n\t\t\t                           HandleMenuItemSelected,\n\t\t\t                           true,\n\t\t\t                           show_focal_length,\n\t\t\t                           false);\n\t\t\t\n\t\t\titem.SetData (\"cb\", focal_length_label.Handle);\n\t\t\t\n\t\t\titem = GtkUtil.MakeCheckMenuItem (popup_menu,\n\t\t\t                           Catalog.GetString (\"Show Camera\"),\n\t\t\t                           HandleMenuItemSelected,\n\t\t\t                           true,\n\t\t\t                           show_camera,\n\t\t\t                           false);\n\t\t\t\n\t\t\titem.SetData (\"cb\", camera_label.Handle);\n\t\t\t\n\t\t\titem = GtkUtil.MakeCheckMenuItem (popup_menu,\n\t\t\t                           Catalog.GetString (\"Show File Size\"),\n\t\t\t                           HandleMenuItemSelected,\n\t\t\t                           true,\n\t\t\t                           show_file_size,\n\t\t\t                           false);\n\t\t\t\n\t\t\titem.SetData (\"cb\", file_size_label.Handle);\n\t\t}\n\t\t\n\t\tprivate void HandleMenuItemSelected (object sender, EventArgs args)\n\t\t{\n\t\t\tIntPtr handle = (sender as CheckMenuItem).GetData (\"cb\");\n\t\t\t\n\t\t\tif (handle == name_label.Handle) {\n\t\t\t\tshow_name = (sender as CheckMenuItem).Active;\n\t\t\t\tContextSwitchStrategy.SetInfoBoxNameVisible (Context, show_name);\n\t\t\t} else if (handle == date_label.Handle) {\n\t\t\t\tshow_date = (sender as CheckMenuItem).Active;\n\t\t\t\tContextSwitchStrategy.SetInfoBoxDateVisible (Context, show_date);\n\t\t\t} else if (handle == size_label.Handle) {\n\t\t\t\tshow_size = (sender as CheckMenuItem).Active;\n\t\t\t\tContextSwitchStrategy.SetInfoBoxSizeVisible (Context, show_size);\n\t\t\t} else if (handle == exposure_label.Handle) {\n\t\t\t\tshow_exposure = (sender as CheckMenuItem).Active;\n\t\t\t\tContextSwitchStrategy.SetInfoBoxExposureVisible (Context, show_exposure);\n\t\t\t} else if (handle == focal_length_label.Handle) {\n\t\t\t\tshow_focal_length = (sender as CheckMenuItem).Active;\n\t\t\t\tContextSwitchStrategy.SetInfoBoxFocalLengthVisible (Context, show_focal_length);\n\t\t\t} else if (handle == camera_label.Handle) {\n\t\t\t\tshow_camera = (sender as CheckMenuItem).Active;\n\t\t\t\tContextSwitchStrategy.SetInfoBoxCameraVisible (Context, show_camera);\n\t\t\t} else if (handle == file_size_label.Handle) {\n\t\t\t\tshow_file_size = (sender as CheckMenuItem).Active;\n\t\t\t\tContextSwitchStrategy.SetInfoBoxFileSizeVisible (Context, show_file_size);\n\t\t\t}\n\t\t\t\n\t\t\tupdate_delay.Start ();\n\t\t}\n\t\n\t\t\/\/ Constructor.\n\t\n\t\tpublic InfoBox () : base (false, 0)\n\t\t{\n\t\t\tContextSwitchStrategy = new MRUInfoBoxContextSwitchStrategy ();\n\t\t\tContextChanged += HandleContextChanged;\n\n\t\t\tSetupWidgets ();\n\n\t\t\tupdate_delay = new Delay (Update);\n\t\t\tupdate_delay.Start ();\n\n\t\t\thistogram_delay = new Delay (DelayedUpdateHistogram);\n\t\t\t\n\t\t\tBorderWidth = 2;\n\t\t\tHide ();\n\t\t}\n\t}\n\n\t\/\/ Decides whether infobox \/ histogram should be shown for each context. Implemented\n\t\/\/ using the Strategy pattern, to make it swappable easily, in case the\n\t\/\/ default MRUInfoBoxContextSwitchStrategy is not sufficiently usable.\n\tpublic abstract class InfoBoxContextSwitchStrategy {\n\t\tpublic abstract bool InfoBoxVisible (ViewContext context);\n\t\tpublic abstract bool HistogramVisible (ViewContext context);\n\t\tpublic abstract bool InfoBoxNameVisible (ViewContext context);\n\t\tpublic abstract bool InfoBoxDateVisible (ViewContext context);\n\t\tpublic abstract bool InfoBoxSizeVisible (ViewContext context);\n\t\tpublic abstract bool InfoBoxExposureVisible (ViewContext context);\n\t\tpublic abstract bool InfoBoxFocalLengthVisible (ViewContext context);\n\t\tpublic abstract bool InfoBoxCameraVisible (ViewContext context);\n\t\tpublic abstract bool InfoBoxFileSizeVisible (ViewContext context);\n\n\t\tpublic abstract void SetInfoBoxVisible (ViewContext context, bool visible);\n\t\tpublic abstract void SetHistogramVisible (ViewContext context, bool visible);\n\t\tpublic abstract void SetInfoBoxNameVisible (ViewContext context, bool visible);\n\t\tpublic abstract void SetInfoBoxDateVisible (ViewContext context, bool visible);\n\t\tpublic abstract void SetInfoBoxSizeVisible (ViewContext context, bool visible);\n\t\tpublic abstract void SetInfoBoxExposureVisible (ViewContext context, bool visible);\n\t\tpublic abstract void SetInfoBoxFocalLengthVisible (ViewContext context, bool visible);\n\t\tpublic abstract void SetInfoBoxCameraVisible (ViewContext context, bool visible);\n\t\tpublic abstract void SetInfoBoxFileSizeVisible (ViewContext context, bool visible);\n\t}\n\n\t\/\/ Values are stored as strings, because bool is not nullable through Preferences.\n\tpublic class MRUInfoBoxContextSwitchStrategy : InfoBoxContextSwitchStrategy {\n\t\tpublic const string PREF_PREFIX = Preferences.APP_FSPOT + \"ui\";\n\n\t\tprivate string PrefKeyForContext (ViewContext context, string item) {\n\t\t\treturn String.Format (\"{0}\/{1}_visible\/{2}\", PREF_PREFIX, item, context);\n\t\t}\n\t\t\n\t\tprivate string PrefKeyForContext (ViewContext context, string parent, string item) {\n\t\t\treturn String.Format (\"{0}\/{1}_visible\/{2}\/{3}\", PREF_PREFIX, parent, item, context);\n\t\t}\n\n\t\tprivate bool VisibilityForContext (ViewContext context, string item, bool default_value) {\n\t\t\tstring visible = Preferences.Get<string> (PrefKeyForContext (context, item));\n\t\t\tif (visible == null)\n\t\t\t\treturn default_value;\n\t\t\telse\n\t\t\t\treturn visible == \"1\";\n\t\t}\n\t\t\n\t\tprivate bool VisibilityForContext (ViewContext context, string parent, string item, bool default_value) {\n\t\t\tstring visible = Preferences.Get<string> (PrefKeyForContext (context, parent, item));\n\t\t\tif (visible == null)\n\t\t\t\treturn default_value;\n\t\t\telse\n\t\t\t\treturn visible == \"1\";\n\t\t}\n\n\t\tprivate void SetVisibilityForContext (ViewContext context, string item, bool visible) {\n\t\t\tPreferences.Set (PrefKeyForContext (context, item), visible ? \"1\" : \"0\");\n\t\t}\n\t\t\n\t\tprivate void SetVisibilityForContext (ViewContext context, string parent, string item, bool visible) {\n\t\t\tPreferences.Set (PrefKeyForContext (context, parent, item), visible ? \"1\" : \"0\");\n\t\t}\n\n\t\tpublic override bool InfoBoxVisible (ViewContext context) {\n\t\t\treturn VisibilityForContext (context, \"infobox\", true);\n\t\t}\n\n\t\tpublic override bool HistogramVisible (ViewContext context) {\n\t\t\treturn VisibilityForContext (context, \"histogram\", true);\n\t\t}\n\t\t\n\t\tpublic override bool InfoBoxNameVisible (ViewContext context) {\n\t\t\treturn VisibilityForContext (context, \"infobox\", \"name\", true);\n\t\t}\n\t\t\n\t\tpublic override bool InfoBoxDateVisible (ViewContext context) {\n\t\t\treturn VisibilityForContext (context, \"infobox\", \"date\", true);\n\t\t}\n\t\t\n\t\tpublic override bool InfoBoxSizeVisible (ViewContext context) {\n\t\t\treturn VisibilityForContext (context, \"infobox\", \"size\", true);\n\t\t}\n\t\t\n\t\tpublic override bool InfoBoxExposureVisible (ViewContext context) {\n\t\t\treturn VisibilityForContext (context, \"infobox\", \"exposure\", true);\n\t\t}\n\t\t\n\t\tpublic override bool InfoBoxFocalLengthVisible (ViewContext context) {\n\t\t\treturn VisibilityForContext (context, \"infobox\", \"focal_length\", false);\n\t\t}\n\t\t\n\t\tpublic override bool InfoBoxCameraVisible (ViewContext context)  {\n\t\t\treturn VisibilityForContext (context, \"infobox\", \"camera\", false);\n\t\t}\n\t\t\n\t\tpublic override bool InfoBoxFileSizeVisible (ViewContext context) {\n\t\t\treturn VisibilityForContext (context, \"infobox\", \"file_size\", false);\n\t\t}\n\n\t\tpublic override void SetInfoBoxVisible (ViewContext context, bool visible) {\n\t\t\tSetVisibilityForContext (context, \"infobox\", visible);\n\t\t}\n\n\t\tpublic override void SetHistogramVisible (ViewContext context, bool visible) {\n\t\t\tSetVisibilityForContext (context, \"histogram\", visible);\n\t\t}\n\t\t\n\t\tpublic override void SetInfoBoxNameVisible (ViewContext context, bool visible) {\n\t\t\tSetVisibilityForContext (context, \"infobox\", \"name\", visible);\n\t\t}\n\t\t\n\t\tpublic override void SetInfoBoxDateVisible (ViewContext context, bool visible) {\n\t\t\tSetVisibilityForContext (context, \"infobox\", \"date\", visible);\n\t\t}\n\t\t\n\t\tpublic override void SetInfoBoxSizeVisible (ViewContext context, bool visible) {\n\t\t\tSetVisibilityForContext (context, \"infobox\", \"size\", visible);\n\t\t}\n\t\t\n\t\tpublic override void SetInfoBoxExposureVisible (ViewContext context, bool visible) {\n\t\t\tSetVisibilityForContext (context, \"infobox\", \"exposure\", visible);\n\t\t}\n\t\t\n\t\tpublic override void SetInfoBoxFocalLengthVisible (ViewContext context, bool visible) {\n\t\t\tSetVisibilityForContext (context, \"infobox\", \"focal_length\", visible);\n\t\t}\n\t\t\n\t\tpublic override void SetInfoBoxCameraVisible (ViewContext context, bool visible) {\n\t\t\tSetVisibilityForContext (context, \"infobox\", \"camera\", visible);\n\t\t}\n\t\t\n\t\tpublic override void SetInfoBoxFileSizeVisible (ViewContext context, bool visible) {\n\t\t\tSetVisibilityForContext (context, \"infobox\", \"file_size\", visible);\n\t\t}\n\t}\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"ee648c7c2c76cb9bcdf3b0833890aeafe30ea083","subject":"Invalid Mouse Over events on NC raw events","message":"Invalid Mouse Over events on NC raw events\n","repos":"grokys\/Perspex,AvaloniaUI\/Avalonia,AvaloniaUI\/Avalonia,AvaloniaUI\/Avalonia,SuperJMN\/Avalonia,SuperJMN\/Avalonia,SuperJMN\/Avalonia,AvaloniaUI\/Avalonia,AvaloniaUI\/Avalonia,SuperJMN\/Avalonia,SuperJMN\/Avalonia,SuperJMN\/Avalonia,AvaloniaUI\/Avalonia,SuperJMN\/Avalonia,AvaloniaUI\/Avalonia,grokys\/Perspex","old_file":"src\/Avalonia.Input\/MouseDevice.cs","new_file":"src\/Avalonia.Input\/MouseDevice.cs","new_contents":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reactive.Linq;\nusing Avalonia.Input.Raw;\nusing Avalonia.Interactivity;\nusing Avalonia.Platform;\nusing Avalonia.Utilities;\nusing Avalonia.VisualTree;\n\nnamespace Avalonia.Input\n{\n    \/\/\/ <summary>\n    \/\/\/ Represents a mouse device.\n    \/\/\/ <\/summary>\n    public class MouseDevice : IMouseDevice, IDisposable\n    {\n        private int _clickCount;\n        private Rect _lastClickRect;\n        private ulong _lastClickTime;\n\n        private readonly Pointer _pointer;\n        private bool _disposed;\n        private PixelPoint? _position; \n\n        public MouseDevice(Pointer? pointer = null)\n        {\n            _pointer = pointer ?? new Pointer(Pointer.GetNextFreeId(), PointerType.Mouse, true);\n        }\n        \n        \/\/\/ <summary>\n        \/\/\/ Gets the control that is currently capturing by the mouse, if any.\n        \/\/\/ <\/summary>\n        \/\/\/ <remarks>\n        \/\/\/ When an element captures the mouse, it receives mouse input whether the cursor is \n        \/\/\/ within the control's bounds or not. To set the mouse capture, call the \n        \/\/\/ <see cref=\"Capture\"\/> method.\n        \/\/\/ <\/remarks>\n        [Obsolete(\"Use IPointer instead\")]\n        public IInputElement? Captured => _pointer.Captured;\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the mouse position, in screen coordinates.\n        \/\/\/ <\/summary>\n        [Obsolete(\"Use events instead\")]\n        public PixelPoint Position\n        {\n            get => _position ?? new PixelPoint(-1, -1);\n            protected set => _position = value;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Captures mouse input to the specified control.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"control\">The control.<\/param>\n        \/\/\/ <remarks>\n        \/\/\/ When an element captures the mouse, it receives mouse input whether the cursor is \n        \/\/\/ within the control's bounds or not. The current mouse capture control is exposed\n        \/\/\/ by the <see cref=\"Captured\"\/> property.\n        \/\/\/ <\/remarks>\n        public void Capture(IInputElement? control)\n        {\n            _pointer.Capture(control);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the mouse position relative to a control.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"relativeTo\">The control.<\/param>\n        \/\/\/ <returns>The mouse position in the control's coordinates.<\/returns>\n        public Point GetPosition(IVisual relativeTo)\n        {\n            relativeTo = relativeTo ?? throw new ArgumentNullException(nameof(relativeTo));\n\n            if (relativeTo.VisualRoot == null)\n            {\n                throw new InvalidOperationException(\"Control is not attached to visual tree.\");\n            }\n\n#pragma warning disable CS0618 \/\/ Type or member is obsolete\n            var rootPoint = relativeTo.VisualRoot.PointToClient(Position);\n#pragma warning restore CS0618 \/\/ Type or member is obsolete\n            var transform = relativeTo.VisualRoot.TransformToVisual(relativeTo);\n            return rootPoint * transform!.Value;\n        }\n\n        public void ProcessRawEvent(RawInputEventArgs e)\n        {\n            if (!e.Handled && e is RawPointerEventArgs margs)\n                ProcessRawEvent(margs);\n        }\n\n        public void TopLevelClosed(IInputRoot root)\n        {\n            ClearPointerOver(this, 0, root, PointerPointProperties.None, KeyModifiers.None);\n        }\n\n        public void SceneInvalidated(IInputRoot root, Rect rect)\n        {\n            \/\/ Pointer is outside of the target area\n            if (_position == null )\n            {\n                if (root.PointerOverElement != null)\n                    ClearPointerOver(this, 0, root, PointerPointProperties.None, KeyModifiers.None);\n                return;\n            }\n            \n            \n            var clientPoint = root.PointToClient(_position.Value);\n\n            if (rect.Contains(clientPoint))\n            {\n                if (_pointer.Captured == null)\n                {\n                    SetPointerOver(this, 0 \/* TODO: proper timestamp *\/, root, clientPoint,\n                        PointerPointProperties.None, KeyModifiers.None);\n                }\n                else\n                {\n                    SetPointerOver(this, 0 \/* TODO: proper timestamp *\/, root, _pointer.Captured,\n                        PointerPointProperties.None, KeyModifiers.None);\n                }\n            }\n        }\n\n        int ButtonCount(PointerPointProperties props)\n        {\n            var rv = 0;\n            if (props.IsLeftButtonPressed)\n                rv++;\n            if (props.IsMiddleButtonPressed)\n                rv++;\n            if (props.IsRightButtonPressed)\n                rv++;\n            if (props.IsXButton1Pressed)\n                rv++;\n            if (props.IsXButton2Pressed)\n                rv++;\n            return rv;\n        }\n        \n        private void ProcessRawEvent(RawPointerEventArgs e)\n        {\n            e = e ?? throw new ArgumentNullException(nameof(e));\n\n            var mouse = (MouseDevice)e.Device;\n            if(mouse._disposed)\n                return;\n\n            if (e.Type == RawPointerEventType.NonClientLeftButtonDown) return;\n\n            _position = e.Root.PointToScreen(e.Position);\n            var props = CreateProperties(e);\n            var keyModifiers = KeyModifiersUtils.ConvertToKey(e.InputModifiers);\n            switch (e.Type)\n            {\n                case RawPointerEventType.LeaveWindow:\n                    LeaveWindow(mouse, e.Timestamp, e.Root, props, keyModifiers);\n                    break;\n                case RawPointerEventType.LeftButtonDown:\n                case RawPointerEventType.RightButtonDown:\n                case RawPointerEventType.MiddleButtonDown:\n                case RawPointerEventType.XButton1Down:\n                case RawPointerEventType.XButton2Down:\n                    if (ButtonCount(props) > 1)\n                        e.Handled = MouseMove(mouse, e.Timestamp, e.Root, e.Position, props, keyModifiers, e.IntermediatePoints);\n                    else\n                        e.Handled = MouseDown(mouse, e.Timestamp, e.Root, e.Position,\n                            props, keyModifiers);\n                    break;\n                case RawPointerEventType.LeftButtonUp:\n                case RawPointerEventType.RightButtonUp:\n                case RawPointerEventType.MiddleButtonUp:\n                case RawPointerEventType.XButton1Up:\n                case RawPointerEventType.XButton2Up:\n                    if (ButtonCount(props) != 0)\n                        e.Handled = MouseMove(mouse, e.Timestamp, e.Root, e.Position, props, keyModifiers, e.IntermediatePoints);\n                    else\n                        e.Handled = MouseUp(mouse, e.Timestamp, e.Root, e.Position, props, keyModifiers);\n                    break;\n                case RawPointerEventType.Move:\n                    e.Handled = MouseMove(mouse, e.Timestamp, e.Root, e.Position, props, keyModifiers, e.IntermediatePoints);\n                    break;\n                case RawPointerEventType.Wheel:\n                    e.Handled = MouseWheel(mouse, e.Timestamp, e.Root, e.Position, props, ((RawMouseWheelEventArgs)e).Delta, keyModifiers);\n                    break;\n                case RawPointerEventType.Magnify:\n                    e.Handled = GestureMagnify(mouse, e.Timestamp, e.Root, e.Position, props, ((RawPointerGestureEventArgs)e).Delta, keyModifiers);\n                    break;\n                case RawPointerEventType.Rotate:\n                    e.Handled = GestureRotate(mouse, e.Timestamp, e.Root, e.Position, props, ((RawPointerGestureEventArgs)e).Delta, keyModifiers);\n                    break;\n                case RawPointerEventType.Swipe:\n                    e.Handled = GestureSwipe(mouse, e.Timestamp, e.Root, e.Position, props, ((RawPointerGestureEventArgs)e).Delta, keyModifiers);\n                    break;\n            }\n        }\n\n        private void LeaveWindow(IMouseDevice device, ulong timestamp, IInputRoot root, PointerPointProperties properties,\n            KeyModifiers inputModifiers)\n        {\n            device = device ?? throw new ArgumentNullException(nameof(device));\n            root = root ?? throw new ArgumentNullException(nameof(root));\n\n            _position = null;\n            ClearPointerOver(this, timestamp, root, properties, inputModifiers);\n        }\n\n\n        PointerPointProperties CreateProperties(RawPointerEventArgs args)\n        {\n\n            var kind = PointerUpdateKind.Other;\n\n            if (args.Type == RawPointerEventType.LeftButtonDown)\n                kind = PointerUpdateKind.LeftButtonPressed;\n            if (args.Type == RawPointerEventType.MiddleButtonDown)\n                kind = PointerUpdateKind.MiddleButtonPressed;\n            if (args.Type == RawPointerEventType.RightButtonDown)\n                kind = PointerUpdateKind.RightButtonPressed;\n            if (args.Type == RawPointerEventType.XButton1Down)\n                kind = PointerUpdateKind.XButton1Pressed;\n            if (args.Type == RawPointerEventType.XButton2Down)\n                kind = PointerUpdateKind.XButton2Pressed;\n            if (args.Type == RawPointerEventType.LeftButtonUp)\n                kind = PointerUpdateKind.LeftButtonReleased;\n            if (args.Type == RawPointerEventType.MiddleButtonUp)\n                kind = PointerUpdateKind.MiddleButtonReleased;\n            if (args.Type == RawPointerEventType.RightButtonUp)\n                kind = PointerUpdateKind.RightButtonReleased;\n            if (args.Type == RawPointerEventType.XButton1Up)\n                kind = PointerUpdateKind.XButton1Released;\n            if (args.Type == RawPointerEventType.XButton2Up)\n                kind = PointerUpdateKind.XButton2Released;\n            \n            return new PointerPointProperties(args.InputModifiers, kind);\n        }\n\n        private MouseButton _lastMouseDownButton;\n        private bool MouseDown(IMouseDevice device, ulong timestamp, IInputElement root, Point p,\n            PointerPointProperties properties,\n            KeyModifiers inputModifiers)\n        {\n            device = device ?? throw new ArgumentNullException(nameof(device));\n            root = root ?? throw new ArgumentNullException(nameof(root));\n\n            var hit = HitTest(root, p);\n\n            if (hit != null)\n            {\n                _pointer.Capture(hit);\n                var source = GetSource(hit);\n                if (source != null)\n                {\n                    var settings = AvaloniaLocator.Current.GetService<IPlatformSettings>();\n                    var doubleClickTime = settings?.DoubleClickTime.TotalMilliseconds ?? 500;\n                    var doubleClickSize = settings?.DoubleClickSize ?? new Size(4, 4);\n\n                    if (!_lastClickRect.Contains(p) || timestamp - _lastClickTime > doubleClickTime)\n                    {\n                        _clickCount = 0;\n                    }\n\n                    ++_clickCount;\n                    _lastClickTime = timestamp;\n                    _lastClickRect = new Rect(p, new Size())\n                        .Inflate(new Thickness(doubleClickSize.Width \/ 2, doubleClickSize.Height \/ 2));\n                    _lastMouseDownButton = properties.PointerUpdateKind.GetMouseButton();\n                    var e = new PointerPressedEventArgs(source, _pointer, root, p, timestamp, properties, inputModifiers, _clickCount);\n                    source.RaiseEvent(e);\n                    return e.Handled;\n                }\n            }\n\n            return false;\n        }\n\n        private bool MouseMove(IMouseDevice device, ulong timestamp, IInputRoot root, Point p, PointerPointProperties properties,\n            KeyModifiers inputModifiers, Lazy<IReadOnlyList<RawPointerPoint>?>? intermediatePoints)\n        {\n            device = device ?? throw new ArgumentNullException(nameof(device));\n            root = root ?? throw new ArgumentNullException(nameof(root));\n\n            IInputElement? source;\n\n            if (_pointer.Captured == null)\n            {\n                source = SetPointerOver(this, timestamp, root, p,  properties, inputModifiers);\n            }\n            else\n            {\n                SetPointerOver(this, timestamp, root, _pointer.Captured, properties, inputModifiers);\n                source = _pointer.Captured;\n            }\n\n            if (source is object)\n            {\n                var e = new PointerEventArgs(InputElement.PointerMovedEvent, source, _pointer, root,\n                    p, timestamp, properties, inputModifiers, intermediatePoints);\n\n                source.RaiseEvent(e);\n                return e.Handled;\n            }\n\n            return false;\n        }\n\n        private bool MouseUp(IMouseDevice device, ulong timestamp, IInputRoot root, Point p, PointerPointProperties props,\n            KeyModifiers inputModifiers)\n        {\n            device = device ?? throw new ArgumentNullException(nameof(device));\n            root = root ?? throw new ArgumentNullException(nameof(root));\n\n            var hit = HitTest(root, p);\n            var source = GetSource(hit);\n\n            if (source is not null)\n            {\n                var e = new PointerReleasedEventArgs(source, _pointer, root, p, timestamp, props, inputModifiers,\n                    _lastMouseDownButton);\n\n                source?.RaiseEvent(e);\n                _pointer.Capture(null);\n                return e.Handled;\n            }\n\n            return false;\n        }\n\n        private bool MouseWheel(IMouseDevice device, ulong timestamp, IInputRoot root, Point p,\n            PointerPointProperties props,\n            Vector delta, KeyModifiers inputModifiers)\n        {\n            device = device ?? throw new ArgumentNullException(nameof(device));\n            root = root ?? throw new ArgumentNullException(nameof(root));\n\n            var hit = HitTest(root, p);\n            var source = GetSource(hit);\n\n            \/\/ KeyModifiers.Shift should scroll in horizontal direction. This does not work on every platform. \n            \/\/ If Shift-Key is pressed and X is close to 0 we swap the Vector.\n            if (inputModifiers == KeyModifiers.Shift && MathUtilities.IsZero(delta.X))\n            {\n                delta = new Vector(delta.Y, delta.X);\n            }\n\n            if (source is not null)\n            {\n                var e = new PointerWheelEventArgs(source, _pointer, root, p, timestamp, props, inputModifiers, delta);\n\n                source?.RaiseEvent(e);\n                return e.Handled;\n            }\n\n            return false;\n        }\n        \n        private bool GestureMagnify(IMouseDevice device, ulong timestamp, IInputRoot root, Point p,\n            PointerPointProperties props, Vector delta, KeyModifiers inputModifiers)\n        {\n            device = device ?? throw new ArgumentNullException(nameof(device));\n            root = root ?? throw new ArgumentNullException(nameof(root));\n\n            var hit = HitTest(root, p);\n\n            if (hit != null)\n            {\n                var source = GetSource(hit);\n                var e = new PointerDeltaEventArgs(Gestures.PointerTouchPadGestureMagnifyEvent, source,\n                    _pointer, root, p, timestamp, props, inputModifiers, delta);\n\n                source?.RaiseEvent(e);\n                return e.Handled;\n            }\n\n            return false;\n        }\n        \n        private bool GestureRotate(IMouseDevice device, ulong timestamp, IInputRoot root, Point p,\n            PointerPointProperties props, Vector delta, KeyModifiers inputModifiers)\n        {\n            device = device ?? throw new ArgumentNullException(nameof(device));\n            root = root ?? throw new ArgumentNullException(nameof(root));\n\n            var hit = HitTest(root, p);\n\n            if (hit != null)\n            {\n                var source = GetSource(hit);\n                var e = new PointerDeltaEventArgs(Gestures.PointerTouchPadGestureRotateEvent, source,\n                    _pointer, root, p, timestamp, props, inputModifiers, delta);\n\n                source?.RaiseEvent(e);\n                return e.Handled;\n            }\n\n            return false;\n        }\n        \n        private bool GestureSwipe(IMouseDevice device, ulong timestamp, IInputRoot root, Point p,\n            PointerPointProperties props, Vector delta, KeyModifiers inputModifiers)\n        {\n            device = device ?? throw new ArgumentNullException(nameof(device));\n            root = root ?? throw new ArgumentNullException(nameof(root));\n\n            var hit = HitTest(root, p);\n\n            if (hit != null)\n            {\n                var source = GetSource(hit);\n                var e = new PointerDeltaEventArgs(Gestures.PointerTouchPadGestureSwipeEvent, source, \n                    _pointer, root, p, timestamp, props, inputModifiers, delta);\n\n                source?.RaiseEvent(e);\n                return e.Handled;\n            }\n\n            return false;\n        }\n\n        private IInteractive? GetSource(IVisual? hit)\n        {\n            if (hit is null)\n                return null;\n\n            return _pointer.Captured ??\n                (hit as IInteractive) ??\n                hit.GetSelfAndVisualAncestors().OfType<IInteractive>().FirstOrDefault();\n        }\n\n        private IInputElement? HitTest(IInputElement root, Point p)\n        {\n            root = root ?? throw new ArgumentNullException(nameof(root));\n\n            return _pointer.Captured ?? root.InputHitTest(p);\n        }\n\n        PointerEventArgs CreateSimpleEvent(RoutedEvent ev, ulong timestamp, IInteractive? source,\n            PointerPointProperties properties,\n            KeyModifiers inputModifiers)\n        {\n            return new PointerEventArgs(ev, source, _pointer, null, default,\n                timestamp, properties, inputModifiers);\n        }\n\n        private void ClearPointerOver(IPointerDevice device, ulong timestamp, IInputRoot root,\n            PointerPointProperties properties,\n            KeyModifiers inputModifiers)\n        {\n            device = device ?? throw new ArgumentNullException(nameof(device));\n            root = root ?? throw new ArgumentNullException(nameof(root));\n\n            var element = root.PointerOverElement;\n            var e = CreateSimpleEvent(InputElement.PointerLeaveEvent, timestamp, element, properties, inputModifiers);\n\n            if (element!=null && !element.IsAttachedToVisualTree)\n            {\n                \/\/ element has been removed from visual tree so do top down cleanup\n                if (root.IsPointerOver)\n                    ClearChildrenPointerOver(e, root,true);\n            }\n            while (element != null)\n            {\n                e.Source = element;\n                e.Handled = false;\n                element.RaiseEvent(e);\n                element = (IInputElement?)element.VisualParent;\n            }\n            \n            root.PointerOverElement = null;\n        }\n\n        private void ClearChildrenPointerOver(PointerEventArgs e, IInputElement element,bool clearRoot)\n        {\n            foreach (IInputElement el in element.VisualChildren)\n            {\n                if (el.IsPointerOver)\n                {\n                    ClearChildrenPointerOver(e, el, true);\n                    break;\n                }\n            }\n            if(clearRoot)\n            {\n                e.Source = element;\n                e.Handled = false;\n                element.RaiseEvent(e);\n            }\n        }\n\n        private IInputElement? SetPointerOver(IPointerDevice device, ulong timestamp, IInputRoot root, Point p, \n            PointerPointProperties properties,\n            KeyModifiers inputModifiers)\n        {\n            device = device ?? throw new ArgumentNullException(nameof(device));\n            root = root ?? throw new ArgumentNullException(nameof(root));\n\n            var element = root.InputHitTest(p);\n\n            if (element != root.PointerOverElement)\n            {\n                if (element != null)\n                {\n                    SetPointerOver(device, timestamp, root, element, properties, inputModifiers);\n                }\n                else\n                {\n                    ClearPointerOver(device, timestamp, root, properties, inputModifiers);\n                }\n            }\n\n            return element;\n        }\n\n        private void SetPointerOver(IPointerDevice device, ulong timestamp, IInputRoot root, IInputElement element,\n            PointerPointProperties properties,\n            KeyModifiers inputModifiers)\n        {\n            device = device ?? throw new ArgumentNullException(nameof(device));\n            root = root ?? throw new ArgumentNullException(nameof(root));\n            element = element ?? throw new ArgumentNullException(nameof(element));\n\n            IInputElement? branch = null;\n\n            IInputElement? el = element;\n\n            while (el != null)\n            {\n                if (el.IsPointerOver)\n                {\n                    branch = el;\n                    break;\n                }\n                el = (IInputElement?)el.VisualParent;\n            }\n\n            el = root.PointerOverElement;\n\n            var e = CreateSimpleEvent(InputElement.PointerLeaveEvent, timestamp, el, properties, inputModifiers);\n            if (el!=null && branch!=null && !el.IsAttachedToVisualTree)\n            {\n                ClearChildrenPointerOver(e,branch,false);\n            }\n            \n            while (el != null && el != branch)\n            {\n                e.Source = el;\n                e.Handled = false;\n                el.RaiseEvent(e);\n                el = (IInputElement?)el.VisualParent;\n            }            \n\n            el = root.PointerOverElement = element;\n            e.RoutedEvent = InputElement.PointerEnterEvent;\n\n            while (el != null && el != branch)\n            {\n                e.Source = el;\n                e.Handled = false;\n                el.RaiseEvent(e);\n                el = (IInputElement?)el.VisualParent;\n            }\n        }\n\n        public void Dispose()\n        {\n            _disposed = true;\n            _pointer?.Dispose();\n        }\n    }\n}\n","old_contents":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reactive.Linq;\nusing Avalonia.Input.Raw;\nusing Avalonia.Interactivity;\nusing Avalonia.Platform;\nusing Avalonia.Utilities;\nusing Avalonia.VisualTree;\n\nnamespace Avalonia.Input\n{\n    \/\/\/ <summary>\n    \/\/\/ Represents a mouse device.\n    \/\/\/ <\/summary>\n    public class MouseDevice : IMouseDevice, IDisposable\n    {\n        private int _clickCount;\n        private Rect _lastClickRect;\n        private ulong _lastClickTime;\n\n        private readonly Pointer _pointer;\n        private bool _disposed;\n        private PixelPoint? _position; \n\n        public MouseDevice(Pointer? pointer = null)\n        {\n            _pointer = pointer ?? new Pointer(Pointer.GetNextFreeId(), PointerType.Mouse, true);\n        }\n        \n        \/\/\/ <summary>\n        \/\/\/ Gets the control that is currently capturing by the mouse, if any.\n        \/\/\/ <\/summary>\n        \/\/\/ <remarks>\n        \/\/\/ When an element captures the mouse, it receives mouse input whether the cursor is \n        \/\/\/ within the control's bounds or not. To set the mouse capture, call the \n        \/\/\/ <see cref=\"Capture\"\/> method.\n        \/\/\/ <\/remarks>\n        [Obsolete(\"Use IPointer instead\")]\n        public IInputElement? Captured => _pointer.Captured;\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the mouse position, in screen coordinates.\n        \/\/\/ <\/summary>\n        [Obsolete(\"Use events instead\")]\n        public PixelPoint Position\n        {\n            get => _position ?? new PixelPoint(-1, -1);\n            protected set => _position = value;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Captures mouse input to the specified control.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"control\">The control.<\/param>\n        \/\/\/ <remarks>\n        \/\/\/ When an element captures the mouse, it receives mouse input whether the cursor is \n        \/\/\/ within the control's bounds or not. The current mouse capture control is exposed\n        \/\/\/ by the <see cref=\"Captured\"\/> property.\n        \/\/\/ <\/remarks>\n        public void Capture(IInputElement? control)\n        {\n            _pointer.Capture(control);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the mouse position relative to a control.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"relativeTo\">The control.<\/param>\n        \/\/\/ <returns>The mouse position in the control's coordinates.<\/returns>\n        public Point GetPosition(IVisual relativeTo)\n        {\n            relativeTo = relativeTo ?? throw new ArgumentNullException(nameof(relativeTo));\n\n            if (relativeTo.VisualRoot == null)\n            {\n                throw new InvalidOperationException(\"Control is not attached to visual tree.\");\n            }\n\n#pragma warning disable CS0618 \/\/ Type or member is obsolete\n            var rootPoint = relativeTo.VisualRoot.PointToClient(Position);\n#pragma warning restore CS0618 \/\/ Type or member is obsolete\n            var transform = relativeTo.VisualRoot.TransformToVisual(relativeTo);\n            return rootPoint * transform!.Value;\n        }\n\n        public void ProcessRawEvent(RawInputEventArgs e)\n        {\n            if (!e.Handled && e is RawPointerEventArgs margs)\n                ProcessRawEvent(margs);\n        }\n\n        public void TopLevelClosed(IInputRoot root)\n        {\n            ClearPointerOver(this, 0, root, PointerPointProperties.None, KeyModifiers.None);\n        }\n\n        public void SceneInvalidated(IInputRoot root, Rect rect)\n        {\n            \/\/ Pointer is outside of the target area\n            if (_position == null )\n            {\n                if (root.PointerOverElement != null)\n                    ClearPointerOver(this, 0, root, PointerPointProperties.None, KeyModifiers.None);\n                return;\n            }\n            \n            \n            var clientPoint = root.PointToClient(_position.Value);\n\n            if (rect.Contains(clientPoint))\n            {\n                if (_pointer.Captured == null)\n                {\n                    SetPointerOver(this, 0 \/* TODO: proper timestamp *\/, root, clientPoint,\n                        PointerPointProperties.None, KeyModifiers.None);\n                }\n                else\n                {\n                    SetPointerOver(this, 0 \/* TODO: proper timestamp *\/, root, _pointer.Captured,\n                        PointerPointProperties.None, KeyModifiers.None);\n                }\n            }\n        }\n\n        int ButtonCount(PointerPointProperties props)\n        {\n            var rv = 0;\n            if (props.IsLeftButtonPressed)\n                rv++;\n            if (props.IsMiddleButtonPressed)\n                rv++;\n            if (props.IsRightButtonPressed)\n                rv++;\n            if (props.IsXButton1Pressed)\n                rv++;\n            if (props.IsXButton2Pressed)\n                rv++;\n            return rv;\n        }\n        \n        private void ProcessRawEvent(RawPointerEventArgs e)\n        {\n            e = e ?? throw new ArgumentNullException(nameof(e));\n\n            var mouse = (MouseDevice)e.Device;\n            if(mouse._disposed)\n                return;\n\n            _position = e.Root.PointToScreen(e.Position);\n            var props = CreateProperties(e);\n            var keyModifiers = KeyModifiersUtils.ConvertToKey(e.InputModifiers);\n            switch (e.Type)\n            {\n                case RawPointerEventType.LeaveWindow:\n                    LeaveWindow(mouse, e.Timestamp, e.Root, props, keyModifiers);\n                    break;\n                case RawPointerEventType.LeftButtonDown:\n                case RawPointerEventType.RightButtonDown:\n                case RawPointerEventType.MiddleButtonDown:\n                case RawPointerEventType.XButton1Down:\n                case RawPointerEventType.XButton2Down:\n                    if (ButtonCount(props) > 1)\n                        e.Handled = MouseMove(mouse, e.Timestamp, e.Root, e.Position, props, keyModifiers, e.IntermediatePoints);\n                    else\n                        e.Handled = MouseDown(mouse, e.Timestamp, e.Root, e.Position,\n                            props, keyModifiers);\n                    break;\n                case RawPointerEventType.LeftButtonUp:\n                case RawPointerEventType.RightButtonUp:\n                case RawPointerEventType.MiddleButtonUp:\n                case RawPointerEventType.XButton1Up:\n                case RawPointerEventType.XButton2Up:\n                    if (ButtonCount(props) != 0)\n                        e.Handled = MouseMove(mouse, e.Timestamp, e.Root, e.Position, props, keyModifiers, e.IntermediatePoints);\n                    else\n                        e.Handled = MouseUp(mouse, e.Timestamp, e.Root, e.Position, props, keyModifiers);\n                    break;\n                case RawPointerEventType.Move:\n                    e.Handled = MouseMove(mouse, e.Timestamp, e.Root, e.Position, props, keyModifiers, e.IntermediatePoints);\n                    break;\n                case RawPointerEventType.Wheel:\n                    e.Handled = MouseWheel(mouse, e.Timestamp, e.Root, e.Position, props, ((RawMouseWheelEventArgs)e).Delta, keyModifiers);\n                    break;\n                case RawPointerEventType.Magnify:\n                    e.Handled = GestureMagnify(mouse, e.Timestamp, e.Root, e.Position, props, ((RawPointerGestureEventArgs)e).Delta, keyModifiers);\n                    break;\n                case RawPointerEventType.Rotate:\n                    e.Handled = GestureRotate(mouse, e.Timestamp, e.Root, e.Position, props, ((RawPointerGestureEventArgs)e).Delta, keyModifiers);\n                    break;\n                case RawPointerEventType.Swipe:\n                    e.Handled = GestureSwipe(mouse, e.Timestamp, e.Root, e.Position, props, ((RawPointerGestureEventArgs)e).Delta, keyModifiers);\n                    break;\n            }\n        }\n\n        private void LeaveWindow(IMouseDevice device, ulong timestamp, IInputRoot root, PointerPointProperties properties,\n            KeyModifiers inputModifiers)\n        {\n            device = device ?? throw new ArgumentNullException(nameof(device));\n            root = root ?? throw new ArgumentNullException(nameof(root));\n\n            _position = null;\n            ClearPointerOver(this, timestamp, root, properties, inputModifiers);\n        }\n\n\n        PointerPointProperties CreateProperties(RawPointerEventArgs args)\n        {\n\n            var kind = PointerUpdateKind.Other;\n\n            if (args.Type == RawPointerEventType.LeftButtonDown)\n                kind = PointerUpdateKind.LeftButtonPressed;\n            if (args.Type == RawPointerEventType.MiddleButtonDown)\n                kind = PointerUpdateKind.MiddleButtonPressed;\n            if (args.Type == RawPointerEventType.RightButtonDown)\n                kind = PointerUpdateKind.RightButtonPressed;\n            if (args.Type == RawPointerEventType.XButton1Down)\n                kind = PointerUpdateKind.XButton1Pressed;\n            if (args.Type == RawPointerEventType.XButton2Down)\n                kind = PointerUpdateKind.XButton2Pressed;\n            if (args.Type == RawPointerEventType.LeftButtonUp)\n                kind = PointerUpdateKind.LeftButtonReleased;\n            if (args.Type == RawPointerEventType.MiddleButtonUp)\n                kind = PointerUpdateKind.MiddleButtonReleased;\n            if (args.Type == RawPointerEventType.RightButtonUp)\n                kind = PointerUpdateKind.RightButtonReleased;\n            if (args.Type == RawPointerEventType.XButton1Up)\n                kind = PointerUpdateKind.XButton1Released;\n            if (args.Type == RawPointerEventType.XButton2Up)\n                kind = PointerUpdateKind.XButton2Released;\n            \n            return new PointerPointProperties(args.InputModifiers, kind);\n        }\n\n        private MouseButton _lastMouseDownButton;\n        private bool MouseDown(IMouseDevice device, ulong timestamp, IInputElement root, Point p,\n            PointerPointProperties properties,\n            KeyModifiers inputModifiers)\n        {\n            device = device ?? throw new ArgumentNullException(nameof(device));\n            root = root ?? throw new ArgumentNullException(nameof(root));\n\n            var hit = HitTest(root, p);\n\n            if (hit != null)\n            {\n                _pointer.Capture(hit);\n                var source = GetSource(hit);\n                if (source != null)\n                {\n                    var settings = AvaloniaLocator.Current.GetService<IPlatformSettings>();\n                    var doubleClickTime = settings?.DoubleClickTime.TotalMilliseconds ?? 500;\n                    var doubleClickSize = settings?.DoubleClickSize ?? new Size(4, 4);\n\n                    if (!_lastClickRect.Contains(p) || timestamp - _lastClickTime > doubleClickTime)\n                    {\n                        _clickCount = 0;\n                    }\n\n                    ++_clickCount;\n                    _lastClickTime = timestamp;\n                    _lastClickRect = new Rect(p, new Size())\n                        .Inflate(new Thickness(doubleClickSize.Width \/ 2, doubleClickSize.Height \/ 2));\n                    _lastMouseDownButton = properties.PointerUpdateKind.GetMouseButton();\n                    var e = new PointerPressedEventArgs(source, _pointer, root, p, timestamp, properties, inputModifiers, _clickCount);\n                    source.RaiseEvent(e);\n                    return e.Handled;\n                }\n            }\n\n            return false;\n        }\n\n        private bool MouseMove(IMouseDevice device, ulong timestamp, IInputRoot root, Point p, PointerPointProperties properties,\n            KeyModifiers inputModifiers, Lazy<IReadOnlyList<RawPointerPoint>?>? intermediatePoints)\n        {\n            device = device ?? throw new ArgumentNullException(nameof(device));\n            root = root ?? throw new ArgumentNullException(nameof(root));\n\n            IInputElement? source;\n\n            if (_pointer.Captured == null)\n            {\n                source = SetPointerOver(this, timestamp, root, p,  properties, inputModifiers);\n            }\n            else\n            {\n                SetPointerOver(this, timestamp, root, _pointer.Captured, properties, inputModifiers);\n                source = _pointer.Captured;\n            }\n\n            if (source is object)\n            {\n                var e = new PointerEventArgs(InputElement.PointerMovedEvent, source, _pointer, root,\n                    p, timestamp, properties, inputModifiers, intermediatePoints);\n\n                source.RaiseEvent(e);\n                return e.Handled;\n            }\n\n            return false;\n        }\n\n        private bool MouseUp(IMouseDevice device, ulong timestamp, IInputRoot root, Point p, PointerPointProperties props,\n            KeyModifiers inputModifiers)\n        {\n            device = device ?? throw new ArgumentNullException(nameof(device));\n            root = root ?? throw new ArgumentNullException(nameof(root));\n\n            var hit = HitTest(root, p);\n            var source = GetSource(hit);\n\n            if (source is not null)\n            {\n                var e = new PointerReleasedEventArgs(source, _pointer, root, p, timestamp, props, inputModifiers,\n                    _lastMouseDownButton);\n\n                source?.RaiseEvent(e);\n                _pointer.Capture(null);\n                return e.Handled;\n            }\n\n            return false;\n        }\n\n        private bool MouseWheel(IMouseDevice device, ulong timestamp, IInputRoot root, Point p,\n            PointerPointProperties props,\n            Vector delta, KeyModifiers inputModifiers)\n        {\n            device = device ?? throw new ArgumentNullException(nameof(device));\n            root = root ?? throw new ArgumentNullException(nameof(root));\n\n            var hit = HitTest(root, p);\n            var source = GetSource(hit);\n\n            \/\/ KeyModifiers.Shift should scroll in horizontal direction. This does not work on every platform. \n            \/\/ If Shift-Key is pressed and X is close to 0 we swap the Vector.\n            if (inputModifiers == KeyModifiers.Shift && MathUtilities.IsZero(delta.X))\n            {\n                delta = new Vector(delta.Y, delta.X);\n            }\n\n            if (source is not null)\n            {\n                var e = new PointerWheelEventArgs(source, _pointer, root, p, timestamp, props, inputModifiers, delta);\n\n                source?.RaiseEvent(e);\n                return e.Handled;\n            }\n\n            return false;\n        }\n        \n        private bool GestureMagnify(IMouseDevice device, ulong timestamp, IInputRoot root, Point p,\n            PointerPointProperties props, Vector delta, KeyModifiers inputModifiers)\n        {\n            device = device ?? throw new ArgumentNullException(nameof(device));\n            root = root ?? throw new ArgumentNullException(nameof(root));\n\n            var hit = HitTest(root, p);\n\n            if (hit != null)\n            {\n                var source = GetSource(hit);\n                var e = new PointerDeltaEventArgs(Gestures.PointerTouchPadGestureMagnifyEvent, source,\n                    _pointer, root, p, timestamp, props, inputModifiers, delta);\n\n                source?.RaiseEvent(e);\n                return e.Handled;\n            }\n\n            return false;\n        }\n        \n        private bool GestureRotate(IMouseDevice device, ulong timestamp, IInputRoot root, Point p,\n            PointerPointProperties props, Vector delta, KeyModifiers inputModifiers)\n        {\n            device = device ?? throw new ArgumentNullException(nameof(device));\n            root = root ?? throw new ArgumentNullException(nameof(root));\n\n            var hit = HitTest(root, p);\n\n            if (hit != null)\n            {\n                var source = GetSource(hit);\n                var e = new PointerDeltaEventArgs(Gestures.PointerTouchPadGestureRotateEvent, source,\n                    _pointer, root, p, timestamp, props, inputModifiers, delta);\n\n                source?.RaiseEvent(e);\n                return e.Handled;\n            }\n\n            return false;\n        }\n        \n        private bool GestureSwipe(IMouseDevice device, ulong timestamp, IInputRoot root, Point p,\n            PointerPointProperties props, Vector delta, KeyModifiers inputModifiers)\n        {\n            device = device ?? throw new ArgumentNullException(nameof(device));\n            root = root ?? throw new ArgumentNullException(nameof(root));\n\n            var hit = HitTest(root, p);\n\n            if (hit != null)\n            {\n                var source = GetSource(hit);\n                var e = new PointerDeltaEventArgs(Gestures.PointerTouchPadGestureSwipeEvent, source, \n                    _pointer, root, p, timestamp, props, inputModifiers, delta);\n\n                source?.RaiseEvent(e);\n                return e.Handled;\n            }\n\n            return false;\n        }\n\n        private IInteractive? GetSource(IVisual? hit)\n        {\n            if (hit is null)\n                return null;\n\n            return _pointer.Captured ??\n                (hit as IInteractive) ??\n                hit.GetSelfAndVisualAncestors().OfType<IInteractive>().FirstOrDefault();\n        }\n\n        private IInputElement? HitTest(IInputElement root, Point p)\n        {\n            root = root ?? throw new ArgumentNullException(nameof(root));\n\n            return _pointer.Captured ?? root.InputHitTest(p);\n        }\n\n        PointerEventArgs CreateSimpleEvent(RoutedEvent ev, ulong timestamp, IInteractive? source,\n            PointerPointProperties properties,\n            KeyModifiers inputModifiers)\n        {\n            return new PointerEventArgs(ev, source, _pointer, null, default,\n                timestamp, properties, inputModifiers);\n        }\n\n        private void ClearPointerOver(IPointerDevice device, ulong timestamp, IInputRoot root,\n            PointerPointProperties properties,\n            KeyModifiers inputModifiers)\n        {\n            device = device ?? throw new ArgumentNullException(nameof(device));\n            root = root ?? throw new ArgumentNullException(nameof(root));\n\n            var element = root.PointerOverElement;\n            var e = CreateSimpleEvent(InputElement.PointerLeaveEvent, timestamp, element, properties, inputModifiers);\n\n            if (element!=null && !element.IsAttachedToVisualTree)\n            {\n                \/\/ element has been removed from visual tree so do top down cleanup\n                if (root.IsPointerOver)\n                    ClearChildrenPointerOver(e, root,true);\n            }\n            while (element != null)\n            {\n                e.Source = element;\n                e.Handled = false;\n                element.RaiseEvent(e);\n                element = (IInputElement?)element.VisualParent;\n            }\n            \n            root.PointerOverElement = null;\n        }\n\n        private void ClearChildrenPointerOver(PointerEventArgs e, IInputElement element,bool clearRoot)\n        {\n            foreach (IInputElement el in element.VisualChildren)\n            {\n                if (el.IsPointerOver)\n                {\n                    ClearChildrenPointerOver(e, el, true);\n                    break;\n                }\n            }\n            if(clearRoot)\n            {\n                e.Source = element;\n                e.Handled = false;\n                element.RaiseEvent(e);\n            }\n        }\n\n        private IInputElement? SetPointerOver(IPointerDevice device, ulong timestamp, IInputRoot root, Point p, \n            PointerPointProperties properties,\n            KeyModifiers inputModifiers)\n        {\n            device = device ?? throw new ArgumentNullException(nameof(device));\n            root = root ?? throw new ArgumentNullException(nameof(root));\n\n            var element = root.InputHitTest(p);\n\n            if (element != root.PointerOverElement)\n            {\n                if (element != null)\n                {\n                    SetPointerOver(device, timestamp, root, element, properties, inputModifiers);\n                }\n                else\n                {\n                    ClearPointerOver(device, timestamp, root, properties, inputModifiers);\n                }\n            }\n\n            return element;\n        }\n\n        private void SetPointerOver(IPointerDevice device, ulong timestamp, IInputRoot root, IInputElement element,\n            PointerPointProperties properties,\n            KeyModifiers inputModifiers)\n        {\n            device = device ?? throw new ArgumentNullException(nameof(device));\n            root = root ?? throw new ArgumentNullException(nameof(root));\n            element = element ?? throw new ArgumentNullException(nameof(element));\n\n            IInputElement? branch = null;\n\n            IInputElement? el = element;\n\n            while (el != null)\n            {\n                if (el.IsPointerOver)\n                {\n                    branch = el;\n                    break;\n                }\n                el = (IInputElement?)el.VisualParent;\n            }\n\n            el = root.PointerOverElement;\n\n            var e = CreateSimpleEvent(InputElement.PointerLeaveEvent, timestamp, el, properties, inputModifiers);\n            if (el!=null && branch!=null && !el.IsAttachedToVisualTree)\n            {\n                ClearChildrenPointerOver(e,branch,false);\n            }\n            \n            while (el != null && el != branch)\n            {\n                e.Source = el;\n                e.Handled = false;\n                el.RaiseEvent(e);\n                el = (IInputElement?)el.VisualParent;\n            }            \n\n            el = root.PointerOverElement = element;\n            e.RoutedEvent = InputElement.PointerEnterEvent;\n\n            while (el != null && el != branch)\n            {\n                e.Source = el;\n                e.Handled = false;\n                el.RaiseEvent(e);\n                el = (IInputElement?)el.VisualParent;\n            }\n        }\n\n        public void Dispose()\n        {\n            _disposed = true;\n            _pointer?.Dispose();\n        }\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"315a0553e859bd45a3135bb1ca07b895dd65a24e","subject":"fix merge conflict","message":"fix merge conflict\n","repos":"hrzafer\/nuve","old_file":"nuve\/Lang\/Language.cs","new_file":"nuve\/Lang\/Language.cs","new_contents":"\ufeffusing System;\nusing System.Collections.Generic;\nusing Nuve.Morphologic;\nusing Nuve.Morphologic.Structure;\nusing Nuve.Orthographic;\n\nnamespace Nuve.Lang\n{\n    \/\/\/ <summary>\n    \/\/\/     Enum for supported languages in N\u00fcve.\n    \/\/\/ <\/summary>\n    \/\/public enum LanguageType\n    \/\/{\n    \/\/    Turkish\n    \/\/}\n\n    \/\/\/ <summary>\n    \/\/\/     Represents a language which is supported by N\u00fcve.\n    \/\/\/ <\/summary>\n    public class Language\n    {\n        internal Language(LanguageType type,\n            Orthography orthography,\n            Morphotactics morphotactics,\n            MorphemeContainer<Root> roots,\n            MorphemeContainer<Suffix> suffixes)\n        {\n            Type = type;\n            Orthography = orthography;\n            Morphotactics = morphotactics;\n            Roots = roots;\n            Suffixes = suffixes;\n            Analyzer = new WordAnalyzer(this);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Type (name) of this language object.\n        \/\/\/ <\/summary>\n        public LanguageType Type { get; }\n\n        internal Orthography Orthography { get; }\n        internal Morphotactics Morphotactics { get; }\n\n        internal MorphemeContainer<Suffix> Suffixes { get; }\n        internal MorphemeContainer<Root> Roots { get; }\n\n        private WordAnalyzer Analyzer { get; }\n\n\n        \/\/\/ <summary>\n        \/\/\/     Returns all suffixes defined in this language.\n        \/\/\/ <\/summary>\n        public IEnumerable<Suffix> AllSuffixes => Suffixes.ById.Values;\n\n        \/\/\/ <summary>\n        \/\/\/     Returns all roots defined in this languages\n        \/\/\/ <\/summary>\n        public IEnumerable<Root> AllRoots => Roots.ById.Values;\n\n        \/\/\/ <summary>\n        \/\/\/     Analyzes a token in the context of this language and returns all possible solutions.\n        \/\/\/ <\/summary>\n        public IList<Word> Analyze(string token)\n        {\n            return Analyzer.Analyze(token);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Returns the Suffix object having specified id in this language.\n        \/\/\/     Returns null if the suffix is not found.\n        \/\/\/ <\/summary>\n        public Suffix GetSuffix(string id)\n        {\n            Suffix suffix;\n            if (Suffixes.ById.TryGetValue(id, out suffix))\n            {\n                return suffix;\n            }\n\n            return null;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Returns the Root object having specified id in this language.\n        \/\/\/     Id of a root is defined with its lexical form and part-of-speech tag such as \"lex\/POS\".\n        \/\/\/     Returns null if the suffix is not found.\n        \/\/\/ <\/summary>\n        public Root GetRoot(string rootId)\n        {\n            rootId.ThrowIfNull();\n            var tokens = rootId.Split('\/');\n            if (tokens.Length != 2)\n            {\n                throw new ArgumentException(\n                    $\"Invalid root id \\\"{rootId}\\\". A valid root ID shoul be in the form of lex\/pos. Ex: kitap\/NOUN\");\n            }\n\n            return GetRoot(tokens[0], tokens[1]);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Returns the Root object having specified lexical form and part-of-speech in this language.\n        \/\/\/     lexical form and part-of-speech defines a uniqe id for a root such as \"lex\/POS\".\n        \/\/\/     Returns null if the suffix is not found.\n        \/\/\/ <\/summary>\n        public Root GetRoot(string lex, string pos)\n        {\n            Root root;\n            var rootId = lex + \"\/\" + pos;\n            if (Roots.ById.TryGetValue(rootId, out root))\n            {\n                return root;\n            }\n            return null;\n        }\n\n        internal IEnumerable<T> GetMorphemesHavingSurface<T>(string surface) where T : Morpheme\n        {\n            if (typeof(T) == typeof(Root))\n            {\n                return Roots.BySurface.Get(surface) as IEnumerable<T>;\n            }\n            return Suffixes.BySurface.Get(surface) as IEnumerable<T>;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Returns the roots having the specified surface. For example if\n        \/\/\/     the surface is \"ara\", for Language.Turkish this method returns\n        \/\/\/     to roots, (ara ISIM) and (ara FIIL)\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"surface\"><\/param>\n        \/\/\/ <returns>Returns an empty list if no root has the specified surface<\/returns>\n        public IEnumerable<Root> GetRootsHavingSurface(string surface)\n        {\n            return Roots.BySurface.Get(surface);\n        }\n\n\n        \/\/\/ <summary>\n        \/\/\/     Returns the suffixes having the specified surface. For example if\n        \/\/\/     the surface is \"ma\", for Language.Turkish this method returns\n        \/\/\/     to suffixes, FIILIMSI_ISIM_mA and FY_OLUMSUZLUK_mA\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"surface\"><\/param>\n        \/\/\/ <returns>Returns an empty list if no suffix has the specified surface<\/returns>\n        public IEnumerable<Suffix> GetSuffixesHavingSurface(string surface)\n        {\n            return Suffixes.BySurface.Get(surface);\n        }\n\n        public override string ToString()\n        {\n            return Type.CountryCode==\"??\" ? Type.Code : Type.CultureCode;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Creates and returns a word with the specified \"morpheme id\" sequence\n        \/\/\/ <\/summary>\n        public Word Generate(params string[] morphemes)\n        {\n            StringExtensions.ThrowIfNullAny(morphemes);\n\n<<<<<<< HEAD\n            var index = StringExtensions.ContainsWhitespaceAny(morphemes);\n=======\n            \/\/var index  = StringExtensions.ContainsWhitespaceAny(morphemes);\n>>>>>>> master\n\n            \/\/if (index >= 0)\n            \/\/{\n            \/\/    throw new ArgumentException($\"Morpheme identifier can not contain whitespace: \\\"{morphemes[index]}\\\"\");\n            \/\/}\n\n            var root = GetRoot(morphemes[0]);\n\n            if (root == null)\n            {\n                return null;\n            }\n\n            var word = new Word(root);\n            for (var i = 1; i < morphemes.Length; i++)\n            {\n                var suffix = GetSuffix(morphemes[i]);\n                if (suffix == null)\n                {\n                    return null;\n                }\n                word.AddSuffix(suffix);\n            }\n\n            return word;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Creates and returns a word with the specified string represenation of its analysis\n        \/\/\/     A word object's analysis can be obtainded as a string with word.ToString() method.\n        \/\/\/ <\/summary>\n        public Word GetWord(string analysis)\n        {\n            analysis.ThrowIfNull();\n            analysis.ThrowIfEmpty();\n\n            var tokens = analysis.Split(' ');\n            return Generate(tokens);\n        }\n    }\n}","old_contents":"\ufeffusing System;\nusing System.Collections.Generic;\nusing Nuve.Morphologic;\nusing Nuve.Morphologic.Structure;\nusing Nuve.Orthographic;\n\nnamespace Nuve.Lang\n{\n    \/\/\/ <summary>\n    \/\/\/     Enum for supported languages in N\u00fcve.\n    \/\/\/ <\/summary>\n    \/\/public enum LanguageType\n    \/\/{\n    \/\/    Turkish\n    \/\/}\n\n    \/\/\/ <summary>\n    \/\/\/     Represents a language which is supported by N\u00fcve.\n    \/\/\/ <\/summary>\n    public class Language\n    {\n        internal Language(LanguageType type,\n            Orthography orthography,\n            Morphotactics morphotactics,\n            MorphemeContainer<Root> roots,\n            MorphemeContainer<Suffix> suffixes)\n        {\n            Type = type;\n            Orthography = orthography;\n            Morphotactics = morphotactics;\n            Roots = roots;\n            Suffixes = suffixes;\n            Analyzer = new WordAnalyzer(this);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Type (name) of this language object.\n        \/\/\/ <\/summary>\n        public LanguageType Type { get; }\n\n        internal Orthography Orthography { get; }\n        internal Morphotactics Morphotactics { get; }\n\n        internal MorphemeContainer<Suffix> Suffixes { get; }\n        internal MorphemeContainer<Root> Roots { get; }\n\n        private WordAnalyzer Analyzer { get; }\n\n\n        \/\/\/ <summary>\n        \/\/\/     Returns all suffixes defined in this language.\n        \/\/\/ <\/summary>\n        public IEnumerable<Suffix> AllSuffixes => Suffixes.ById.Values;\n\n        \/\/\/ <summary>\n        \/\/\/     Returns all roots defined in this languages\n        \/\/\/ <\/summary>\n        public IEnumerable<Root> AllRoots => Roots.ById.Values;\n\n        \/\/\/ <summary>\n        \/\/\/     Analyzes a token in the context of this language and returns all possible solutions.\n        \/\/\/ <\/summary>\n        public IList<Word> Analyze(string token)\n        {\n            return Analyzer.Analyze(token);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Returns the Suffix object having specified id in this language.\n        \/\/\/     Returns null if the suffix is not found.\n        \/\/\/ <\/summary>\n        public Suffix GetSuffix(string id)\n        {\n            Suffix suffix;\n            if (Suffixes.ById.TryGetValue(id, out suffix))\n            {\n                return suffix;\n            }\n\n            return null;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Returns the Root object having specified id in this language.\n        \/\/\/     Id of a root is defined with its lexical form and part-of-speech tag such as \"lex\/POS\".\n        \/\/\/     Returns null if the suffix is not found.\n        \/\/\/ <\/summary>\n        public Root GetRoot(string rootId)\n        {\n            rootId.ThrowIfNull();\n            var tokens = rootId.Split('\/');\n            if (tokens.Length != 2)\n            {\n                throw new ArgumentException(\n                    $\"Invalid root id \\\"{rootId}\\\". A valid root ID shoul be in the form of lex\/pos. Ex: kitap\/NOUN\");\n            }\n\n            return GetRoot(tokens[0], tokens[1]);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Returns the Root object having specified lexical form and part-of-speech in this language.\n        \/\/\/     lexical form and part-of-speech defines a uniqe id for a root such as \"lex\/POS\".\n        \/\/\/     Returns null if the suffix is not found.\n        \/\/\/ <\/summary>\n        public Root GetRoot(string lex, string pos)\n        {\n            Root root;\n            var rootId = lex + \"\/\" + pos;\n            if (Roots.ById.TryGetValue(rootId, out root))\n            {\n                return root;\n            }\n            return null;\n        }\n\n        internal IEnumerable<T> GetMorphemesHavingSurface<T>(string surface) where T : Morpheme\n        {\n            if (typeof(T) == typeof(Root))\n            {\n                return Roots.BySurface.Get(surface) as IEnumerable<T>;\n            }\n            return Suffixes.BySurface.Get(surface) as IEnumerable<T>;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Returns the roots having the specified surface. For example if\n        \/\/\/     the surface is \"ara\", for Language.Turkish this method returns\n        \/\/\/     to roots, (ara ISIM) and (ara FIIL)\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"surface\"><\/param>\n        \/\/\/ <returns>Returns an empty list if no root has the specified surface<\/returns>\n        public IEnumerable<Root> GetRootsHavingSurface(string surface)\n        {\n            return Roots.BySurface.Get(surface);\n        }\n\n\n        \/\/\/ <summary>\n        \/\/\/     Returns the suffixes having the specified surface. For example if\n        \/\/\/     the surface is \"ma\", for Language.Turkish this method returns\n        \/\/\/     to suffixes, FIILIMSI_ISIM_mA and FY_OLUMSUZLUK_mA\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"surface\"><\/param>\n        \/\/\/ <returns>Returns an empty list if no suffix has the specified surface<\/returns>\n        public IEnumerable<Suffix> GetSuffixesHavingSurface(string surface)\n        {\n            return Suffixes.BySurface.Get(surface);\n        }\n\n        public override string ToString()\n        {\n            return Type.CountryCode==\"??\" ? Type.Code : Type.CultureCode;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Creates and returns a word with the specified \"morpheme id\" sequence\n        \/\/\/ <\/summary>\n        public Word Generate(params string[] morphemes)\n        {\n            StringExtensions.ThrowIfNullAny(morphemes);\n\n            var index = StringExtensions.ContainsWhitespaceAny(morphemes);\n\n            if (index >= 0)\n            {\n                throw new ArgumentException($\"Morpheme identifier can not contain whitespace: \\\"{morphemes[index]}\\\"\");\n            }\n\n            var root = GetRoot(morphemes[0]);\n\n            if (root == null)\n            {\n                return null;\n            }\n\n            var word = new Word(root);\n            for (var i = 1; i < morphemes.Length; i++)\n            {\n                var suffix = GetSuffix(morphemes[i]);\n                if (suffix == null)\n                {\n                    return null;\n                }\n                word.AddSuffix(suffix);\n            }\n\n            return word;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/     Creates and returns a word with the specified string represenation of its analysis\n        \/\/\/     A word object's analysis can be obtainded as a string with word.ToString() method.\n        \/\/\/ <\/summary>\n        public Word GetWord(string analysis)\n        {\n            analysis.ThrowIfNull();\n            analysis.ThrowIfEmpty();\n\n            var tokens = analysis.Split(' ');\n            return Generate(tokens);\n        }\n    }\n}","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"6eb9c0051974cbde2671a5848a51caab343b4efa","subject":"Fix ExecuteWithRetry to use cleanup action","message":"Fix ExecuteWithRetry to use cleanup action\n","repos":"nuke-build\/nuke,nuke-build\/nuke,nuke-build\/nuke,nuke-build\/nuke","old_file":"source\/Nuke.Common\/ControlFlow.cs","new_file":"source\/Nuke.Common\/ControlFlow.cs","new_contents":"\ufeff\/\/ Copyright 2019 Maintainers of NUKE.\n\/\/ Distributed under the MIT License.\n\/\/ https:\/\/github.com\/nuke-build\/nuke\/blob\/master\/LICENSE\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing JetBrains.Annotations;\nusing Nuke.Common.Utilities;\n\n\/\/ ReSharper disable CompareNonConstrainedGenericWithNull\n\nnamespace Nuke.Common\n{\n    [PublicAPI]\n    [DebuggerNonUserCode]\n    [DebuggerStepThrough]\n    public static class ControlFlow\n    {\n        \/\/\/ <summary>\n        \/\/\/ Logs a message as failure. Halts execution.\n        \/\/\/ <\/summary>\n        [StringFormatMethod(\"format\")]\n        [ContractAnnotation(\"=> halt\")]\n        public static void Fail(string format, params object[] args)\n        {\n            Fail(string.Format(format, args));\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Logs a message as failure. Halts execution.\n        \/\/\/ <\/summary>\n        [ContractAnnotation(\"=> halt\")]\n        public static void Fail(object value)\n        {\n            Fail(value.ToString());\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Logs a message as failure. Halts execution.\n        \/\/\/ <\/summary>\n        [ContractAnnotation(\"=> halt\")]\n        public static void Fail(string text)\n        {\n            throw new Exception(text);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Asserts a condition to be true, calling <see cref=\"Logger.Warn(string)\"\/> otherwise.\n        \/\/\/ <\/summary>\n        [AssertionMethod]\n        public static void AssertWarn(bool condition, string text)\n        {\n            if (!condition)\n                Logger.Warn($\"Assertion failed: {text}\");\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Asserts a condition to be true, halts otherwise.\n        \/\/\/ <\/summary>\n        [AssertionMethod]\n        [ContractAnnotation(\"condition: false => halt\")]\n        public static void Assert(\n            [AssertionCondition(AssertionConditionType.IS_TRUE)]\n            bool condition,\n            string text)\n        {\n            if (!condition)\n                Fail($\"Assertion failed: {text}\");\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Asserts an object to be not null, halts otherwise.\n        \/\/\/ <\/summary>\n        [AssertionMethod]\n        [ContractAnnotation(\"obj: null => halt\")]\n        public static T NotNull<T>(\n            [AssertionCondition(AssertionConditionType.IS_NOT_NULL)] [CanBeNull]\n            this T obj,\n            string text = null)\n        {\n            if (obj == null)\n                Fail($\"Assertion failed: {text ?? \"obj != null\"}\");\n            return obj;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Checks an object to be not null, calling <see cref=\"Logger.Warn(string)\"\/> otherwise.\n        \/\/\/ <\/summary>\n        [CanBeNull]\n        [AssertionMethod]\n        public static T NotNullWarn<T>([CanBeNull] this T obj, string text = null)\n        {\n            if (obj == null)\n                Logger.Warn($\"Check failed: {text ?? \"obj != null\"}\");\n            return obj;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Asserts a collection to be not empty, halts otherwise.\n        \/\/\/ <\/summary>\n        [ContractAnnotation(\"enumerable: null => halt\")]\n        public static IReadOnlyCollection<T> NotEmpty<T>([CanBeNull] this IEnumerable<T> enumerable, string message = null)\n        {\n            var collection = enumerable.NotNull(\"enumerable != null\").ToList().AsReadOnly();\n            Assert(collection.Count > 0, message ?? \"collection.Count > 0\");\n            return collection;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Asserts a collection to contain only <em>non-null<\/em> elements, halts otherwise.\n        \/\/\/ <\/summary>\n        [ContractAnnotation(\"enumerable: null => halt\")]\n        public static IReadOnlyCollection<T> NoNullItems<T>([CanBeNull] this IEnumerable<T> enumerable)\n        {\n            var collection = enumerable.NotNull(\"enumerable != null\").ToList().AsReadOnly();\n            Assert(collection.All(x => x != null), \"collection.All(x => x != null)\");\n            return collection;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes a given action and suppresses all errors while delegating them to <see cref=\"Logger.Warn(string)\"\/>.\n        \/\/\/ <\/summary>\n        public static void SuppressErrors(Action action, bool includeStackTrace = false)\n        {\n            SuppressErrorsIf(condition: true, action, includeStackTrace: includeStackTrace);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes a given action and suppresses all errors while delegating them to <see cref=\"Logger.Warn(string)\"\/>.\n        \/\/\/ <\/summary>\n        \/\/\/ <example>\n        \/\/\/ <code>\n        \/\/\/ var author = SuppressErrors(GetAuthor, defaultValue: \"John Doe\");\n        \/\/\/ <\/code>\n        \/\/\/ <\/example>\n        [ContractAnnotation(\"defaultValue: notnull => notnull\")]\n        [CanBeNull]\n        public static T SuppressErrors<T>(Func<T> action, T defaultValue = default, bool includeStackTrace = false)\n        {\n            return (T) SuppressErrorsIf(condition: true, action, defaultValue, includeStackTrace);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes a given action and suppresses all errors while delegating them to <see cref=\"Logger.Warn(string)\"\/>.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>\n        \/\/\/ Returns an empty collection for convenience.\n        \/\/\/ <\/returns>\n        \/\/\/ <example>\n        \/\/\/ <code>\n        \/\/\/ \/\/ Won't throw NRE if GetAuthors throws\n        \/\/\/ var authorsCount = SuppressErrors(GetAuthors).Length;\n        \/\/\/ <\/code>\n        \/\/\/ <\/example>\n        public static IEnumerable<T> SuppressErrors<T>(Func<IEnumerable<T>> action, bool includeStackTrace = false)\n        {\n            return SuppressErrors<IEnumerable<T>>(action, includeStackTrace: includeStackTrace) ?? Enumerable.Empty<T>();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes a given action and suppresses all errors while delegating them to <see cref=\"Logger.Warn(string)\"\/>.\n        \/\/\/ <\/summary>\n        [ContractAnnotation(\"defaultValue: notnull => notnull\")]\n        [CanBeNull]\n        private static object SuppressErrorsIf(bool condition, Delegate action, object defaultValue = null, bool includeStackTrace = false)\n        {\n            if (!condition)\n                return defaultValue;\n\n            try\n            {\n                return action.DynamicInvoke();\n            }\n            catch (Exception exception)\n            {\n                var innerException = exception.InnerException.NotNull(\"innerException != null\");\n                Logger.Warn(includeStackTrace\n                    ? new[] { innerException.Message, \"StackTrace:\", innerException.StackTrace }.JoinNewLine()\n                    : innerException.Message);\n                return defaultValue;\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes a given action under retry-policy. After reaching the specified amount of attempts, the actions fails permanently.\n        \/\/\/ <\/summary>\n        \/\/\/ <example>\n        \/\/\/ <code>\n        \/\/\/ ExecuteWithRetry(() => NuGetRestore(SolutionFile), waitInSeconds: 30);\n        \/\/\/ <\/code>\n        \/\/\/ <\/example>\n        public static void ExecuteWithRetry(\n            [InstantHandle] Action action,\n            [InstantHandle] Action cleanup = null,\n            int retryAttempts = 3,\n            int waitInSeconds = 0)\n        {\n            Assert(retryAttempts > 0, \"retryAttempts > 0\");\n\n            for (var attempt = 0; attempt < retryAttempts; attempt++)\n            {\n                try\n                {\n                    action.Invoke();\n                    return;\n                }\n                catch (Exception exception)\n                {\n                    Logger.Warn($\"Attempt #{attempt + 1} failed with:\");\n                    Logger.Warn(exception.Message);\n\n                    if (waitInSeconds <= 0 || attempt + 1 >= retryAttempts)\n                        continue;\n\n                    Logger.Warn($\"Waiting {waitInSeconds} seconds before next attempt...\");\n                    Task.Delay(TimeSpan.FromSeconds(waitInSeconds)).Wait();\n                }\n                finally\n                {\n                    cleanup?.Invoke();\n                }\n            }\n\n            Fail($\"Executing failed permanently after {retryAttempts} attempts.\");\n        }\n    }\n}\n","old_contents":"\ufeff\/\/ Copyright 2019 Maintainers of NUKE.\n\/\/ Distributed under the MIT License.\n\/\/ https:\/\/github.com\/nuke-build\/nuke\/blob\/master\/LICENSE\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing JetBrains.Annotations;\nusing Nuke.Common.Utilities;\n\n\/\/ ReSharper disable CompareNonConstrainedGenericWithNull\n\nnamespace Nuke.Common\n{\n    [PublicAPI]\n    [DebuggerNonUserCode]\n    [DebuggerStepThrough]\n    public static class ControlFlow\n    {\n        \/\/\/ <summary>\n        \/\/\/ Logs a message as failure. Halts execution.\n        \/\/\/ <\/summary>\n        [StringFormatMethod(\"format\")]\n        [ContractAnnotation(\"=> halt\")]\n        public static void Fail(string format, params object[] args)\n        {\n            Fail(string.Format(format, args));\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Logs a message as failure. Halts execution.\n        \/\/\/ <\/summary>\n        [ContractAnnotation(\"=> halt\")]\n        public static void Fail(object value)\n        {\n            Fail(value.ToString());\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Logs a message as failure. Halts execution.\n        \/\/\/ <\/summary>\n        [ContractAnnotation(\"=> halt\")]\n        public static void Fail(string text)\n        {\n            throw new Exception(text);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Asserts a condition to be true, calling <see cref=\"Logger.Warn(string)\"\/> otherwise.\n        \/\/\/ <\/summary>\n        [AssertionMethod]\n        public static void AssertWarn(bool condition, string text)\n        {\n            if (!condition)\n                Logger.Warn($\"Assertion failed: {text}\");\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Asserts a condition to be true, halts otherwise.\n        \/\/\/ <\/summary>\n        [AssertionMethod]\n        [ContractAnnotation(\"condition: false => halt\")]\n        public static void Assert(\n            [AssertionCondition(AssertionConditionType.IS_TRUE)]\n            bool condition,\n            string text)\n        {\n            if (!condition)\n                Fail($\"Assertion failed: {text}\");\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Asserts an object to be not null, halts otherwise.\n        \/\/\/ <\/summary>\n        [AssertionMethod]\n        [ContractAnnotation(\"obj: null => halt\")]\n        public static T NotNull<T>(\n            [AssertionCondition(AssertionConditionType.IS_NOT_NULL)] [CanBeNull]\n            this T obj,\n            string text = null)\n        {\n            if (obj == null)\n                Fail($\"Assertion failed: {text ?? \"obj != null\"}\");\n            return obj;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Checks an object to be not null, calling <see cref=\"Logger.Warn(string)\"\/> otherwise.\n        \/\/\/ <\/summary>\n        [CanBeNull]\n        [AssertionMethod]\n        public static T NotNullWarn<T>([CanBeNull] this T obj, string text = null)\n        {\n            if (obj == null)\n                Logger.Warn($\"Check failed: {text ?? \"obj != null\"}\");\n            return obj;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Asserts a collection to be not empty, halts otherwise.\n        \/\/\/ <\/summary>\n        [ContractAnnotation(\"enumerable: null => halt\")]\n        public static IReadOnlyCollection<T> NotEmpty<T>([CanBeNull] this IEnumerable<T> enumerable, string message = null)\n        {\n            var collection = enumerable.NotNull(\"enumerable != null\").ToList().AsReadOnly();\n            Assert(collection.Count > 0, message ?? \"collection.Count > 0\");\n            return collection;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Asserts a collection to contain only <em>non-null<\/em> elements, halts otherwise.\n        \/\/\/ <\/summary>\n        [ContractAnnotation(\"enumerable: null => halt\")]\n        public static IReadOnlyCollection<T> NoNullItems<T>([CanBeNull] this IEnumerable<T> enumerable)\n        {\n            var collection = enumerable.NotNull(\"enumerable != null\").ToList().AsReadOnly();\n            Assert(collection.All(x => x != null), \"collection.All(x => x != null)\");\n            return collection;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes a given action and suppresses all errors while delegating them to <see cref=\"Logger.Warn(string)\"\/>.\n        \/\/\/ <\/summary>\n        public static void SuppressErrors(Action action, bool includeStackTrace = false)\n        {\n            SuppressErrorsIf(condition: true, action, includeStackTrace: includeStackTrace);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes a given action and suppresses all errors while delegating them to <see cref=\"Logger.Warn(string)\"\/>.\n        \/\/\/ <\/summary>\n        \/\/\/ <example>\n        \/\/\/ <code>\n        \/\/\/ var author = SuppressErrors(GetAuthor, defaultValue: \"John Doe\");\n        \/\/\/ <\/code>\n        \/\/\/ <\/example>\n        [ContractAnnotation(\"defaultValue: notnull => notnull\")]\n        [CanBeNull]\n        public static T SuppressErrors<T>(Func<T> action, T defaultValue = default, bool includeStackTrace = false)\n        {\n            return (T) SuppressErrorsIf(condition: true, action, defaultValue, includeStackTrace);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes a given action and suppresses all errors while delegating them to <see cref=\"Logger.Warn(string)\"\/>.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>\n        \/\/\/ Returns an empty collection for convenience.\n        \/\/\/ <\/returns>\n        \/\/\/ <example>\n        \/\/\/ <code>\n        \/\/\/ \/\/ Won't throw NRE if GetAuthors throws\n        \/\/\/ var authorsCount = SuppressErrors(GetAuthors).Length;\n        \/\/\/ <\/code>\n        \/\/\/ <\/example>\n        public static IEnumerable<T> SuppressErrors<T>(Func<IEnumerable<T>> action, bool includeStackTrace = false)\n        {\n            return SuppressErrors<IEnumerable<T>>(action, includeStackTrace: includeStackTrace) ?? Enumerable.Empty<T>();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes a given action and suppresses all errors while delegating them to <see cref=\"Logger.Warn(string)\"\/>.\n        \/\/\/ <\/summary>\n        [ContractAnnotation(\"defaultValue: notnull => notnull\")]\n        [CanBeNull]\n        private static object SuppressErrorsIf(bool condition, Delegate action, object defaultValue = null, bool includeStackTrace = false)\n        {\n            if (!condition)\n                return defaultValue;\n\n            try\n            {\n                return action.DynamicInvoke();\n            }\n            catch (Exception exception)\n            {\n                var innerException = exception.InnerException.NotNull(\"innerException != null\");\n                Logger.Warn(includeStackTrace\n                    ? new[] { innerException.Message, \"StackTrace:\", innerException.StackTrace }.JoinNewLine()\n                    : innerException.Message);\n                return defaultValue;\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes a given action under retry-policy. After reaching the specified amount of attempts, the actions fails permanently.\n        \/\/\/ <\/summary>\n        \/\/\/ <example>\n        \/\/\/ <code>\n        \/\/\/ ExecuteWithRetry(() => NuGetRestore(SolutionFile), waitInSeconds: 30);\n        \/\/\/ <\/code>\n        \/\/\/ <\/example>\n        public static void ExecuteWithRetry(\n            [InstantHandle] Action action,\n            [InstantHandle] Action cleanup = null,\n            int retryAttempts = 3,\n            int waitInSeconds = 0)\n        {\n            Assert(retryAttempts > 0, \"retryAttempts > 0\");\n\n            for (var attempt = 0; attempt < retryAttempts; attempt++)\n            {\n                try\n                {\n                    action();\n                    return;\n                }\n                catch (Exception exception)\n                {\n                    Logger.Warn($\"Attempt #{attempt + 1} failed with:\");\n                    Logger.Warn(exception.Message);\n\n                    if (waitInSeconds <= 0 || attempt + 1 >= retryAttempts)\n                        continue;\n\n                    Logger.Warn($\"Waiting {waitInSeconds} seconds before next attempt...\");\n                    Task.Delay(TimeSpan.FromSeconds(waitInSeconds)).Wait();\n                }\n            }\n\n            Fail($\"Executing failed permanently after {retryAttempts} attempts.\");\n        }\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"00b042728c1126a9fc63cf473e746a45e2b654f4","subject":"Fixed MaxLength on AuditLog.CustomData","message":"Fixed MaxLength on AuditLog.CustomData\n","repos":"lemestrez\/module-zero,abdllhbyrktr\/module-zero,CooperLiu\/module-zero,AndHuang\/module-zero,andmattia\/module-zero,aspnetboilerplate\/module-zero,chilin\/module-zero,lemestrez\/module-zero,daywrite\/module-zero,AndHuang\/module-zero,ilyhacker\/module-zero","old_file":"src\/Abp.Zero\/Auditing\/AuditLog.cs","new_file":"src\/Abp.Zero\/Auditing\/AuditLog.cs","new_contents":"\ufeffusing System;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing System.ComponentModel.DataAnnotations.Schema;\r\nusing Abp.Domain.Entities;\r\nusing Abp.Extensions;\r\n\r\nnamespace Abp.Auditing\r\n{\r\n    \/\/\/ <summary>\r\n    \/\/\/ Used to store audit logs.\r\n    \/\/\/ <\/summary>\r\n    [Table(\"AbpAuditLogs\")]\r\n    public class AuditLog : Entity<long>, IMayHaveTenant\r\n    {\r\n        \/\/\/ <summary>\r\n        \/\/\/ Maximum length of <see cref=\"ServiceName\"\/> property.\r\n        \/\/\/ <\/summary>\r\n        public const int MaxServiceNameLength = 256;\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Maximum length of <see cref=\"MethodName\"\/> property.\r\n        \/\/\/ <\/summary>\r\n        public const int MaxMethodNameLength = 256;\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Maximum length of <see cref=\"Parameters\"\/> property.\r\n        \/\/\/ <\/summary>\r\n        public const int MaxParametersLength = 1024;\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Maximum length of <see cref=\"ClientIpAddress\"\/> property.\r\n        \/\/\/ <\/summary>\r\n        public const int MaxClientIpAddressLength = 64;\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Maximum length of <see cref=\"ClientName\"\/> property.\r\n        \/\/\/ <\/summary>\r\n        public const int MaxClientNameLength = 128;\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Maximum length of <see cref=\"BrowserInfo\"\/> property.\r\n        \/\/\/ <\/summary>\r\n        public const int MaxBrowserInfoLength = 256;\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Maximum length of <see cref=\"Exception\"\/> property.\r\n        \/\/\/ <\/summary>\r\n        public const int MaxExceptionLength = 2000;\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Maximum length of <see cref=\"CustomData\"\/> property.\r\n        \/\/\/ <\/summary>\r\n        public const int MaxCustomDataLength = 2000;\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ TenantId.\r\n        \/\/\/ <\/summary>\r\n        public virtual int? TenantId { get; set; }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ UserId.\r\n        \/\/\/ <\/summary>\r\n        public virtual long? UserId { get; set; }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Service (class\/interface) name.\r\n        \/\/\/ <\/summary>\r\n        [MaxLength(MaxServiceNameLength)]\r\n        public virtual string ServiceName { get; set; }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Executed method name.\r\n        \/\/\/ <\/summary>\r\n        [MaxLength(MaxMethodNameLength)]\r\n        public virtual string MethodName { get; set; }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Calling parameters.\r\n        \/\/\/ <\/summary>\r\n        [MaxLength(MaxParametersLength)]\r\n        public virtual string Parameters { get; set; }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Start time of the method execution.\r\n        \/\/\/ <\/summary>\r\n        public virtual DateTime ExecutionTime { get; set; }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Total duration of the method call as milliseconds.\r\n        \/\/\/ <\/summary>\r\n        public virtual int ExecutionDuration { get; set; }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ IP address of the client.\r\n        \/\/\/ <\/summary>\r\n        [MaxLength(MaxClientIpAddressLength)]\r\n        public virtual string ClientIpAddress { get; set; }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Name (generally computer name) of the client.\r\n        \/\/\/ <\/summary>\r\n        [MaxLength(MaxClientNameLength)]\r\n        public virtual string ClientName { get; set; }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Browser information if this method is called in a web request.\r\n        \/\/\/ <\/summary>\r\n        [MaxLength(MaxBrowserInfoLength)]\r\n        public virtual string BrowserInfo { get; set; }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Exception object, if an exception occured during execution of the method.\r\n        \/\/\/ <\/summary>\r\n        [MaxLength(MaxExceptionLength)]\r\n        public virtual string Exception { get; set; }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ <see cref=\"AuditInfo.ImpersonatorUserId\"\/>.\r\n        \/\/\/ <\/summary>\r\n        public virtual long? ImpersonatorUserId { get; set; }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ <see cref=\"AuditInfo.ImpersonatorTenantId\"\/>.\r\n        \/\/\/ <\/summary>\r\n        public virtual int? ImpersonatorTenantId { get; set; }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ <see cref=\"AuditInfo.CustomData\"\/>.\r\n        \/\/\/ <\/summary>\r\n        [MaxLength(MaxCustomDataLength)]\r\n        public virtual string CustomData { get; set; }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Creates a new CreateFromAuditInfo from given <see cref=\"auditInfo\"\/>.\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <param name=\"auditInfo\">Source <see cref=\"AuditInfo\"\/> object<\/param>\r\n        \/\/\/ <returns>The <see cref=\"AuditLog\"\/> object that is created using <see cref=\"auditInfo\"\/><\/returns>\r\n        public static AuditLog CreateFromAuditInfo(AuditInfo auditInfo)\r\n        {\r\n            var exceptionMessage = auditInfo.Exception != null ? auditInfo.Exception.ToString() : null;\r\n            return new AuditLog\r\n                   {\r\n                       TenantId = auditInfo.TenantId,\r\n                       UserId = auditInfo.UserId,\r\n                       ServiceName = auditInfo.ServiceName.TruncateWithPostfix(MaxServiceNameLength),\r\n                       MethodName = auditInfo.MethodName.TruncateWithPostfix(MaxMethodNameLength),\r\n                       Parameters = auditInfo.Parameters.TruncateWithPostfix(MaxParametersLength),\r\n                       ExecutionTime = auditInfo.ExecutionTime,\r\n                       ExecutionDuration = auditInfo.ExecutionDuration,\r\n                       ClientIpAddress = auditInfo.ClientIpAddress.TruncateWithPostfix(MaxClientIpAddressLength),\r\n                       ClientName = auditInfo.ClientName.TruncateWithPostfix(MaxClientNameLength),\r\n                       BrowserInfo = auditInfo.BrowserInfo.TruncateWithPostfix(MaxBrowserInfoLength),\r\n                       Exception = exceptionMessage.TruncateWithPostfix(MaxExceptionLength),\r\n                       ImpersonatorUserId = auditInfo.ImpersonatorUserId,\r\n                       ImpersonatorTenantId = auditInfo.ImpersonatorTenantId,\r\n                       CustomData = auditInfo.CustomData.TruncateWithPostfix(MaxCustomDataLength)\r\n                   };\r\n        }\r\n\r\n        public override string ToString()\r\n        {\r\n            return string.Format(\r\n                \"AUDIT LOG: {0}.{1} is executed by user {2} in {3} ms from {4} IP address.\",\r\n                ServiceName, MethodName, UserId, ExecutionDuration, ClientIpAddress\r\n                );\r\n        }\r\n    }\r\n}\r\n","old_contents":"\ufeffusing System;\r\nusing System.ComponentModel.DataAnnotations;\r\nusing System.ComponentModel.DataAnnotations.Schema;\r\nusing Abp.Domain.Entities;\r\nusing Abp.Extensions;\r\n\r\nnamespace Abp.Auditing\r\n{\r\n    \/\/\/ <summary>\r\n    \/\/\/ Used to store audit logs.\r\n    \/\/\/ <\/summary>\r\n    [Table(\"AbpAuditLogs\")]\r\n    public class AuditLog : Entity<long>, IMayHaveTenant\r\n    {\r\n        \/\/\/ <summary>\r\n        \/\/\/ Maximum length of <see cref=\"ServiceName\"\/> property.\r\n        \/\/\/ <\/summary>\r\n        public const int MaxServiceNameLength = 256;\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Maximum length of <see cref=\"MethodName\"\/> property.\r\n        \/\/\/ <\/summary>\r\n        public const int MaxMethodNameLength = 256;\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Maximum length of <see cref=\"Parameters\"\/> property.\r\n        \/\/\/ <\/summary>\r\n        public const int MaxParametersLength = 1024;\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Maximum length of <see cref=\"ClientIpAddress\"\/> property.\r\n        \/\/\/ <\/summary>\r\n        public const int MaxClientIpAddressLength = 64;\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Maximum length of <see cref=\"ClientName\"\/> property.\r\n        \/\/\/ <\/summary>\r\n        public const int MaxClientNameLength = 128;\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Maximum length of <see cref=\"BrowserInfo\"\/> property.\r\n        \/\/\/ <\/summary>\r\n        public const int MaxBrowserInfoLength = 256;\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Maximum length of <see cref=\"Exception\"\/> property.\r\n        \/\/\/ <\/summary>\r\n        public const int MaxExceptionLength = 2000;\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Maximum length of <see cref=\"CustomData\"\/> property.\r\n        \/\/\/ <\/summary>\r\n        public const int MaxCustomDataLength = 2000;\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ TenantId.\r\n        \/\/\/ <\/summary>\r\n        public virtual int? TenantId { get; set; }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ UserId.\r\n        \/\/\/ <\/summary>\r\n        public virtual long? UserId { get; set; }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Service (class\/interface) name.\r\n        \/\/\/ <\/summary>\r\n        [MaxLength(MaxServiceNameLength)]\r\n        public virtual string ServiceName { get; set; }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Executed method name.\r\n        \/\/\/ <\/summary>\r\n        [MaxLength(MaxMethodNameLength)]\r\n        public virtual string MethodName { get; set; }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Calling parameters.\r\n        \/\/\/ <\/summary>\r\n        [MaxLength(MaxParametersLength)]\r\n        public virtual string Parameters { get; set; }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Start time of the method execution.\r\n        \/\/\/ <\/summary>\r\n        public virtual DateTime ExecutionTime { get; set; }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Total duration of the method call as milliseconds.\r\n        \/\/\/ <\/summary>\r\n        public virtual int ExecutionDuration { get; set; }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ IP address of the client.\r\n        \/\/\/ <\/summary>\r\n        [MaxLength(MaxClientIpAddressLength)]\r\n        public virtual string ClientIpAddress { get; set; }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Name (generally computer name) of the client.\r\n        \/\/\/ <\/summary>\r\n        [MaxLength(MaxClientNameLength)]\r\n        public virtual string ClientName { get; set; }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Browser information if this method is called in a web request.\r\n        \/\/\/ <\/summary>\r\n        [MaxLength(MaxBrowserInfoLength)]\r\n        public virtual string BrowserInfo { get; set; }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Exception object, if an exception occured during execution of the method.\r\n        \/\/\/ <\/summary>\r\n        [MaxLength(MaxExceptionLength)]\r\n        public virtual string Exception { get; set; }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ <see cref=\"AuditInfo.ImpersonatorUserId\"\/>.\r\n        \/\/\/ <\/summary>\r\n        public virtual long? ImpersonatorUserId { get; set; }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ <see cref=\"AuditInfo.ImpersonatorTenantId\"\/>.\r\n        \/\/\/ <\/summary>\r\n        public virtual int? ImpersonatorTenantId { get; set; }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ <see cref=\"AuditInfo.CustomData\"\/>.\r\n        \/\/\/ <\/summary>\r\n        public virtual string CustomData { get; set; }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Creates a new CreateFromAuditInfo from given <see cref=\"auditInfo\"\/>.\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <param name=\"auditInfo\">Source <see cref=\"AuditInfo\"\/> object<\/param>\r\n        \/\/\/ <returns>The <see cref=\"AuditLog\"\/> object that is created using <see cref=\"auditInfo\"\/><\/returns>\r\n        public static AuditLog CreateFromAuditInfo(AuditInfo auditInfo)\r\n        {\r\n            var exceptionMessage = auditInfo.Exception != null ? auditInfo.Exception.ToString() : null;\r\n            return new AuditLog\r\n                   {\r\n                       TenantId = auditInfo.TenantId,\r\n                       UserId = auditInfo.UserId,\r\n                       ServiceName = auditInfo.ServiceName.TruncateWithPostfix(MaxServiceNameLength),\r\n                       MethodName = auditInfo.MethodName.TruncateWithPostfix(MaxMethodNameLength),\r\n                       Parameters = auditInfo.Parameters.TruncateWithPostfix(MaxParametersLength),\r\n                       ExecutionTime = auditInfo.ExecutionTime,\r\n                       ExecutionDuration = auditInfo.ExecutionDuration,\r\n                       ClientIpAddress = auditInfo.ClientIpAddress.TruncateWithPostfix(MaxClientIpAddressLength),\r\n                       ClientName = auditInfo.ClientName.TruncateWithPostfix(MaxClientNameLength),\r\n                       BrowserInfo = auditInfo.BrowserInfo.TruncateWithPostfix(MaxBrowserInfoLength),\r\n                       Exception = exceptionMessage.TruncateWithPostfix(MaxExceptionLength),\r\n                       ImpersonatorUserId = auditInfo.ImpersonatorUserId,\r\n                       ImpersonatorTenantId = auditInfo.ImpersonatorTenantId,\r\n                       CustomData = auditInfo.CustomData.TruncateWithPostfix(MaxCustomDataLength)\r\n                   };\r\n        }\r\n\r\n        public override string ToString()\r\n        {\r\n            return string.Format(\r\n                \"AUDIT LOG: {0}.{1} is executed by user {2} in {3} ms from {4} IP address.\",\r\n                ServiceName, MethodName, UserId, ExecutionDuration, ClientIpAddress\r\n                );\r\n        }\r\n    }\r\n}\r\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"ddbe82652f673f7b6bc720562d59d2937eaca5bc","subject":"allow binding of notification managers","message":"allow binding of notification managers\n\n","repos":"SuperJMN\/Avalonia,wieslawsoltes\/Perspex,grokys\/Perspex,AvaloniaUI\/Avalonia,AvaloniaUI\/Avalonia,jkoritzinsky\/Avalonia,jkoritzinsky\/Avalonia,AvaloniaUI\/Avalonia,SuperJMN\/Avalonia,jkoritzinsky\/Avalonia,jkoritzinsky\/Avalonia,SuperJMN\/Avalonia,SuperJMN\/Avalonia,wieslawsoltes\/Perspex,jkoritzinsky\/Perspex,AvaloniaUI\/Avalonia,wieslawsoltes\/Perspex,jkoritzinsky\/Avalonia,grokys\/Perspex,SuperJMN\/Avalonia,SuperJMN\/Avalonia,jkoritzinsky\/Avalonia,wieslawsoltes\/Perspex,jkoritzinsky\/Avalonia,AvaloniaUI\/Avalonia,SuperJMN\/Avalonia,AvaloniaUI\/Avalonia,wieslawsoltes\/Perspex,Perspex\/Perspex,AvaloniaUI\/Avalonia,akrisiun\/Perspex,Perspex\/Perspex,wieslawsoltes\/Perspex,wieslawsoltes\/Perspex","old_file":"src\/Avalonia.Controls\/TopLevel.cs","new_file":"src\/Avalonia.Controls\/TopLevel.cs","new_contents":"\/\/ Copyright (c) The Avalonia Project. All rights reserved.\n\/\/ Licensed under the MIT license. See licence.md file in the project root for full license information.\n\nusing System;\nusing System.Linq;\nusing System.Reactive.Linq;\nusing Avalonia.Controls.Notifications;\nusing Avalonia.Controls.Primitives;\nusing Avalonia.Input;\nusing Avalonia.Input.Raw;\nusing Avalonia.Layout;\nusing Avalonia.Logging;\nusing Avalonia.LogicalTree;\nusing Avalonia.Platform;\nusing Avalonia.Rendering;\nusing Avalonia.Styling;\nusing Avalonia.Utilities;\nusing Avalonia.VisualTree;\nusing JetBrains.Annotations;\n\nnamespace Avalonia.Controls\n{\n    \/\/\/ <summary>\n    \/\/\/ Base class for top-level widgets.\n    \/\/\/ <\/summary>\n    \/\/\/ <remarks>\n    \/\/\/ This class acts as a base for top level widget.\n    \/\/\/ It handles scheduling layout, styling and rendering as well as\n    \/\/\/ tracking the widget's <see cref=\"ClientSize\"\/>.\n    \/\/\/ <\/remarks>\n    public abstract class TopLevel : ContentControl,\n        IInputRoot,\n        ILayoutRoot,\n        IRenderRoot,\n        ICloseable,\n        IStyleRoot,\n        IWeakSubscriber<ResourcesChangedEventArgs>\n    {\n        \/\/\/ <summary>\n        \/\/\/ Defines the <see cref=\"ClientSize\"\/> property.\n        \/\/\/ <\/summary>\n        public static readonly DirectProperty<TopLevel, Size> ClientSizeProperty =\n            AvaloniaProperty.RegisterDirect<TopLevel, Size>(nameof(ClientSize), o => o.ClientSize);\n\n        \/\/\/ <summary>\n        \/\/\/ Defines the <see cref=\"IInputRoot.PointerOverElement\"\/> property.\n        \/\/\/ <\/summary>\n        public static readonly StyledProperty<IInputElement> PointerOverElementProperty =\n            AvaloniaProperty.Register<TopLevel, IInputElement>(nameof(IInputRoot.PointerOverElement));\n\n        \/\/\/ <summary>\n        \/\/\/ Defines the <see cref=\"LocalNotificationManager\"\/> property.\n        \/\/\/ <\/summary>\n        public static readonly DirectProperty<TopLevel, INotificationManager> LocalNotificationManagerProperty =\n            AvaloniaProperty.RegisterDirect<TopLevel, INotificationManager>(nameof(LocalNotificationManager), o => o.LocalNotificationManager, (o, v) => o.LocalNotificationManager = v);\n\n        \/\/\/ <summary>\n        \/\/\/ Defines the <see cref=\"SystemNotificationManager\"\/> property.\n        \/\/\/ <\/summary>\n        public static readonly DirectProperty<TopLevel, INotificationManager> SystemNotificationManagerProperty =\n            AvaloniaProperty.RegisterDirect<TopLevel, INotificationManager>(nameof(SystemNotificationManager), o => o.SystemNotificationManager, (o, v) => o.SystemNotificationManager = v);\n\n        private readonly IInputManager _inputManager;\n        private readonly IAccessKeyHandler _accessKeyHandler;\n        private readonly IKeyboardNavigationHandler _keyboardNavigationHandler;\n        private readonly IApplicationLifecycle _applicationLifecycle;\n        private readonly IPlatformRenderInterface _renderInterface;\n        private Size _clientSize;\n        private INotificationManager _localNotificationManager;\n        private INotificationManager _systemNotificationManager;\n        private ILayoutManager _layoutManager;\n\n        \/\/\/ <summary>\n        \/\/\/ Initializes static members of the <see cref=\"TopLevel\"\/> class.\n        \/\/\/ <\/summary>\n        static TopLevel()\n        {\n            AffectsMeasure<TopLevel>(ClientSizeProperty);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Initializes a new instance of the <see cref=\"TopLevel\"\/> class.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"impl\">The platform-specific window implementation.<\/param>\n        public TopLevel(ITopLevelImpl impl)\n            : this(impl, AvaloniaLocator.Current)\n        {\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Initializes a new instance of the <see cref=\"TopLevel\"\/> class.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"impl\">The platform-specific window implementation.<\/param>\n        \/\/\/ <param name=\"dependencyResolver\">\n        \/\/\/ The dependency resolver to use. If null the default dependency resolver will be used.\n        \/\/\/ <\/param>\n        public TopLevel(ITopLevelImpl impl, IAvaloniaDependencyResolver dependencyResolver)\n        {\n            if (impl == null)\n            {\n                throw new InvalidOperationException(\n                    \"Could not create window implementation: maybe no windowing subsystem was initialized?\");\n            }\n\n            PlatformImpl = impl;\n\n            LocalNotificationManager = new NotificationArea();\n\n            dependencyResolver = dependencyResolver ?? AvaloniaLocator.Current;\n            var styler = TryGetService<IStyler>(dependencyResolver);\n\n            _accessKeyHandler = TryGetService<IAccessKeyHandler>(dependencyResolver);\n            _inputManager = TryGetService<IInputManager>(dependencyResolver);\n            _keyboardNavigationHandler = TryGetService<IKeyboardNavigationHandler>(dependencyResolver);\n            _applicationLifecycle = TryGetService<IApplicationLifecycle>(dependencyResolver);\n            _renderInterface = TryGetService<IPlatformRenderInterface>(dependencyResolver);\n\n            _systemNotificationManager = TryGetService<INotificationManager>(dependencyResolver);\n\n            if(_systemNotificationManager == null)\n            {\n                SystemNotificationManager = _localNotificationManager;\n            }\n\n            Renderer = impl.CreateRenderer(this);\n\n            if (Renderer != null)\n            {\n                Renderer.SceneInvalidated += SceneInvalidated;\n            }\n\n            impl.SetInputRoot(this);\n\n            impl.Closed = HandleClosed;\n            impl.Input = HandleInput;\n            impl.Paint = HandlePaint;\n            impl.Resized = HandleResized;\n            impl.ScalingChanged = HandleScalingChanged;\n\n            _keyboardNavigationHandler?.SetOwner(this);\n            _accessKeyHandler?.SetOwner(this);\n            styler?.ApplyStyles(this);\n\n            ClientSize = impl.ClientSize;\n            \n            this.GetObservable(PointerOverElementProperty)\n                .Select(\n                    x => (x as InputElement)?.GetObservable(CursorProperty) ?? Observable.Empty<Cursor>())\n                .Switch().Subscribe(cursor => PlatformImpl?.SetCursor(cursor?.PlatformCursor));\n\n            if (_applicationLifecycle != null)\n            {\n                _applicationLifecycle.OnExit += OnApplicationExiting;\n            }\n\n            if (((IStyleHost)this).StylingParent is IResourceProvider applicationResources)\n            {\n                WeakSubscriptionManager.Subscribe(\n                    applicationResources,\n                    nameof(IResourceProvider.ResourcesChanged),\n                    this);\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Fired when the window is opened.\n        \/\/\/ <\/summary>\n        public event EventHandler Opened;\n\n        \/\/\/ <summary>\n        \/\/\/ Fired when the window is closed.\n        \/\/\/ <\/summary>\n        public event EventHandler Closed;\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the client size of the window.\n        \/\/\/ <\/summary>\n        public Size ClientSize\n        {\n            get { return _clientSize; }\n            protected set { SetAndRaise(ClientSizeProperty, ref _clientSize, value); }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the Local (in window managed) notification manager.\n        \/\/\/ <\/summary>\n        public INotificationManager LocalNotificationManager\n        {\n            get => _localNotificationManager;\n            protected set => SetAndRaise(LocalNotificationManagerProperty, ref _localNotificationManager, value);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the System (native os) notification manager. If the system doesnt natively support notifications then this property\n        \/\/\/ will match the <see cref=\"LocalNotificationManager\"\/>.\n        \/\/\/ <\/summary>\n        public INotificationManager SystemNotificationManager\n        {\n            get => _systemNotificationManager;\n            protected set => SetAndRaise(SystemNotificationManagerProperty, ref _systemNotificationManager, value);\n        }\n\n        public ILayoutManager LayoutManager\n        {\n            get\n            {\n                if (_layoutManager == null)\n                    _layoutManager = CreateLayoutManager();\n                return _layoutManager;\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the platform-specific window implementation.\n        \/\/\/ <\/summary>\n        [CanBeNull]\n        public ITopLevelImpl PlatformImpl { get; private set; }\n        \n        \/\/\/ <summary>\n        \/\/\/ Gets the renderer for the window.\n        \/\/\/ <\/summary>\n        public IRenderer Renderer { get; private set; }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the access key handler for the window.\n        \/\/\/ <\/summary>\n        IAccessKeyHandler IInputRoot.AccessKeyHandler => _accessKeyHandler;\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the keyboard navigation handler for the window.\n        \/\/\/ <\/summary>\n        IKeyboardNavigationHandler IInputRoot.KeyboardNavigationHandler => _keyboardNavigationHandler;\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the input element that the pointer is currently over.\n        \/\/\/ <\/summary>\n        IInputElement IInputRoot.PointerOverElement\n        {\n            get { return GetValue(PointerOverElementProperty); }\n            set { SetValue(PointerOverElementProperty, value); }\n        }\n\n        \/\/\/ <inheritdoc\/>\n        IMouseDevice IInputRoot.MouseDevice => PlatformImpl?.MouseDevice;\n\n        void IWeakSubscriber<ResourcesChangedEventArgs>.OnEvent(object sender, ResourcesChangedEventArgs e)\n        {\n            ((ILogical)this).NotifyResourcesChanged(e);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets a value indicating whether access keys are shown in the window.\n        \/\/\/ <\/summary>\n        bool IInputRoot.ShowAccessKeys\n        {\n            get { return GetValue(AccessText.ShowAccessKeyProperty); }\n            set { SetValue(AccessText.ShowAccessKeyProperty, value); }\n        }\n\n        \/\/\/ <inheritdoc\/>\n        Size ILayoutRoot.MaxClientSize => Size.Infinity;\n\n        \/\/\/ <inheritdoc\/>\n        double ILayoutRoot.LayoutScaling => PlatformImpl?.Scaling ?? 1;\n\n        \/\/\/ <inheritdoc\/>\n        double IRenderRoot.RenderScaling => PlatformImpl?.Scaling ?? 1;\n\n        IStyleHost IStyleHost.StylingParent\n        {\n            get { return AvaloniaLocator.Current.GetService<IGlobalStyles>(); }\n        }\n\n        IRenderTarget IRenderRoot.CreateRenderTarget() => CreateRenderTarget();\n\n        \/\/\/ <inheritdoc\/>\n        protected virtual IRenderTarget CreateRenderTarget()\n        {\n            if(PlatformImpl == null)\n                throw new InvalidOperationException(\"Can't create render target, PlatformImpl is null (might be already disposed)\");\n            return _renderInterface.CreateRenderTarget(PlatformImpl.Surfaces);\n        }\n\n        \/\/\/ <inheritdoc\/>\n        void IRenderRoot.Invalidate(Rect rect)\n        {\n            PlatformImpl?.Invalidate(rect);\n        }\n        \n        \/\/\/ <inheritdoc\/>\n        Point IRenderRoot.PointToClient(PixelPoint p)\n        {\n            return PlatformImpl?.PointToClient(p) ?? default;\n        }\n\n        \/\/\/ <inheritdoc\/>\n        PixelPoint IRenderRoot.PointToScreen(Point p)\n        {\n            return PlatformImpl?.PointToScreen(p) ?? default;\n        }\n        \n        \/\/\/ <summary>\n        \/\/\/ Creates the layout manager for this <see cref=\"TopLevel\" \/>.\n        \/\/\/ <\/summary>\n        protected virtual ILayoutManager CreateLayoutManager() => new LayoutManager();\n\n        \/\/\/ <summary>\n        \/\/\/ Handles a paint notification from <see cref=\"ITopLevelImpl.Resized\"\/>.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"rect\">The dirty area.<\/param>\n        protected virtual void HandlePaint(Rect rect)\n        {\n            Renderer?.Paint(rect);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Handles a closed notification from <see cref=\"ITopLevelImpl.Closed\"\/>.\n        \/\/\/ <\/summary>\n        protected virtual void HandleClosed()\n        {\n            PlatformImpl = null;\n\n            Closed?.Invoke(this, EventArgs.Empty);\n            Renderer?.Dispose();\n            Renderer = null;\n            _applicationLifecycle.OnExit -= OnApplicationExiting;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Handles a resize notification from <see cref=\"ITopLevelImpl.Resized\"\/>.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"clientSize\">The new client size.<\/param>\n        protected virtual void HandleResized(Size clientSize)\n        {\n            ClientSize = clientSize;\n            Width = clientSize.Width;\n            Height = clientSize.Height;\n            LayoutManager.ExecuteLayoutPass();\n            Renderer?.Resized(clientSize);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Handles a window scaling change notification from \n        \/\/\/ <see cref=\"ITopLevelImpl.ScalingChanged\"\/>.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"scaling\">The window scaling.<\/param>\n        protected virtual void HandleScalingChanged(double scaling)\n        {\n            foreach (ILayoutable control in this.GetSelfAndVisualDescendants())\n            {\n                control.InvalidateMeasure();\n            }\n        }\n\n        \/\/\/ <inheritdoc\/>\n        protected override void OnAttachedToVisualTree(VisualTreeAttachmentEventArgs e)\n        {\n            base.OnAttachedToVisualTree(e);\n\n            throw new InvalidOperationException(\n                $\"Control '{GetType().Name}' is a top level control and cannot be added as a child.\");\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Raises the <see cref=\"Opened\"\/> event.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"e\">The event args.<\/param>\n        protected virtual void OnOpened(EventArgs e) => Opened?.Invoke(this, e);\n\n        \/\/\/ <summary>\n        \/\/\/ Tries to get a service from an <see cref=\"IAvaloniaDependencyResolver\"\/>, logging a\n        \/\/\/ warning if not found.\n        \/\/\/ <\/summary>\n        \/\/\/ <typeparam name=\"T\">The service type.<\/typeparam>\n        \/\/\/ <param name=\"resolver\">The resolver.<\/param>\n        \/\/\/ <returns>The service.<\/returns>\n        private T TryGetService<T>(IAvaloniaDependencyResolver resolver) where T : class\n        {\n            var result = resolver.GetService<T>();\n\n            if (result == null)\n            {\n                Logger.Warning(\n                    LogArea.Control,\n                    this,\n                    \"Could not create {Service} : maybe Application.RegisterServices() wasn't called?\",\n                    typeof(T));\n            }\n\n            return result;\n        }\n\n        private void OnApplicationExiting(object sender, EventArgs args)\n        {\n            HandleApplicationExiting();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Handles the application exiting, either from the last window closing, or a call to <see cref=\"IApplicationLifecycle.Exit\"\/>.\n        \/\/\/ <\/summary>\n        protected virtual void HandleApplicationExiting()\n        {\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Handles input from <see cref=\"ITopLevelImpl.Input\"\/>.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"e\">The event args.<\/param>\n        private void HandleInput(RawInputEventArgs e)\n        {\n            _inputManager.ProcessInput(e);\n        }\n\n        private void SceneInvalidated(object sender, SceneInvalidatedEventArgs e)\n        {\n            (this as IInputRoot).MouseDevice.SceneInvalidated(this, e.DirtyRect);\n        }\n\n        protected override void OnTemplateApplied(TemplateAppliedEventArgs e)\n        {\n            var adornerLayer = this.GetVisualDescendants()\n                .OfType<AdornerDecorator>()\n                .FirstOrDefault()\n                ?.AdornerLayer;\n\n            if (adornerLayer != null)\n            {\n                adornerLayer.Children.Add(LocalNotificationManager as IControl);\n            }\n\n            base.OnTemplateApplied(e);\n        }\n    }\n}\n","old_contents":"\/\/ Copyright (c) The Avalonia Project. All rights reserved.\n\/\/ Licensed under the MIT license. See licence.md file in the project root for full license information.\n\nusing System;\nusing System.Linq;\nusing System.Reactive.Linq;\nusing Avalonia.Controls.Notifications;\nusing Avalonia.Controls.Primitives;\nusing Avalonia.Input;\nusing Avalonia.Input.Raw;\nusing Avalonia.Layout;\nusing Avalonia.Logging;\nusing Avalonia.LogicalTree;\nusing Avalonia.Platform;\nusing Avalonia.Rendering;\nusing Avalonia.Styling;\nusing Avalonia.Utilities;\nusing Avalonia.VisualTree;\nusing JetBrains.Annotations;\n\nnamespace Avalonia.Controls\n{\n    \/\/\/ <summary>\n    \/\/\/ Base class for top-level widgets.\n    \/\/\/ <\/summary>\n    \/\/\/ <remarks>\n    \/\/\/ This class acts as a base for top level widget.\n    \/\/\/ It handles scheduling layout, styling and rendering as well as\n    \/\/\/ tracking the widget's <see cref=\"ClientSize\"\/>.\n    \/\/\/ <\/remarks>\n    public abstract class TopLevel : ContentControl,\n        IInputRoot,\n        ILayoutRoot,\n        IRenderRoot,\n        ICloseable,\n        IStyleRoot,\n        IWeakSubscriber<ResourcesChangedEventArgs>\n    {\n        \/\/\/ <summary>\n        \/\/\/ Defines the <see cref=\"ClientSize\"\/> property.\n        \/\/\/ <\/summary>\n        public static readonly DirectProperty<TopLevel, Size> ClientSizeProperty =\n            AvaloniaProperty.RegisterDirect<TopLevel, Size>(nameof(ClientSize), o => o.ClientSize);\n\n        \/\/\/ <summary>\n        \/\/\/ Defines the <see cref=\"IInputRoot.PointerOverElement\"\/> property.\n        \/\/\/ <\/summary>\n        public static readonly StyledProperty<IInputElement> PointerOverElementProperty =\n            AvaloniaProperty.Register<TopLevel, IInputElement>(nameof(IInputRoot.PointerOverElement));\n\n        \/\/\/ <summary>\n        \/\/\/ Defines the <see cref=\"LocalNotificationManager\"\/> property.\n        \/\/\/ <\/summary>\n        public static readonly DirectProperty<TopLevel, INotificationManager> LocalNotificationManagerProperty =\n            AvaloniaProperty.RegisterDirect<TopLevel, INotificationManager>(nameof(LocalNotificationManager), o => o.LocalNotificationManager);\n\n        \/\/\/ <summary>\n        \/\/\/ Defines the <see cref=\"SystemNotificationManager\"\/> property.\n        \/\/\/ <\/summary>\n        public static readonly DirectProperty<TopLevel, INotificationManager> SystemNotificationManagerProperty =\n            AvaloniaProperty.RegisterDirect<TopLevel, INotificationManager>(nameof(SystemNotificationManager), o => o.SystemNotificationManager);\n\n        private readonly IInputManager _inputManager;\n        private readonly IAccessKeyHandler _accessKeyHandler;\n        private readonly IKeyboardNavigationHandler _keyboardNavigationHandler;\n        private readonly IApplicationLifecycle _applicationLifecycle;\n        private readonly IPlatformRenderInterface _renderInterface;\n        private Size _clientSize;\n        private INotificationManager _localNotificationManager;\n        private INotificationManager _systemNotificationManager;\n        private ILayoutManager _layoutManager;\n\n        \/\/\/ <summary>\n        \/\/\/ Initializes static members of the <see cref=\"TopLevel\"\/> class.\n        \/\/\/ <\/summary>\n        static TopLevel()\n        {\n            AffectsMeasure<TopLevel>(ClientSizeProperty);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Initializes a new instance of the <see cref=\"TopLevel\"\/> class.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"impl\">The platform-specific window implementation.<\/param>\n        public TopLevel(ITopLevelImpl impl)\n            : this(impl, AvaloniaLocator.Current)\n        {\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Initializes a new instance of the <see cref=\"TopLevel\"\/> class.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"impl\">The platform-specific window implementation.<\/param>\n        \/\/\/ <param name=\"dependencyResolver\">\n        \/\/\/ The dependency resolver to use. If null the default dependency resolver will be used.\n        \/\/\/ <\/param>\n        public TopLevel(ITopLevelImpl impl, IAvaloniaDependencyResolver dependencyResolver)\n        {\n            if (impl == null)\n            {\n                throw new InvalidOperationException(\n                    \"Could not create window implementation: maybe no windowing subsystem was initialized?\");\n            }\n\n            PlatformImpl = impl;\n\n            LocalNotificationManager = new NotificationArea();\n\n            dependencyResolver = dependencyResolver ?? AvaloniaLocator.Current;\n            var styler = TryGetService<IStyler>(dependencyResolver);\n\n            _accessKeyHandler = TryGetService<IAccessKeyHandler>(dependencyResolver);\n            _inputManager = TryGetService<IInputManager>(dependencyResolver);\n            _keyboardNavigationHandler = TryGetService<IKeyboardNavigationHandler>(dependencyResolver);\n            _applicationLifecycle = TryGetService<IApplicationLifecycle>(dependencyResolver);\n            _renderInterface = TryGetService<IPlatformRenderInterface>(dependencyResolver);\n\n            _systemNotificationManager = TryGetService<INotificationManager>(dependencyResolver);\n\n            if(_systemNotificationManager == null)\n            {\n                SystemNotificationManager = _localNotificationManager;\n            }\n\n            Renderer = impl.CreateRenderer(this);\n\n            if (Renderer != null)\n            {\n                Renderer.SceneInvalidated += SceneInvalidated;\n            }\n\n            impl.SetInputRoot(this);\n\n            impl.Closed = HandleClosed;\n            impl.Input = HandleInput;\n            impl.Paint = HandlePaint;\n            impl.Resized = HandleResized;\n            impl.ScalingChanged = HandleScalingChanged;\n\n            _keyboardNavigationHandler?.SetOwner(this);\n            _accessKeyHandler?.SetOwner(this);\n            styler?.ApplyStyles(this);\n\n            ClientSize = impl.ClientSize;\n            \n            this.GetObservable(PointerOverElementProperty)\n                .Select(\n                    x => (x as InputElement)?.GetObservable(CursorProperty) ?? Observable.Empty<Cursor>())\n                .Switch().Subscribe(cursor => PlatformImpl?.SetCursor(cursor?.PlatformCursor));\n\n            if (_applicationLifecycle != null)\n            {\n                _applicationLifecycle.OnExit += OnApplicationExiting;\n            }\n\n            if (((IStyleHost)this).StylingParent is IResourceProvider applicationResources)\n            {\n                WeakSubscriptionManager.Subscribe(\n                    applicationResources,\n                    nameof(IResourceProvider.ResourcesChanged),\n                    this);\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Fired when the window is opened.\n        \/\/\/ <\/summary>\n        public event EventHandler Opened;\n\n        \/\/\/ <summary>\n        \/\/\/ Fired when the window is closed.\n        \/\/\/ <\/summary>\n        public event EventHandler Closed;\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the client size of the window.\n        \/\/\/ <\/summary>\n        public Size ClientSize\n        {\n            get { return _clientSize; }\n            protected set { SetAndRaise(ClientSizeProperty, ref _clientSize, value); }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the Local (in window managed) notification manager.\n        \/\/\/ <\/summary>\n        public INotificationManager LocalNotificationManager\n        {\n            get => _localNotificationManager;\n            protected set => SetAndRaise(LocalNotificationManagerProperty, ref _localNotificationManager, value);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the System (native os) notification manager. If the system doesnt natively support notifications then this property\n        \/\/\/ will match the <see cref=\"LocalNotificationManager\"\/>.\n        \/\/\/ <\/summary>\n        public INotificationManager SystemNotificationManager\n        {\n            get => _systemNotificationManager;\n            protected set => SetAndRaise(SystemNotificationManagerProperty, ref _systemNotificationManager, value);\n        }\n\n        public ILayoutManager LayoutManager\n        {\n            get\n            {\n                if (_layoutManager == null)\n                    _layoutManager = CreateLayoutManager();\n                return _layoutManager;\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the platform-specific window implementation.\n        \/\/\/ <\/summary>\n        [CanBeNull]\n        public ITopLevelImpl PlatformImpl { get; private set; }\n        \n        \/\/\/ <summary>\n        \/\/\/ Gets the renderer for the window.\n        \/\/\/ <\/summary>\n        public IRenderer Renderer { get; private set; }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the access key handler for the window.\n        \/\/\/ <\/summary>\n        IAccessKeyHandler IInputRoot.AccessKeyHandler => _accessKeyHandler;\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the keyboard navigation handler for the window.\n        \/\/\/ <\/summary>\n        IKeyboardNavigationHandler IInputRoot.KeyboardNavigationHandler => _keyboardNavigationHandler;\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the input element that the pointer is currently over.\n        \/\/\/ <\/summary>\n        IInputElement IInputRoot.PointerOverElement\n        {\n            get { return GetValue(PointerOverElementProperty); }\n            set { SetValue(PointerOverElementProperty, value); }\n        }\n\n        \/\/\/ <inheritdoc\/>\n        IMouseDevice IInputRoot.MouseDevice => PlatformImpl?.MouseDevice;\n\n        void IWeakSubscriber<ResourcesChangedEventArgs>.OnEvent(object sender, ResourcesChangedEventArgs e)\n        {\n            ((ILogical)this).NotifyResourcesChanged(e);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets a value indicating whether access keys are shown in the window.\n        \/\/\/ <\/summary>\n        bool IInputRoot.ShowAccessKeys\n        {\n            get { return GetValue(AccessText.ShowAccessKeyProperty); }\n            set { SetValue(AccessText.ShowAccessKeyProperty, value); }\n        }\n\n        \/\/\/ <inheritdoc\/>\n        Size ILayoutRoot.MaxClientSize => Size.Infinity;\n\n        \/\/\/ <inheritdoc\/>\n        double ILayoutRoot.LayoutScaling => PlatformImpl?.Scaling ?? 1;\n\n        \/\/\/ <inheritdoc\/>\n        double IRenderRoot.RenderScaling => PlatformImpl?.Scaling ?? 1;\n\n        IStyleHost IStyleHost.StylingParent\n        {\n            get { return AvaloniaLocator.Current.GetService<IGlobalStyles>(); }\n        }\n\n        IRenderTarget IRenderRoot.CreateRenderTarget() => CreateRenderTarget();\n\n        \/\/\/ <inheritdoc\/>\n        protected virtual IRenderTarget CreateRenderTarget()\n        {\n            if(PlatformImpl == null)\n                throw new InvalidOperationException(\"Can't create render target, PlatformImpl is null (might be already disposed)\");\n            return _renderInterface.CreateRenderTarget(PlatformImpl.Surfaces);\n        }\n\n        \/\/\/ <inheritdoc\/>\n        void IRenderRoot.Invalidate(Rect rect)\n        {\n            PlatformImpl?.Invalidate(rect);\n        }\n        \n        \/\/\/ <inheritdoc\/>\n        Point IRenderRoot.PointToClient(PixelPoint p)\n        {\n            return PlatformImpl?.PointToClient(p) ?? default;\n        }\n\n        \/\/\/ <inheritdoc\/>\n        PixelPoint IRenderRoot.PointToScreen(Point p)\n        {\n            return PlatformImpl?.PointToScreen(p) ?? default;\n        }\n        \n        \/\/\/ <summary>\n        \/\/\/ Creates the layout manager for this <see cref=\"TopLevel\" \/>.\n        \/\/\/ <\/summary>\n        protected virtual ILayoutManager CreateLayoutManager() => new LayoutManager();\n\n        \/\/\/ <summary>\n        \/\/\/ Handles a paint notification from <see cref=\"ITopLevelImpl.Resized\"\/>.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"rect\">The dirty area.<\/param>\n        protected virtual void HandlePaint(Rect rect)\n        {\n            Renderer?.Paint(rect);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Handles a closed notification from <see cref=\"ITopLevelImpl.Closed\"\/>.\n        \/\/\/ <\/summary>\n        protected virtual void HandleClosed()\n        {\n            PlatformImpl = null;\n\n            Closed?.Invoke(this, EventArgs.Empty);\n            Renderer?.Dispose();\n            Renderer = null;\n            _applicationLifecycle.OnExit -= OnApplicationExiting;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Handles a resize notification from <see cref=\"ITopLevelImpl.Resized\"\/>.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"clientSize\">The new client size.<\/param>\n        protected virtual void HandleResized(Size clientSize)\n        {\n            ClientSize = clientSize;\n            Width = clientSize.Width;\n            Height = clientSize.Height;\n            LayoutManager.ExecuteLayoutPass();\n            Renderer?.Resized(clientSize);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Handles a window scaling change notification from \n        \/\/\/ <see cref=\"ITopLevelImpl.ScalingChanged\"\/>.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"scaling\">The window scaling.<\/param>\n        protected virtual void HandleScalingChanged(double scaling)\n        {\n            foreach (ILayoutable control in this.GetSelfAndVisualDescendants())\n            {\n                control.InvalidateMeasure();\n            }\n        }\n\n        \/\/\/ <inheritdoc\/>\n        protected override void OnAttachedToVisualTree(VisualTreeAttachmentEventArgs e)\n        {\n            base.OnAttachedToVisualTree(e);\n\n            throw new InvalidOperationException(\n                $\"Control '{GetType().Name}' is a top level control and cannot be added as a child.\");\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Raises the <see cref=\"Opened\"\/> event.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"e\">The event args.<\/param>\n        protected virtual void OnOpened(EventArgs e) => Opened?.Invoke(this, e);\n\n        \/\/\/ <summary>\n        \/\/\/ Tries to get a service from an <see cref=\"IAvaloniaDependencyResolver\"\/>, logging a\n        \/\/\/ warning if not found.\n        \/\/\/ <\/summary>\n        \/\/\/ <typeparam name=\"T\">The service type.<\/typeparam>\n        \/\/\/ <param name=\"resolver\">The resolver.<\/param>\n        \/\/\/ <returns>The service.<\/returns>\n        private T TryGetService<T>(IAvaloniaDependencyResolver resolver) where T : class\n        {\n            var result = resolver.GetService<T>();\n\n            if (result == null)\n            {\n                Logger.Warning(\n                    LogArea.Control,\n                    this,\n                    \"Could not create {Service} : maybe Application.RegisterServices() wasn't called?\",\n                    typeof(T));\n            }\n\n            return result;\n        }\n\n        private void OnApplicationExiting(object sender, EventArgs args)\n        {\n            HandleApplicationExiting();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Handles the application exiting, either from the last window closing, or a call to <see cref=\"IApplicationLifecycle.Exit\"\/>.\n        \/\/\/ <\/summary>\n        protected virtual void HandleApplicationExiting()\n        {\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Handles input from <see cref=\"ITopLevelImpl.Input\"\/>.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"e\">The event args.<\/param>\n        private void HandleInput(RawInputEventArgs e)\n        {\n            _inputManager.ProcessInput(e);\n        }\n\n        private void SceneInvalidated(object sender, SceneInvalidatedEventArgs e)\n        {\n            (this as IInputRoot).MouseDevice.SceneInvalidated(this, e.DirtyRect);\n        }\n\n        protected override void OnTemplateApplied(TemplateAppliedEventArgs e)\n        {\n            var adornerLayer = this.GetVisualDescendants()\n                .OfType<AdornerDecorator>()\n                .FirstOrDefault()\n                ?.AdornerLayer;\n\n            if (adornerLayer != null)\n            {\n                adornerLayer.Children.Add(LocalNotificationManager as IControl);\n            }\n\n            base.OnTemplateApplied(e);\n        }\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"3e3eddca87e08d586b2ff6a7b00a9b9ed979a115","subject":"Save a few value lookups during arrange and measure.","message":"Save a few value lookups during arrange and measure.\n","repos":"jkoritzinsky\/Avalonia,AvaloniaUI\/Avalonia,jkoritzinsky\/Avalonia,jkoritzinsky\/Avalonia,SuperJMN\/Avalonia,jkoritzinsky\/Avalonia,jkoritzinsky\/Avalonia,SuperJMN\/Avalonia,AvaloniaUI\/Avalonia,AvaloniaUI\/Avalonia,wieslawsoltes\/Perspex,akrisiun\/Perspex,wieslawsoltes\/Perspex,Perspex\/Perspex,SuperJMN\/Avalonia,SuperJMN\/Avalonia,jkoritzinsky\/Avalonia,SuperJMN\/Avalonia,wieslawsoltes\/Perspex,wieslawsoltes\/Perspex,grokys\/Perspex,jkoritzinsky\/Avalonia,SuperJMN\/Avalonia,AvaloniaUI\/Avalonia,AvaloniaUI\/Avalonia,wieslawsoltes\/Perspex,AvaloniaUI\/Avalonia,jkoritzinsky\/Perspex,grokys\/Perspex,AvaloniaUI\/Avalonia,wieslawsoltes\/Perspex,Perspex\/Perspex,SuperJMN\/Avalonia,wieslawsoltes\/Perspex","old_file":"src\/Avalonia.Layout\/Layoutable.cs","new_file":"src\/Avalonia.Layout\/Layoutable.cs","new_contents":"\/\/ Copyright (c) The Avalonia Project. All rights reserved.\n\/\/ Licensed under the MIT license. See licence.md file in the project root for full license information.\n\nusing System;\nusing System.Linq;\nusing Avalonia.Logging;\nusing Avalonia.VisualTree;\n\nnamespace Avalonia.Layout\n{\n    \/\/\/ <summary>\n    \/\/\/ Defines how a control aligns itself horizontally in its parent control.\n    \/\/\/ <\/summary>\n    public enum HorizontalAlignment\n    {\n        \/\/\/ <summary>\n        \/\/\/ The control stretches to fill the width of the parent control.\n        \/\/\/ <\/summary>\n        Stretch,\n\n        \/\/\/ <summary>\n        \/\/\/ The control aligns itself to the left of the parent control.\n        \/\/\/ <\/summary>\n        Left,\n\n        \/\/\/ <summary>\n        \/\/\/ The control centers itself in the parent control.\n        \/\/\/ <\/summary>\n        Center,\n\n        \/\/\/ <summary>\n        \/\/\/ The control aligns itself to the right of the parent control.\n        \/\/\/ <\/summary>\n        Right,\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Defines how a control aligns itself vertically in its parent control.\n    \/\/\/ <\/summary>\n    public enum VerticalAlignment\n    {\n        \/\/\/ <summary>\n        \/\/\/ The control stretches to fill the height of the parent control.\n        \/\/\/ <\/summary>\n        Stretch,\n\n        \/\/\/ <summary>\n        \/\/\/ The control aligns itself to the top of the parent control.\n        \/\/\/ <\/summary>\n        Top,\n\n        \/\/\/ <summary>\n        \/\/\/ The control centers itself within the parent control.\n        \/\/\/ <\/summary>\n        Center,\n\n        \/\/\/ <summary>\n        \/\/\/ The control aligns itself to the bottom of the parent control.\n        \/\/\/ <\/summary>\n        Bottom,\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Implements layout-related functionality for a control.\n    \/\/\/ <\/summary>\n    public class Layoutable : Visual, ILayoutable\n    {\n        \/\/\/ <summary>\n        \/\/\/ Defines the <see cref=\"DesiredSize\"\/> property.\n        \/\/\/ <\/summary>\n        public static readonly DirectProperty<Layoutable, Size> DesiredSizeProperty =\n            AvaloniaProperty.RegisterDirect<Layoutable, Size>(nameof(DesiredSize), o => o.DesiredSize);\n\n        \/\/\/ <summary>\n        \/\/\/ Defines the <see cref=\"Width\"\/> property.\n        \/\/\/ <\/summary>\n        public static readonly StyledProperty<double> WidthProperty =\n            AvaloniaProperty.Register<Layoutable, double>(nameof(Width), double.NaN);\n\n        \/\/\/ <summary>\n        \/\/\/ Defines the <see cref=\"Height\"\/> property.\n        \/\/\/ <\/summary>\n        public static readonly StyledProperty<double> HeightProperty =\n            AvaloniaProperty.Register<Layoutable, double>(nameof(Height), double.NaN);\n\n        \/\/\/ <summary>\n        \/\/\/ Defines the <see cref=\"MinWidth\"\/> property.\n        \/\/\/ <\/summary>\n        public static readonly StyledProperty<double> MinWidthProperty =\n            AvaloniaProperty.Register<Layoutable, double>(nameof(MinWidth));\n\n        \/\/\/ <summary>\n        \/\/\/ Defines the <see cref=\"MaxWidth\"\/> property.\n        \/\/\/ <\/summary>\n        public static readonly StyledProperty<double> MaxWidthProperty =\n            AvaloniaProperty.Register<Layoutable, double>(nameof(MaxWidth), double.PositiveInfinity);\n\n        \/\/\/ <summary>\n        \/\/\/ Defines the <see cref=\"MinHeight\"\/> property.\n        \/\/\/ <\/summary>\n        public static readonly StyledProperty<double> MinHeightProperty =\n            AvaloniaProperty.Register<Layoutable, double>(nameof(MinHeight));\n\n        \/\/\/ <summary>\n        \/\/\/ Defines the <see cref=\"MaxHeight\"\/> property.\n        \/\/\/ <\/summary>\n        public static readonly StyledProperty<double> MaxHeightProperty =\n            AvaloniaProperty.Register<Layoutable, double>(nameof(MaxHeight), double.PositiveInfinity);\n\n        \/\/\/ <summary>\n        \/\/\/ Defines the <see cref=\"Margin\"\/> property.\n        \/\/\/ <\/summary>\n        public static readonly StyledProperty<Thickness> MarginProperty =\n            AvaloniaProperty.Register<Layoutable, Thickness>(nameof(Margin));\n\n        \/\/\/ <summary>\n        \/\/\/ Defines the <see cref=\"HorizontalAlignment\"\/> property.\n        \/\/\/ <\/summary>\n        public static readonly StyledProperty<HorizontalAlignment> HorizontalAlignmentProperty =\n            AvaloniaProperty.Register<Layoutable, HorizontalAlignment>(nameof(HorizontalAlignment));\n\n        \/\/\/ <summary>\n        \/\/\/ Defines the <see cref=\"VerticalAlignment\"\/> property.\n        \/\/\/ <\/summary>\n        public static readonly StyledProperty<VerticalAlignment> VerticalAlignmentProperty =\n            AvaloniaProperty.Register<Layoutable, VerticalAlignment>(nameof(VerticalAlignment));\n\n        \/\/\/ <summary>\n        \/\/\/ Defines the <see cref=\"UseLayoutRoundingProperty\"\/> property.\n        \/\/\/ <\/summary>\n        public static readonly StyledProperty<bool> UseLayoutRoundingProperty =\n            AvaloniaProperty.Register<Layoutable, bool>(nameof(UseLayoutRounding), defaultValue: true, inherits: true);\n\n        private bool _measuring;\n        private Size? _previousMeasure;\n        private Rect? _previousArrange;\n\n        \/\/\/ <summary>\n        \/\/\/ Initializes static members of the <see cref=\"Layoutable\"\/> class.\n        \/\/\/ <\/summary>\n        static Layoutable()\n        {\n            AffectsMeasure<Layoutable>(\n                IsVisibleProperty,\n                WidthProperty,\n                HeightProperty,\n                MinWidthProperty,\n                MaxWidthProperty,\n                MinHeightProperty,\n                MaxHeightProperty,\n                MarginProperty,\n                HorizontalAlignmentProperty,\n                VerticalAlignmentProperty);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Occurs when a layout pass completes for the control.\n        \/\/\/ <\/summary>\n        public event EventHandler LayoutUpdated;\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the width of the element.\n        \/\/\/ <\/summary>\n        public double Width\n        {\n            get { return GetValue(WidthProperty); }\n            set { SetValue(WidthProperty, value); }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the height of the element.\n        \/\/\/ <\/summary>\n        public double Height\n        {\n            get { return GetValue(HeightProperty); }\n            set { SetValue(HeightProperty, value); }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the minimum width of the element.\n        \/\/\/ <\/summary>\n        public double MinWidth\n        {\n            get { return GetValue(MinWidthProperty); }\n            set { SetValue(MinWidthProperty, value); }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the maximum width of the element.\n        \/\/\/ <\/summary>\n        public double MaxWidth\n        {\n            get { return GetValue(MaxWidthProperty); }\n            set { SetValue(MaxWidthProperty, value); }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the minimum height of the element.\n        \/\/\/ <\/summary>\n        public double MinHeight\n        {\n            get { return GetValue(MinHeightProperty); }\n            set { SetValue(MinHeightProperty, value); }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the maximum height of the element.\n        \/\/\/ <\/summary>\n        public double MaxHeight\n        {\n            get { return GetValue(MaxHeightProperty); }\n            set { SetValue(MaxHeightProperty, value); }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the margin around the element.\n        \/\/\/ <\/summary>\n        public Thickness Margin\n        {\n            get { return GetValue(MarginProperty); }\n            set { SetValue(MarginProperty, value); }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the element's preferred horizontal alignment in its parent.\n        \/\/\/ <\/summary>\n        public HorizontalAlignment HorizontalAlignment\n        {\n            get { return GetValue(HorizontalAlignmentProperty); }\n            set { SetValue(HorizontalAlignmentProperty, value); }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the element's preferred vertical alignment in its parent.\n        \/\/\/ <\/summary>\n        public VerticalAlignment VerticalAlignment\n        {\n            get { return GetValue(VerticalAlignmentProperty); }\n            set { SetValue(VerticalAlignmentProperty, value); }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the size that this element computed during the measure pass of the layout process.\n        \/\/\/ <\/summary>\n        public Size DesiredSize\n        {\n            get;\n            private set;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets a value indicating whether the control's layout measure is valid.\n        \/\/\/ <\/summary>\n        public bool IsMeasureValid\n        {\n            get;\n            private set;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets a value indicating whether the control's layouts arrange is valid.\n        \/\/\/ <\/summary>\n        public bool IsArrangeValid\n        {\n            get;\n            private set;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets a value that determines whether the element should be snapped to pixel\n        \/\/\/ boundaries at layout time.\n        \/\/\/ <\/summary>\n        public bool UseLayoutRounding\n        {\n            get { return GetValue(UseLayoutRoundingProperty); }\n            set { SetValue(UseLayoutRoundingProperty, value); }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the available size passed in the previous layout pass, if any.\n        \/\/\/ <\/summary>\n        Size? ILayoutable.PreviousMeasure => _previousMeasure;\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the layout rect passed in the previous layout pass, if any.\n        \/\/\/ <\/summary>\n        Rect? ILayoutable.PreviousArrange => _previousArrange;\n\n        \/\/\/ <summary>\n        \/\/\/ Creates the visual children of the control, if necessary\n        \/\/\/ <\/summary>\n        public virtual void ApplyTemplate()\n        {\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Carries out a measure of the control.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"availableSize\">The available size for the control.<\/param>\n        public void Measure(Size availableSize)\n        {\n            if (double.IsNaN(availableSize.Width) || double.IsNaN(availableSize.Height))\n            {\n                throw new InvalidOperationException(\"Cannot call Measure using a size with NaN values.\");\n            }\n\n            if (!IsMeasureValid || _previousMeasure != availableSize)\n            {\n                var previousDesiredSize = DesiredSize;\n                var desiredSize = default(Size);\n\n                IsMeasureValid = true;\n\n                try\n                {\n                    _measuring = true;\n                    desiredSize = MeasureCore(availableSize);\n                }\n                finally\n                {\n                    _measuring = false;\n                }\n\n                if (IsInvalidSize(desiredSize))\n                {\n                    throw new InvalidOperationException(\"Invalid size returned for Measure.\");\n                }\n\n                DesiredSize = desiredSize;\n                _previousMeasure = availableSize;\n\n                Logger.TryGet(LogEventLevel.Verbose)?.Log(LogArea.Layout, this, \"Measure requested {DesiredSize}\", DesiredSize);\n\n                if (DesiredSize != previousDesiredSize)\n                {\n                    this.GetVisualParent<ILayoutable>()?.ChildDesiredSizeChanged(this);\n                }\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Arranges the control and its children.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"rect\">The control's new bounds.<\/param>\n        public void Arrange(Rect rect)\n        {\n            if (IsInvalidRect(rect))\n            {\n                throw new InvalidOperationException(\"Invalid Arrange rectangle.\");\n            }\n\n            if (!IsMeasureValid)\n            {\n                Measure(_previousMeasure ?? rect.Size);\n            }\n\n            if (!IsArrangeValid || _previousArrange != rect)\n            {\n                Logger.TryGet(LogEventLevel.Verbose)?.Log(LogArea.Layout, this, \"Arrange to {Rect} \", rect);\n\n                IsArrangeValid = true;\n                ArrangeCore(rect);\n                _previousArrange = rect;\n\n                LayoutUpdated?.Invoke(this, EventArgs.Empty);\n            }\n        }\n\n\n        \/\/\/ <summary>\n        \/\/\/ Called by InvalidateMeasure\n        \/\/\/ <\/summary>\n        protected virtual void OnMeasureInvalidated()\n        {\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Invalidates the measurement of the control and queues a new layout pass.\n        \/\/\/ <\/summary>\n        public void InvalidateMeasure()\n        {\n            if (IsMeasureValid)\n            {\n                Logger.TryGet(LogEventLevel.Verbose)?.Log(LogArea.Layout, this, \"Invalidated measure\");\n\n                IsMeasureValid = false;\n                IsArrangeValid = false;\n\n                if (((ILayoutable)this).IsAttachedToVisualTree)\n                {\n                    (VisualRoot as ILayoutRoot)?.LayoutManager.InvalidateMeasure(this);\n                    InvalidateVisual();\n                }\n                OnMeasureInvalidated();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Invalidates the arrangement of the control and queues a new layout pass.\n        \/\/\/ <\/summary>\n        public void InvalidateArrange()\n        {\n            if (IsArrangeValid)\n            {\n                Logger.TryGet(LogEventLevel.Verbose)?.Log(LogArea.Layout, this, \"Invalidated arrange\");\n\n                IsArrangeValid = false;\n                (VisualRoot as ILayoutRoot)?.LayoutManager?.InvalidateArrange(this);\n                InvalidateVisual();\n            }\n        }\n\n        \/\/\/ <inheritdoc\/>\n        void ILayoutable.ChildDesiredSizeChanged(ILayoutable control)\n        {\n            if (!_measuring)\n            {\n                InvalidateMeasure();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Marks a property as affecting the control's measurement.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"properties\">The properties.<\/param>\n        \/\/\/ <remarks>\n        \/\/\/ After a call to this method in a control's static constructor, any change to the\n        \/\/\/ property will cause <see cref=\"InvalidateMeasure\"\/> to be called on the element.\n        \/\/\/ <\/remarks>\n        [Obsolete(\"Use AffectsMeasure<T> and specify the control type.\")]\n        protected static void AffectsMeasure(params AvaloniaProperty[] properties)\n        {\n            AffectsMeasure<Layoutable>(properties);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Marks a property as affecting the control's measurement.\n        \/\/\/ <\/summary>\n        \/\/\/ <typeparam name=\"T\">The control which the property affects.<\/typeparam>\n        \/\/\/ <param name=\"properties\">The properties.<\/param>\n        \/\/\/ <remarks>\n        \/\/\/ After a call to this method in a control's static constructor, any change to the\n        \/\/\/ property will cause <see cref=\"InvalidateMeasure\"\/> to be called on the element.\n        \/\/\/ <\/remarks>\n        protected static void AffectsMeasure<T>(params AvaloniaProperty[] properties)\n            where T : class, ILayoutable\n        {\n            void Invalidate(AvaloniaPropertyChangedEventArgs e)\n            {\n                (e.Sender as T)?.InvalidateMeasure();\n            }\n\n            foreach (var property in properties)\n            {\n                property.Changed.Subscribe(Invalidate);\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Marks a property as affecting the control's arrangement.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"properties\">The properties.<\/param>\n        \/\/\/ <remarks>\n        \/\/\/ After a call to this method in a control's static constructor, any change to the\n        \/\/\/ property will cause <see cref=\"InvalidateArrange\"\/> to be called on the element.\n        \/\/\/ <\/remarks>\n        [Obsolete(\"Use AffectsArrange<T> and specify the control type.\")]\n        protected static void AffectsArrange(params AvaloniaProperty[] properties)\n        {\n            AffectsArrange<Layoutable>(properties);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Marks a property as affecting the control's arrangement.\n        \/\/\/ <\/summary>\n        \/\/\/ <typeparam name=\"T\">The control which the property affects.<\/typeparam>\n        \/\/\/ <param name=\"properties\">The properties.<\/param>\n        \/\/\/ <remarks>\n        \/\/\/ After a call to this method in a control's static constructor, any change to the\n        \/\/\/ property will cause <see cref=\"InvalidateArrange\"\/> to be called on the element.\n        \/\/\/ <\/remarks>\n        protected static void AffectsArrange<T>(params AvaloniaProperty[] properties)\n            where T : class, ILayoutable\n        {\n            void Invalidate(AvaloniaPropertyChangedEventArgs e)\n            {\n                (e.Sender as T)?.InvalidateArrange();\n            }\n\n            foreach (var property in properties)\n            {\n                property.Changed.Subscribe(Invalidate);\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ The default implementation of the control's measure pass.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"availableSize\">The size available to the control.<\/param>\n        \/\/\/ <returns>The desired size for the control.<\/returns>\n        \/\/\/ <remarks>\n        \/\/\/ This method calls <see cref=\"MeasureOverride(Size)\"\/> which is probably the method you\n        \/\/\/ want to override in order to modify a control's arrangement.\n        \/\/\/ <\/remarks>\n        protected virtual Size MeasureCore(Size availableSize)\n        {\n            if (IsVisible)\n            {\n                var margin = Margin;\n\n                ApplyTemplate();\n\n                var constrained = LayoutHelper.ApplyLayoutConstraints(\n                    this,\n                    availableSize.Deflate(margin));\n                var measured = MeasureOverride(constrained);\n\n                var width = measured.Width;\n                var height = measured.Height;\n\n                {\n                    double widthCache = Width;\n\n                    if (!double.IsNaN(widthCache))\n                    {\n                        width = widthCache;\n                    }\n                }\n\n                width = Math.Min(width, MaxWidth);\n                width = Math.Max(width, MinWidth);\n\n                {\n                    double heightCache = Height;\n\n                    if (!double.IsNaN(heightCache))\n                    {\n                        height = Height;\n                    }\n                }\n\n                height = Math.Min(height, MaxHeight);\n                height = Math.Max(height, MinHeight);\n\n                width = Math.Min(width, availableSize.Width);\n                height = Math.Min(height, availableSize.Height);\n\n                if (UseLayoutRounding)\n                {\n                    var scale = GetLayoutScale();\n                    width = Math.Ceiling(width * scale) \/ scale;\n                    height = Math.Ceiling(height * scale) \/ scale;\n                }\n\n                return NonNegative(new Size(width, height).Inflate(margin));\n            }\n            else\n            {\n                return new Size();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Measures the control and its child elements as part of a layout pass.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"availableSize\">The size available to the control.<\/param>\n        \/\/\/ <returns>The desired size for the control.<\/returns>\n        protected virtual Size MeasureOverride(Size availableSize)\n        {\n            double width = 0;\n            double height = 0;\n\n            var visualCount = VisualChildren.Count;\n\n            for (var i = 0; i < visualCount; i++)\n            {\n                IVisual visual = VisualChildren[i];\n\n                if (visual is ILayoutable layoutable)\n                {\n                    layoutable.Measure(availableSize);\n                    width = Math.Max(width, layoutable.DesiredSize.Width);\n                    height = Math.Max(height, layoutable.DesiredSize.Height);\n                }\n            }\n\n            return new Size(width, height);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ The default implementation of the control's arrange pass.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"finalRect\">The control's new bounds.<\/param>\n        \/\/\/ <remarks>\n        \/\/\/ This method calls <see cref=\"ArrangeOverride(Size)\"\/> which is probably the method you\n        \/\/\/ want to override in order to modify a control's arrangement.\n        \/\/\/ <\/remarks>\n        protected virtual void ArrangeCore(Rect finalRect)\n        {\n            if (IsVisible)\n            {\n                var margin = Margin;\n                var originX = finalRect.X + margin.Left;\n                var originY = finalRect.Y + margin.Top;\n                var availableSizeMinusMargins = new Size(\n                    Math.Max(0, finalRect.Width - margin.Left - margin.Right),\n                    Math.Max(0, finalRect.Height - margin.Top - margin.Bottom));\n                var horizontalAlignment = HorizontalAlignment;\n                var verticalAlignment = VerticalAlignment;\n                var size = availableSizeMinusMargins;\n                var scale = GetLayoutScale();\n                var useLayoutRounding = UseLayoutRounding;\n\n                if (horizontalAlignment != HorizontalAlignment.Stretch)\n                {\n                    size = size.WithWidth(Math.Min(size.Width, DesiredSize.Width - margin.Left - margin.Right));\n                }\n\n                if (verticalAlignment != VerticalAlignment.Stretch)\n                {\n                    size = size.WithHeight(Math.Min(size.Height, DesiredSize.Height - margin.Top - margin.Bottom));\n                }\n\n                size = LayoutHelper.ApplyLayoutConstraints(this, size);\n\n                if (useLayoutRounding)\n                {\n                    size = new Size(\n                        Math.Ceiling(size.Width * scale) \/ scale, \n                        Math.Ceiling(size.Height * scale) \/ scale);\n                    availableSizeMinusMargins = new Size(\n                        Math.Ceiling(availableSizeMinusMargins.Width * scale) \/ scale, \n                        Math.Ceiling(availableSizeMinusMargins.Height * scale) \/ scale);\n                }\n\n                size = ArrangeOverride(size).Constrain(size);\n\n                switch (horizontalAlignment)\n                {\n                    case HorizontalAlignment.Center:\n                    case HorizontalAlignment.Stretch:\n                        originX += (availableSizeMinusMargins.Width - size.Width) \/ 2;\n                        break;\n                    case HorizontalAlignment.Right:\n                        originX += availableSizeMinusMargins.Width - size.Width;\n                        break;\n                }\n\n                switch (verticalAlignment)\n                {\n                    case VerticalAlignment.Center:\n                    case VerticalAlignment.Stretch:\n                        originY += (availableSizeMinusMargins.Height - size.Height) \/ 2;\n                        break;\n                    case VerticalAlignment.Bottom:\n                        originY += availableSizeMinusMargins.Height - size.Height;\n                        break;\n                }\n\n                if (useLayoutRounding)\n                {\n                    originX = Math.Floor(originX * scale) \/ scale;\n                    originY = Math.Floor(originY * scale) \/ scale;\n                }\n\n                Bounds = new Rect(originX, originY, size.Width, size.Height);\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Positions child elements as part of a layout pass.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"finalSize\">The size available to the control.<\/param>\n        \/\/\/ <returns>The actual size used.<\/returns>\n        protected virtual Size ArrangeOverride(Size finalSize)\n        {\n            var arrangeRect = new Rect(finalSize);\n\n            var visualCount = VisualChildren.Count;\n\n            for (var i = 0; i < visualCount; i++)\n            {\n                IVisual visual = VisualChildren[i];\n\n                if (visual is ILayoutable layoutable)\n                {\n                    layoutable.Arrange(arrangeRect);\n                }\n            }\n\n            return finalSize;\n        }\n\n        \/\/\/ <inheritdoc\/>\n        protected override sealed void OnVisualParentChanged(IVisual oldParent, IVisual newParent)\n        {\n            foreach (ILayoutable i in this.GetSelfAndVisualDescendants())\n            {\n                i.InvalidateMeasure();\n            }\n\n            base.OnVisualParentChanged(oldParent, newParent);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Tests whether any of a <see cref=\"Rect\"\/>'s properties include negative values,\n        \/\/\/ a NaN or Infinity.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"rect\">The rect.<\/param>\n        \/\/\/ <returns>True if the rect is invalid; otherwise false.<\/returns>\n        private static bool IsInvalidRect(Rect rect)\n        {\n            return rect.Width < 0 || rect.Height < 0 ||\n                double.IsInfinity(rect.X) || double.IsInfinity(rect.Y) ||\n                double.IsInfinity(rect.Width) || double.IsInfinity(rect.Height) ||\n                double.IsNaN(rect.X) || double.IsNaN(rect.Y) ||\n                double.IsNaN(rect.Width) || double.IsNaN(rect.Height);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Tests whether any of a <see cref=\"Size\"\/>'s properties include negative values,\n        \/\/\/ a NaN or Infinity.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"size\">The size.<\/param>\n        \/\/\/ <returns>True if the size is invalid; otherwise false.<\/returns>\n        private static bool IsInvalidSize(Size size)\n        {\n            return size.Width < 0 || size.Height < 0 ||\n                double.IsInfinity(size.Width) || double.IsInfinity(size.Height) ||\n                double.IsNaN(size.Width) || double.IsNaN(size.Height);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Ensures neither component of a <see cref=\"Size\"\/> is negative.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"size\">The size.<\/param>\n        \/\/\/ <returns>The non-negative size.<\/returns>\n        private static Size NonNegative(Size size)\n        {\n            return new Size(Math.Max(size.Width, 0), Math.Max(size.Height, 0));\n        }\n\n        private double GetLayoutScale()\n        {\n            var result =  (VisualRoot as ILayoutRoot)?.LayoutScaling ?? 1.0;\n\n            if (result == 0 || double.IsNaN(result) || double.IsInfinity(result))\n            {\n                throw new Exception($\"Invalid LayoutScaling returned from {VisualRoot.GetType()}\");\n            }\n\n            return result;\n        }\n    }\n}\n","old_contents":"\/\/ Copyright (c) The Avalonia Project. All rights reserved.\n\/\/ Licensed under the MIT license. See licence.md file in the project root for full license information.\n\nusing System;\nusing System.Linq;\nusing Avalonia.Logging;\nusing Avalonia.VisualTree;\n\nnamespace Avalonia.Layout\n{\n    \/\/\/ <summary>\n    \/\/\/ Defines how a control aligns itself horizontally in its parent control.\n    \/\/\/ <\/summary>\n    public enum HorizontalAlignment\n    {\n        \/\/\/ <summary>\n        \/\/\/ The control stretches to fill the width of the parent control.\n        \/\/\/ <\/summary>\n        Stretch,\n\n        \/\/\/ <summary>\n        \/\/\/ The control aligns itself to the left of the parent control.\n        \/\/\/ <\/summary>\n        Left,\n\n        \/\/\/ <summary>\n        \/\/\/ The control centers itself in the parent control.\n        \/\/\/ <\/summary>\n        Center,\n\n        \/\/\/ <summary>\n        \/\/\/ The control aligns itself to the right of the parent control.\n        \/\/\/ <\/summary>\n        Right,\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Defines how a control aligns itself vertically in its parent control.\n    \/\/\/ <\/summary>\n    public enum VerticalAlignment\n    {\n        \/\/\/ <summary>\n        \/\/\/ The control stretches to fill the height of the parent control.\n        \/\/\/ <\/summary>\n        Stretch,\n\n        \/\/\/ <summary>\n        \/\/\/ The control aligns itself to the top of the parent control.\n        \/\/\/ <\/summary>\n        Top,\n\n        \/\/\/ <summary>\n        \/\/\/ The control centers itself within the parent control.\n        \/\/\/ <\/summary>\n        Center,\n\n        \/\/\/ <summary>\n        \/\/\/ The control aligns itself to the bottom of the parent control.\n        \/\/\/ <\/summary>\n        Bottom,\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Implements layout-related functionality for a control.\n    \/\/\/ <\/summary>\n    public class Layoutable : Visual, ILayoutable\n    {\n        \/\/\/ <summary>\n        \/\/\/ Defines the <see cref=\"DesiredSize\"\/> property.\n        \/\/\/ <\/summary>\n        public static readonly DirectProperty<Layoutable, Size> DesiredSizeProperty =\n            AvaloniaProperty.RegisterDirect<Layoutable, Size>(nameof(DesiredSize), o => o.DesiredSize);\n\n        \/\/\/ <summary>\n        \/\/\/ Defines the <see cref=\"Width\"\/> property.\n        \/\/\/ <\/summary>\n        public static readonly StyledProperty<double> WidthProperty =\n            AvaloniaProperty.Register<Layoutable, double>(nameof(Width), double.NaN);\n\n        \/\/\/ <summary>\n        \/\/\/ Defines the <see cref=\"Height\"\/> property.\n        \/\/\/ <\/summary>\n        public static readonly StyledProperty<double> HeightProperty =\n            AvaloniaProperty.Register<Layoutable, double>(nameof(Height), double.NaN);\n\n        \/\/\/ <summary>\n        \/\/\/ Defines the <see cref=\"MinWidth\"\/> property.\n        \/\/\/ <\/summary>\n        public static readonly StyledProperty<double> MinWidthProperty =\n            AvaloniaProperty.Register<Layoutable, double>(nameof(MinWidth));\n\n        \/\/\/ <summary>\n        \/\/\/ Defines the <see cref=\"MaxWidth\"\/> property.\n        \/\/\/ <\/summary>\n        public static readonly StyledProperty<double> MaxWidthProperty =\n            AvaloniaProperty.Register<Layoutable, double>(nameof(MaxWidth), double.PositiveInfinity);\n\n        \/\/\/ <summary>\n        \/\/\/ Defines the <see cref=\"MinHeight\"\/> property.\n        \/\/\/ <\/summary>\n        public static readonly StyledProperty<double> MinHeightProperty =\n            AvaloniaProperty.Register<Layoutable, double>(nameof(MinHeight));\n\n        \/\/\/ <summary>\n        \/\/\/ Defines the <see cref=\"MaxHeight\"\/> property.\n        \/\/\/ <\/summary>\n        public static readonly StyledProperty<double> MaxHeightProperty =\n            AvaloniaProperty.Register<Layoutable, double>(nameof(MaxHeight), double.PositiveInfinity);\n\n        \/\/\/ <summary>\n        \/\/\/ Defines the <see cref=\"Margin\"\/> property.\n        \/\/\/ <\/summary>\n        public static readonly StyledProperty<Thickness> MarginProperty =\n            AvaloniaProperty.Register<Layoutable, Thickness>(nameof(Margin));\n\n        \/\/\/ <summary>\n        \/\/\/ Defines the <see cref=\"HorizontalAlignment\"\/> property.\n        \/\/\/ <\/summary>\n        public static readonly StyledProperty<HorizontalAlignment> HorizontalAlignmentProperty =\n            AvaloniaProperty.Register<Layoutable, HorizontalAlignment>(nameof(HorizontalAlignment));\n\n        \/\/\/ <summary>\n        \/\/\/ Defines the <see cref=\"VerticalAlignment\"\/> property.\n        \/\/\/ <\/summary>\n        public static readonly StyledProperty<VerticalAlignment> VerticalAlignmentProperty =\n            AvaloniaProperty.Register<Layoutable, VerticalAlignment>(nameof(VerticalAlignment));\n\n        \/\/\/ <summary>\n        \/\/\/ Defines the <see cref=\"UseLayoutRoundingProperty\"\/> property.\n        \/\/\/ <\/summary>\n        public static readonly StyledProperty<bool> UseLayoutRoundingProperty =\n            AvaloniaProperty.Register<Layoutable, bool>(nameof(UseLayoutRounding), defaultValue: true, inherits: true);\n\n        private bool _measuring;\n        private Size? _previousMeasure;\n        private Rect? _previousArrange;\n\n        \/\/\/ <summary>\n        \/\/\/ Initializes static members of the <see cref=\"Layoutable\"\/> class.\n        \/\/\/ <\/summary>\n        static Layoutable()\n        {\n            AffectsMeasure<Layoutable>(\n                IsVisibleProperty,\n                WidthProperty,\n                HeightProperty,\n                MinWidthProperty,\n                MaxWidthProperty,\n                MinHeightProperty,\n                MaxHeightProperty,\n                MarginProperty,\n                HorizontalAlignmentProperty,\n                VerticalAlignmentProperty);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Occurs when a layout pass completes for the control.\n        \/\/\/ <\/summary>\n        public event EventHandler LayoutUpdated;\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the width of the element.\n        \/\/\/ <\/summary>\n        public double Width\n        {\n            get { return GetValue(WidthProperty); }\n            set { SetValue(WidthProperty, value); }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the height of the element.\n        \/\/\/ <\/summary>\n        public double Height\n        {\n            get { return GetValue(HeightProperty); }\n            set { SetValue(HeightProperty, value); }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the minimum width of the element.\n        \/\/\/ <\/summary>\n        public double MinWidth\n        {\n            get { return GetValue(MinWidthProperty); }\n            set { SetValue(MinWidthProperty, value); }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the maximum width of the element.\n        \/\/\/ <\/summary>\n        public double MaxWidth\n        {\n            get { return GetValue(MaxWidthProperty); }\n            set { SetValue(MaxWidthProperty, value); }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the minimum height of the element.\n        \/\/\/ <\/summary>\n        public double MinHeight\n        {\n            get { return GetValue(MinHeightProperty); }\n            set { SetValue(MinHeightProperty, value); }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the maximum height of the element.\n        \/\/\/ <\/summary>\n        public double MaxHeight\n        {\n            get { return GetValue(MaxHeightProperty); }\n            set { SetValue(MaxHeightProperty, value); }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the margin around the element.\n        \/\/\/ <\/summary>\n        public Thickness Margin\n        {\n            get { return GetValue(MarginProperty); }\n            set { SetValue(MarginProperty, value); }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the element's preferred horizontal alignment in its parent.\n        \/\/\/ <\/summary>\n        public HorizontalAlignment HorizontalAlignment\n        {\n            get { return GetValue(HorizontalAlignmentProperty); }\n            set { SetValue(HorizontalAlignmentProperty, value); }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the element's preferred vertical alignment in its parent.\n        \/\/\/ <\/summary>\n        public VerticalAlignment VerticalAlignment\n        {\n            get { return GetValue(VerticalAlignmentProperty); }\n            set { SetValue(VerticalAlignmentProperty, value); }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the size that this element computed during the measure pass of the layout process.\n        \/\/\/ <\/summary>\n        public Size DesiredSize\n        {\n            get;\n            private set;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets a value indicating whether the control's layout measure is valid.\n        \/\/\/ <\/summary>\n        public bool IsMeasureValid\n        {\n            get;\n            private set;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets a value indicating whether the control's layouts arrange is valid.\n        \/\/\/ <\/summary>\n        public bool IsArrangeValid\n        {\n            get;\n            private set;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets a value that determines whether the element should be snapped to pixel\n        \/\/\/ boundaries at layout time.\n        \/\/\/ <\/summary>\n        public bool UseLayoutRounding\n        {\n            get { return GetValue(UseLayoutRoundingProperty); }\n            set { SetValue(UseLayoutRoundingProperty, value); }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the available size passed in the previous layout pass, if any.\n        \/\/\/ <\/summary>\n        Size? ILayoutable.PreviousMeasure => _previousMeasure;\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the layout rect passed in the previous layout pass, if any.\n        \/\/\/ <\/summary>\n        Rect? ILayoutable.PreviousArrange => _previousArrange;\n\n        \/\/\/ <summary>\n        \/\/\/ Creates the visual children of the control, if necessary\n        \/\/\/ <\/summary>\n        public virtual void ApplyTemplate()\n        {\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Carries out a measure of the control.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"availableSize\">The available size for the control.<\/param>\n        public void Measure(Size availableSize)\n        {\n            if (double.IsNaN(availableSize.Width) || double.IsNaN(availableSize.Height))\n            {\n                throw new InvalidOperationException(\"Cannot call Measure using a size with NaN values.\");\n            }\n\n            if (!IsMeasureValid || _previousMeasure != availableSize)\n            {\n                var previousDesiredSize = DesiredSize;\n                var desiredSize = default(Size);\n\n                IsMeasureValid = true;\n\n                try\n                {\n                    _measuring = true;\n                    desiredSize = MeasureCore(availableSize);\n                }\n                finally\n                {\n                    _measuring = false;\n                }\n\n                if (IsInvalidSize(desiredSize))\n                {\n                    throw new InvalidOperationException(\"Invalid size returned for Measure.\");\n                }\n\n                DesiredSize = desiredSize;\n                _previousMeasure = availableSize;\n\n                Logger.TryGet(LogEventLevel.Verbose)?.Log(LogArea.Layout, this, \"Measure requested {DesiredSize}\", DesiredSize);\n\n                if (DesiredSize != previousDesiredSize)\n                {\n                    this.GetVisualParent<ILayoutable>()?.ChildDesiredSizeChanged(this);\n                }\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Arranges the control and its children.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"rect\">The control's new bounds.<\/param>\n        public void Arrange(Rect rect)\n        {\n            if (IsInvalidRect(rect))\n            {\n                throw new InvalidOperationException(\"Invalid Arrange rectangle.\");\n            }\n\n            if (!IsMeasureValid)\n            {\n                Measure(_previousMeasure ?? rect.Size);\n            }\n\n            if (!IsArrangeValid || _previousArrange != rect)\n            {\n                Logger.TryGet(LogEventLevel.Verbose)?.Log(LogArea.Layout, this, \"Arrange to {Rect} \", rect);\n\n                IsArrangeValid = true;\n                ArrangeCore(rect);\n                _previousArrange = rect;\n\n                LayoutUpdated?.Invoke(this, EventArgs.Empty);\n            }\n        }\n\n\n        \/\/\/ <summary>\n        \/\/\/ Called by InvalidateMeasure\n        \/\/\/ <\/summary>\n        protected virtual void OnMeasureInvalidated()\n        {\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Invalidates the measurement of the control and queues a new layout pass.\n        \/\/\/ <\/summary>\n        public void InvalidateMeasure()\n        {\n            if (IsMeasureValid)\n            {\n                Logger.TryGet(LogEventLevel.Verbose)?.Log(LogArea.Layout, this, \"Invalidated measure\");\n\n                IsMeasureValid = false;\n                IsArrangeValid = false;\n\n                if (((ILayoutable)this).IsAttachedToVisualTree)\n                {\n                    (VisualRoot as ILayoutRoot)?.LayoutManager.InvalidateMeasure(this);\n                    InvalidateVisual();\n                }\n                OnMeasureInvalidated();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Invalidates the arrangement of the control and queues a new layout pass.\n        \/\/\/ <\/summary>\n        public void InvalidateArrange()\n        {\n            if (IsArrangeValid)\n            {\n                Logger.TryGet(LogEventLevel.Verbose)?.Log(LogArea.Layout, this, \"Invalidated arrange\");\n\n                IsArrangeValid = false;\n                (VisualRoot as ILayoutRoot)?.LayoutManager?.InvalidateArrange(this);\n                InvalidateVisual();\n            }\n        }\n\n        \/\/\/ <inheritdoc\/>\n        void ILayoutable.ChildDesiredSizeChanged(ILayoutable control)\n        {\n            if (!_measuring)\n            {\n                InvalidateMeasure();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Marks a property as affecting the control's measurement.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"properties\">The properties.<\/param>\n        \/\/\/ <remarks>\n        \/\/\/ After a call to this method in a control's static constructor, any change to the\n        \/\/\/ property will cause <see cref=\"InvalidateMeasure\"\/> to be called on the element.\n        \/\/\/ <\/remarks>\n        [Obsolete(\"Use AffectsMeasure<T> and specify the control type.\")]\n        protected static void AffectsMeasure(params AvaloniaProperty[] properties)\n        {\n            AffectsMeasure<Layoutable>(properties);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Marks a property as affecting the control's measurement.\n        \/\/\/ <\/summary>\n        \/\/\/ <typeparam name=\"T\">The control which the property affects.<\/typeparam>\n        \/\/\/ <param name=\"properties\">The properties.<\/param>\n        \/\/\/ <remarks>\n        \/\/\/ After a call to this method in a control's static constructor, any change to the\n        \/\/\/ property will cause <see cref=\"InvalidateMeasure\"\/> to be called on the element.\n        \/\/\/ <\/remarks>\n        protected static void AffectsMeasure<T>(params AvaloniaProperty[] properties)\n            where T : class, ILayoutable\n        {\n            void Invalidate(AvaloniaPropertyChangedEventArgs e)\n            {\n                (e.Sender as T)?.InvalidateMeasure();\n            }\n\n            foreach (var property in properties)\n            {\n                property.Changed.Subscribe(Invalidate);\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Marks a property as affecting the control's arrangement.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"properties\">The properties.<\/param>\n        \/\/\/ <remarks>\n        \/\/\/ After a call to this method in a control's static constructor, any change to the\n        \/\/\/ property will cause <see cref=\"InvalidateArrange\"\/> to be called on the element.\n        \/\/\/ <\/remarks>\n        [Obsolete(\"Use AffectsArrange<T> and specify the control type.\")]\n        protected static void AffectsArrange(params AvaloniaProperty[] properties)\n        {\n            AffectsArrange<Layoutable>(properties);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Marks a property as affecting the control's arrangement.\n        \/\/\/ <\/summary>\n        \/\/\/ <typeparam name=\"T\">The control which the property affects.<\/typeparam>\n        \/\/\/ <param name=\"properties\">The properties.<\/param>\n        \/\/\/ <remarks>\n        \/\/\/ After a call to this method in a control's static constructor, any change to the\n        \/\/\/ property will cause <see cref=\"InvalidateArrange\"\/> to be called on the element.\n        \/\/\/ <\/remarks>\n        protected static void AffectsArrange<T>(params AvaloniaProperty[] properties)\n            where T : class, ILayoutable\n        {\n            void Invalidate(AvaloniaPropertyChangedEventArgs e)\n            {\n                (e.Sender as T)?.InvalidateArrange();\n            }\n\n            foreach (var property in properties)\n            {\n                property.Changed.Subscribe(Invalidate);\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ The default implementation of the control's measure pass.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"availableSize\">The size available to the control.<\/param>\n        \/\/\/ <returns>The desired size for the control.<\/returns>\n        \/\/\/ <remarks>\n        \/\/\/ This method calls <see cref=\"MeasureOverride(Size)\"\/> which is probably the method you\n        \/\/\/ want to override in order to modify a control's arrangement.\n        \/\/\/ <\/remarks>\n        protected virtual Size MeasureCore(Size availableSize)\n        {\n            if (IsVisible)\n            {\n                var margin = Margin;\n\n                ApplyTemplate();\n\n                var constrained = LayoutHelper.ApplyLayoutConstraints(\n                    this,\n                    availableSize.Deflate(margin));\n                var measured = MeasureOverride(constrained);\n\n                var width = measured.Width;\n                var height = measured.Height;\n\n                if (!double.IsNaN(Width))\n                {\n                    width = Width;\n                }\n\n                width = Math.Min(width, MaxWidth);\n                width = Math.Max(width, MinWidth);\n\n                if (!double.IsNaN(Height))\n                {\n                    height = Height;\n                }\n\n                height = Math.Min(height, MaxHeight);\n                height = Math.Max(height, MinHeight);\n\n                width = Math.Min(width, availableSize.Width);\n                height = Math.Min(height, availableSize.Height);\n\n                if (UseLayoutRounding)\n                {\n                    var scale = GetLayoutScale();\n                    width = Math.Ceiling(width * scale) \/ scale;\n                    height = Math.Ceiling(height * scale) \/ scale;\n                }\n\n                return NonNegative(new Size(width, height).Inflate(margin));\n            }\n            else\n            {\n                return new Size();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Measures the control and its child elements as part of a layout pass.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"availableSize\">The size available to the control.<\/param>\n        \/\/\/ <returns>The desired size for the control.<\/returns>\n        protected virtual Size MeasureOverride(Size availableSize)\n        {\n            double width = 0;\n            double height = 0;\n\n            var visualCount = VisualChildren.Count;\n\n            for (var i = 0; i < visualCount; i++)\n            {\n                IVisual visual = VisualChildren[i];\n\n                if (visual is ILayoutable layoutable)\n                {\n                    layoutable.Measure(availableSize);\n                    width = Math.Max(width, layoutable.DesiredSize.Width);\n                    height = Math.Max(height, layoutable.DesiredSize.Height);\n                }\n            }\n\n            return new Size(width, height);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ The default implementation of the control's arrange pass.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"finalRect\">The control's new bounds.<\/param>\n        \/\/\/ <remarks>\n        \/\/\/ This method calls <see cref=\"ArrangeOverride(Size)\"\/> which is probably the method you\n        \/\/\/ want to override in order to modify a control's arrangement.\n        \/\/\/ <\/remarks>\n        protected virtual void ArrangeCore(Rect finalRect)\n        {\n            if (IsVisible)\n            {\n                var margin = Margin;\n                var originX = finalRect.X + margin.Left;\n                var originY = finalRect.Y + margin.Top;\n                var availableSizeMinusMargins = new Size(\n                    Math.Max(0, finalRect.Width - margin.Left - margin.Right),\n                    Math.Max(0, finalRect.Height - margin.Top - margin.Bottom));\n                var horizontalAlignment = HorizontalAlignment;\n                var verticalAlignment = VerticalAlignment;\n                var size = availableSizeMinusMargins;\n                var scale = GetLayoutScale();\n\n                if (horizontalAlignment != HorizontalAlignment.Stretch)\n                {\n                    size = size.WithWidth(Math.Min(size.Width, DesiredSize.Width - margin.Left - margin.Right));\n                }\n\n                if (verticalAlignment != VerticalAlignment.Stretch)\n                {\n                    size = size.WithHeight(Math.Min(size.Height, DesiredSize.Height - margin.Top - margin.Bottom));\n                }\n\n                size = LayoutHelper.ApplyLayoutConstraints(this, size);\n\n                if (UseLayoutRounding)\n                {\n                    size = new Size(\n                        Math.Ceiling(size.Width * scale) \/ scale, \n                        Math.Ceiling(size.Height * scale) \/ scale);\n                    availableSizeMinusMargins = new Size(\n                        Math.Ceiling(availableSizeMinusMargins.Width * scale) \/ scale, \n                        Math.Ceiling(availableSizeMinusMargins.Height * scale) \/ scale);\n                }\n\n                size = ArrangeOverride(size).Constrain(size);\n\n                switch (horizontalAlignment)\n                {\n                    case HorizontalAlignment.Center:\n                    case HorizontalAlignment.Stretch:\n                        originX += (availableSizeMinusMargins.Width - size.Width) \/ 2;\n                        break;\n                    case HorizontalAlignment.Right:\n                        originX += availableSizeMinusMargins.Width - size.Width;\n                        break;\n                }\n\n                switch (verticalAlignment)\n                {\n                    case VerticalAlignment.Center:\n                    case VerticalAlignment.Stretch:\n                        originY += (availableSizeMinusMargins.Height - size.Height) \/ 2;\n                        break;\n                    case VerticalAlignment.Bottom:\n                        originY += availableSizeMinusMargins.Height - size.Height;\n                        break;\n                }\n\n                if (UseLayoutRounding)\n                {\n                    originX = Math.Floor(originX * scale) \/ scale;\n                    originY = Math.Floor(originY * scale) \/ scale;\n                }\n\n                Bounds = new Rect(originX, originY, size.Width, size.Height);\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Positions child elements as part of a layout pass.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"finalSize\">The size available to the control.<\/param>\n        \/\/\/ <returns>The actual size used.<\/returns>\n        protected virtual Size ArrangeOverride(Size finalSize)\n        {\n            var arrangeRect = new Rect(finalSize);\n\n            var visualCount = VisualChildren.Count;\n\n            for (var i = 0; i < visualCount; i++)\n            {\n                IVisual visual = VisualChildren[i];\n\n                if (visual is ILayoutable layoutable)\n                {\n                    layoutable.Arrange(arrangeRect);\n                }\n            }\n\n            return finalSize;\n        }\n\n        \/\/\/ <inheritdoc\/>\n        protected override sealed void OnVisualParentChanged(IVisual oldParent, IVisual newParent)\n        {\n            foreach (ILayoutable i in this.GetSelfAndVisualDescendants())\n            {\n                i.InvalidateMeasure();\n            }\n\n            base.OnVisualParentChanged(oldParent, newParent);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Tests whether any of a <see cref=\"Rect\"\/>'s properties include negative values,\n        \/\/\/ a NaN or Infinity.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"rect\">The rect.<\/param>\n        \/\/\/ <returns>True if the rect is invalid; otherwise false.<\/returns>\n        private static bool IsInvalidRect(Rect rect)\n        {\n            return rect.Width < 0 || rect.Height < 0 ||\n                double.IsInfinity(rect.X) || double.IsInfinity(rect.Y) ||\n                double.IsInfinity(rect.Width) || double.IsInfinity(rect.Height) ||\n                double.IsNaN(rect.X) || double.IsNaN(rect.Y) ||\n                double.IsNaN(rect.Width) || double.IsNaN(rect.Height);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Tests whether any of a <see cref=\"Size\"\/>'s properties include negative values,\n        \/\/\/ a NaN or Infinity.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"size\">The size.<\/param>\n        \/\/\/ <returns>True if the size is invalid; otherwise false.<\/returns>\n        private static bool IsInvalidSize(Size size)\n        {\n            return size.Width < 0 || size.Height < 0 ||\n                double.IsInfinity(size.Width) || double.IsInfinity(size.Height) ||\n                double.IsNaN(size.Width) || double.IsNaN(size.Height);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Ensures neither component of a <see cref=\"Size\"\/> is negative.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"size\">The size.<\/param>\n        \/\/\/ <returns>The non-negative size.<\/returns>\n        private static Size NonNegative(Size size)\n        {\n            return new Size(Math.Max(size.Width, 0), Math.Max(size.Height, 0));\n        }\n\n        private double GetLayoutScale()\n        {\n            var result =  (VisualRoot as ILayoutRoot)?.LayoutScaling ?? 1.0;\n\n            if (result == 0 || double.IsNaN(result) || double.IsInfinity(result))\n            {\n                throw new Exception($\"Invalid LayoutScaling returned from {VisualRoot.GetType()}\");\n            }\n\n            return result;\n        }\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"88d0c6550767050352a2f822e39aca6fb211cf47","subject":"[TouchCanvas] optimize","message":"[TouchCanvas] optimize\n","repos":"xamarin\/monotouch-samples,xamarin\/monotouch-samples,xamarin\/monotouch-samples","old_file":"ios9\/TouchCanvas\/TouchCanvas\/Model\/Line.cs","new_file":"ios9\/TouchCanvas\/TouchCanvas\/Model\/Line.cs","new_contents":"","old_contents":"","returncode":0,"stderr":"unknown","license":"mit","lang":"C#"}
{"commit":"805b70fab5715e9a496f1aa2a79d289afd1ae843","subject":"Ported RS2Sharp's Model class","message":"Ported RS2Sharp's Model class\n","repos":"HelloKitty\/317refactor","old_file":"src\/Rs317.Library.Client\/Model.cs","new_file":"src\/Rs317.Library.Client\/Model.cs","new_contents":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Rs317.Sharp\n{\n\tpublic class Model : Animable\n\t{\n\t\tpublic static void nullLoader()\n\t\t{\n\t\t\tmodelHeaders = null;\n\t\t\taBooleanArray1663 = null;\n\t\t\taBooleanArray1664 = null;\n\t\t\tanIntArray1665 = null;\n\t\t\tanIntArray1666 = null;\n\t\t\tanIntArray1667 = null;\n\t\t\tanIntArray1668 = null;\n\t\t\tanIntArray1669 = null;\n\t\t\tanIntArray1670 = null;\n\t\t\tanIntArray1671 = null;\n\t\t\tanIntArrayArray1672 = null;\n\t\t\tanIntArray1673 = null;\n\t\t\tanIntArrayArray1674 = null;\n\t\t\tanIntArray1675 = null;\n\t\t\tanIntArray1676 = null;\n\t\t\tanIntArray1677 = null;\n\t\t\tSINE = null;\n\t\t\tCOSINE = null;\n\t\t\tHSLtoRGB = null;\n\t\t\tmodelIntArray4 = null;\n\t\t}\n\n\t\tpublic static void init(int modelCount, OnDemandFetcher requester)\n\t\t{\n\t\t\tmodelHeaders = new ModelHeader[modelCount];\n\t\t\taOnDemandFetcherParent_1662 = requester;\n\t\t}\n\n\t\tpublic static void loadModelHeader(byte[] modelData, int modelId)\n\t\t{\n\t\t\tif(modelData == null)\n\t\t\t{\n\t\t\t\tModelHeader modelHeader = modelHeaders[modelId] = new ModelHeader();\n\t\t\t\tmodelHeader.vertexCount = 0;\n\t\t\t\tmodelHeader.triangleCount = 0;\n\t\t\t\tmodelHeader.texturedTriangleCount = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDefault317Buffer stream = new Default317Buffer(modelData);\n\t\t\t\tstream.position = modelData.Length - 18;\n\t\t\t\tModelHeader modelHeader = modelHeaders[modelId] = new ModelHeader();\n\t\t\t\tmodelHeader.modelData = modelData;\n\t\t\t\tmodelHeader.vertexCount = stream.getUnsignedLEShort();\n\t\t\t\tmodelHeader.triangleCount = stream.getUnsignedLEShort();\n\t\t\t\tmodelHeader.texturedTriangleCount = stream.getUnsignedByte();\n\t\t\t\tint useTextures = stream.getUnsignedByte();\n\t\t\t\tint useTrianglePriority = stream.getUnsignedByte();\n\t\t\t\tint useAlpha = stream.getUnsignedByte();\n\t\t\t\tint useTriangleSkins = stream.getUnsignedByte();\n\t\t\t\tint useVertexSkins = stream.getUnsignedByte();\n\t\t\t\tint dataLengthX = stream.getUnsignedLEShort();\n\t\t\t\tint dataLengthY = stream.getUnsignedLEShort();\n\t\t\t\tint dataLengthZ = stream.getUnsignedLEShort();\n\t\t\t\tint dataLengthTriangle = stream.getUnsignedLEShort();\n\t\t\t\tint offset = 0;\n\t\t\t\tmodelHeader.vertexDirectionOffset = offset;\n\t\t\t\toffset += modelHeader.vertexCount;\n\t\t\t\tmodelHeader.triangleTypeOffset = offset;\n\t\t\t\toffset += modelHeader.triangleCount;\n\t\t\t\tmodelHeader.trianglePriorityOffset = offset;\n\t\t\t\tif(useTrianglePriority == 255)\n\t\t\t\t\toffset += modelHeader.triangleCount;\n\t\t\t\telse\n\t\t\t\t\tmodelHeader.trianglePriorityOffset = -useTrianglePriority - 1;\n\t\t\t\tmodelHeader.triangleSkinOffset = offset;\n\t\t\t\tif(useTriangleSkins == 1)\n\t\t\t\t\toffset += modelHeader.triangleCount;\n\t\t\t\telse\n\t\t\t\t\tmodelHeader.triangleSkinOffset = -1;\n\t\t\t\tmodelHeader.texturePointerOffset = offset;\n\t\t\t\tif(useTextures == 1)\n\t\t\t\t\toffset += modelHeader.triangleCount;\n\t\t\t\telse\n\t\t\t\t\tmodelHeader.texturePointerOffset = -1;\n\t\t\t\tmodelHeader.vertexSkinOffset = offset;\n\t\t\t\tif(useVertexSkins == 1)\n\t\t\t\t\toffset += modelHeader.vertexCount;\n\t\t\t\telse\n\t\t\t\t\tmodelHeader.vertexSkinOffset = -1;\n\t\t\t\tmodelHeader.triangleAlphaOffset = offset;\n\t\t\t\tif(useAlpha == 1)\n\t\t\t\t\toffset += modelHeader.triangleCount;\n\t\t\t\telse\n\t\t\t\t\tmodelHeader.triangleAlphaOffset = -1;\n\t\t\t\tmodelHeader.triangleDataOffset = offset;\n\t\t\t\toffset += dataLengthTriangle;\n\t\t\t\tmodelHeader.colourDataOffset = offset;\n\t\t\t\toffset += modelHeader.triangleCount * 2;\n\t\t\t\tmodelHeader.texturedTriangleOffset = offset;\n\t\t\t\toffset += modelHeader.texturedTriangleCount * 6;\n\t\t\t\tmodelHeader.dataOffsetX = offset;\n\t\t\t\toffset += dataLengthX;\n\t\t\t\tmodelHeader.dataOffsetY = offset;\n\t\t\t\toffset += dataLengthY;\n\t\t\t\tmodelHeader.dataOffsetZ = offset;\n\t\t\t\toffset += dataLengthZ;\n\t\t\t}\n\t\t}\n\n\t\tpublic static void resetModel(int j)\n\t\t{\n\t\t\tmodelHeaders[j] = null;\n\t\t}\n\n\t\tpublic static Model getModel(int model)\n\t\t{\n\t\t\tif(modelHeaders == null)\n\t\t\t\treturn null;\n\t\t\tModelHeader modelHeader = modelHeaders[model];\n\t\t\tif(modelHeader == null)\n\t\t\t{\n\t\t\t\taOnDemandFetcherParent_1662.request(model);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn new Model(model);\n\t\t\t}\n\t\t}\n\n\t\tpublic static bool isCached(int model)\n\t\t{\n\t\t\tif(model >= modelHeaders.Length)\n\t\t\t{\n\t\t\t\tstring error = $\"Cannot check cache for {model} as it exceeds the metadata container's length.\";\n\t\t\t\tsignlink.reporterror(error);\n\t\t\t\tthrow new ArgumentException($\"Cannot check cache for {model} as it exceeds the metadata container's length.\");\n\t\t\t}\n\n\t\t\tif(modelHeaders == null)\n\t\t\t\treturn false;\n\t\t\tModelHeader modelHeader = modelHeaders[model];\n\t\t\tif(modelHeader == null)\n\t\t\t{\n\t\t\t\taOnDemandFetcherParent_1662.request(model);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tpublic Model()\n\t\t{\n\t\t\tsingleTile = false;\n\t\t}\n\n\t\tpublic Model(int i)\n\t\t{\n\t\t\tsingleTile = false;\n\t\t\tModelHeader ModelHeader = modelHeaders[i];\n\t\t\tvertexCount = ModelHeader.vertexCount;\n\t\t\ttriangleCount = ModelHeader.triangleCount;\n\t\t\ttexturedTriangleCount = ModelHeader.texturedTriangleCount;\n\t\t\tverticesX = new int[vertexCount];\n\t\t\tverticesY = new int[vertexCount];\n\t\t\tverticesZ = new int[vertexCount];\n\t\t\ttriangleX = new int[triangleCount];\n\t\t\ttriangleY = new int[triangleCount];\n\t\t\ttriangleZ = new int[triangleCount];\n\t\t\ttexturedTrianglePointsX = new int[texturedTriangleCount];\n\t\t\ttexturedTrianglePointsY = new int[texturedTriangleCount];\n\t\t\ttexturedTrianglePointsZ = new int[texturedTriangleCount];\n\t\t\tif(ModelHeader.vertexSkinOffset >= 0)\n\t\t\t\tvertexSkins = new int[vertexCount];\n\t\t\tif(ModelHeader.texturePointerOffset >= 0)\n\t\t\t\ttriangleDrawType = new int[triangleCount];\n\t\t\tif(ModelHeader.trianglePriorityOffset >= 0)\n\t\t\t\ttrianglePriorities = new int[triangleCount];\n\t\t\telse\n\t\t\t\ttrianglePriority = -ModelHeader.trianglePriorityOffset - 1;\n\t\t\tif(ModelHeader.triangleAlphaOffset >= 0)\n\t\t\t\ttriangleAlpha = new int[triangleCount];\n\t\t\tif(ModelHeader.triangleSkinOffset >= 0)\n\t\t\t\ttriangleSkins = new int[triangleCount];\n\t\t\ttriangleColours = new int[triangleCount];\n\t\t\tDefault317Buffer vertexDirectionOffsetStream = new Default317Buffer(ModelHeader.modelData);\n\t\t\tvertexDirectionOffsetStream.position = ModelHeader.vertexDirectionOffset;\n\t\t\tDefault317Buffer xDataOffsetStream = new Default317Buffer(ModelHeader.modelData);\n\t\t\txDataOffsetStream.position = ModelHeader.dataOffsetX;\n\t\t\tDefault317Buffer yDataOffsetStream = new Default317Buffer(ModelHeader.modelData);\n\t\t\tyDataOffsetStream.position = ModelHeader.dataOffsetY;\n\t\t\tDefault317Buffer zDataOffsetStream = new Default317Buffer(ModelHeader.modelData);\n\t\t\tzDataOffsetStream.position = ModelHeader.dataOffsetZ;\n\t\t\tDefault317Buffer vertexSkinOffsetStream = new Default317Buffer(ModelHeader.modelData);\n\t\t\tvertexSkinOffsetStream.position = ModelHeader.vertexSkinOffset;\n\t\t\tint baseOffsetX = 0;\n\t\t\tint baseOffsetY = 0;\n\t\t\tint baseOffsetZ = 0;\n\t\t\tfor(int j1 = 0; j1 < vertexCount; j1++)\n\t\t\t{\n\t\t\t\tint k1 = vertexDirectionOffsetStream.getUnsignedByte();\n\t\t\t\tint i2 = 0;\n\t\t\t\tif((k1 & 1) != 0)\n\t\t\t\t\ti2 = xDataOffsetStream.getSmartA();\n\t\t\t\tint k2 = 0;\n\t\t\t\tif((k1 & 2) != 0)\n\t\t\t\t\tk2 = yDataOffsetStream.getSmartA();\n\t\t\t\tint i3 = 0;\n\t\t\t\tif((k1 & 4) != 0)\n\t\t\t\t\ti3 = zDataOffsetStream.getSmartA();\n\t\t\t\tverticesX[j1] = baseOffsetX + i2;\n\t\t\t\tverticesY[j1] = baseOffsetY + k2;\n\t\t\t\tverticesZ[j1] = baseOffsetZ + i3;\n\t\t\t\tbaseOffsetX = verticesX[j1];\n\t\t\t\tbaseOffsetY = verticesY[j1];\n\t\t\t\tbaseOffsetZ = verticesZ[j1];\n\t\t\t\tif(vertexSkins != null)\n\t\t\t\t\tvertexSkins[j1] = vertexSkinOffsetStream.getUnsignedByte();\n\t\t\t}\n\n\t\t\tvertexDirectionOffsetStream.position = ModelHeader.colourDataOffset;\n\t\t\txDataOffsetStream.position = ModelHeader.texturePointerOffset;\n\t\t\tyDataOffsetStream.position = ModelHeader.trianglePriorityOffset;\n\t\t\tzDataOffsetStream.position = ModelHeader.triangleAlphaOffset;\n\t\t\tvertexSkinOffsetStream.position = ModelHeader.triangleSkinOffset;\n\t\t\tfor(int l1 = 0; l1 < triangleCount; l1++)\n\t\t\t{\n\t\t\t\ttriangleColours[l1] = vertexDirectionOffsetStream.getUnsignedLEShort();\n\t\t\t\tif(triangleDrawType != null)\n\t\t\t\t\ttriangleDrawType[l1] = xDataOffsetStream.getUnsignedByte();\n\t\t\t\tif(trianglePriorities != null)\n\t\t\t\t\ttrianglePriorities[l1] = yDataOffsetStream.getUnsignedByte();\n\t\t\t\tif(triangleAlpha != null)\n\t\t\t\t\ttriangleAlpha[l1] = zDataOffsetStream.getUnsignedByte();\n\t\t\t\tif(triangleSkins != null)\n\t\t\t\t\ttriangleSkins[l1] = vertexSkinOffsetStream.getUnsignedByte();\n\t\t\t}\n\n\t\t\tvertexDirectionOffsetStream.position = ModelHeader.triangleDataOffset;\n\t\t\txDataOffsetStream.position = ModelHeader.triangleTypeOffset;\n\t\t\tint trianglePointOffsetX = 0;\n\t\t\tint trianglePointOffsetY = 0;\n\t\t\tint trianglePointOffsetZ = 0;\n\t\t\tint offset = 0;\n\t\t\tfor(int triangle = 0; triangle < triangleCount; triangle++)\n\t\t\t{\n\t\t\t\tint i4 = xDataOffsetStream.getUnsignedByte();\n\t\t\t\tif(i4 == 1)\n\t\t\t\t{\n\t\t\t\t\ttrianglePointOffsetX = vertexDirectionOffsetStream.getSmartA() + offset;\n\t\t\t\t\toffset = trianglePointOffsetX;\n\t\t\t\t\ttrianglePointOffsetY = vertexDirectionOffsetStream.getSmartA() + offset;\n\t\t\t\t\toffset = trianglePointOffsetY;\n\t\t\t\t\ttrianglePointOffsetZ = vertexDirectionOffsetStream.getSmartA() + offset;\n\t\t\t\t\toffset = trianglePointOffsetZ;\n\t\t\t\t\ttriangleX[triangle] = trianglePointOffsetX;\n\t\t\t\t\ttriangleY[triangle] = trianglePointOffsetY;\n\t\t\t\t\ttriangleZ[triangle] = trianglePointOffsetZ;\n\t\t\t\t}\n\t\t\t\tif(i4 == 2)\n\t\t\t\t{\n\t\t\t\t\ttrianglePointOffsetX = trianglePointOffsetX;\n\t\t\t\t\ttrianglePointOffsetY = trianglePointOffsetZ;\n\t\t\t\t\ttrianglePointOffsetZ = vertexDirectionOffsetStream.getSmartA() + offset;\n\t\t\t\t\toffset = trianglePointOffsetZ;\n\t\t\t\t\ttriangleX[triangle] = trianglePointOffsetX;\n\t\t\t\t\ttriangleY[triangle] = trianglePointOffsetY;\n\t\t\t\t\ttriangleZ[triangle] = trianglePointOffsetZ;\n\t\t\t\t}\n\t\t\t\tif(i4 == 3)\n\t\t\t\t{\n\t\t\t\t\ttrianglePointOffsetX = trianglePointOffsetZ;\n\t\t\t\t\ttrianglePointOffsetY = trianglePointOffsetY;\n\t\t\t\t\ttrianglePointOffsetZ = vertexDirectionOffsetStream.getSmartA() + offset;\n\t\t\t\t\toffset = trianglePointOffsetZ;\n\t\t\t\t\ttriangleX[triangle] = trianglePointOffsetX;\n\t\t\t\t\ttriangleY[triangle] = trianglePointOffsetY;\n\t\t\t\t\ttriangleZ[triangle] = trianglePointOffsetZ;\n\t\t\t\t}\n\t\t\t\tif(i4 == 4)\n\t\t\t\t{\n\t\t\t\t\tint k4 = trianglePointOffsetX;\n\t\t\t\t\ttrianglePointOffsetX = trianglePointOffsetY;\n\t\t\t\t\ttrianglePointOffsetY = k4;\n\t\t\t\t\ttrianglePointOffsetZ = vertexDirectionOffsetStream.getSmartA() + offset;\n\t\t\t\t\toffset = trianglePointOffsetZ;\n\t\t\t\t\ttriangleX[triangle] = trianglePointOffsetX;\n\t\t\t\t\ttriangleY[triangle] = trianglePointOffsetY;\n\t\t\t\t\ttriangleZ[triangle] = trianglePointOffsetZ;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvertexDirectionOffsetStream.position = ModelHeader.texturedTriangleOffset;\n\t\t\tfor(int j4 = 0; j4 < texturedTriangleCount; j4++)\n\t\t\t{\n\t\t\t\ttexturedTrianglePointsX[j4] = vertexDirectionOffsetStream.getUnsignedLEShort();\n\t\t\t\ttexturedTrianglePointsY[j4] = vertexDirectionOffsetStream.getUnsignedLEShort();\n\t\t\t\ttexturedTrianglePointsZ[j4] = vertexDirectionOffsetStream.getUnsignedLEShort();\n\t\t\t}\n\n\t\t}\n\n\t\tpublic Model(int i, Model[] aclass30_sub2_sub4_sub6s)\n\t\t{\n\t\t\tsingleTile = false;\n\t\t\tbool flag = false;\n\t\t\tbool flag1 = false;\n\t\t\tbool flag2 = false;\n\t\t\tbool flag3 = false;\n\t\t\tvertexCount = 0;\n\t\t\ttriangleCount = 0;\n\t\t\ttexturedTriangleCount = 0;\n\t\t\ttrianglePriority = -1;\n\t\t\tfor(int k = 0; k < i; k++)\n\t\t\t{\n\t\t\t\tModel model = aclass30_sub2_sub4_sub6s[k];\n\t\t\t\tif(model != null)\n\t\t\t\t{\n\t\t\t\t\tvertexCount += model.vertexCount;\n\t\t\t\t\ttriangleCount += model.triangleCount;\n\t\t\t\t\ttexturedTriangleCount += model.texturedTriangleCount;\n\t\t\t\t\tflag |= model.triangleDrawType != null;\n\t\t\t\t\tif(model.trianglePriorities != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tflag1 = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(trianglePriority == -1)\n\t\t\t\t\t\t\ttrianglePriority = model.trianglePriority;\n\t\t\t\t\t\tif(trianglePriority != model.trianglePriority)\n\t\t\t\t\t\t\tflag1 = true;\n\t\t\t\t\t}\n\t\t\t\t\tflag2 |= model.triangleAlpha != null;\n\t\t\t\t\tflag3 |= model.triangleSkins != null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tverticesX = new int[vertexCount];\n\t\t\tverticesY = new int[vertexCount];\n\t\t\tverticesZ = new int[vertexCount];\n\t\t\tvertexSkins = new int[vertexCount];\n\t\t\ttriangleX = new int[triangleCount];\n\t\t\ttriangleY = new int[triangleCount];\n\t\t\ttriangleZ = new int[triangleCount];\n\t\t\ttexturedTrianglePointsX = new int[texturedTriangleCount];\n\t\t\ttexturedTrianglePointsY = new int[texturedTriangleCount];\n\t\t\ttexturedTrianglePointsZ = new int[texturedTriangleCount];\n\t\t\tif(flag)\n\t\t\t\ttriangleDrawType = new int[triangleCount];\n\t\t\tif(flag1)\n\t\t\t\ttrianglePriorities = new int[triangleCount];\n\t\t\tif(flag2)\n\t\t\t\ttriangleAlpha = new int[triangleCount];\n\t\t\tif(flag3)\n\t\t\t\ttriangleSkins = new int[triangleCount];\n\t\t\ttriangleColours = new int[triangleCount];\n\t\t\tvertexCount = 0;\n\t\t\ttriangleCount = 0;\n\t\t\ttexturedTriangleCount = 0;\n\t\t\tint l = 0;\n\t\t\tfor(int i1 = 0; i1 < i; i1++)\n\t\t\t{\n\t\t\t\tModel model_1 = aclass30_sub2_sub4_sub6s[i1];\n\t\t\t\tif(model_1 != null)\n\t\t\t\t{\n\t\t\t\t\tfor(int j1 = 0; j1 < model_1.triangleCount; j1++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(flag)\n\t\t\t\t\t\t\tif(model_1.triangleDrawType == null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttriangleDrawType[triangleCount] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint k1 = model_1.triangleDrawType[j1];\n\t\t\t\t\t\t\t\tif((k1 & 2) == 2)\n\t\t\t\t\t\t\t\t\tk1 += l << 2;\n\t\t\t\t\t\t\t\ttriangleDrawType[triangleCount] = k1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flag1)\n\t\t\t\t\t\t\tif(model_1.trianglePriorities == null)\n\t\t\t\t\t\t\t\ttrianglePriorities[triangleCount] = model_1.trianglePriority;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\ttrianglePriorities[triangleCount] = model_1.trianglePriorities[j1];\n\t\t\t\t\t\tif(flag2)\n\t\t\t\t\t\t\tif(model_1.triangleAlpha == null)\n\t\t\t\t\t\t\t\ttriangleAlpha[triangleCount] = 0;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\ttriangleAlpha[triangleCount] = model_1.triangleAlpha[j1];\n\t\t\t\t\t\tif(flag3 && model_1.triangleSkins != null)\n\t\t\t\t\t\t\ttriangleSkins[triangleCount] = model_1.triangleSkins[j1];\n\t\t\t\t\t\ttriangleColours[triangleCount] = model_1.triangleColours[j1];\n\t\t\t\t\t\ttriangleX[triangleCount] = method465(model_1, model_1.triangleX[j1]);\n\t\t\t\t\t\ttriangleY[triangleCount] = method465(model_1, model_1.triangleY[j1]);\n\t\t\t\t\t\ttriangleZ[triangleCount] = method465(model_1, model_1.triangleZ[j1]);\n\t\t\t\t\t\ttriangleCount++;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int l1 = 0; l1 < model_1.texturedTriangleCount; l1++)\n\t\t\t\t\t{\n\t\t\t\t\t\ttexturedTrianglePointsX[texturedTriangleCount] = method465(model_1, model_1.texturedTrianglePointsX[l1]);\n\t\t\t\t\t\ttexturedTrianglePointsY[texturedTriangleCount] = method465(model_1, model_1.texturedTrianglePointsY[l1]);\n\t\t\t\t\t\ttexturedTrianglePointsZ[texturedTriangleCount] = method465(model_1, model_1.texturedTrianglePointsZ[l1]);\n\t\t\t\t\t\ttexturedTriangleCount++;\n\t\t\t\t\t}\n\n\t\t\t\t\tl += model_1.texturedTriangleCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tpublic Model(Model[] aclass30_sub2_sub4_sub6s)\n\t\t{\n\t\t\tint i = 2;\/\/was parameter\n\t\t\tsingleTile = false;\n\t\t\tbool flag1 = false;\n\t\t\tbool flag2 = false;\n\t\t\tbool flag3 = false;\n\t\t\tbool flag4 = false;\n\t\t\tvertexCount = 0;\n\t\t\ttriangleCount = 0;\n\t\t\ttexturedTriangleCount = 0;\n\t\t\ttrianglePriority = -1;\n\t\t\tfor(int k = 0; k < i; k++)\n\t\t\t{\n\t\t\t\tModel model = aclass30_sub2_sub4_sub6s[k];\n\t\t\t\tif(model != null)\n\t\t\t\t{\n\t\t\t\t\tvertexCount += model.vertexCount;\n\t\t\t\t\ttriangleCount += model.triangleCount;\n\t\t\t\t\ttexturedTriangleCount += model.texturedTriangleCount;\n\t\t\t\t\tflag1 |= model.triangleDrawType != null;\n\t\t\t\t\tif(model.trianglePriorities != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tflag2 = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(trianglePriority == -1)\n\t\t\t\t\t\t\ttrianglePriority = model.trianglePriority;\n\t\t\t\t\t\tif(trianglePriority != model.trianglePriority)\n\t\t\t\t\t\t\tflag2 = true;\n\t\t\t\t\t}\n\t\t\t\t\tflag3 |= model.triangleAlpha != null;\n\t\t\t\t\tflag4 |= model.triangleColours != null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tverticesX = new int[vertexCount];\n\t\t\tverticesY = new int[vertexCount];\n\t\t\tverticesZ = new int[vertexCount];\n\t\t\ttriangleX = new int[triangleCount];\n\t\t\ttriangleY = new int[triangleCount];\n\t\t\ttriangleZ = new int[triangleCount];\n\t\t\tanIntArray1634 = new int[triangleCount];\n\t\t\tanIntArray1635 = new int[triangleCount];\n\t\t\tanIntArray1636 = new int[triangleCount];\n\t\t\ttexturedTrianglePointsX = new int[texturedTriangleCount];\n\t\t\ttexturedTrianglePointsY = new int[texturedTriangleCount];\n\t\t\ttexturedTrianglePointsZ = new int[texturedTriangleCount];\n\t\t\tif(flag1)\n\t\t\t\ttriangleDrawType = new int[triangleCount];\n\t\t\tif(flag2)\n\t\t\t\ttrianglePriorities = new int[triangleCount];\n\t\t\tif(flag3)\n\t\t\t\ttriangleAlpha = new int[triangleCount];\n\t\t\tif(flag4)\n\t\t\t\ttriangleColours = new int[triangleCount];\n\t\t\tvertexCount = 0;\n\t\t\ttriangleCount = 0;\n\t\t\ttexturedTriangleCount = 0;\n\t\t\tint i1 = 0;\n\t\t\tfor(int j1 = 0; j1 < i; j1++)\n\t\t\t{\n\t\t\t\tModel model_1 = aclass30_sub2_sub4_sub6s[j1];\n\t\t\t\tif(model_1 != null)\n\t\t\t\t{\n\t\t\t\t\tint k1 = vertexCount;\n\t\t\t\t\tfor(int l1 = 0; l1 < model_1.vertexCount; l1++)\n\t\t\t\t\t{\n\t\t\t\t\t\tverticesX[vertexCount] = model_1.verticesX[l1];\n\t\t\t\t\t\tverticesY[vertexCount] = model_1.verticesY[l1];\n\t\t\t\t\t\tverticesZ[vertexCount] = model_1.verticesZ[l1];\n\t\t\t\t\t\tvertexCount++;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int i2 = 0; i2 < model_1.triangleCount; i2++)\n\t\t\t\t\t{\n\t\t\t\t\t\ttriangleX[triangleCount] = model_1.triangleX[i2] + k1;\n\t\t\t\t\t\ttriangleY[triangleCount] = model_1.triangleY[i2] + k1;\n\t\t\t\t\t\ttriangleZ[triangleCount] = model_1.triangleZ[i2] + k1;\n\t\t\t\t\t\tanIntArray1634[triangleCount] = model_1.anIntArray1634[i2];\n\t\t\t\t\t\tanIntArray1635[triangleCount] = model_1.anIntArray1635[i2];\n\t\t\t\t\t\tanIntArray1636[triangleCount] = model_1.anIntArray1636[i2];\n\t\t\t\t\t\tif(flag1)\n\t\t\t\t\t\t\tif(model_1.triangleDrawType == null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttriangleDrawType[triangleCount] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint j2 = model_1.triangleDrawType[i2];\n\t\t\t\t\t\t\t\tif((j2 & 2) == 2)\n\t\t\t\t\t\t\t\t\tj2 += i1 << 2;\n\t\t\t\t\t\t\t\ttriangleDrawType[triangleCount] = j2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flag2)\n\t\t\t\t\t\t\tif(model_1.trianglePriorities == null)\n\t\t\t\t\t\t\t\ttrianglePriorities[triangleCount] = model_1.trianglePriority;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\ttrianglePriorities[triangleCount] = model_1.trianglePriorities[i2];\n\t\t\t\t\t\tif(flag3)\n\t\t\t\t\t\t\tif(model_1.triangleAlpha == null)\n\t\t\t\t\t\t\t\ttriangleAlpha[triangleCount] = 0;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\ttriangleAlpha[triangleCount] = model_1.triangleAlpha[i2];\n\t\t\t\t\t\tif(flag4 && model_1.triangleColours != null)\n\t\t\t\t\t\t\ttriangleColours[triangleCount] = model_1.triangleColours[i2];\n\t\t\t\t\t\ttriangleCount++;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int k2 = 0; k2 < model_1.texturedTriangleCount; k2++)\n\t\t\t\t\t{\n\t\t\t\t\t\ttexturedTrianglePointsX[texturedTriangleCount] = model_1.texturedTrianglePointsX[k2] + k1;\n\t\t\t\t\t\ttexturedTrianglePointsY[texturedTriangleCount] = model_1.texturedTrianglePointsY[k2] + k1;\n\t\t\t\t\t\ttexturedTrianglePointsZ[texturedTriangleCount] = model_1.texturedTrianglePointsZ[k2] + k1;\n\t\t\t\t\t\ttexturedTriangleCount++;\n\t\t\t\t\t}\n\n\t\t\t\t\ti1 += model_1.texturedTriangleCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcalculateDiagonals();\n\t\t}\n\n\t\tpublic Model(bool flag, bool flag1, bool flag2, Model model)\n\t\t{\n\t\t\tsingleTile = false;\n\t\t\tvertexCount = model.vertexCount;\n\t\t\ttriangleCount = model.triangleCount;\n\t\t\ttexturedTriangleCount = model.texturedTriangleCount;\n\t\t\tif(flag2)\n\t\t\t{\n\t\t\t\tverticesX = model.verticesX;\n\t\t\t\tverticesY = model.verticesY;\n\t\t\t\tverticesZ = model.verticesZ;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tverticesX = new int[vertexCount];\n\t\t\t\tverticesY = new int[vertexCount];\n\t\t\t\tverticesZ = new int[vertexCount];\n\t\t\t\tfor(int j = 0; j < vertexCount; j++)\n\t\t\t\t{\n\t\t\t\t\tverticesX[j] = model.verticesX[j];\n\t\t\t\t\tverticesY[j] = model.verticesY[j];\n\t\t\t\t\tverticesZ[j] = model.verticesZ[j];\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif(flag)\n\t\t\t{\n\t\t\t\ttriangleColours = model.triangleColours;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttriangleColours = new int[triangleCount];\n\t\t\t\tArray.Copy(model.triangleColours, 0, triangleColours, 0, triangleCount);\n\n\t\t\t}\n\t\t\tif(flag1)\n\t\t\t{\n\t\t\t\ttriangleAlpha = model.triangleAlpha;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttriangleAlpha = new int[triangleCount];\n\t\t\t\tif(model.triangleAlpha == null)\n\t\t\t\t{\n\t\t\t\t\tfor(int l = 0; l < triangleCount; l++)\n\t\t\t\t\t\ttriangleAlpha[l] = 0;\n\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tArray.Copy(model.triangleAlpha, 0, triangleAlpha, 0, triangleCount);\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tvertexSkins = model.vertexSkins;\n\t\t\ttriangleSkins = model.triangleSkins;\n\t\t\ttriangleDrawType = model.triangleDrawType;\n\t\t\ttriangleX = model.triangleX;\n\t\t\ttriangleY = model.triangleY;\n\t\t\ttriangleZ = model.triangleZ;\n\t\t\ttrianglePriorities = model.trianglePriorities;\n\t\t\ttrianglePriority = model.trianglePriority;\n\t\t\ttexturedTrianglePointsX = model.texturedTrianglePointsX;\n\t\t\ttexturedTrianglePointsY = model.texturedTrianglePointsY;\n\t\t\ttexturedTrianglePointsZ = model.texturedTrianglePointsZ;\n\t\t}\n\n\t\tpublic Model(bool flag, bool flag1, Model model)\n\t\t{\n\t\t\tsingleTile = false;\n\t\t\tvertexCount = model.vertexCount;\n\t\t\ttriangleCount = model.triangleCount;\n\t\t\ttexturedTriangleCount = model.texturedTriangleCount;\n\t\t\tif(flag)\n\t\t\t{\n\t\t\t\tverticesY = new int[vertexCount];\n\t\t\t\tBuffer.BlockCopy(model.verticesY, 0, verticesY, 0, sizeof(int) * vertexCount);\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tverticesY = model.verticesY;\n\t\t\t}\n\t\t\tif(flag1)\n\t\t\t{\n\t\t\t\tanIntArray1634 = new int[triangleCount];\n\t\t\t\tanIntArray1635 = new int[triangleCount];\n\t\t\t\tanIntArray1636 = new int[triangleCount];\n\t\t\t\tfor(int k = 0; k < triangleCount; k++)\n\t\t\t\t{\n\t\t\t\t\tanIntArray1634[k] = model.anIntArray1634[k];\n\t\t\t\t\tanIntArray1635[k] = model.anIntArray1635[k];\n\t\t\t\t\tanIntArray1636[k] = model.anIntArray1636[k];\n\t\t\t\t}\n\n\t\t\t\ttriangleDrawType = new int[triangleCount];\n\t\t\t\tif(model.triangleDrawType == null)\n\t\t\t\t{\n\t\t\t\t\tfor(int l = 0; l < triangleCount; l++)\n\t\t\t\t\t\ttriangleDrawType[l] = 0;\n\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tBuffer.BlockCopy(model.triangleDrawType, 0, triangleDrawType, 0, sizeof(int) * triangleCount);\n\n\t\t\t\t}\n\t\t\t\t\/\/base.vertexNormals = new VertexNormal[anInt1626];\n\t\t\t\tbase.vertexNormals = new VertexNormal[vertexCount];\n\t\t\t\tfor(int j1 = 0; j1 < vertexCount; j1++)\n\t\t\t\t{\n\t\t\t\t\tVertexNormal class33 = base.vertexNormals[j1] = new VertexNormal();\n\t\t\t\t\tVertexNormal class33_1 = model.vertexNormals[j1];\n\t\t\t\t\tclass33.x = class33_1.x;\n\t\t\t\t\tclass33.y = class33_1.y;\n\t\t\t\t\tclass33.z = class33_1.z;\n\t\t\t\t\tclass33.magnitude = class33_1.magnitude;\n\t\t\t\t}\n\n\t\t\t\tvertexNormalOffset = model.vertexNormalOffset;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tanIntArray1634 = model.anIntArray1634;\n\t\t\t\tanIntArray1635 = model.anIntArray1635;\n\t\t\t\tanIntArray1636 = model.anIntArray1636;\n\t\t\t\ttriangleDrawType = model.triangleDrawType;\n\t\t\t}\n\t\t\tverticesX = model.verticesX;\n\t\t\tverticesZ = model.verticesZ;\n\t\t\ttriangleColours = model.triangleColours;\n\t\t\ttriangleAlpha = model.triangleAlpha;\n\t\t\ttrianglePriorities = model.trianglePriorities;\n\t\t\ttrianglePriority = model.trianglePriority;\n\t\t\ttriangleX = model.triangleX;\n\t\t\ttriangleY = model.triangleY;\n\t\t\ttriangleZ = model.triangleZ;\n\t\t\ttexturedTrianglePointsX = model.texturedTrianglePointsX;\n\t\t\ttexturedTrianglePointsY = model.texturedTrianglePointsY;\n\t\t\ttexturedTrianglePointsZ = model.texturedTrianglePointsZ;\n\t\t\tbase.modelHeight = model.modelHeight;\n\t\t\tmaxY = model.maxY;\n\t\t\tdiagonal2DAboveOrigin = model.diagonal2DAboveOrigin;\n\t\t\tanInt1653 = model.anInt1653;\n\t\t\tanInt1652 = model.anInt1652;\n\t\t\tminX = model.minX;\n\t\t\tmaxZ = model.maxZ;\n\t\t\tminZ = model.minZ;\n\t\t\tmaxX = model.maxX;\n\t\t}\n\n\t\t\/\/TODO: Refactor https:\/\/github.com\/HelloKitty\/RS317.Sharp\/blob\/master\/src\/Rs317.Library.Client\/Model.cs#L1923\n\t\tpublic void replaceWithModel(Model model, bool flag)\n\t\t{\n\t\t\tvertexCount = model.vertexCount;\n\t\t\ttriangleCount = model.triangleCount;\n\t\t\ttexturedTriangleCount = model.texturedTriangleCount;\n\t\t\tif(anIntArray1622.Length < vertexCount)\n\t\t\t{\n\t\t\t\tanIntArray1622 = new int[vertexCount + 100];\n\t\t\t\tanIntArray1623 = new int[vertexCount + 100];\n\t\t\t\tanIntArray1624 = new int[vertexCount + 100];\n\t\t\t}\n\t\t\tverticesX = anIntArray1622;\n\t\t\tverticesY = anIntArray1623;\n\t\t\tverticesZ = anIntArray1624;\n\t\t\tfor(int k = 0; k < vertexCount; k++)\n\t\t\t{\n\t\t\t\tverticesX[k] = model.verticesX[k];\n\t\t\t\tverticesY[k] = model.verticesY[k];\n\t\t\t\tverticesZ[k] = model.verticesZ[k];\n\t\t\t}\n\n\t\t\tif(flag)\n\t\t\t{\n\t\t\t\ttriangleAlpha = model.triangleAlpha;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(anIntArray1625.Length < triangleCount)\n\t\t\t\t\tanIntArray1625 = new int[triangleCount + 100];\n\t\t\t\ttriangleAlpha = anIntArray1625;\n\t\t\t\tif(model.triangleAlpha == null)\n\t\t\t\t{\n\t\t\t\t\tfor(int l = 0; l < triangleCount; l++)\n\t\t\t\t\t\ttriangleAlpha[l] = 0;\n\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tArray.Copy(model.triangleAlpha, 0, triangleAlpha, 0, triangleCount);\n\n\t\t\t\t}\n\t\t\t}\n\t\t\ttriangleDrawType = model.triangleDrawType;\n\t\t\ttriangleColours = model.triangleColours;\n\t\t\ttrianglePriorities = model.trianglePriorities;\n\t\t\ttrianglePriority = model.trianglePriority;\n\t\t\ttriangleSkin = model.triangleSkin;\n\t\t\tvertexSkin = model.vertexSkin;\n\t\t\ttriangleX = model.triangleX;\n\t\t\ttriangleY = model.triangleY;\n\t\t\ttriangleZ = model.triangleZ;\n\t\t\tanIntArray1634 = model.anIntArray1634;\n\t\t\tanIntArray1635 = model.anIntArray1635;\n\t\t\tanIntArray1636 = model.anIntArray1636;\n\t\t\ttexturedTrianglePointsX = model.texturedTrianglePointsX;\n\t\t\ttexturedTrianglePointsY = model.texturedTrianglePointsY;\n\t\t\ttexturedTrianglePointsZ = model.texturedTrianglePointsZ;\n\t\t}\n\n\t\tprivate int method465(Model model, int i)\n\t\t{\n\t\t\tint j = -1;\n\t\t\tint k = model.verticesX[i];\n\t\t\tint l = model.verticesY[i];\n\t\t\tint i1 = model.verticesZ[i];\n\t\t\tfor(int j1 = 0; j1 < vertexCount; j1++)\n\t\t\t{\n\t\t\t\tif(k != verticesX[j1] || l != verticesY[j1] || i1 != verticesZ[j1])\n\t\t\t\t\tcontinue;\n\t\t\t\tj = j1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(j == -1)\n\t\t\t{\n\t\t\t\tverticesX[vertexCount] = k;\n\t\t\t\tverticesY[vertexCount] = l;\n\t\t\t\tverticesZ[vertexCount] = i1;\n\t\t\t\tif(model.vertexSkins != null)\n\t\t\t\t\tvertexSkins[vertexCount] = model.vertexSkins[i];\n\t\t\t\tj = vertexCount++;\n\t\t\t}\n\t\t\treturn j;\n\t\t}\n\n\t\tpublic void calculateDiagonals()\n\t\t{\n\t\t\tbase.modelHeight = 0;\n\t\t\tdiagonal2DAboveOrigin = 0;\n\t\t\tmaxY = 0;\n\t\t\tfor(int i = 0; i < vertexCount; i++)\n\t\t\t{\n\t\t\t\tint j = verticesX[i];\n\t\t\t\tint k = verticesY[i];\n\t\t\t\tint l = verticesZ[i];\n\t\t\t\tif(-k > base.modelHeight)\n\t\t\t\t\tbase.modelHeight = -k;\n\t\t\t\tif(k > maxY)\n\t\t\t\t\tmaxY = k;\n\t\t\t\tint i1 = j * j + l * l;\n\t\t\t\tif(i1 > diagonal2DAboveOrigin)\n\t\t\t\t\tdiagonal2DAboveOrigin = i1;\n\t\t\t}\n\t\t\tdiagonal2DAboveOrigin = (int)(Math.Sqrt(diagonal2DAboveOrigin) + 0.98999999999999999D);\n\t\t\tanInt1653 = (int)(Math.Sqrt(diagonal2DAboveOrigin * diagonal2DAboveOrigin + base.modelHeight * base.modelHeight) + 0.98999999999999999D);\n\t\t\tanInt1652 = anInt1653 + (int)(Math.Sqrt(diagonal2DAboveOrigin * diagonal2DAboveOrigin + maxY * maxY) + 0.98999999999999999D);\n\t\t}\n\n\t\tpublic void normalise()\n\t\t{\n\t\t\tbase.modelHeight = 0;\n\t\t\tmaxY = 0;\n\t\t\tfor(int i = 0; i < vertexCount; i++)\n\t\t\t{\n\t\t\t\tint j = verticesY[i];\n\t\t\t\tif(-j > base.modelHeight)\n\t\t\t\t\tbase.modelHeight = -j;\n\t\t\t\tif(j > maxY)\n\t\t\t\t\tmaxY = j;\n\t\t\t}\n\n\t\t\tanInt1653 = (int)(Math.Sqrt(diagonal2DAboveOrigin * diagonal2DAboveOrigin + base.modelHeight * base.modelHeight) + 0.98999999999999999D);\n\t\t\tanInt1652 = anInt1653 + (int)(Math.Sqrt(diagonal2DAboveOrigin * diagonal2DAboveOrigin + maxY * maxY) + 0.98999999999999999D);\n\t\t}\n\n\t\tprivate void calculateDiagonalsAndBounds()\n\t\t{\n\t\t\tbase.modelHeight = 0;\n\t\t\tdiagonal2DAboveOrigin = 0;\n\t\t\tmaxY = 0;\n\t\t\tminX = 0xf423f;\n\t\t\tmaxX = unchecked((int)0xfff0bdc1);\n\t\t\tmaxZ = unchecked((int)0xfffe7961);\n\t\t\tminZ = 0x1869f;\n\t\t\tfor(int j = 0; j < vertexCount; j++)\n\t\t\t{\n\t\t\t\tint x = verticesX[j];\n\t\t\t\tint y = verticesY[j];\n\t\t\t\tint z = verticesZ[j];\n\t\t\t\tif(x < minX)\n\t\t\t\t\tminX = x;\n\t\t\t\tif(x > maxX)\n\t\t\t\t\tmaxX = x;\n\t\t\t\tif(z < minZ)\n\t\t\t\t\tminZ = z;\n\t\t\t\tif(z > maxZ)\n\t\t\t\t\tmaxZ = z;\n\t\t\t\tif(-y > base.modelHeight)\n\t\t\t\t\tbase.modelHeight = -y;\n\t\t\t\tif(y > maxY)\n\t\t\t\t\tmaxY = y;\n\t\t\t\tint j1 = x * x + z * z;\n\t\t\t\tif(j1 > diagonal2DAboveOrigin)\n\t\t\t\t\tdiagonal2DAboveOrigin = j1;\n\t\t\t}\n\n\t\t\tdiagonal2DAboveOrigin = (int)Math.Sqrt(diagonal2DAboveOrigin);\n\t\t\tanInt1653 = (int)Math.Sqrt(diagonal2DAboveOrigin * diagonal2DAboveOrigin + base.modelHeight * base.modelHeight);\n\t\t\tanInt1652 = anInt1653 + (int)Math.Sqrt(diagonal2DAboveOrigin * diagonal2DAboveOrigin + maxY * maxY);\n\t\t}\n\n\t\tpublic void createBones()\n\t\t{\n\t\t\tif(vertexSkins != null)\n\t\t\t{\n\t\t\t\tint[] ai = new int[256];\n\t\t\t\tint j = 0;\n\t\t\t\tfor(int l = 0; l < vertexCount; l++)\n\t\t\t\t{\n\t\t\t\t\tint j1 = vertexSkins[l];\n\t\t\t\t\tai[j1]++;\n\t\t\t\t\tif(j1 > j)\n\t\t\t\t\t\tj = j1;\n\t\t\t\t}\n\n\t\t\t\tvertexSkin = new int[j + 1][];\n\t\t\t\tfor(int k1 = 0; k1 <= j; k1++)\n\t\t\t\t{\n\t\t\t\t\tvertexSkin[k1] = new int[ai[k1]];\n\t\t\t\t\tai[k1] = 0;\n\t\t\t\t}\n\n\t\t\t\tfor(int j2 = 0; j2 < vertexCount; j2++)\n\t\t\t\t{\n\t\t\t\t\tint l2 = vertexSkins[j2];\n\t\t\t\t\tvertexSkin[l2][ai[l2]++] = j2;\n\t\t\t\t}\n\n\t\t\t\tvertexSkins = null;\n\t\t\t}\n\t\t\tif(triangleSkins != null)\n\t\t\t{\n\t\t\t\tint[] ai1 = new int[256];\n\t\t\t\tint k = 0;\n\t\t\t\tfor(int i1 = 0; i1 < triangleCount; i1++)\n\t\t\t\t{\n\t\t\t\t\tint l1 = triangleSkins[i1];\n\t\t\t\t\tai1[l1]++;\n\t\t\t\t\tif(l1 > k)\n\t\t\t\t\t\tk = l1;\n\t\t\t\t}\n\n\t\t\t\ttriangleSkin = new int[k + 1][];\n\t\t\t\tfor(int i2 = 0; i2 <= k; i2++)\n\t\t\t\t{\n\t\t\t\t\ttriangleSkin[i2] = new int[ai1[i2]];\n\t\t\t\t\tai1[i2] = 0;\n\t\t\t\t}\n\n\t\t\t\tfor(int k2 = 0; k2 < triangleCount; k2++)\n\t\t\t\t{\n\t\t\t\t\tint i3 = triangleSkins[k2];\n\t\t\t\t\ttriangleSkin[i3][ai1[i3]++] = k2;\n\t\t\t\t}\n\n\t\t\t\ttriangleSkins = null;\n\t\t\t}\n\t\t}\n\n\t\t\/\/TODO: Refactor https:\/\/github.com\/HelloKitty\/RS317.Sharp\/blob\/master\/src\/Rs317.Library.Client\/Model.cs#L934\n\t\tpublic void applyTransformation(int i)\n\t\t{\n\t\t\tif(vertexSkin == null)\n\t\t\t\treturn;\n\t\t\tif(i == -1)\n\t\t\t\treturn;\n\t\t\tAnimation animationFrame = Animation.forFrameId(i);\n\t\t\tif(animationFrame == null)\n\t\t\t\treturn;\n\t\t\tSkins skins = animationFrame.animationSkins;\n\t\t\tvertexModifierX = 0;\n\t\t\tvertexModifierY = 0;\n\t\t\tvertexModifierZ = 0;\n\t\t\tfor(int stepId = 0; stepId < animationFrame.frameCount; stepId++)\n\t\t\t{\n\t\t\t\tint opcode = animationFrame.opcodeTable[stepId];\n\t\t\t\ttransformFrame(skins.opcodes[opcode], skins.skinList[opcode], animationFrame.transformationX[stepId],\n\t\t\t\t\tanimationFrame.transformationY[stepId], animationFrame.transformationZ[stepId]);\n\t\t\t}\n\n\t\t}\n\n\t\tpublic void mixAnimationFrames(int[] framesFrom2, int frameId2, int frameId1)\n\t\t{\n\t\t\tif(frameId1 == -1)\n\t\t\t\treturn;\n\t\t\tif(framesFrom2 == null || frameId2 == -1)\n\t\t\t{\n\t\t\t\tapplyTransformation(frameId1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tAnimation animationFrame1 = Animation.forFrameId(frameId1);\n\t\t\tif(animationFrame1 == null)\n\t\t\t\treturn;\n\t\t\tAnimation animationFrame2 = Animation.forFrameId(frameId2);\n\t\t\tif(animationFrame2 == null)\n\t\t\t{\n\t\t\t\tapplyTransformation(frameId1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tSkins skins = animationFrame1.animationSkins;\n\t\t\tvertexModifierX = 0;\n\t\t\tvertexModifierY = 0;\n\t\t\tvertexModifierZ = 0;\n\t\t\tint counter = 0;\n\t\t\tint frameCount = framesFrom2[counter++];\n\t\t\tfor(int frame = 0; frame < animationFrame1.frameCount; frame++)\n\t\t\t{\n\t\t\t\tint skin;\n\t\t\t\tfor(skin = animationFrame1.opcodeTable[frame]; skin > frameCount; frameCount = framesFrom2[counter++])\n\t\t\t\t\t;\n\t\t\t\tif(skin != frameCount || skins.opcodes[skin] == 0)\n\t\t\t\t\ttransformFrame(skins.opcodes[skin], skins.skinList[skin], animationFrame1.transformationX[frame],\n\t\t\t\t\t\tanimationFrame1.transformationY[frame], animationFrame1.transformationZ[frame]);\n\t\t\t}\n\n\t\t\tvertexModifierX = 0;\n\t\t\tvertexModifierY = 0;\n\t\t\tvertexModifierZ = 0;\n\t\t\tcounter = 0;\n\t\t\tframeCount = framesFrom2[counter++];\n\t\t\tfor(int frame = 0; frame < animationFrame2.frameCount; frame++)\n\t\t\t{\n\t\t\t\tint skin;\n\t\t\t\tfor(skin = animationFrame2.opcodeTable[frame]; skin > frameCount; frameCount = framesFrom2[counter++])\n\t\t\t\t\t;\n\t\t\t\tif(skin == frameCount || skins.opcodes[skin] == 0)\n\t\t\t\t\ttransformFrame(skins.opcodes[skin], skins.skinList[skin], animationFrame2.transformationX[frame],\n\t\t\t\t\t\tanimationFrame2.transformationY[frame], animationFrame2.transformationZ[frame]);\n\t\t\t}\n\n\t\t}\n\n\t\tprivate void transformFrame(int i, int[] ai, int j, int k, int l)\n\t\t{\n\t\t\tint i1 = ai.Length;\n\t\t\tif(i == 0)\n\t\t\t{\n\t\t\t\tint j1 = 0;\n\t\t\t\tvertexModifierX = 0;\n\t\t\t\tvertexModifierY = 0;\n\t\t\t\tvertexModifierZ = 0;\n\t\t\t\tfor(int k2 = 0; k2 < i1; k2++)\n\t\t\t\t{\n\t\t\t\t\tint l3 = ai[k2];\n\t\t\t\t\tif(l3 < vertexSkin.Length)\n\t\t\t\t\t{\n\t\t\t\t\t\tint[] ai5 = vertexSkin[l3];\n\t\t\t\t\t\tfor(int i5 = 0; i5 < ai5.Length; i5++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint j6 = ai5[i5];\n\t\t\t\t\t\t\tvertexModifierX += verticesX[j6];\n\t\t\t\t\t\t\tvertexModifierY += verticesY[j6];\n\t\t\t\t\t\t\tvertexModifierZ += verticesZ[j6];\n\t\t\t\t\t\t\tj1++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(j1 > 0)\n\t\t\t\t{\n\t\t\t\t\tvertexModifierX = vertexModifierX \/ j1 + j;\n\t\t\t\t\tvertexModifierY = vertexModifierY \/ j1 + k;\n\t\t\t\t\tvertexModifierZ = vertexModifierZ \/ j1 + l;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvertexModifierX = j;\n\t\t\t\t\tvertexModifierY = k;\n\t\t\t\t\tvertexModifierZ = l;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i == 1)\n\t\t\t{\n\t\t\t\tfor(int k1 = 0; k1 < i1; k1++)\n\t\t\t\t{\n\t\t\t\t\tint l2 = ai[k1];\n\t\t\t\t\tif(l2 < vertexSkin.Length)\n\t\t\t\t\t{\n\t\t\t\t\t\tint[] ai1 = vertexSkin[l2];\n\t\t\t\t\t\tfor(int i4 = 0; i4 < ai1.Length; i4++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint j5 = ai1[i4];\n\t\t\t\t\t\t\tverticesX[j5] += j;\n\t\t\t\t\t\t\tverticesY[j5] += k;\n\t\t\t\t\t\t\tverticesZ[j5] += l;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(i == 2)\n\t\t\t{\n\t\t\t\tfor(int l1 = 0; l1 < i1; l1++)\n\t\t\t\t{\n\t\t\t\t\tint i3 = ai[l1];\n\t\t\t\t\tif(i3 < vertexSkin.Length)\n\t\t\t\t\t{\n\t\t\t\t\t\tint[] ai2 = vertexSkin[i3];\n\t\t\t\t\t\tfor(int j4 = 0; j4 < ai2.Length; j4++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint k5 = ai2[j4];\n\t\t\t\t\t\t\tverticesX[k5] -= vertexModifierX;\n\t\t\t\t\t\t\tverticesY[k5] -= vertexModifierY;\n\t\t\t\t\t\t\tverticesZ[k5] -= vertexModifierZ;\n\t\t\t\t\t\t\tint k6 = (j & 0xff) * 8;\n\t\t\t\t\t\t\tint l6 = (k & 0xff) * 8;\n\t\t\t\t\t\t\tint i7 = (l & 0xff) * 8;\n\t\t\t\t\t\t\tif(i7 != 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint j7 = SINE[i7];\n\t\t\t\t\t\t\t\tint i8 = COSINE[i7];\n\t\t\t\t\t\t\t\tint l8 = verticesY[k5] * j7 + verticesX[k5] * i8 >> 16;\n\t\t\t\t\t\t\t\tverticesY[k5] = verticesY[k5] * i8 - verticesX[k5] * j7 >> 16;\n\t\t\t\t\t\t\t\tverticesX[k5] = l8;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(k6 != 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint k7 = SINE[k6];\n\t\t\t\t\t\t\t\tint j8 = COSINE[k6];\n\t\t\t\t\t\t\t\tint i9 = verticesY[k5] * j8 - verticesZ[k5] * k7 >> 16;\n\t\t\t\t\t\t\t\tverticesZ[k5] = verticesY[k5] * k7 + verticesZ[k5] * j8 >> 16;\n\t\t\t\t\t\t\t\tverticesY[k5] = i9;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(l6 != 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint l7 = SINE[l6];\n\t\t\t\t\t\t\t\tint k8 = COSINE[l6];\n\t\t\t\t\t\t\t\tint j9 = verticesZ[k5] * l7 + verticesX[k5] * k8 >> 16;\n\t\t\t\t\t\t\t\tverticesZ[k5] = verticesZ[k5] * k8 - verticesX[k5] * l7 >> 16;\n\t\t\t\t\t\t\t\tverticesX[k5] = j9;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tverticesX[k5] += vertexModifierX;\n\t\t\t\t\t\t\tverticesY[k5] += vertexModifierY;\n\t\t\t\t\t\t\tverticesZ[k5] += vertexModifierZ;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(i == 3)\n\t\t\t{\n\t\t\t\tfor(int i2 = 0; i2 < i1; i2++)\n\t\t\t\t{\n\t\t\t\t\tint j3 = ai[i2];\n\t\t\t\t\tif(j3 < vertexSkin.Length)\n\t\t\t\t\t{\n\t\t\t\t\t\tint[] ai3 = vertexSkin[j3];\n\t\t\t\t\t\tfor(int k4 = 0; k4 < ai3.Length; k4++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint l5 = ai3[k4];\n\t\t\t\t\t\t\tverticesX[l5] -= vertexModifierX;\n\t\t\t\t\t\t\tverticesY[l5] -= vertexModifierY;\n\t\t\t\t\t\t\tverticesZ[l5] -= vertexModifierZ;\n\t\t\t\t\t\t\tverticesX[l5] = (verticesX[l5] * j) \/ 128;\n\t\t\t\t\t\t\tverticesY[l5] = (verticesY[l5] * k) \/ 128;\n\t\t\t\t\t\t\tverticesZ[l5] = (verticesZ[l5] * l) \/ 128;\n\t\t\t\t\t\t\tverticesX[l5] += vertexModifierX;\n\t\t\t\t\t\t\tverticesY[l5] += vertexModifierY;\n\t\t\t\t\t\t\tverticesZ[l5] += vertexModifierZ;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(i == 5 && triangleSkin != null && triangleAlpha != null)\n\t\t\t{\n\t\t\t\tfor(int j2 = 0; j2 < i1; j2++)\n\t\t\t\t{\n\t\t\t\t\tint k3 = ai[j2];\n\t\t\t\t\tif(k3 < triangleSkin.Length)\n\t\t\t\t\t{\n\t\t\t\t\t\tint[] ai4 = triangleSkin[k3];\n\t\t\t\t\t\tfor(int l4 = 0; l4 < ai4.Length; l4++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint i6 = ai4[l4];\n\t\t\t\t\t\t\ttriangleAlpha[i6] += j * 8;\n\t\t\t\t\t\t\tif(triangleAlpha[i6] < 0)\n\t\t\t\t\t\t\t\ttriangleAlpha[i6] = 0;\n\t\t\t\t\t\t\tif(triangleAlpha[i6] > 255)\n\t\t\t\t\t\t\t\ttriangleAlpha[i6] = 255;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tpublic void rotate90Degrees()\n\t\t{\n\t\t\tfor(int j = 0; j < vertexCount; j++)\n\t\t\t{\n\t\t\t\tint k = verticesX[j];\n\t\t\t\tverticesX[j] = verticesZ[j];\n\t\t\t\tverticesZ[j] = -k;\n\t\t\t}\n\n\t\t}\n\n\t\tpublic void rotateX(int degrees)\n\t\t{\n\t\t\tint k = SINE[degrees];\n\t\t\tint l = COSINE[degrees];\n\t\t\tfor(int i1 = 0; i1 < vertexCount; i1++)\n\t\t\t{\n\t\t\t\tint j1 = verticesY[i1] * l - verticesZ[i1] * k >> 16;\n\t\t\t\tverticesZ[i1] = verticesY[i1] * k + verticesZ[i1] * l >> 16;\n\t\t\t\tverticesY[i1] = j1;\n\t\t\t}\n\t\t}\n\n\t\tpublic void translate(int x, int y, int z)\n\t\t{\n\t\t\tfor(int i1 = 0; i1 < vertexCount; i1++)\n\t\t\t{\n\t\t\t\tverticesX[i1] += x;\n\t\t\t\tverticesY[i1] += y;\n\t\t\t\tverticesZ[i1] += z;\n\t\t\t}\n\n\t\t}\n\n\t\tpublic void recolour(int targetColour, int replacementColour)\n\t\t{\n\t\t\tfor(int k = 0; k < triangleCount; k++)\n\t\t\t\tif(triangleColours[k] == targetColour)\n\t\t\t\t\ttriangleColours[k] = replacementColour;\n\n\t\t}\n\n\t\t\/\/TODO: Refactor again https:\/\/github.com\/HelloKitty\/RS317.Sharp\/blob\/master\/src\/Rs317.Library.Client\/Model.cs#L1570\n\t\tpublic void mirror()\n\t\t{\n\t\t\tfor(int j = 0; j < vertexCount; j++)\n\t\t\t\tverticesZ[j] = -verticesZ[j];\n\n\t\t\tfor(int k = 0; k < triangleCount; k++)\n\t\t\t{\n\t\t\t\tint l = triangleX[k];\n\t\t\t\ttriangleX[k] = triangleZ[k];\n\t\t\t\ttriangleZ[k] = l;\n\t\t\t}\n\t\t}\n\n\t\tpublic void scaleT(int x, int z, int y)\n\t\t{\n\t\t\tfor(int i1 = 0; i1 < vertexCount; i1++)\n\t\t\t{\n\t\t\t\tverticesX[i1] = (verticesX[i1] * x) \/ 128;\n\t\t\t\tverticesY[i1] = (verticesY[i1] * y) \/ 128;\n\t\t\t\tverticesZ[i1] = (verticesZ[i1] * z) \/ 128;\n\t\t\t}\n\n\t\t}\n\n\t\tpublic void applyLighting(int lightMod, int magnitudeMultiplier, int lightX, int lightY, int lightZ, bool flatShading)\n\t\t{\n\t\t\tint lightMagnitude = (int)Math.Sqrt(lightX * lightX + lightY * lightY + lightZ * lightZ);\n\t\t\tint magnitude = magnitudeMultiplier * lightMagnitude >> 8;\n\t\t\tif(anIntArray1634 == null)\n\t\t\t{\n\t\t\t\tanIntArray1634 = new int[triangleCount];\n\t\t\t\tanIntArray1635 = new int[triangleCount];\n\t\t\t\tanIntArray1636 = new int[triangleCount];\n\t\t\t}\n\t\t\tif(base.vertexNormals == null)\n\t\t\t{\n\t\t\t\tbase.vertexNormals = new VertexNormal[vertexCount];\n\t\t\t\tfor(int l1 = 0; l1 < vertexCount; l1++)\n\t\t\t\t\tbase.vertexNormals[l1] = new VertexNormal();\n\n\t\t\t}\n\t\t\tfor(int i2 = 0; i2 < triangleCount; i2++)\n\t\t\t{\n\t\t\t\tint _triangleX = triangleX[i2];\n\t\t\t\tint _triangleY = triangleY[i2];\n\t\t\t\tint _triangleZ = triangleZ[i2];\n\t\t\t\tint distanceXXY = verticesX[_triangleY] - verticesX[_triangleX];\n\t\t\t\tint distanceYXY = verticesY[_triangleY] - verticesY[_triangleX];\n\t\t\t\tint distanceZXY = verticesZ[_triangleY] - verticesZ[_triangleX];\n\t\t\t\tint distanceXZX = verticesX[_triangleZ] - verticesX[_triangleX];\n\t\t\t\tint distanceYZX = verticesY[_triangleZ] - verticesY[_triangleX];\n\t\t\t\tint distanceZZX = verticesZ[_triangleZ] - verticesZ[_triangleX];\n\t\t\t\tint normalX = distanceYXY * distanceZZX - distanceYZX * distanceZXY;\n\t\t\t\tint normalY = distanceZXY * distanceXZX - distanceZZX * distanceXXY;\n\t\t\t\tint normalZ;\n\t\t\t\tfor(normalZ = distanceXXY * distanceYZX - distanceXZX * distanceYXY; normalX > 8192 || normalY > 8192 || normalZ > 8192 || normalX < -8192 || normalY < -8192 || normalZ < -8192; normalZ >>= 1)\n\t\t\t\t{\n\t\t\t\t\tnormalX >>= 1;\n\t\t\t\t\tnormalY >>= 1;\n\t\t\t\t}\n\n\t\t\t\tint normalLength = (int)Math.Sqrt(normalX * normalX + normalY * normalY + normalZ * normalZ);\n\t\t\t\tif(normalLength <= 0)\n\t\t\t\t\tnormalLength = 1;\n\t\t\t\tnormalX = (normalX * 256) \/ normalLength;\n\t\t\t\tnormalY = (normalY * 256) \/ normalLength;\n\t\t\t\tnormalZ = (normalZ * 256) \/ normalLength;\n\t\t\t\tif(triangleDrawType == null || (triangleDrawType[i2] & 1) == 0)\n\t\t\t\t{\n\t\t\t\t\tVertexNormal class33_2 = base.vertexNormals[_triangleX];\n\t\t\t\t\tclass33_2.x += normalX;\n\t\t\t\t\tclass33_2.y += normalY;\n\t\t\t\t\tclass33_2.z += normalZ;\n\t\t\t\t\tclass33_2.magnitude++;\n\t\t\t\t\tclass33_2 = base.vertexNormals[_triangleY];\n\t\t\t\t\tclass33_2.x += normalX;\n\t\t\t\t\tclass33_2.y += normalY;\n\t\t\t\t\tclass33_2.z += normalZ;\n\t\t\t\t\tclass33_2.magnitude++;\n\t\t\t\t\tclass33_2 = base.vertexNormals[_triangleZ];\n\t\t\t\t\tclass33_2.x += normalX;\n\t\t\t\t\tclass33_2.y += normalY;\n\t\t\t\t\tclass33_2.z += normalZ;\n\t\t\t\t\tclass33_2.magnitude++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint lightness = lightMod + (lightX * normalX + lightY * normalY + lightZ * normalZ) \/ (magnitude + magnitude \/ 2);\n\t\t\t\t\tanIntArray1634[i2] = method481(triangleColours[i2], lightness, triangleDrawType[i2]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(flatShading)\n\t\t\t{\n\t\t\t\thandleShading(lightMod, magnitude, lightX, lightY, lightZ);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvertexNormalOffset = new VertexNormal[vertexCount];\n\t\t\t\tfor(int k2 = 0; k2 < vertexCount; k2++)\n\t\t\t\t{\n\t\t\t\t\tVertexNormal class33 = base.vertexNormals[k2];\n\t\t\t\t\tVertexNormal class33_1 = vertexNormalOffset[k2] = new VertexNormal();\n\t\t\t\t\tclass33_1.x = class33.x;\n\t\t\t\t\tclass33_1.y = class33.y;\n\t\t\t\t\tclass33_1.z = class33.z;\n\t\t\t\t\tclass33_1.magnitude = class33.magnitude;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif(flatShading)\n\t\t\t{\n\t\t\t\tcalculateDiagonals();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcalculateDiagonalsAndBounds();\n\t\t\t}\n\t\t}\n\n\t\tpublic void handleShading(int intensity, int falloff, int lightX, int lightY, int lightZ)\n\t\t{\n\t\t\tfor(int triangle = 0; triangle < triangleCount; triangle++)\n\t\t\t{\n\t\t\t\tint x = triangleX[triangle];\n\t\t\t\tint y = triangleY[triangle];\n\t\t\t\tint z = triangleZ[triangle];\n\t\t\t\tif(triangleDrawType == null)\n\t\t\t\t{\n\t\t\t\t\tint i3 = triangleColours[triangle];\n\t\t\t\t\tVertexNormal class33 = base.vertexNormals[x];\n\t\t\t\t\tint k2 = intensity + (lightX * class33.x + lightY * class33.y + lightZ * class33.z) \/ (falloff * class33.magnitude);\n\t\t\t\t\tanIntArray1634[triangle] = method481(i3, k2, 0);\n\t\t\t\t\tclass33 = base.vertexNormals[y];\n\t\t\t\t\tk2 = intensity + (lightX * class33.x + lightY * class33.y + lightZ * class33.z) \/ (falloff * class33.magnitude);\n\t\t\t\t\tanIntArray1635[triangle] = method481(i3, k2, 0);\n\t\t\t\t\tclass33 = base.vertexNormals[z];\n\t\t\t\t\tk2 = intensity + (lightX * class33.x + lightY * class33.y + lightZ * class33.z) \/ (falloff * class33.magnitude);\n\t\t\t\t\tanIntArray1636[triangle] = method481(i3, k2, 0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tif((triangleDrawType[triangle] & 1) == 0)\n\t\t\t\t{\n\t\t\t\t\tint j3 = triangleColours[triangle];\n\t\t\t\t\tint k3 = triangleDrawType[triangle];\n\t\t\t\t\tVertexNormal class33_1 = base.vertexNormals[x];\n\t\t\t\t\tint l2 = intensity + (lightX * class33_1.x + lightY * class33_1.y + lightZ * class33_1.z) \/ (falloff * class33_1.magnitude);\n\t\t\t\t\tanIntArray1634[triangle] = method481(j3, l2, k3);\n\t\t\t\t\tclass33_1 = base.vertexNormals[y];\n\t\t\t\t\tl2 = intensity + (lightX * class33_1.x + lightY * class33_1.y + lightZ * class33_1.z) \/ (falloff * class33_1.magnitude);\n\t\t\t\t\tanIntArray1635[triangle] = method481(j3, l2, k3);\n\t\t\t\t\tclass33_1 = base.vertexNormals[z];\n\t\t\t\t\tl2 = intensity + (lightX * class33_1.x + lightY * class33_1.y + lightZ * class33_1.z) \/ (falloff * class33_1.magnitude);\n\t\t\t\t\tanIntArray1636[triangle] = method481(j3, l2, k3);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbase.vertexNormals = null;\n\t\t\tvertexNormalOffset = null;\n\t\t\tvertexSkins = null;\n\t\t\ttriangleSkins = null;\n\t\t\tif(triangleDrawType != null)\n\t\t\t{\n\t\t\t\tfor(int l1 = 0; l1 < triangleCount; l1++)\n\t\t\t\t\tif((triangleDrawType[l1] & 2) == 2)\n\t\t\t\t\t\treturn;\n\n\t\t\t}\n\t\t\ttriangleColours = null;\n\t\t}\n\n\t\tprivate static int method481(int colour, int lightness, int drawType)\n\t\t{\n\t\t\tif((drawType & 2) == 2)\n\t\t\t{\n\t\t\t\tif(lightness < 0)\n\t\t\t\t\tlightness = 0;\n\t\t\t\telse\n\t\t\t\t\tif(lightness > 127)\n\t\t\t\t\tlightness = 127;\n\t\t\t\tlightness = 127 - lightness;\n\t\t\t\treturn lightness;\n\t\t\t}\n\t\t\tlightness = lightness * (colour & 0x7f) >> 7;\n\t\t\tif(lightness < 2)\n\t\t\t\tlightness = 2;\n\t\t\telse\n\t\t\t\tif(lightness > 126)\n\t\t\t\tlightness = 126;\n\t\t\treturn (colour & 0xff80) + lightness;\n\t\t}\n\n\t\t\/\/TODO: Refactor https:\/\/github.com\/HelloKitty\/RS317.Sharp\/blob\/master\/src\/Rs317.Library.Client\/Model.cs#L1854\n\t\tpublic void renderSingle(int j, int k, int l, int i1, int j1, int k1)\n\t\t{\n\t\t\tint i = 0; \/\/was a parameter\n\t\t\tint l1 = Rasterizer.centreX;\n\t\t\tint i2 = Rasterizer.centreY;\n\t\t\tint j2 = SINE[i];\n\t\t\tint k2 = COSINE[i];\n\t\t\tint l2 = SINE[j];\n\t\t\tint i3 = COSINE[j];\n\t\t\tint j3 = SINE[k];\n\t\t\tint k3 = COSINE[k];\n\t\t\tint l3 = SINE[l];\n\t\t\tint i4 = COSINE[l];\n\t\t\tint j4 = j1 * l3 + k1 * i4 >> 16;\n\t\t\tfor(int k4 = 0; k4 < vertexCount; k4++)\n\t\t\t{\n\t\t\t\tint l4 = verticesX[k4];\n\t\t\t\tint i5 = verticesY[k4];\n\t\t\t\tint j5 = verticesZ[k4];\n\t\t\t\tif(k != 0)\n\t\t\t\t{\n\t\t\t\t\tint k5 = i5 * j3 + l4 * k3 >> 16;\n\t\t\t\t\ti5 = i5 * k3 - l4 * j3 >> 16;\n\t\t\t\t\tl4 = k5;\n\t\t\t\t}\n\t\t\t\tif(i != 0)\n\t\t\t\t{\n\t\t\t\t\tint l5 = i5 * k2 - j5 * j2 >> 16;\n\t\t\t\t\tj5 = i5 * j2 + j5 * k2 >> 16;\n\t\t\t\t\ti5 = l5;\n\t\t\t\t}\n\t\t\t\tif(j != 0)\n\t\t\t\t{\n\t\t\t\t\tint i6 = j5 * l2 + l4 * i3 >> 16;\n\t\t\t\t\tj5 = j5 * i3 - l4 * l2 >> 16;\n\t\t\t\t\tl4 = i6;\n\t\t\t\t}\n\t\t\t\tl4 += i1;\n\t\t\t\ti5 += j1;\n\t\t\t\tj5 += k1;\n\t\t\t\tint j6 = i5 * i4 - j5 * l3 >> 16;\n\t\t\t\tj5 = i5 * l3 + j5 * i4 >> 16;\n\t\t\t\ti5 = j6;\n\t\t\t\tanIntArray1667[k4] = j5 - j4;\n\t\t\t\tanIntArray1665[k4] = l1 + (l4 << 9) \/ j5;\n\t\t\t\tanIntArray1666[k4] = i2 + (i5 << 9) \/ j5;\n\t\t\t\tif(texturedTriangleCount > 0)\n\t\t\t\t{\n\t\t\t\t\tanIntArray1668[k4] = l4;\n\t\t\t\t\tanIntArray1669[k4] = i5;\n\t\t\t\t\tanIntArray1670[k4] = j5;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tmethod483(false, false, 0);\n\t\t\t}\n\t\t\tcatch(Exception _ex)\n\t\t\t{\n\t\t\t}\n\t\t}\n\n\t\tpublic override void renderAtPoint(int i, int j, int k, int l, int i1, int j1, int k1,\n\t\t\t\tint l1, int i2)\n\t\t{\n\t\t\tunchecked\n\t\t\t{\n\t\t\t\tint j2 = l1 * i1 - j1 * l >> 16;\n\t\t\t\tint k2 = k1 * j + j2 * k >> 16;\n\t\t\t\tint l2 = diagonal2DAboveOrigin * k >> 16;\n\t\t\t\tint i3 = k2 + l2;\n\t\t\t\tif (i3 <= 50 || k2 >= 3500)\n\t\t\t\t\treturn;\n\t\t\t\tint j3 = l1 * l + j1 * i1 >> 16;\n\t\t\t\tint k3 = j3 - diagonal2DAboveOrigin << 9;\n\t\t\t\tif (k3 \/ i3 >= DrawingArea.viewportCentreX)\n\t\t\t\t\treturn;\n\t\t\t\tint l3 = j3 + diagonal2DAboveOrigin << 9;\n\t\t\t\tif (l3 \/ i3 <= -DrawingArea.viewportCentreX)\n\t\t\t\t\treturn;\n\t\t\t\tint i4 = k1 * k - j2 * j >> 16;\n\t\t\t\tint j4 = diagonal2DAboveOrigin * j >> 16;\n\t\t\t\tint k4 = i4 + j4 << 9;\n\t\t\t\tif (k4 \/ i3 <= -DrawingArea.viewportCentreY)\n\t\t\t\t\treturn;\n\t\t\t\tint l4 = j4 + (base.modelHeight * k >> 16);\n\t\t\t\tint i5 = i4 - l4 << 9;\n\t\t\t\tif (i5 \/ i3 >= DrawingArea.viewportCentreY)\n\t\t\t\t\treturn;\n\t\t\t\tint j5 = l2 + (base.modelHeight * j >> 16);\n\t\t\t\tbool flag = false;\n\t\t\t\tif (k2 - j5 <= 50)\n\t\t\t\t\tflag = true;\n\t\t\t\tbool flag1 = false;\n\t\t\t\tif (i2 > 0 && abool1684)\n\t\t\t\t{\n\t\t\t\t\tint k5 = k2 - l2;\n\t\t\t\t\tif (k5 <= 50)\n\t\t\t\t\t\tk5 = 50;\n\t\t\t\t\tif (j3 > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tk3 \/= i3;\n\t\t\t\t\t\tl3 \/= k5;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tl3 \/= i3;\n\t\t\t\t\t\tk3 \/= k5;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (i4 > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\ti5 \/= i3;\n\t\t\t\t\t\tk4 \/= k5;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tk4 \/= i3;\n\t\t\t\t\t\ti5 \/= k5;\n\t\t\t\t\t}\n\n\t\t\t\t\tint i6 = cursorX - Rasterizer.centreX;\n\t\t\t\t\tint k6 = cursorY - Rasterizer.centreY;\n\t\t\t\t\tif (i6 > k3 && i6 < l3 && k6 > i5 && k6 < k4)\n\t\t\t\t\t\tif (singleTile)\n\t\t\t\t\t\t\tresourceId[resourceCount++] = i2;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tflag1 = true;\n\t\t\t\t}\n\n\t\t\t\tint l5 = Rasterizer.centreX;\n\t\t\t\tint j6 = Rasterizer.centreY;\n\t\t\t\tint l6 = 0;\n\t\t\t\tint i7 = 0;\n\t\t\t\tif (i != 0)\n\t\t\t\t{\n\t\t\t\t\tl6 = SINE[i];\n\t\t\t\t\ti7 = COSINE[i];\n\t\t\t\t}\n\n\t\t\t\tfor (int j7 = 0; j7 < vertexCount; j7++)\n\t\t\t\t{\n\t\t\t\t\tint k7 = verticesX[j7];\n\t\t\t\t\tint l7 = verticesY[j7];\n\t\t\t\t\tint i8 = verticesZ[j7];\n\t\t\t\t\tif (i != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tint j8 = i8 * l6 + k7 * i7 >> 16;\n\t\t\t\t\t\ti8 = i8 * i7 - k7 * l6 >> 16;\n\t\t\t\t\t\tk7 = j8;\n\t\t\t\t\t}\n\n\t\t\t\t\tk7 += j1;\n\t\t\t\t\tl7 += k1;\n\t\t\t\t\ti8 += l1;\n\t\t\t\t\tint k8 = i8 * l + k7 * i1 >> 16;\n\t\t\t\t\ti8 = i8 * i1 - k7 * l >> 16;\n\t\t\t\t\tk7 = k8;\n\t\t\t\t\tk8 = l7 * k - i8 * j >> 16;\n\t\t\t\t\ti8 = l7 * j + i8 * k >> 16;\n\t\t\t\t\tl7 = k8;\n\t\t\t\t\tanIntArray1667[j7] = i8 - k2;\n\t\t\t\t\tif (i8 >= 50)\n\t\t\t\t\t{\n\t\t\t\t\t\tanIntArray1665[j7] = l5 + (k7 << 9) \/ i8;\n\t\t\t\t\t\tanIntArray1666[j7] = j6 + (l7 << 9) \/ i8;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tanIntArray1665[j7] = -5000;\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (flag || texturedTriangleCount > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tanIntArray1668[j7] = k7;\n\t\t\t\t\t\tanIntArray1669[j7] = l7;\n\t\t\t\t\t\tanIntArray1670[j7] = i8;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tmethod483(flag, flag1, i2);\n\t\t\t\t}\n\t\t\t\tcatch (Exception _ex)\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void method483(bool flag, bool flag1, int i)\n\t\t{\n\t\t\tfor(int j = 0; j < anInt1652; j++)\n\t\t\t\tanIntArray1671[j] = 0;\n\n\t\t\tfor(int k = 0; k < triangleCount; k++)\n\t\t\t\tif(triangleDrawType == null || triangleDrawType[k] != -1)\n\t\t\t\t{\n\t\t\t\t\tint l = triangleX[k];\n\t\t\t\t\tint k1 = triangleY[k];\n\t\t\t\t\tint j2 = triangleZ[k];\n\t\t\t\t\tint i3 = anIntArray1665[l];\n\t\t\t\t\tint l3 = anIntArray1665[k1];\n\t\t\t\t\tint k4 = anIntArray1665[j2];\n\t\t\t\t\tif(flag && (i3 == -5000 || l3 == -5000 || k4 == -5000))\n\t\t\t\t\t{\n\t\t\t\t\t\taBooleanArray1664[k] = true;\n\t\t\t\t\t\tint j5 = (anIntArray1667[l] + anIntArray1667[k1] + anIntArray1667[j2]) \/ 3 + anInt1653;\n\t\t\t\t\t\tanIntArrayArray1672[j5][anIntArray1671[j5]++] = k;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(flag1 && method486(cursorX, cursorY, anIntArray1666[l], anIntArray1666[k1], anIntArray1666[j2], i3, l3, k4))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresourceId[resourceCount++] = i;\n\t\t\t\t\t\t\tflag1 = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif((i3 - l3) * (anIntArray1666[j2] - anIntArray1666[k1]) - (anIntArray1666[l] - anIntArray1666[k1]) * (k4 - l3) > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taBooleanArray1664[k] = false;\n\t\t\t\t\t\t\taBooleanArray1663[k] = i3 < 0 || l3 < 0 || k4 < 0 || i3 > DrawingArea.centerX || l3 > DrawingArea.centerX || k4 > DrawingArea.centerX;\n\t\t\t\t\t\t\tint k5 = (anIntArray1667[l] + anIntArray1667[k1] + anIntArray1667[j2]) \/ 3 + anInt1653;\n\t\t\t\t\t\t\tanIntArrayArray1672[k5][anIntArray1671[k5]++] = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tif(trianglePriorities == null)\n\t\t\t{\n\t\t\t\tfor(int i1 = anInt1652 - 1; i1 >= 0; i1--)\n\t\t\t\t{\n\t\t\t\t\tint l1 = anIntArray1671[i1];\n\t\t\t\t\tif(l1 > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tint[] ai = anIntArrayArray1672[i1];\n\t\t\t\t\t\tfor(int j3 = 0; j3 < l1; j3++)\n\t\t\t\t\t\t\trasterise(ai[j3]);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor(int j1 = 0; j1 < 12; j1++)\n\t\t\t{\n\t\t\t\tanIntArray1673[j1] = 0;\n\t\t\t\tanIntArray1677[j1] = 0;\n\t\t\t}\n\n\t\t\tfor(int i2 = anInt1652 - 1; i2 >= 0; i2--)\n\t\t\t{\n\t\t\t\tint k2 = anIntArray1671[i2];\n\t\t\t\tif(k2 > 0)\n\t\t\t\t{\n\t\t\t\t\tint[] ai1 = anIntArrayArray1672[i2];\n\t\t\t\t\tfor(int i4 = 0; i4 < k2; i4++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint l4 = ai1[i4];\n\t\t\t\t\t\tint l5 = trianglePriorities[l4];\n\t\t\t\t\t\tint j6 = anIntArray1673[l5]++;\n\t\t\t\t\t\tanIntArrayArray1674[l5][j6] = l4;\n\t\t\t\t\t\tif(l5 < 10)\n\t\t\t\t\t\t\tanIntArray1677[l5] += i2;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tif(l5 == 10)\n\t\t\t\t\t\t\tanIntArray1675[j6] = i2;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tanIntArray1676[j6] = i2;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint l2 = 0;\n\t\t\tif(anIntArray1673[1] > 0 || anIntArray1673[2] > 0)\n\t\t\t\tl2 = (anIntArray1677[1] + anIntArray1677[2]) \/ (anIntArray1673[1] + anIntArray1673[2]);\n\t\t\tint k3 = 0;\n\t\t\tif(anIntArray1673[3] > 0 || anIntArray1673[4] > 0)\n\t\t\t\tk3 = (anIntArray1677[3] + anIntArray1677[4]) \/ (anIntArray1673[3] + anIntArray1673[4]);\n\t\t\tint j4 = 0;\n\t\t\tif(anIntArray1673[6] > 0 || anIntArray1673[8] > 0)\n\t\t\t\tj4 = (anIntArray1677[6] + anIntArray1677[8]) \/ (anIntArray1673[6] + anIntArray1673[8]);\n\t\t\tint i6 = 0;\n\t\t\tint k6 = anIntArray1673[10];\n\t\t\tint[] ai2 = anIntArrayArray1674[10];\n\t\t\tint[] ai3 = anIntArray1675;\n\t\t\tif(i6 == k6)\n\t\t\t{\n\t\t\t\ti6 = 0;\n\t\t\t\tk6 = anIntArray1673[11];\n\t\t\t\tai2 = anIntArrayArray1674[11];\n\t\t\t\tai3 = anIntArray1676;\n\t\t\t}\n\t\t\tint i5;\n\t\t\tif(i6 < k6)\n\t\t\t\ti5 = ai3[i6];\n\t\t\telse\n\t\t\t\ti5 = -1000;\n\t\t\tfor(int l6 = 0; l6 < 10; l6++)\n\t\t\t{\n\t\t\t\twhile(l6 == 0 && i5 > l2)\n\t\t\t\t{\n\t\t\t\t\trasterise(ai2[i6++]);\n\t\t\t\t\tif(i6 == k6 && ai2 != anIntArrayArray1674[11])\n\t\t\t\t\t{\n\t\t\t\t\t\ti6 = 0;\n\t\t\t\t\t\tk6 = anIntArray1673[11];\n\t\t\t\t\t\tai2 = anIntArrayArray1674[11];\n\t\t\t\t\t\tai3 = anIntArray1676;\n\t\t\t\t\t}\n\t\t\t\t\tif(i6 < k6)\n\t\t\t\t\t\ti5 = ai3[i6];\n\t\t\t\t\telse\n\t\t\t\t\t\ti5 = -1000;\n\t\t\t\t}\n\t\t\t\twhile(l6 == 3 && i5 > k3)\n\t\t\t\t{\n\t\t\t\t\trasterise(ai2[i6++]);\n\t\t\t\t\tif(i6 == k6 && ai2 != anIntArrayArray1674[11])\n\t\t\t\t\t{\n\t\t\t\t\t\ti6 = 0;\n\t\t\t\t\t\tk6 = anIntArray1673[11];\n\t\t\t\t\t\tai2 = anIntArrayArray1674[11];\n\t\t\t\t\t\tai3 = anIntArray1676;\n\t\t\t\t\t}\n\t\t\t\t\tif(i6 < k6)\n\t\t\t\t\t\ti5 = ai3[i6];\n\t\t\t\t\telse\n\t\t\t\t\t\ti5 = -1000;\n\t\t\t\t}\n\t\t\t\twhile(l6 == 5 && i5 > j4)\n\t\t\t\t{\n\t\t\t\t\trasterise(ai2[i6++]);\n\t\t\t\t\tif(i6 == k6 && ai2 != anIntArrayArray1674[11])\n\t\t\t\t\t{\n\t\t\t\t\t\ti6 = 0;\n\t\t\t\t\t\tk6 = anIntArray1673[11];\n\t\t\t\t\t\tai2 = anIntArrayArray1674[11];\n\t\t\t\t\t\tai3 = anIntArray1676;\n\t\t\t\t\t}\n\t\t\t\t\tif(i6 < k6)\n\t\t\t\t\t\ti5 = ai3[i6];\n\t\t\t\t\telse\n\t\t\t\t\t\ti5 = -1000;\n\t\t\t\t}\n\t\t\t\tint i7 = anIntArray1673[l6];\n\t\t\t\tint[] ai4 = anIntArrayArray1674[l6];\n\t\t\t\tfor(int j7 = 0; j7 < i7; j7++)\n\t\t\t\t\trasterise(ai4[j7]);\n\n\t\t\t}\n\n\t\t\twhile(i5 != -1000)\n\t\t\t{\n\t\t\t\trasterise(ai2[i6++]);\n\t\t\t\tif(i6 == k6 && ai2 != anIntArrayArray1674[11])\n\t\t\t\t{\n\t\t\t\t\ti6 = 0;\n\t\t\t\t\tai2 = anIntArrayArray1674[11];\n\t\t\t\t\tk6 = anIntArray1673[11];\n\t\t\t\t\tai3 = anIntArray1676;\n\t\t\t\t}\n\t\t\t\tif(i6 < k6)\n\t\t\t\t\ti5 = ai3[i6];\n\t\t\t\telse\n\t\t\t\t\ti5 = -1000;\n\t\t\t}\n\t\t}\n\n\t\t\/\/TODO: Reactor again https:\/\/github.com\/HelloKitty\/RS317.Sharp\/blob\/master\/src\/Rs317.Library.Client\/Model.cs#L1655\n\t\tprivate void rasterise(int i)\n\t\t{\n\t\t\tif(aBooleanArray1664[i])\n\t\t\t{\n\t\t\t\tmethod485(i);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint j = triangleX[i];\n\t\t\tint k = triangleY[i];\n\t\t\tint l = triangleZ[i];\n\t\t\tRasterizer.restrictEdges = aBooleanArray1663[i];\n\t\t\tif(triangleAlpha == null)\n\t\t\t\tRasterizer.alpha = 0;\n\t\t\telse\n\t\t\t\tRasterizer.alpha = triangleAlpha[i];\n\t\t\tint i1;\n\t\t\tif(triangleDrawType == null)\n\t\t\t\ti1 = 0;\n\t\t\telse\n\t\t\t\ti1 = triangleDrawType[i] & 3;\n\t\t\tif(i1 == 0)\n\t\t\t{\n\t\t\t\tRasterizer.drawShadedTriangle(anIntArray1666[j], anIntArray1666[k], anIntArray1666[l], anIntArray1665[j], anIntArray1665[k], anIntArray1665[l], anIntArray1634[i], anIntArray1635[i], anIntArray1636[i]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(i1 == 1)\n\t\t\t{\n\t\t\t\tRasterizer.drawFlatTriangle(anIntArray1666[j], anIntArray1666[k], anIntArray1666[l], anIntArray1665[j], anIntArray1665[k], anIntArray1665[l], HSLtoRGB[anIntArray1634[i]]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(i1 == 2)\n\t\t\t{\n\t\t\t\tint j1 = triangleDrawType[i] >> 2;\n\t\t\t\tint l1 = texturedTrianglePointsX[j1];\n\t\t\t\tint j2 = texturedTrianglePointsY[j1];\n\t\t\t\tint l2 = texturedTrianglePointsZ[j1];\n\t\t\t\tRasterizer.drawTexturedTriangle(anIntArray1666[j], anIntArray1666[k], anIntArray1666[l], anIntArray1665[j], anIntArray1665[k], anIntArray1665[l], anIntArray1634[i], anIntArray1635[i], anIntArray1636[i], anIntArray1668[l1], anIntArray1668[j2], anIntArray1668[l2], anIntArray1669[l1], anIntArray1669[j2], anIntArray1669[l2], anIntArray1670[l1], anIntArray1670[j2], anIntArray1670[l2], triangleColours[i]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(i1 == 3)\n\t\t\t{\n\t\t\t\tint k1 = triangleDrawType[i] >> 2;\n\t\t\t\tint i2 = texturedTrianglePointsX[k1];\n\t\t\t\tint k2 = texturedTrianglePointsY[k1];\n\t\t\t\tint i3 = texturedTrianglePointsZ[k1];\n\t\t\t\tRasterizer.drawTexturedTriangle(anIntArray1666[j], anIntArray1666[k], anIntArray1666[l], anIntArray1665[j], anIntArray1665[k], anIntArray1665[l], anIntArray1634[i], anIntArray1634[i], anIntArray1634[i], anIntArray1668[i2], anIntArray1668[k2], anIntArray1668[i3], anIntArray1669[i2], anIntArray1669[k2], anIntArray1669[i3], anIntArray1670[i2], anIntArray1670[k2], anIntArray1670[i3], triangleColours[i]);\n\t\t\t}\n\t\t}\n\n\t\tprivate void method485(int i)\n\t\t{\n\t\t\tint j = Rasterizer.centreX;\n\t\t\tint k = Rasterizer.centreY;\n\t\t\tint l = 0;\n\t\t\tint x = triangleX[i];\n\t\t\tint y = triangleY[i];\n\t\t\tint z = triangleZ[i];\n\t\t\tint movedX = anIntArray1670[x];\n\t\t\tint movedY = anIntArray1670[y];\n\t\t\tint movedZ = anIntArray1670[z];\n\t\t\tif(movedX >= 50)\n\t\t\t{\n\t\t\t\tanIntArray1678[l] = anIntArray1665[x];\n\t\t\t\tanIntArray1679[l] = anIntArray1666[x];\n\t\t\t\tanIntArray1680[l++] = anIntArray1634[i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint k2 = anIntArray1668[x];\n\t\t\t\tint k3 = anIntArray1669[x];\n\t\t\t\tint k4 = anIntArray1634[i];\n\t\t\t\tif(movedZ >= 50)\n\t\t\t\t{\n\t\t\t\t\tint k5 = (50 - movedX) * modelIntArray4[movedZ - movedX];\n\t\t\t\t\tanIntArray1678[l] = j + (k2 + ((anIntArray1668[z] - k2) * k5 >> 16) << 9) \/ 50;\n\t\t\t\t\tanIntArray1679[l] = k + (k3 + ((anIntArray1669[z] - k3) * k5 >> 16) << 9) \/ 50;\n\t\t\t\t\tanIntArray1680[l++] = k4 + ((anIntArray1636[i] - k4) * k5 >> 16);\n\t\t\t\t}\n\t\t\t\tif(movedY >= 50)\n\t\t\t\t{\n\t\t\t\t\tint l5 = (50 - movedX) * modelIntArray4[movedY - movedX];\n\t\t\t\t\tanIntArray1678[l] = j + (k2 + ((anIntArray1668[y] - k2) * l5 >> 16) << 9) \/ 50;\n\t\t\t\t\tanIntArray1679[l] = k + (k3 + ((anIntArray1669[y] - k3) * l5 >> 16) << 9) \/ 50;\n\t\t\t\t\tanIntArray1680[l++] = k4 + ((anIntArray1635[i] - k4) * l5 >> 16);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(movedY >= 50)\n\t\t\t{\n\t\t\t\tanIntArray1678[l] = anIntArray1665[y];\n\t\t\t\tanIntArray1679[l] = anIntArray1666[y];\n\t\t\t\tanIntArray1680[l++] = anIntArray1635[i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint l2 = anIntArray1668[y];\n\t\t\t\tint l3 = anIntArray1669[y];\n\t\t\t\tint l4 = anIntArray1635[i];\n\t\t\t\tif(movedX >= 50)\n\t\t\t\t{\n\t\t\t\t\tint i6 = (50 - movedY) * modelIntArray4[movedX - movedY];\n\t\t\t\t\tanIntArray1678[l] = j + (l2 + ((anIntArray1668[x] - l2) * i6 >> 16) << 9) \/ 50;\n\t\t\t\t\tanIntArray1679[l] = k + (l3 + ((anIntArray1669[x] - l3) * i6 >> 16) << 9) \/ 50;\n\t\t\t\t\tanIntArray1680[l++] = l4 + ((anIntArray1634[i] - l4) * i6 >> 16);\n\t\t\t\t}\n\t\t\t\tif(movedZ >= 50)\n\t\t\t\t{\n\t\t\t\t\tint j6 = (50 - movedY) * modelIntArray4[movedZ - movedY];\n\t\t\t\t\tanIntArray1678[l] = j + (l2 + ((anIntArray1668[z] - l2) * j6 >> 16) << 9) \/ 50;\n\t\t\t\t\tanIntArray1679[l] = k + (l3 + ((anIntArray1669[z] - l3) * j6 >> 16) << 9) \/ 50;\n\t\t\t\t\tanIntArray1680[l++] = l4 + ((anIntArray1636[i] - l4) * j6 >> 16);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(movedZ >= 50)\n\t\t\t{\n\t\t\t\tanIntArray1678[l] = anIntArray1665[z];\n\t\t\t\tanIntArray1679[l] = anIntArray1666[z];\n\t\t\t\tanIntArray1680[l++] = anIntArray1636[i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint i3 = anIntArray1668[z];\n\t\t\t\tint i4 = anIntArray1669[z];\n\t\t\t\tint i5 = anIntArray1636[i];\n\t\t\t\tif(movedY >= 50)\n\t\t\t\t{\n\t\t\t\t\tint k6 = (50 - movedZ) * modelIntArray4[movedY - movedZ];\n\t\t\t\t\tanIntArray1678[l] = j + (i3 + ((anIntArray1668[y] - i3) * k6 >> 16) << 9) \/ 50;\n\t\t\t\t\tanIntArray1679[l] = k + (i4 + ((anIntArray1669[y] - i4) * k6 >> 16) << 9) \/ 50;\n\t\t\t\t\tanIntArray1680[l++] = i5 + ((anIntArray1635[i] - i5) * k6 >> 16);\n\t\t\t\t}\n\t\t\t\tif(movedX >= 50)\n\t\t\t\t{\n\t\t\t\t\tint l6 = (50 - movedZ) * modelIntArray4[movedX - movedZ];\n\t\t\t\t\tanIntArray1678[l] = j + (i3 + ((anIntArray1668[x] - i3) * l6 >> 16) << 9) \/ 50;\n\t\t\t\t\tanIntArray1679[l] = k + (i4 + ((anIntArray1669[x] - i4) * l6 >> 16) << 9) \/ 50;\n\t\t\t\t\tanIntArray1680[l++] = i5 + ((anIntArray1634[i] - i5) * l6 >> 16);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint j3 = anIntArray1678[0];\n\t\t\tint j4 = anIntArray1678[1];\n\t\t\tint j5 = anIntArray1678[2];\n\t\t\tint i7 = anIntArray1679[0];\n\t\t\tint j7 = anIntArray1679[1];\n\t\t\tint k7 = anIntArray1679[2];\n\t\t\tif((j3 - j4) * (k7 - j7) - (i7 - j7) * (j5 - j4) > 0)\n\t\t\t{\n\t\t\t\tRasterizer.restrictEdges = false;\n\t\t\t\tif(l == 3)\n\t\t\t\t{\n\t\t\t\t\tif(j3 < 0 || j4 < 0 || j5 < 0 || j3 > DrawingArea.centerX || j4 > DrawingArea.centerX || j5 > DrawingArea.centerX)\n\t\t\t\t\t\tRasterizer.restrictEdges = true;\n\t\t\t\t\tint drawType;\n\t\t\t\t\tif(triangleDrawType == null)\n\t\t\t\t\t\tdrawType = 0;\n\t\t\t\t\telse\n\t\t\t\t\t\tdrawType = triangleDrawType[i] & 3;\n\t\t\t\t\tif(drawType == 0)\n\t\t\t\t\t\tRasterizer.drawShadedTriangle(i7, j7, k7, j3, j4, j5, anIntArray1680[0], anIntArray1680[1], anIntArray1680[2]);\n\t\t\t\t\telse if(drawType == 1)\n\t\t\t\t\t\t\tRasterizer.drawFlatTriangle(i7, j7, k7, j3, j4, j5, HSLtoRGB[anIntArray1634[i]]);\n\t\t\t\t\telse if(drawType == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tint j8 = triangleDrawType[i] >> 2;\n\t\t\t\t\t\tint k9 = texturedTrianglePointsX[j8];\n\t\t\t\t\t\tint k10 = texturedTrianglePointsY[j8];\n\t\t\t\t\t\tint k11 = texturedTrianglePointsZ[j8];\n\t\t\t\t\t\tRasterizer.drawTexturedTriangle(i7, j7, k7, j3, j4, j5, anIntArray1680[0], anIntArray1680[1], anIntArray1680[2], anIntArray1668[k9], anIntArray1668[k10], anIntArray1668[k11], anIntArray1669[k9], anIntArray1669[k10], anIntArray1669[k11], anIntArray1670[k9], anIntArray1670[k10], anIntArray1670[k11], triangleColours[i]);\n\t\t\t\t\t}\n\t\t\t\t\telse if(drawType == 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tint k8 = triangleDrawType[i] >> 2;\n\t\t\t\t\t\tint l9 = texturedTrianglePointsX[k8];\n\t\t\t\t\t\tint l10 = texturedTrianglePointsY[k8];\n\t\t\t\t\t\tint l11 = texturedTrianglePointsZ[k8];\n\t\t\t\t\t\tRasterizer.drawTexturedTriangle(i7, j7, k7, j3, j4, j5, anIntArray1634[i], anIntArray1634[i], anIntArray1634[i], anIntArray1668[l9], anIntArray1668[l10], anIntArray1668[l11], anIntArray1669[l9], anIntArray1669[l10], anIntArray1669[l11], anIntArray1670[l9], anIntArray1670[l10], anIntArray1670[l11], triangleColours[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(l == 4)\n\t\t\t\t{\n\t\t\t\t\tif(j3 < 0 || j4 < 0 || j5 < 0 || j3 > DrawingArea.centerX || j4 > DrawingArea.centerX || j5 > DrawingArea.centerX || anIntArray1678[3] < 0 || anIntArray1678[3] > DrawingArea.centerX)\n\t\t\t\t\t\tRasterizer.restrictEdges = true;\n\t\t\t\t\tint i8;\n\t\t\t\t\tif(triangleDrawType == null)\n\t\t\t\t\t\ti8 = 0;\n\t\t\t\t\telse\n\t\t\t\t\t\ti8 = triangleDrawType[i] & 3;\n\t\t\t\t\tif(i8 == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tRasterizer.drawShadedTriangle(i7, j7, k7, j3, j4, j5, anIntArray1680[0], anIntArray1680[1], anIntArray1680[2]);\n\t\t\t\t\t\tRasterizer.drawShadedTriangle(i7, k7, anIntArray1679[3], j3, j5, anIntArray1678[3], anIntArray1680[0], anIntArray1680[2], anIntArray1680[3]);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(i8 == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tint l8 = HSLtoRGB[anIntArray1634[i]];\n\t\t\t\t\t\tRasterizer.drawFlatTriangle(i7, j7, k7, j3, j4, j5, l8);\n\t\t\t\t\t\tRasterizer.drawFlatTriangle(i7, k7, anIntArray1679[3], j3, j5, anIntArray1678[3], l8);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(i8 == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tint i9 = triangleDrawType[i] >> 2;\n\t\t\t\t\t\tint i10 = texturedTrianglePointsX[i9];\n\t\t\t\t\t\tint i11 = texturedTrianglePointsY[i9];\n\t\t\t\t\t\tint i12 = texturedTrianglePointsZ[i9];\n\t\t\t\t\t\tRasterizer.drawTexturedTriangle(i7, j7, k7, j3, j4, j5, anIntArray1680[0], anIntArray1680[1], anIntArray1680[2], anIntArray1668[i10], anIntArray1668[i11], anIntArray1668[i12], anIntArray1669[i10], anIntArray1669[i11], anIntArray1669[i12], anIntArray1670[i10], anIntArray1670[i11], anIntArray1670[i12], triangleColours[i]);\n\t\t\t\t\t\tRasterizer.drawTexturedTriangle(i7, k7, anIntArray1679[3], j3, j5, anIntArray1678[3], anIntArray1680[0], anIntArray1680[2], anIntArray1680[3], anIntArray1668[i10], anIntArray1668[i11], anIntArray1668[i12], anIntArray1669[i10], anIntArray1669[i11], anIntArray1669[i12], anIntArray1670[i10], anIntArray1670[i11], anIntArray1670[i12], triangleColours[i]);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif(i8 == 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tint j9 = triangleDrawType[i] >> 2;\n\t\t\t\t\t\tint j10 = texturedTrianglePointsX[j9];\n\t\t\t\t\t\tint j11 = texturedTrianglePointsY[j9];\n\t\t\t\t\t\tint j12 = texturedTrianglePointsZ[j9];\n\t\t\t\t\t\tRasterizer.drawTexturedTriangle(i7, j7, k7, j3, j4, j5, anIntArray1634[i], anIntArray1634[i], anIntArray1634[i], anIntArray1668[j10], anIntArray1668[j11], anIntArray1668[j12], anIntArray1669[j10], anIntArray1669[j11], anIntArray1669[j12], anIntArray1670[j10], anIntArray1670[j11], anIntArray1670[j12], triangleColours[i]);\n\t\t\t\t\t\tRasterizer.drawTexturedTriangle(i7, k7, anIntArray1679[3], j3, j5, anIntArray1678[3], anIntArray1634[i], anIntArray1634[i], anIntArray1634[i], anIntArray1668[j10], anIntArray1668[j11], anIntArray1668[j12], anIntArray1669[j10], anIntArray1669[j11], anIntArray1669[j12], anIntArray1670[j10], anIntArray1670[j11], anIntArray1670[j12], triangleColours[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate bool method486(int i, int j, int k, int l, int i1, int j1, int k1,\n\t\t\t\tint l1)\n\t\t{\n\t\t\tif(j < k && j < l && j < i1)\n\t\t\t\treturn false;\n\t\t\tif(j > k && j > l && j > i1)\n\t\t\t\treturn false;\n\t\t\treturn !(i < j1 && i < k1 && i < l1) && (i <= j1 || i <= k1 || i <= l1);\n\t\t}\n\n\t\tpublic static Model aModel_1621 = new Model();\n\t\tprivate static int[] anIntArray1622 = new int[2000];\n\t\tprivate static int[] anIntArray1623 = new int[2000];\n\t\tprivate static int[] anIntArray1624 = new int[2000];\n\t\tprivate static int[] anIntArray1625 = new int[2000];\n\t\tpublic int vertexCount;\n\t\tpublic int[] verticesX;\n\t\tpublic int[] verticesY;\n\t\tpublic int[] verticesZ;\n\t\tpublic int triangleCount;\n\t\tpublic int[] triangleX;\n\t\tpublic int[] triangleY;\n\t\tpublic int[] triangleZ;\n\t\tprivate int[] anIntArray1634;\n\t\tprivate int[] anIntArray1635;\n\t\tprivate int[] anIntArray1636;\n\t\tpublic int[] triangleDrawType;\n\t\tprivate int[] trianglePriorities;\n\t\tprivate int[] triangleAlpha;\n\t\tpublic int[] triangleColours;\n\t\tprivate int trianglePriority;\n\t\tprivate int texturedTriangleCount;\n\t\tprivate int[] texturedTrianglePointsX;\n\t\tprivate int[] texturedTrianglePointsY;\n\t\tprivate int[] texturedTrianglePointsZ;\n\t\tpublic int minX;\n\t\tpublic int maxX;\n\t\tpublic int maxZ;\n\t\tpublic int minZ;\n\t\tpublic int diagonal2DAboveOrigin;\n\t\tpublic int maxY;\n\t\tprivate int anInt1652;\n\t\tprivate int anInt1653;\n\t\tpublic int anInt1654;\n\t\tprivate int[] vertexSkins;\n\t\tprivate int[] triangleSkins;\n\t\tpublic int[][] vertexSkin;\n\t\tpublic int[][] triangleSkin;\n\t\tpublic bool singleTile;\n\t\tpublic VertexNormal[] vertexNormalOffset;\n\t\tprivate static ModelHeader[] modelHeaders;\n\t\tprivate static OnDemandFetcher aOnDemandFetcherParent_1662;\n\t\tprivate static bool[] aBooleanArray1663 = new bool[4096];\n\t\tprivate static bool[] aBooleanArray1664 = new bool[4096];\n\t\tprivate static int[] anIntArray1665 = new int[4096];\n\t\tprivate static int[] anIntArray1666 = new int[4096];\n\t\tprivate static int[] anIntArray1667 = new int[4096];\n\t\tprivate static int[] anIntArray1668 = new int[4096];\n\t\tprivate static int[] anIntArray1669 = new int[4096];\n\t\tprivate static int[] anIntArray1670 = new int[4096];\n\t\tprivate static int[] anIntArray1671 = new int[1500];\n\t\tprivate static int[][] anIntArrayArray1672 = new int[1500][];\n\t\tprivate static int[] anIntArray1673 = new int[12];\n\t\tprivate static int[][] anIntArrayArray1674 = new int[12][];\n\t\tprivate static int[] anIntArray1675 = new int[2000];\n\t\tprivate static int[] anIntArray1676 = new int[2000];\n\t\tprivate static int[] anIntArray1677 = new int[12];\n\t\tprivate static int[] anIntArray1678 = new int[10];\n\t\tprivate static int[] anIntArray1679 = new int[10];\n\t\tprivate static int[] anIntArray1680 = new int[10];\n\t\tprivate static int vertexModifierX;\n\t\tprivate static int vertexModifierY;\n\t\tprivate static int vertexModifierZ;\n\t\tpublic static bool abool1684;\n\t\tpublic static int cursorX;\n\t\tpublic static int cursorY;\n\t\tpublic static int resourceCount;\n\t\tpublic static int[] resourceId = new int[1000];\n\t\tpublic static int[] SINE;\n\t\tpublic static int[] COSINE;\n\t\tprivate static int[] HSLtoRGB;\n\t\tprivate static int[] modelIntArray4;\n\n\t\tstatic Model()\n\t\t{\n\t\t\tSINE = Rasterizer.SINE;\n\t\t\tCOSINE = Rasterizer.COSINE;\n\t\t\tHSLtoRGB = Rasterizer.HSL_TO_RGB;\n\t\t\tmodelIntArray4 = Rasterizer.anIntArray1469;\n\n\t\t\tfor(int i = 0; i < 1500; i++)\n\t\t\t\tanIntArrayArray1672[i] = new int[512];\n\t\t\tfor(int i = 0; i < 12; i++)\n\t\t\t\tanIntArrayArray1674[i] = new int[2000];\n\t\t}\n\t}\n}","old_contents":"using System;\n\nnamespace Rs317.Sharp\n{\n\tpublic sealed class Model : Animable\n\t{\n\t\tpublic static Model getModel(int model)\n\t\t{\n\t\t\tif(modelHeaders == null)\n\t\t\t\treturn null;\n\t\t\tModelHeader modelHeader = modelHeaders[model];\n\t\t\tif(modelHeader == null)\n\t\t\t{\n\t\t\t\trequester.request(model);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn new Model(model);\n\t\t\t}\n\t\t}\n\n\t\tpublic static void init(int modelCount, OnDemandFetcher requester)\n\t\t{\n\t\t\tmodelHeaders = new ModelHeader[modelCount];\n\t\t\tModel.requester = requester;\n\t\t}\n\n\t\tpublic static bool isCached(int model)\n\t\t{\n\t\t\tif(model >= modelHeaders.Length)\n\t\t\t{\n\t\t\t\tstring error = $\"Cannot check cache for {model} as it exceeds the metadata container's length.\";\n\t\t\t\tsignlink.reporterror(error);\n\t\t\t\tthrow new ArgumentException($\"Cannot check cache for {model} as it exceeds the metadata container's length.\");\n\t\t\t}\n\n\t\t\tif(modelHeaders == null)\n\t\t\t\treturn false;\n\t\t\tModelHeader modelHeader = modelHeaders[model];\n\t\t\tif(modelHeader == null)\n\t\t\t{\n\t\t\t\trequester.request(model);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tpublic static void loadModelHeader(byte[] modelData, int modelId)\n\t\t{\n\t\t\tif(modelData == null)\n\t\t\t{\n\t\t\t\tModelHeader modelHeader = modelHeaders[modelId] = new ModelHeader();\n\t\t\t\tmodelHeader.vertexCount = 0;\n\t\t\t\tmodelHeader.triangleCount = 0;\n\t\t\t\tmodelHeader.texturedTriangleCount = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tDefault317Buffer stream = new Default317Buffer(modelData);\n\t\t\t\tstream.position = modelData.Length - 18;\n\t\t\t\tModelHeader modelHeader = modelHeaders[modelId] = new ModelHeader();\n\t\t\t\tmodelHeader.modelData = modelData;\n\t\t\t\tmodelHeader.vertexCount = stream.getUnsignedLEShort();\n\t\t\t\tmodelHeader.triangleCount = stream.getUnsignedLEShort();\n\t\t\t\tmodelHeader.texturedTriangleCount = stream.getUnsignedByte();\n\t\t\t\tint useTextures = stream.getUnsignedByte();\n\t\t\t\tint useTrianglePriority = stream.getUnsignedByte();\n\t\t\t\tint useAlpha = stream.getUnsignedByte();\n\t\t\t\tint useTriangleSkins = stream.getUnsignedByte();\n\t\t\t\tint useVertexSkins = stream.getUnsignedByte();\n\t\t\t\tint dataLengthX = stream.getUnsignedLEShort();\n\t\t\t\tint dataLengthY = stream.getUnsignedLEShort();\n\t\t\t\tint dataLengthZ = stream.getUnsignedLEShort();\n\t\t\t\tint dataLengthTriangle = stream.getUnsignedLEShort();\n\t\t\t\tint offset = 0;\n\t\t\t\tmodelHeader.vertexDirectionOffset = offset;\n\t\t\t\toffset += modelHeader.vertexCount;\n\t\t\t\tmodelHeader.triangleTypeOffset = offset;\n\t\t\t\toffset += modelHeader.triangleCount;\n\t\t\t\tmodelHeader.trianglePriorityOffset = offset;\n\t\t\t\tif(useTrianglePriority == 255)\n\t\t\t\t\toffset += modelHeader.triangleCount;\n\t\t\t\telse\n\t\t\t\t\tmodelHeader.trianglePriorityOffset = -useTrianglePriority - 1;\n\t\t\t\tmodelHeader.triangleSkinOffset = offset;\n\t\t\t\tif(useTriangleSkins == 1)\n\t\t\t\t\toffset += modelHeader.triangleCount;\n\t\t\t\telse\n\t\t\t\t\tmodelHeader.triangleSkinOffset = -1;\n\t\t\t\tmodelHeader.texturePointerOffset = offset;\n\t\t\t\tif(useTextures == 1)\n\t\t\t\t\toffset += modelHeader.triangleCount;\n\t\t\t\telse\n\t\t\t\t\tmodelHeader.texturePointerOffset = -1;\n\t\t\t\tmodelHeader.vertexSkinOffset = offset;\n\t\t\t\tif(useVertexSkins == 1)\n\t\t\t\t\toffset += modelHeader.vertexCount;\n\t\t\t\telse\n\t\t\t\t\tmodelHeader.vertexSkinOffset = -1;\n\t\t\t\tmodelHeader.triangleAlphaOffset = offset;\n\t\t\t\tif(useAlpha == 1)\n\t\t\t\t\toffset += modelHeader.triangleCount;\n\t\t\t\telse\n\t\t\t\t\tmodelHeader.triangleAlphaOffset = -1;\n\t\t\t\tmodelHeader.triangleDataOffset = offset;\n\t\t\t\toffset += dataLengthTriangle;\n\t\t\t\tmodelHeader.colourDataOffset = offset;\n\t\t\t\toffset += modelHeader.triangleCount * 2;\n\t\t\t\tmodelHeader.texturedTriangleOffset = offset;\n\t\t\t\toffset += modelHeader.texturedTriangleCount * 6;\n\t\t\t\tmodelHeader.dataOffsetX = offset;\n\t\t\t\toffset += dataLengthX;\n\t\t\t\tmodelHeader.dataOffsetY = offset;\n\t\t\t\toffset += dataLengthY;\n\t\t\t\tmodelHeader.dataOffsetZ = offset;\n\t\t\t\toffset += dataLengthZ;\n\t\t\t}\n\t\t}\n\n\t\tprivate static int mixLightness(int colour, int lightness, int drawType)\n\t\t{\n\t\t\tif((drawType & 2) == 2)\n\t\t\t{\n\t\t\t\tif(lightness < 0)\n\t\t\t\t\tlightness = 0;\n\t\t\t\telse if(lightness > 127)\n\t\t\t\t\tlightness = 127;\n\t\t\t\tlightness = 127 - lightness;\n\t\t\t\treturn lightness;\n\t\t\t}\n\n\t\t\tlightness = lightness * (colour & 0x7f) >> 7;\n\t\t\tif(lightness < 2)\n\t\t\t\tlightness = 2;\n\t\t\telse if(lightness > 126)\n\t\t\t\tlightness = 126;\n\t\t\treturn (colour & 0xff80) + lightness;\n\t\t}\n\n\t\tpublic static void nullLoader()\n\t\t{\n\t\t\tmodelHeaders = null;\n\t\t\trestrictEdges = null;\n\t\t\taboolArray1664 = null;\n\t\t\tvertexScreenX = null;\n\t\t\tvertexScreenY = null;\n\t\t\tvertexScreenZ = null;\n\t\t\tvertexMovedX = null;\n\t\t\tvertexMovedY = null;\n\t\t\tvertexMovedZ = null;\n\t\t\tanIntArray1671 = null;\n\t\t\tanIntArrayArray1672 = null;\n\t\t\tanIntArray1673 = null;\n\t\t\tanIntArrayArray1674 = null;\n\t\t\tanIntArray1675 = null;\n\t\t\tanIntArray1676 = null;\n\t\t\tanIntArray1677 = null;\n\t\t\tSINE = null;\n\t\t\tCOSINE = null;\n\t\t\tHSLtoRGB = null;\n\t\t\tmodelIntArray4 = null;\n\t\t}\n\n\t\tpublic static void resetModel(int model)\n\t\t{\n\t\t\tmodelHeaders[model] = null;\n\t\t}\n\n\t\tpublic static Model aModel_1621 = new Model();\n\n\t\tprivate static int[] anIntArray1622 = new int[2000];\n\n\t\tprivate static int[] anIntArray1623 = new int[2000];\n\n\t\tprivate static int[] anIntArray1624 = new int[2000];\n\n\t\tprivate static int[] anIntArray1625 = new int[2000];\n\n\t\tpublic int vertexCount;\n\n\t\tpublic int[] verticesX;\n\n\t\tpublic int[] verticesY;\n\n\t\tpublic int[] verticesZ;\n\n\t\tpublic int triangleCount;\n\n\t\tpublic int[] triangleX;\n\n\t\tpublic int[] triangleY;\n\n\t\tpublic int[] triangleZ;\n\n\t\tprivate int[] triangleHSLA;\n\n\t\tprivate int[] triangleHSLB;\n\n\t\tprivate int[] triangleHSLC;\n\n\t\tpublic int[] triangleDrawType;\n\n\t\tprivate int[] trianglePriorities;\n\n\t\tprivate int[] triangleAlpha;\n\n\t\tpublic int[] triangleColours;\n\n\t\tprivate int trianglePriority;\n\n\t\tprivate int texturedTriangleCount;\n\n\t\tprivate int[] texturedTrianglePointsX;\n\n\t\tprivate int[] texturedTrianglePointsY;\n\n\t\tprivate int[] texturedTrianglePointsZ;\n\n\t\tpublic int maxY;\n\n\t\tpublic int maxX;\n\n\t\tpublic int maxZ;\n\n\t\tpublic int minZ;\n\n\t\tpublic int diagonal2DAboveOrigin;\n\t\tpublic int minX;\n\t\tprivate int diagonal3D;\n\t\tprivate int diagonal3DAboveOrigin;\n\t\tpublic int anInt1654;\n\t\tprivate int[] vertexSkins;\n\t\tprivate int[] triangleSkins;\n\t\tpublic int[][] vertexSkin;\n\t\tpublic int[][] triangleSkin;\n\t\tpublic bool singleTile;\n\t\tpublic VertexNormal[] vertexNormalOffset;\n\t\tprivate static ModelHeader[] modelHeaders;\n\t\tprivate static OnDemandFetcher requester;\n\t\tprivate static bool[] restrictEdges = new bool[4096];\n\t\tprivate static bool[] aboolArray1664 = new bool[4096];\n\t\tprivate static int[] vertexScreenX = new int[4096];\n\t\tprivate static int[] vertexScreenY = new int[4096];\n\t\tprivate static int[] vertexScreenZ = new int[4096];\n\t\tprivate static int[] vertexMovedX = new int[4096];\n\t\tprivate static int[] vertexMovedY = new int[4096];\n\t\tprivate static int[] vertexMovedZ = new int[4096];\n\t\tprivate static int[] anIntArray1671 = new int[1500];\n\t\tprivate static int[,] anIntArrayArray1672 = new int[1500, 512];\n\t\tprivate static int[] anIntArray1673 = new int[12];\n\t\tprivate static int[,] anIntArrayArray1674 = new int[12, 2000];\n\t\tprivate static int[] anIntArray1675 = new int[2000];\n\t\tprivate static int[] anIntArray1676 = new int[2000];\n\t\tprivate static int[] anIntArray1677 = new int[12];\n\t\tprivate static int[] xPosition = new int[10];\n\t\tprivate static int[] yPosition = new int[10];\n\t\tprivate static int[] zPosition = new int[10];\n\t\tprivate static int vertexModifierX;\n\t\tprivate static int vertexModifierY;\n\t\tprivate static int vertexModifierZ;\n\t\tpublic static bool abool1684;\n\t\tpublic static int cursorX;\n\t\tpublic static int cursorY;\n\t\tpublic static int resourceCount;\n\t\tpublic static int[] resourceId = new int[1000];\n\t\tpublic static int[] SINE;\n\t\tpublic static int[] COSINE;\n\t\tprivate static int[] HSLtoRGB;\n\t\tprivate static int[] modelIntArray4;\n\n\t\tstatic Model()\n\t\t{\n\t\t\tSINE = Rasterizer.SINE;\n\t\t\tCOSINE = Rasterizer.COSINE;\n\t\t\tHSLtoRGB = Rasterizer.HSL_TO_RGB;\n\t\t\tmodelIntArray4 = Rasterizer.anIntArray1469;\n\t\t}\n\n\t\tprivate Model()\n\t\t{\n\t\t\tsingleTile = false;\n\t\t}\n\n\t\tpublic Model(bool flag, bool flag1, bool flag2, Model model)\n\t\t{\n\t\t\tsingleTile = false;\n\t\t\tvertexCount = model.vertexCount;\n\t\t\ttriangleCount = model.triangleCount;\n\t\t\ttexturedTriangleCount = model.texturedTriangleCount;\n\t\t\tif(flag2)\n\t\t\t{\n\t\t\t\tverticesX = model.verticesX;\n\t\t\t\tverticesY = model.verticesY;\n\t\t\t\tverticesZ = model.verticesZ;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tverticesX = new int[vertexCount];\n\t\t\t\tverticesY = new int[vertexCount];\n\t\t\t\tverticesZ = new int[vertexCount];\n\t\t\t\tfor(int vertex = 0; vertex < vertexCount; vertex++)\n\t\t\t\t{\n\t\t\t\t\tverticesX[vertex] = model.verticesX[vertex];\n\t\t\t\t\tverticesY[vertex] = model.verticesY[vertex];\n\t\t\t\t\tverticesZ[vertex] = model.verticesZ[vertex];\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif(flag)\n\t\t\t{\n\t\t\t\ttriangleColours = model.triangleColours;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttriangleColours = new int[triangleCount];\n\t\t\t\tSystem.Buffer.BlockCopy(model.triangleColours, 0, triangleColours, 0, sizeof(int) * triangleCount);\n\t\t\t}\n\n\t\t\tif(flag1)\n\t\t\t{\n\t\t\t\ttriangleAlpha = model.triangleAlpha;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttriangleAlpha = new int[triangleCount];\n\t\t\t\tif(model.triangleAlpha == null)\n\t\t\t\t{\n\t\t\t\t\tfor(int triangle = 0; triangle < triangleCount; triangle++)\n\t\t\t\t\t\ttriangleAlpha[triangle] = 0;\n\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.Buffer.BlockCopy(model.triangleAlpha, 0, triangleAlpha, 0, sizeof(int) * triangleCount);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvertexSkins = model.vertexSkins;\n\t\t\ttriangleSkins = model.triangleSkins;\n\t\t\ttriangleDrawType = model.triangleDrawType;\n\t\t\ttriangleX = model.triangleX;\n\t\t\ttriangleY = model.triangleY;\n\t\t\ttriangleZ = model.triangleZ;\n\t\t\ttrianglePriorities = model.trianglePriorities;\n\t\t\ttrianglePriority = model.trianglePriority;\n\t\t\ttexturedTrianglePointsX = model.texturedTrianglePointsX;\n\t\t\ttexturedTrianglePointsY = model.texturedTrianglePointsY;\n\t\t\ttexturedTrianglePointsZ = model.texturedTrianglePointsZ;\n\t\t}\n\n\t\tpublic Model(bool flag, bool flag1, Model model)\n\t\t{\n\t\t\tsingleTile = false;\n\t\t\tvertexCount = model.vertexCount;\n\t\t\ttriangleCount = model.triangleCount;\n\t\t\ttexturedTriangleCount = model.texturedTriangleCount;\n\t\t\tif(flag)\n\t\t\t{\n\t\t\t\tverticesY = new int[vertexCount];\n\t\t\t\tSystem.Buffer.BlockCopy(model.verticesY, 0, verticesY, 0, sizeof(int) * vertexCount);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tverticesY = model.verticesY;\n\t\t\t}\n\n\t\t\tif(flag1)\n\t\t\t{\n\t\t\t\ttriangleHSLA = new int[triangleCount];\n\t\t\t\ttriangleHSLB = new int[triangleCount];\n\t\t\t\ttriangleHSLC = new int[triangleCount];\n\t\t\t\tfor(int triangle = 0; triangle < triangleCount; triangle++)\n\t\t\t\t{\n\t\t\t\t\ttriangleHSLA[triangle] = model.triangleHSLA[triangle];\n\t\t\t\t\ttriangleHSLB[triangle] = model.triangleHSLB[triangle];\n\t\t\t\t\ttriangleHSLC[triangle] = model.triangleHSLC[triangle];\n\t\t\t\t}\n\n\t\t\t\ttriangleDrawType = new int[triangleCount];\n\t\t\t\tif(model.triangleDrawType == null)\n\t\t\t\t{\n\t\t\t\t\tfor(int triangle = 0; triangle < triangleCount; triangle++)\n\t\t\t\t\t\ttriangleDrawType[triangle] = 0;\n\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.Buffer.BlockCopy(model.triangleDrawType, 0, triangleDrawType, 0, sizeof(int) * triangleCount);\n\t\t\t\t}\n\n\t\t\t\tbase.vertexNormals = new VertexNormal[vertexCount];\n\t\t\t\tfor(int vertex = 0; vertex < vertexCount; vertex++)\n\t\t\t\t{\n\t\t\t\t\tVertexNormal vertexNormalNew = base.vertexNormals[vertex] = new VertexNormal();\n\t\t\t\t\tVertexNormal vertexNormalOld = model.vertexNormals[vertex];\n\t\t\t\t\tvertexNormalNew.x = vertexNormalOld.x;\n\t\t\t\t\tvertexNormalNew.y = vertexNormalOld.y;\n\t\t\t\t\tvertexNormalNew.z = vertexNormalOld.z;\n\t\t\t\t\tvertexNormalNew.magnitude = vertexNormalOld.magnitude;\n\t\t\t\t}\n\n\t\t\t\tvertexNormalOffset = model.vertexNormalOffset;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttriangleHSLA = model.triangleHSLA;\n\t\t\t\ttriangleHSLB = model.triangleHSLB;\n\t\t\t\ttriangleHSLC = model.triangleHSLC;\n\t\t\t\ttriangleDrawType = model.triangleDrawType;\n\t\t\t}\n\n\t\t\tverticesX = model.verticesX;\n\t\t\tverticesZ = model.verticesZ;\n\t\t\ttriangleColours = model.triangleColours;\n\t\t\ttriangleAlpha = model.triangleAlpha;\n\t\t\ttrianglePriorities = model.trianglePriorities;\n\t\t\ttrianglePriority = model.trianglePriority;\n\t\t\ttriangleX = model.triangleX;\n\t\t\ttriangleY = model.triangleY;\n\t\t\ttriangleZ = model.triangleZ;\n\t\t\ttexturedTrianglePointsX = model.texturedTrianglePointsX;\n\t\t\ttexturedTrianglePointsY = model.texturedTrianglePointsY;\n\t\t\ttexturedTrianglePointsZ = model.texturedTrianglePointsZ;\n\t\t\tbase.modelHeight = model.modelHeight;\n\t\t\tmaxY = model.maxY;\n\t\t\tdiagonal2DAboveOrigin = model.diagonal2DAboveOrigin;\n\t\t\tdiagonal3DAboveOrigin = model.diagonal3DAboveOrigin;\n\t\t\tdiagonal3D = model.diagonal3D;\n\t\t\tminX = model.minX;\n\t\t\tmaxZ = model.maxZ;\n\t\t\tminZ = model.minZ;\n\t\t\tmaxX = model.maxX;\n\t\t}\n\n\t\tprivate Model(int model)\n\t\t{\n\t\t\tsingleTile = false;\n\t\t\tModelHeader modelHeader = modelHeaders[model];\n\t\t\tvertexCount = modelHeader.vertexCount;\n\t\t\ttriangleCount = modelHeader.triangleCount;\n\t\t\ttexturedTriangleCount = modelHeader.texturedTriangleCount;\n\t\t\tverticesX = new int[vertexCount];\n\t\t\tverticesY = new int[vertexCount];\n\t\t\tverticesZ = new int[vertexCount];\n\t\t\ttriangleX = new int[triangleCount];\n\t\t\ttriangleY = new int[triangleCount];\n\t\t\ttriangleZ = new int[triangleCount];\n\t\t\ttexturedTrianglePointsX = new int[texturedTriangleCount];\n\t\t\ttexturedTrianglePointsY = new int[texturedTriangleCount];\n\t\t\ttexturedTrianglePointsZ = new int[texturedTriangleCount];\n\t\t\tif(modelHeader.vertexSkinOffset >= 0)\n\t\t\t\tvertexSkins = new int[vertexCount];\n\t\t\tif(modelHeader.texturePointerOffset >= 0)\n\t\t\t\ttriangleDrawType = new int[triangleCount];\n\t\t\tif(modelHeader.trianglePriorityOffset >= 0)\n\t\t\t\ttrianglePriorities = new int[triangleCount];\n\t\t\telse\n\t\t\t\ttrianglePriority = -modelHeader.trianglePriorityOffset - 1;\n\t\t\tif(modelHeader.triangleAlphaOffset >= 0)\n\t\t\t\ttriangleAlpha = new int[triangleCount];\n\t\t\tif(modelHeader.triangleSkinOffset >= 0)\n\t\t\t\ttriangleSkins = new int[triangleCount];\n\t\t\ttriangleColours = new int[triangleCount];\n\t\t\tDefault317Buffer vertexDirectionOffsetStream = new Default317Buffer(modelHeader.modelData);\n\t\t\tvertexDirectionOffsetStream.position = modelHeader.vertexDirectionOffset;\n\t\t\tDefault317Buffer xDataOffsetStream = new Default317Buffer(modelHeader.modelData);\n\t\t\txDataOffsetStream.position = modelHeader.dataOffsetX;\n\t\t\tDefault317Buffer yDataOffsetStream = new Default317Buffer(modelHeader.modelData);\n\t\t\tyDataOffsetStream.position = modelHeader.dataOffsetY;\n\t\t\tDefault317Buffer zDataOffsetStream = new Default317Buffer(modelHeader.modelData);\n\t\t\tzDataOffsetStream.position = modelHeader.dataOffsetZ;\n\t\t\tDefault317Buffer vertexSkinOffsetStream = new Default317Buffer(modelHeader.modelData);\n\t\t\tvertexSkinOffsetStream.position = modelHeader.vertexSkinOffset;\n\t\t\tint baseOffsetX = 0;\n\t\t\tint baseOffsetY = 0;\n\t\t\tint baseOffsetZ = 0;\n\t\t\tfor(int vertex = 0; vertex < vertexCount; vertex++)\n\t\t\t{\n\t\t\t\tint flag = vertexDirectionOffsetStream.getUnsignedByte();\n\t\t\t\tint currentOffsetX = 0;\n\t\t\t\tif((flag & 1) != 0)\n\t\t\t\t\tcurrentOffsetX = xDataOffsetStream.getSmartA();\n\t\t\t\tint currentOffsetY = 0;\n\t\t\t\tif((flag & 2) != 0)\n\t\t\t\t\tcurrentOffsetY = yDataOffsetStream.getSmartA();\n\t\t\t\tint currentOffsetZ = 0;\n\t\t\t\tif((flag & 4) != 0)\n\t\t\t\t\tcurrentOffsetZ = zDataOffsetStream.getSmartA();\n\t\t\t\tverticesX[vertex] = baseOffsetX + currentOffsetX;\n\t\t\t\tverticesY[vertex] = baseOffsetY + currentOffsetY;\n\t\t\t\tverticesZ[vertex] = baseOffsetZ + currentOffsetZ;\n\t\t\t\tbaseOffsetX = verticesX[vertex];\n\t\t\t\tbaseOffsetY = verticesY[vertex];\n\t\t\t\tbaseOffsetZ = verticesZ[vertex];\n\t\t\t\tif(vertexSkins != null)\n\t\t\t\t\tvertexSkins[vertex] = vertexSkinOffsetStream.getUnsignedByte();\n\t\t\t}\n\n\t\t\tvertexDirectionOffsetStream.position = modelHeader.colourDataOffset;\n\t\t\txDataOffsetStream.position = modelHeader.texturePointerOffset;\n\t\t\tyDataOffsetStream.position = modelHeader.trianglePriorityOffset;\n\t\t\tzDataOffsetStream.position = modelHeader.triangleAlphaOffset;\n\t\t\tvertexSkinOffsetStream.position = modelHeader.triangleSkinOffset;\n\t\t\tfor(int triangle = 0; triangle < triangleCount; triangle++)\n\t\t\t{\n\t\t\t\ttriangleColours[triangle] = vertexDirectionOffsetStream.getUnsignedLEShort();\n\t\t\t\tif(triangleDrawType != null)\n\t\t\t\t\ttriangleDrawType[triangle] = xDataOffsetStream.getUnsignedByte();\n\t\t\t\tif(trianglePriorities != null)\n\t\t\t\t\ttrianglePriorities[triangle] = yDataOffsetStream.getUnsignedByte();\n\t\t\t\tif(triangleAlpha != null)\n\t\t\t\t\ttriangleAlpha[triangle] = zDataOffsetStream.getUnsignedByte();\n\t\t\t\tif(triangleSkins != null)\n\t\t\t\t\ttriangleSkins[triangle] = vertexSkinOffsetStream.getUnsignedByte();\n\t\t\t}\n\n\t\t\tvertexDirectionOffsetStream.position = modelHeader.triangleDataOffset;\n\t\t\txDataOffsetStream.position = modelHeader.triangleTypeOffset;\n\t\t\tint trianglePointOffsetX = 0;\n\t\t\tint trianglePointOffsetY = 0;\n\t\t\tint trianglePointOffsetZ = 0;\n\t\t\tint offset = 0;\n\t\t\tfor(int triangle = 0; triangle < triangleCount; triangle++)\n\t\t\t{\n\t\t\t\tint type = xDataOffsetStream.getUnsignedByte();\n\t\t\t\tif(type == 1)\n\t\t\t\t{\n\t\t\t\t\ttrianglePointOffsetX = vertexDirectionOffsetStream.getSmartA() + offset;\n\t\t\t\t\toffset = trianglePointOffsetX;\n\t\t\t\t\ttrianglePointOffsetY = vertexDirectionOffsetStream.getSmartA() + offset;\n\t\t\t\t\toffset = trianglePointOffsetY;\n\t\t\t\t\ttrianglePointOffsetZ = vertexDirectionOffsetStream.getSmartA() + offset;\n\t\t\t\t\toffset = trianglePointOffsetZ;\n\t\t\t\t\ttriangleX[triangle] = trianglePointOffsetX;\n\t\t\t\t\ttriangleY[triangle] = trianglePointOffsetY;\n\t\t\t\t\ttriangleZ[triangle] = trianglePointOffsetZ;\n\t\t\t\t}\n\n\t\t\t\tif(type == 2)\n\t\t\t\t{\n\t\t\t\t\ttrianglePointOffsetY = trianglePointOffsetZ;\n\t\t\t\t\ttrianglePointOffsetZ = vertexDirectionOffsetStream.getSmartA() + offset;\n\t\t\t\t\toffset = trianglePointOffsetZ;\n\t\t\t\t\ttriangleX[triangle] = trianglePointOffsetX;\n\t\t\t\t\ttriangleY[triangle] = trianglePointOffsetY;\n\t\t\t\t\ttriangleZ[triangle] = trianglePointOffsetZ;\n\t\t\t\t}\n\n\t\t\t\tif(type == 3)\n\t\t\t\t{\n\t\t\t\t\ttrianglePointOffsetX = trianglePointOffsetZ;\n\t\t\t\t\ttrianglePointOffsetZ = vertexDirectionOffsetStream.getSmartA() + offset;\n\t\t\t\t\toffset = trianglePointOffsetZ;\n\t\t\t\t\ttriangleX[triangle] = trianglePointOffsetX;\n\t\t\t\t\ttriangleY[triangle] = trianglePointOffsetY;\n\t\t\t\t\ttriangleZ[triangle] = trianglePointOffsetZ;\n\t\t\t\t}\n\n\t\t\t\tif(type == 4)\n\t\t\t\t{\n\t\t\t\t\tint oldTrianglePointOffsetX = trianglePointOffsetX;\n\t\t\t\t\ttrianglePointOffsetX = trianglePointOffsetY;\n\t\t\t\t\ttrianglePointOffsetY = oldTrianglePointOffsetX;\n\t\t\t\t\ttrianglePointOffsetZ = vertexDirectionOffsetStream.getSmartA() + offset;\n\t\t\t\t\toffset = trianglePointOffsetZ;\n\t\t\t\t\ttriangleX[triangle] = trianglePointOffsetX;\n\t\t\t\t\ttriangleY[triangle] = trianglePointOffsetY;\n\t\t\t\t\ttriangleZ[triangle] = trianglePointOffsetZ;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvertexDirectionOffsetStream.position = modelHeader.texturedTriangleOffset;\n\t\t\tfor(int triangle = 0; triangle < texturedTriangleCount; triangle++)\n\t\t\t{\n\t\t\t\ttexturedTrianglePointsX[triangle] = vertexDirectionOffsetStream.getUnsignedLEShort();\n\t\t\t\ttexturedTrianglePointsY[triangle] = vertexDirectionOffsetStream.getUnsignedLEShort();\n\t\t\t\ttexturedTrianglePointsZ[triangle] = vertexDirectionOffsetStream.getUnsignedLEShort();\n\t\t\t}\n\n\t\t}\n\n\t\tpublic Model(int modelCount, Model[] models)\n\t\t{\n\t\t\tsingleTile = false;\n\t\t\tbool setDrawType = false;\n\t\t\tbool setPriority = false;\n\t\t\tbool setAlpha = false;\n\t\t\tbool setSkins = false;\n\t\t\tvertexCount = 0;\n\t\t\ttriangleCount = 0;\n\t\t\ttexturedTriangleCount = 0;\n\t\t\ttrianglePriority = -1;\n\t\t\tfor(int m = 0; m < modelCount; m++)\n\t\t\t{\n\t\t\t\tModel model = models[m];\n\t\t\t\tif(model != null)\n\t\t\t\t{\n\t\t\t\t\tvertexCount += model.vertexCount;\n\t\t\t\t\ttriangleCount += model.triangleCount;\n\t\t\t\t\ttexturedTriangleCount += model.texturedTriangleCount;\n\t\t\t\t\tsetDrawType |= model.triangleDrawType != null;\n\t\t\t\t\tif(model.trianglePriorities != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tsetPriority = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(trianglePriority == -1)\n\t\t\t\t\t\t\ttrianglePriority = model.trianglePriority;\n\t\t\t\t\t\tif(trianglePriority != model.trianglePriority)\n\t\t\t\t\t\t\tsetPriority = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tsetAlpha |= model.triangleAlpha != null;\n\t\t\t\t\tsetSkins |= model.triangleSkins != null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tverticesX = new int[vertexCount];\n\t\t\tverticesY = new int[vertexCount];\n\t\t\tverticesZ = new int[vertexCount];\n\t\t\tvertexSkins = new int[vertexCount];\n\t\t\ttriangleX = new int[triangleCount];\n\t\t\ttriangleY = new int[triangleCount];\n\t\t\ttriangleZ = new int[triangleCount];\n\t\t\ttexturedTrianglePointsX = new int[texturedTriangleCount];\n\t\t\ttexturedTrianglePointsY = new int[texturedTriangleCount];\n\t\t\ttexturedTrianglePointsZ = new int[texturedTriangleCount];\n\t\t\tif(setDrawType)\n\t\t\t\ttriangleDrawType = new int[triangleCount];\n\t\t\tif(setPriority)\n\t\t\t\ttrianglePriorities = new int[triangleCount];\n\t\t\tif(setAlpha)\n\t\t\t\ttriangleAlpha = new int[triangleCount];\n\t\t\tif(setSkins)\n\t\t\t\ttriangleSkins = new int[triangleCount];\n\t\t\ttriangleColours = new int[triangleCount];\n\t\t\tvertexCount = 0;\n\t\t\ttriangleCount = 0;\n\t\t\ttexturedTriangleCount = 0;\n\t\t\tint count = 0;\n\t\t\tfor(int m = 0; m < modelCount; m++)\n\t\t\t{\n\t\t\t\tModel model = models[m];\n\t\t\t\tif(model != null)\n\t\t\t\t{\n\t\t\t\t\tfor(int triangle = 0; triangle < model.triangleCount; triangle++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(setDrawType)\n\t\t\t\t\t\t\tif(model.triangleDrawType == null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttriangleDrawType[triangleCount] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint drawType = model.triangleDrawType[triangle];\n\t\t\t\t\t\t\t\tif((drawType & 2) == 2)\n\t\t\t\t\t\t\t\t\tdrawType += count << 2;\n\t\t\t\t\t\t\t\ttriangleDrawType[triangleCount] = drawType;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(setPriority)\n\t\t\t\t\t\t\tif(model.trianglePriorities == null)\n\t\t\t\t\t\t\t\ttrianglePriorities[triangleCount] = model.trianglePriority;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\ttrianglePriorities[triangleCount] = model.trianglePriorities[triangle];\n\t\t\t\t\t\tif(setAlpha)\n\t\t\t\t\t\t\tif(model.triangleAlpha == null)\n\t\t\t\t\t\t\t\ttriangleAlpha[triangleCount] = 0;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\ttriangleAlpha[triangleCount] = model.triangleAlpha[triangle];\n\t\t\t\t\t\tif(setSkins && model.triangleSkins != null)\n\t\t\t\t\t\t\ttriangleSkins[triangleCount] = model.triangleSkins[triangle];\n\t\t\t\t\t\ttriangleColours[triangleCount] = model.triangleColours[triangle];\n\t\t\t\t\t\ttriangleX[triangleCount] = getFirstIdenticalVertexId(model, model.triangleX[triangle]);\n\t\t\t\t\t\ttriangleY[triangleCount] = getFirstIdenticalVertexId(model, model.triangleY[triangle]);\n\t\t\t\t\t\ttriangleZ[triangleCount] = getFirstIdenticalVertexId(model, model.triangleZ[triangle]);\n\t\t\t\t\t\ttriangleCount++;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int triangle = 0; triangle < model.texturedTriangleCount; triangle++)\n\t\t\t\t\t{\n\t\t\t\t\t\ttexturedTrianglePointsX[texturedTriangleCount] = getFirstIdenticalVertexId(model,\n\t\t\t\t\t\t\tmodel.texturedTrianglePointsX[triangle]);\n\t\t\t\t\t\ttexturedTrianglePointsY[texturedTriangleCount] = getFirstIdenticalVertexId(model,\n\t\t\t\t\t\t\tmodel.texturedTrianglePointsY[triangle]);\n\t\t\t\t\t\ttexturedTrianglePointsZ[texturedTriangleCount] = getFirstIdenticalVertexId(model,\n\t\t\t\t\t\t\tmodel.texturedTrianglePointsZ[triangle]);\n\t\t\t\t\t\ttexturedTriangleCount++;\n\t\t\t\t\t}\n\n\t\t\t\t\tcount += model.texturedTriangleCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tpublic Model(Model[] models)\n\t\t{\n\t\t\tint modelCount = 2; \/\/ was parameter\n\t\t\tsingleTile = false;\n\t\t\tbool flag1 = false;\n\t\t\tbool flag2 = false;\n\t\t\tbool flag3 = false;\n\t\t\tbool flag4 = false;\n\t\t\tvertexCount = 0;\n\t\t\ttriangleCount = 0;\n\t\t\ttexturedTriangleCount = 0;\n\t\t\ttrianglePriority = -1;\n\t\t\tfor(int m = 0; m < modelCount; m++)\n\t\t\t{\n\t\t\t\tModel model = models[m];\n\t\t\t\tif(model != null)\n\t\t\t\t{\n\t\t\t\t\tvertexCount += model.vertexCount;\n\t\t\t\t\ttriangleCount += model.triangleCount;\n\t\t\t\t\ttexturedTriangleCount += model.texturedTriangleCount;\n\t\t\t\t\tflag1 |= model.triangleDrawType != null;\n\t\t\t\t\tif(model.trianglePriorities != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tflag2 = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(trianglePriority == -1)\n\t\t\t\t\t\t\ttrianglePriority = model.trianglePriority;\n\t\t\t\t\t\tif(trianglePriority != model.trianglePriority)\n\t\t\t\t\t\t\tflag2 = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tflag3 |= model.triangleAlpha != null;\n\t\t\t\t\tflag4 |= model.triangleColours != null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tverticesX = new int[vertexCount];\n\t\t\tverticesY = new int[vertexCount];\n\t\t\tverticesZ = new int[vertexCount];\n\t\t\ttriangleX = new int[triangleCount];\n\t\t\ttriangleY = new int[triangleCount];\n\t\t\ttriangleZ = new int[triangleCount];\n\t\t\ttriangleHSLA = new int[triangleCount];\n\t\t\ttriangleHSLB = new int[triangleCount];\n\t\t\ttriangleHSLC = new int[triangleCount];\n\t\t\ttexturedTrianglePointsX = new int[texturedTriangleCount];\n\t\t\ttexturedTrianglePointsY = new int[texturedTriangleCount];\n\t\t\ttexturedTrianglePointsZ = new int[texturedTriangleCount];\n\t\t\tif(flag1)\n\t\t\t\ttriangleDrawType = new int[triangleCount];\n\t\t\tif(flag2)\n\t\t\t\ttrianglePriorities = new int[triangleCount];\n\t\t\tif(flag3)\n\t\t\t\ttriangleAlpha = new int[triangleCount];\n\t\t\tif(flag4)\n\t\t\t\ttriangleColours = new int[triangleCount];\n\t\t\tvertexCount = 0;\n\t\t\ttriangleCount = 0;\n\t\t\ttexturedTriangleCount = 0;\n\t\t\tint count = 0;\n\t\t\tfor(int m = 0; m < modelCount; m++)\n\t\t\t{\n\t\t\t\tModel model = models[m];\n\t\t\t\tif(model != null)\n\t\t\t\t{\n\t\t\t\t\tint v = vertexCount;\n\t\t\t\t\tfor(int vertex = 0; vertex < model.vertexCount; vertex++)\n\t\t\t\t\t{\n\t\t\t\t\t\tverticesX[vertexCount] = model.verticesX[vertex];\n\t\t\t\t\t\tverticesY[vertexCount] = model.verticesY[vertex];\n\t\t\t\t\t\tverticesZ[vertexCount] = model.verticesZ[vertex];\n\t\t\t\t\t\tvertexCount++;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int triangle = 0; triangle < model.triangleCount; triangle++)\n\t\t\t\t\t{\n\t\t\t\t\t\ttriangleX[triangleCount] = model.triangleX[triangle] + v;\n\t\t\t\t\t\ttriangleY[triangleCount] = model.triangleY[triangle] + v;\n\t\t\t\t\t\ttriangleZ[triangleCount] = model.triangleZ[triangle] + v;\n\t\t\t\t\t\ttriangleHSLA[triangleCount] = model.triangleHSLA[triangle];\n\t\t\t\t\t\ttriangleHSLB[triangleCount] = model.triangleHSLB[triangle];\n\t\t\t\t\t\ttriangleHSLC[triangleCount] = model.triangleHSLC[triangle];\n\t\t\t\t\t\tif(flag1)\n\t\t\t\t\t\t\tif(model.triangleDrawType == null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttriangleDrawType[triangleCount] = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint drawType = model.triangleDrawType[triangle];\n\t\t\t\t\t\t\t\tif((drawType & 2) == 2)\n\t\t\t\t\t\t\t\t\tdrawType += count << 2;\n\t\t\t\t\t\t\t\ttriangleDrawType[triangleCount] = drawType;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(flag2)\n\t\t\t\t\t\t\tif(model.trianglePriorities == null)\n\t\t\t\t\t\t\t\ttrianglePriorities[triangleCount] = model.trianglePriority;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\ttrianglePriorities[triangleCount] = model.trianglePriorities[triangle];\n\t\t\t\t\t\tif(flag3)\n\t\t\t\t\t\t\tif(model.triangleAlpha == null)\n\t\t\t\t\t\t\t\ttriangleAlpha[triangleCount] = 0;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\ttriangleAlpha[triangleCount] = model.triangleAlpha[triangle];\n\t\t\t\t\t\tif(flag4 && model.triangleColours != null)\n\t\t\t\t\t\t\ttriangleColours[triangleCount] = model.triangleColours[triangle];\n\t\t\t\t\t\ttriangleCount++;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int triangle = 0; triangle < model.texturedTriangleCount; triangle++)\n\t\t\t\t\t{\n\t\t\t\t\t\ttexturedTrianglePointsX[texturedTriangleCount] = model.texturedTrianglePointsX[triangle] + v;\n\t\t\t\t\t\ttexturedTrianglePointsY[texturedTriangleCount] = model.texturedTrianglePointsY[triangle] + v;\n\t\t\t\t\t\ttexturedTrianglePointsZ[texturedTriangleCount] = model.texturedTrianglePointsZ[triangle] + v;\n\t\t\t\t\t\ttexturedTriangleCount++;\n\t\t\t\t\t}\n\n\t\t\t\t\tcount += model.texturedTriangleCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcalculateDiagonals();\n\t\t}\n\n\t\tpublic void applyLighting(int lightMod, int magnitudeMultiplier, int lightX, int lightY, int lightZ,\n\t\t\tbool flatShading)\n\t\t{\n\t\t\tint lightMagnitude = (int)Math.Sqrt(lightX * lightX + lightY * lightY + lightZ * lightZ);\n\t\t\tint magnitude = magnitudeMultiplier * lightMagnitude >> 8;\n\t\t\tif(triangleHSLA == null)\n\t\t\t{\n\t\t\t\ttriangleHSLA = new int[triangleCount];\n\t\t\t\ttriangleHSLB = new int[triangleCount];\n\t\t\t\ttriangleHSLC = new int[triangleCount];\n\t\t\t}\n\n\t\t\tif(base.vertexNormals == null)\n\t\t\t{\n\t\t\t\tbase.vertexNormals = new VertexNormal[vertexCount];\n\t\t\t\tfor(int vertex = 0; vertex < vertexCount; vertex++)\n\t\t\t\t\tbase.vertexNormals[vertex] = new VertexNormal();\n\n\t\t\t}\n\n\t\t\tfor(int triangle = 0; triangle < triangleCount; triangle++)\n\t\t\t{\n\t\t\t\tint _triangleX = triangleX[triangle];\n\t\t\t\tint _triangleY = triangleY[triangle];\n\t\t\t\tint _triangleZ = triangleZ[triangle];\n\t\t\t\tint distanceXXY = verticesX[_triangleY] - verticesX[_triangleX];\n\t\t\t\tint distanceYXY = verticesY[_triangleY] - verticesY[_triangleX];\n\t\t\t\tint distanceZXY = verticesZ[_triangleY] - verticesZ[_triangleX];\n\t\t\t\tint distanceXZX = verticesX[_triangleZ] - verticesX[_triangleX];\n\t\t\t\tint distanceYZX = verticesY[_triangleZ] - verticesY[_triangleX];\n\t\t\t\tint distanceZZX = verticesZ[_triangleZ] - verticesZ[_triangleX];\n\t\t\t\tint normalX = distanceYXY * distanceZZX - distanceYZX * distanceZXY;\n\t\t\t\tint normalY = distanceZXY * distanceXZX - distanceZZX * distanceXXY;\n\t\t\t\tint normalZ;\n\t\t\t\tfor(normalZ = distanceXXY * distanceYZX - distanceXZX * distanceYXY;\n\t\t\t\t\tnormalX > 8192 || normalY > 8192\n\t\t\t\t\t\t\t\t   || normalZ > 8192 || normalX < -8192 || normalY < -8192 || normalZ < -8192;\n\t\t\t\t\tnormalZ >>= 1)\n\t\t\t\t{\n\t\t\t\t\tnormalX >>= 1;\n\t\t\t\t\tnormalY >>= 1;\n\t\t\t\t}\n\n\t\t\t\tint normalLength = (int)Math.Sqrt(normalX * normalX + normalY * normalY + normalZ * normalZ);\n\t\t\t\tif(normalLength <= 0)\n\t\t\t\t\tnormalLength = 1;\n\t\t\t\tnormalX = (normalX * 256) \/ normalLength;\n\t\t\t\tnormalY = (normalY * 256) \/ normalLength;\n\t\t\t\tnormalZ = (normalZ * 256) \/ normalLength;\n\t\t\t\tif(triangleDrawType == null || (triangleDrawType[triangle] & 1) == 0)\n\t\t\t\t{\n\t\t\t\t\tVertexNormal vertexNormal = base.vertexNormals[_triangleX];\n\t\t\t\t\tvertexNormal.x += normalX;\n\t\t\t\t\tvertexNormal.y += normalY;\n\t\t\t\t\tvertexNormal.z += normalZ;\n\t\t\t\t\tvertexNormal.magnitude++;\n\t\t\t\t\tvertexNormal = base.vertexNormals[_triangleY];\n\t\t\t\t\tvertexNormal.x += normalX;\n\t\t\t\t\tvertexNormal.y += normalY;\n\t\t\t\t\tvertexNormal.z += normalZ;\n\t\t\t\t\tvertexNormal.magnitude++;\n\t\t\t\t\tvertexNormal = base.vertexNormals[_triangleZ];\n\t\t\t\t\tvertexNormal.x += normalX;\n\t\t\t\t\tvertexNormal.y += normalY;\n\t\t\t\t\tvertexNormal.z += normalZ;\n\t\t\t\t\tvertexNormal.magnitude++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint lightness = lightMod\n\t\t\t\t\t\t\t\t\t+ (lightX * normalX + lightY * normalY + lightZ * normalZ) \/ (magnitude + magnitude \/ 2);\n\t\t\t\t\ttriangleHSLA[triangle] = mixLightness(triangleColours[triangle], lightness, triangleDrawType[triangle]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(flatShading)\n\t\t\t{\n\t\t\t\thandleShading(lightMod, magnitude, lightX, lightY, lightZ);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvertexNormalOffset = new VertexNormal[vertexCount];\n\t\t\t\tfor(int vertex = 0; vertex < vertexCount; vertex++)\n\t\t\t\t{\n\t\t\t\t\tVertexNormal vertexNormal = base.vertexNormals[vertex];\n\t\t\t\t\tVertexNormal shadowVertexNormal = vertexNormalOffset[vertex] = new VertexNormal();\n\t\t\t\t\tshadowVertexNormal.x = vertexNormal.x;\n\t\t\t\t\tshadowVertexNormal.y = vertexNormal.y;\n\t\t\t\t\tshadowVertexNormal.z = vertexNormal.z;\n\t\t\t\t\tshadowVertexNormal.magnitude = vertexNormal.magnitude;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif(flatShading)\n\t\t\t{\n\t\t\t\tcalculateDiagonals();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcalculateDiagonalsAndBounds();\n\t\t\t}\n\t\t}\n\n\t\tpublic void applyTransformation(int frameId)\n\t\t{\n\t\t\tif(vertexSkin == null)\n\t\t\t\treturn;\n\t\t\tif(frameId == -1)\n\t\t\t\treturn;\n\t\t\tAnimation animationFrame = Animation.forFrameId(frameId);\n\t\t\tif(animationFrame == null)\n\t\t\t\treturn;\n\t\t\tSkins skins = animationFrame.animationSkins;\n\t\t\tvertexModifierX = 0;\n\t\t\tvertexModifierY = 0;\n\t\t\tvertexModifierZ = 0;\n\t\t\tfor(int stepId = 0; stepId < animationFrame.frameCount; stepId++)\n\t\t\t{\n\t\t\t\tint opcode = animationFrame.opcodeTable[stepId];\n\t\t\t\ttransformFrame(skins.opcodes[opcode], skins.skinList[opcode], animationFrame.transformationX[stepId],\n\t\t\t\t\tanimationFrame.transformationY[stepId], animationFrame.transformationZ[stepId]);\n\t\t\t}\n\t\t}\n\n\t\tpublic void calculateDiagonals()\n\t\t{\n\t\t\tbase.modelHeight = 0;\n\t\t\tdiagonal2DAboveOrigin = 0;\n\t\t\tmaxY = 0;\n\t\t\tfor(int vertex = 0; vertex < vertexCount; vertex++)\n\t\t\t{\n\t\t\t\tint x = verticesX[vertex];\n\t\t\t\tint y = verticesY[vertex];\n\t\t\t\tint z = verticesZ[vertex];\n\t\t\t\tif(-y > base.modelHeight)\n\t\t\t\t\tbase.modelHeight = -y;\n\t\t\t\tif(y > maxY)\n\t\t\t\t\tmaxY = y;\n\t\t\t\tint bounds = x * x + z * z;\n\t\t\t\tif(bounds > diagonal2DAboveOrigin)\n\t\t\t\t\tdiagonal2DAboveOrigin = bounds;\n\t\t\t}\n\n\t\t\tdiagonal2DAboveOrigin = (int)(Math.Sqrt(diagonal2DAboveOrigin) + 0.98999999999999999D);\n\t\t\tdiagonal3DAboveOrigin = (int)(Math.Sqrt(diagonal2DAboveOrigin * diagonal2DAboveOrigin + base.modelHeight * base.modelHeight)\n\t\t\t\t\t\t\t\t\t\t   + 0.98999999999999999D);\n\t\t\tdiagonal3D = diagonal3DAboveOrigin\n\t\t\t\t\t\t + (int)(Math.Sqrt(diagonal2DAboveOrigin * diagonal2DAboveOrigin + maxY * maxY) + 0.98999999999999999D);\n\t\t}\n\n\t\tprivate void calculateDiagonalsAndBounds()\n\t\t{\n\t\t\tbase.modelHeight = 0;\n\t\t\tdiagonal2DAboveOrigin = 0;\n\t\t\tmaxY = 0;\n\t\t\tminX = 0xf423f;\n\t\t\tmaxX = unchecked((int)0xfff0bdc1);\n\t\t\tmaxZ = unchecked((int)0xfffe7961); \/\/TODO: RS2Sharp does this, but I'm not sure it's actually right.\n\t\t\tminZ = 0x1869f;\n\t\t\tfor(int vertex = 0; vertex < vertexCount; vertex++)\n\t\t\t{\n\t\t\t\tint x = verticesX[vertex];\n\t\t\t\tint y = verticesY[vertex];\n\t\t\t\tint z = verticesZ[vertex];\n\t\t\t\tif(x < minX)\n\t\t\t\t\tminX = x;\n\t\t\t\tif(x > maxX)\n\t\t\t\t\tmaxX = x;\n\t\t\t\tif(z < minZ)\n\t\t\t\t\tminZ = z;\n\t\t\t\tif(z > maxZ)\n\t\t\t\t\tmaxZ = z;\n\t\t\t\tif(-y > base.modelHeight)\n\t\t\t\t\tbase.modelHeight = -y;\n\t\t\t\tif(y > maxY)\n\t\t\t\t\tmaxY = y;\n\t\t\t\tint bounds = x * x + z * z;\n\t\t\t\tif(bounds > diagonal2DAboveOrigin)\n\t\t\t\t\tdiagonal2DAboveOrigin = bounds;\n\t\t\t}\n\n\t\t\tdiagonal2DAboveOrigin = (int)Math.Sqrt(diagonal2DAboveOrigin);\n\t\t\tdiagonal3DAboveOrigin = (int)Math.Sqrt(diagonal2DAboveOrigin * diagonal2DAboveOrigin + base.modelHeight * base.modelHeight);\n\t\t\tdiagonal3D = diagonal3DAboveOrigin\n\t\t\t\t\t\t + (int)Math.Sqrt(diagonal2DAboveOrigin * diagonal2DAboveOrigin + maxY * maxY);\n\t\t}\n\n\t\tpublic void createBones()\n\t\t{\n\t\t\tif(vertexSkins != null)\n\t\t\t{\n\t\t\t\t\/\/TODO: Use pooled array\n\t\t\t\tint[] ai = new int[256];\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int vertex = 0; vertex < vertexCount; vertex++)\n\t\t\t\t{\n\t\t\t\t\tint skins = vertexSkins[vertex];\n\t\t\t\t\tai[skins]++;\n\t\t\t\t\tif(skins > count)\n\t\t\t\t\t\tcount = skins;\n\t\t\t\t}\n\n\t\t\t\tvertexSkin = new int[count + 1][];\n\t\t\t\tfor(int vertex = 0; vertex <= count; vertex++)\n\t\t\t\t{\n\t\t\t\t\tvertexSkin[vertex] = new int[ai[vertex]];\n\t\t\t\t\tai[vertex] = 0;\n\t\t\t\t}\n\n\t\t\t\tfor(int vertex = 0; vertex < vertexCount; vertex++)\n\t\t\t\t{\n\t\t\t\t\tint skin = vertexSkins[vertex];\n\t\t\t\t\tvertexSkin[skin][ai[skin]++] = vertex;\n\t\t\t\t}\n\n\t\t\t\tvertexSkins = null;\n\t\t\t}\n\n\t\t\tif(triangleSkins != null)\n\t\t\t{\n\t\t\t\t\/\/TODO: Use pooled array\n\t\t\t\tint[] ai1 = new int[256];\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int triangle = 0; triangle < triangleCount; triangle++)\n\t\t\t\t{\n\t\t\t\t\tint skins = triangleSkins[triangle];\n\t\t\t\t\tai1[skins]++;\n\t\t\t\t\tif(skins > count)\n\t\t\t\t\t\tcount = skins;\n\t\t\t\t}\n\n\t\t\t\ttriangleSkin = new int[count + 1][];\n\t\t\t\tfor(int triangle = 0; triangle <= count; triangle++)\n\t\t\t\t{\n\t\t\t\t\ttriangleSkin[triangle] = new int[ai1[triangle]];\n\t\t\t\t\tai1[triangle] = 0;\n\t\t\t\t}\n\n\t\t\t\tfor(int triangle = 0; triangle < triangleCount; triangle++)\n\t\t\t\t{\n\t\t\t\t\tint skins = triangleSkins[triangle];\n\t\t\t\t\ttriangleSkin[skins][ai1[skins]++] = triangle;\n\t\t\t\t}\n\n\t\t\t\ttriangleSkins = null;\n\t\t\t}\n\t\t}\n\n\t\tprivate int getFirstIdenticalVertexId(Model model, int vertex)\n\t\t{\n\t\t\tint vertexId = -1;\n\t\t\tint x = model.verticesX[vertex];\n\t\t\tint y = model.verticesY[vertex];\n\t\t\tint z = model.verticesZ[vertex];\n\t\t\tfor(int v = 0; v < vertexCount; v++)\n\t\t\t{\n\t\t\t\tif(x != verticesX[v] || y != verticesY[v] || z != verticesZ[v])\n\t\t\t\t\tcontinue;\n\t\t\t\tvertexId = v;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(vertexId == -1)\n\t\t\t{\n\t\t\t\tverticesX[vertexCount] = x;\n\t\t\t\tverticesY[vertexCount] = y;\n\t\t\t\tverticesZ[vertexCount] = z;\n\t\t\t\tif(model.vertexSkins != null)\n\t\t\t\t\tvertexSkins[vertexCount] = model.vertexSkins[vertex];\n\t\t\t\tvertexId = vertexCount++;\n\t\t\t}\n\n\t\t\treturn vertexId;\n\t\t}\n\n\t\tpublic void handleShading(int intensity, int falloff, int lightX, int lightY, int lightZ)\n\t\t{\n\t\t\tfor(int triangle = 0; triangle < triangleCount; triangle++)\n\t\t\t{\n\t\t\t\tint x = triangleX[triangle];\n\t\t\t\tint y = triangleY[triangle];\n\t\t\t\tint z = triangleZ[triangle];\n\t\t\t\tif(triangleDrawType == null)\n\t\t\t\t{\n\t\t\t\t\tint colour = triangleColours[triangle];\n\t\t\t\t\tVertexNormal vertexNormal = base.vertexNormals[x];\n\t\t\t\t\tint lightness = intensity + (lightX * vertexNormal.x + lightY * vertexNormal.y + lightZ * vertexNormal.z) \/ (falloff * vertexNormal.magnitude);\n\t\t\t\t\ttriangleHSLA[triangle] = mixLightness(colour, lightness, 0);\n\t\t\t\t\tvertexNormal = base.vertexNormals[y];\n\t\t\t\t\tlightness = intensity + (lightX * vertexNormal.x + lightY * vertexNormal.y + lightZ * vertexNormal.z) \/ (falloff * vertexNormal.magnitude);\n\t\t\t\t\ttriangleHSLB[triangle] = mixLightness(colour, lightness, 0);\n\t\t\t\t\tvertexNormal = base.vertexNormals[z];\n\t\t\t\t\tlightness = intensity + (lightX * vertexNormal.x + lightY * vertexNormal.y + lightZ * vertexNormal.z) \/ (falloff * vertexNormal.magnitude);\n\t\t\t\t\ttriangleHSLC[triangle] = mixLightness(colour, lightness, 0);\n\t\t\t\t}\n\t\t\t\telse if((triangleDrawType[triangle] & 1) == 0)\n\t\t\t\t{\n\t\t\t\t\tint colour = triangleColours[triangle];\n\t\t\t\t\tint drawType = triangleDrawType[triangle];\n\t\t\t\t\tVertexNormal vertexNormal = base.vertexNormals[x];\n\t\t\t\t\tint lightness = intensity + (lightX * vertexNormal.x + lightY * vertexNormal.y + lightZ * vertexNormal.z) \/ (falloff * vertexNormal.magnitude);\n\t\t\t\t\ttriangleHSLA[triangle] = mixLightness(colour, lightness, drawType);\n\t\t\t\t\tvertexNormal = base.vertexNormals[y];\n\t\t\t\t\tlightness = intensity + (lightX * vertexNormal.x + lightY * vertexNormal.y + lightZ * vertexNormal.z) \/ (falloff * vertexNormal.magnitude);\n\t\t\t\t\ttriangleHSLB[triangle] = mixLightness(colour, lightness, drawType);\n\t\t\t\t\tvertexNormal = base.vertexNormals[z];\n\t\t\t\t\tlightness = intensity + (lightX * vertexNormal.x + lightY * vertexNormal.y + lightZ * vertexNormal.z) \/ (falloff * vertexNormal.magnitude);\n\t\t\t\t\ttriangleHSLC[triangle] = mixLightness(colour, lightness, drawType);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbase.vertexNormals = null;\n\t\t\tvertexNormalOffset = null;\n\t\t\tvertexSkins = null;\n\t\t\ttriangleSkins = null;\n\t\t\tif(triangleDrawType != null)\n\t\t\t{\n\t\t\t\tfor(int triangle = 0; triangle < triangleCount; triangle++)\n\t\t\t\t\tif((triangleDrawType[triangle] & 2) == 2)\n\t\t\t\t\t\treturn;\n\n\t\t\t}\n\t\t\ttriangleColours = null;\n\t\t}\n\n\t\tprivate void method483(bool flag, bool flag1, int i)\n\t\t{\n\t\t\tfor(int j = 0; j < diagonal3D; j++)\n\t\t\t\tanIntArray1671[j] = 0;\n\n\t\t\tfor(int triangle = 0; triangle < triangleCount; triangle++)\n\t\t\t\tif(triangleDrawType == null || triangleDrawType[triangle] != -1)\n\t\t\t\t{\n\t\t\t\t\tint x = triangleX[triangle];\n\t\t\t\t\tint y = triangleY[triangle];\n\t\t\t\t\tint z = triangleZ[triangle];\n\t\t\t\t\tint screenXX = vertexScreenX[x];\n\t\t\t\t\tint screenXY = vertexScreenX[y];\n\t\t\t\t\tint screenXZ = vertexScreenX[z];\n\t\t\t\t\tif(flag && (screenXX == -5000 || screenXY == -5000 || screenXZ == -5000))\n\t\t\t\t\t{\n\t\t\t\t\t\taboolArray1664[triangle] = true;\n\t\t\t\t\t\tint j5 = (vertexScreenZ[x] + vertexScreenZ[y] + vertexScreenZ[z]) \/ 3 + diagonal3DAboveOrigin;\n\t\t\t\t\t\tanIntArrayArray1672[j5, anIntArray1671[j5]++] = triangle;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(flag1 && method486(cursorX, cursorY, vertexScreenY[x], vertexScreenY[y], vertexScreenY[z],\n\t\t\t\t\t\t\t\tscreenXX, screenXY, screenXZ))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tresourceId[resourceCount++] = i;\n\t\t\t\t\t\t\tflag1 = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif((screenXX - screenXY) * (vertexScreenY[z] - vertexScreenY[y])\n\t\t\t\t\t\t\t- (vertexScreenY[x] - vertexScreenY[y]) * (screenXZ - screenXY) > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taboolArray1664[triangle] = false;\n\t\t\t\t\t\t\trestrictEdges[triangle] = screenXX < 0 || screenXY < 0 || screenXZ < 0\n\t\t\t\t\t\t\t\t\t\t\t\t\t  || screenXX > DrawingArea.centerX || screenXY > DrawingArea.centerX\n\t\t\t\t\t\t\t\t\t\t\t\t\t  || screenXZ > DrawingArea.centerX;\n\t\t\t\t\t\t\tint k5 = (vertexScreenZ[x] + vertexScreenZ[y] + vertexScreenZ[z]) \/ 3 + diagonal3DAboveOrigin;\n\t\t\t\t\t\t\tanIntArrayArray1672[k5, anIntArray1671[k5]++] = triangle;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tif(trianglePriorities == null)\n\t\t\t{\n\t\t\t\tfor(int i1 = diagonal3D - 1; i1 >= 0; i1--)\n\t\t\t\t{\n\t\t\t\t\tint l1 = anIntArray1671[i1];\n\t\t\t\t\tif(l1 > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int j3 = 0; j3 < l1; j3++)\n\t\t\t\t\t\t\trasterise(anIntArrayArray1672[i1, j3]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor(int j1 = 0; j1 < 12; j1++)\n\t\t\t{\n\t\t\t\tanIntArray1673[j1] = 0;\n\t\t\t\tanIntArray1677[j1] = 0;\n\t\t\t}\n\n\t\t\tfor(int i2 = diagonal3D - 1; i2 >= 0; i2--)\n\t\t\t{\n\t\t\t\tint k2 = anIntArray1671[i2];\n\t\t\t\tif(k2 > 0)\n\t\t\t\t{\n\t\t\t\t\tfor(int i4 = 0; i4 < k2; i4++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint l4 = anIntArrayArray1672[i2, i4];\n\t\t\t\t\t\tint l5 = trianglePriorities[l4];\n\t\t\t\t\t\tint j6 = anIntArray1673[l5]++;\n\t\t\t\t\t\tanIntArrayArray1674[l5, j6] = l4;\n\t\t\t\t\t\tif(l5 < 10)\n\t\t\t\t\t\t\tanIntArray1677[l5] += i2;\n\t\t\t\t\t\telse if(l5 == 10)\n\t\t\t\t\t\t\tanIntArray1675[j6] = i2;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tanIntArray1676[j6] = i2;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint l2 = 0;\n\t\t\tif(anIntArray1673[1] > 0 || anIntArray1673[2] > 0)\n\t\t\t\tl2 = (anIntArray1677[1] + anIntArray1677[2]) \/ (anIntArray1673[1] + anIntArray1673[2]);\n\t\t\tint k3 = 0;\n\t\t\tif(anIntArray1673[3] > 0 || anIntArray1673[4] > 0)\n\t\t\t\tk3 = (anIntArray1677[3] + anIntArray1677[4]) \/ (anIntArray1673[3] + anIntArray1673[4]);\n\t\t\tint j4 = 0;\n\t\t\tif(anIntArray1673[6] > 0 || anIntArray1673[8] > 0)\n\t\t\t\tj4 = (anIntArray1677[6] + anIntArray1677[8]) \/ (anIntArray1673[6] + anIntArray1673[8]);\n\t\t\tint i6 = 0;\n\t\t\tint k6 = anIntArray1673[10];\n\n\t\t\t\/\/anIntArrayArray1674\n\t\t\tint ai2Index;\n\t\t\tint[] ai3 = anIntArray1675;\n\t\t\tif(i6 == k6)\n\t\t\t{\n\t\t\t\ti6 = 0;\n\t\t\t\tk6 = anIntArray1673[11];\n\t\t\t\tai2Index = 11;\n\t\t\t\tai3 = anIntArray1676;\n\t\t\t}\n\t\t\telse\n\t\t\t\tai2Index = 10;\n\n\t\t\tint i5;\n\t\t\tif(i6 < k6)\n\t\t\t\ti5 = ai3[i6];\n\t\t\telse\n\t\t\t\ti5 = -1000;\n\t\t\tfor(int l6 = 0; l6 < 10; l6++)\n\t\t\t{\n\t\t\t\t\/\/TODO: Remove inlined duplicate code.\n\t\t\t\twhile(l6 == 0 && i5 > l2)\n\t\t\t\t{\n\t\t\t\t\trasterise(anIntArrayArray1674[ai2Index, i6++]);\n\t\t\t\t\tif(i6 == k6 && ai2Index != 11) \/\/see above. I converted to index, so we can check index value instead.\n\t\t\t\t\t{\n\t\t\t\t\t\ti6 = 0;\n\t\t\t\t\t\tk6 = anIntArray1673[11];\n\t\t\t\t\t\tai2Index = 11;\n\t\t\t\t\t\tai3 = anIntArray1676;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(i6 < k6)\n\t\t\t\t\t\ti5 = ai3[i6];\n\t\t\t\t\telse\n\t\t\t\t\t\ti5 = -1000;\n\t\t\t\t}\n\n\t\t\t\twhile(l6 == 3 && i5 > k3)\n\t\t\t\t{\n\t\t\t\t\trasterise(anIntArrayArray1674[ai2Index, i6++]);\n\t\t\t\t\tif(i6 == k6 && ai2Index != 11)\n\t\t\t\t\t{\n\t\t\t\t\t\ti6 = 0;\n\t\t\t\t\t\tk6 = anIntArray1673[11];\n\t\t\t\t\t\tai2Index = 11;\n\t\t\t\t\t\tai3 = anIntArray1676;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(i6 < k6)\n\t\t\t\t\t\ti5 = ai3[i6];\n\t\t\t\t\telse\n\t\t\t\t\t\ti5 = -1000;\n\t\t\t\t}\n\n\t\t\t\twhile(l6 == 5 && i5 > j4)\n\t\t\t\t{\n\t\t\t\t\trasterise(anIntArrayArray1674[ai2Index, i6++]);\n\t\t\t\t\tif(i6 == k6 && ai2Index != 11)\n\t\t\t\t\t{\n\t\t\t\t\t\ti6 = 0;\n\t\t\t\t\t\tk6 = anIntArray1673[11];\n\t\t\t\t\t\tai2Index = 11;\n\t\t\t\t\t\tai3 = anIntArray1676;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(i6 < k6)\n\t\t\t\t\t\ti5 = ai3[i6];\n\t\t\t\t\telse\n\t\t\t\t\t\ti5 = -1000;\n\t\t\t\t}\n\n\t\t\t\tint i7 = anIntArray1673[l6];\n\t\t\t\tfor(int j7 = 0; j7 < i7; j7++)\n\t\t\t\t\trasterise(anIntArrayArray1674[l6, j7]);\n\t\t\t}\n\n\t\t\twhile(i5 != -1000)\n\t\t\t{\n\t\t\t\trasterise(anIntArrayArray1674[ai2Index, i6++]);\n\t\t\t\tif(i6 == k6 && ai2Index != 11)\n\t\t\t\t{\n\t\t\t\t\ti6 = 0;\n\t\t\t\t\tai2Index = 11;\n\t\t\t\t\tk6 = anIntArray1673[11];\n\t\t\t\t\tai3 = anIntArray1676;\n\t\t\t\t}\n\n\t\t\t\tif(i6 < k6)\n\t\t\t\t\ti5 = ai3[i6];\n\t\t\t\telse\n\t\t\t\t\ti5 = -1000;\n\t\t\t}\n\t\t}\n\n\t\tprivate void method485(int triangle)\n\t\t{\n\t\t\tint centreX = Rasterizer.centreX;\n\t\t\tint centreY = Rasterizer.centreY;\n\t\t\tint counter = 0;\n\t\t\tint x = triangleX[triangle];\n\t\t\tint y = triangleY[triangle];\n\t\t\tint z = triangleZ[triangle];\n\t\t\tint movedX = vertexMovedZ[x];\n\t\t\tint movedY = vertexMovedZ[y];\n\t\t\tint movedZ = vertexMovedZ[z];\n\t\t\tif(movedX >= 50)\n\t\t\t{\n\t\t\t\txPosition[counter] = vertexScreenX[x];\n\t\t\t\tyPosition[counter] = vertexScreenY[x];\n\t\t\t\tzPosition[counter++] = triangleHSLA[triangle];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint movedX2 = vertexMovedX[x];\n\t\t\t\tint movedY2 = vertexMovedY[x];\n\t\t\t\tint colour = triangleHSLA[triangle];\n\t\t\t\tif(movedZ >= 50)\n\t\t\t\t{\n\t\t\t\t\tint k5 = (50 - movedX) * modelIntArray4[movedZ - movedX];\n\t\t\t\t\txPosition[counter] = centreX + (movedX2 + ((vertexMovedX[z] - movedX2) * k5 >> 16) << 9) \/ 50;\n\t\t\t\t\tyPosition[counter] = centreY + (movedY2 + ((vertexMovedY[z] - movedY2) * k5 >> 16) << 9) \/ 50;\n\t\t\t\t\tzPosition[counter++] = colour + ((triangleHSLC[triangle] - colour) * k5 >> 16);\n\t\t\t\t}\n\n\t\t\t\tif(movedY >= 50)\n\t\t\t\t{\n\t\t\t\t\tint l5 = (50 - movedX) * modelIntArray4[movedY - movedX];\n\t\t\t\t\txPosition[counter] = centreX + (movedX2 + ((vertexMovedX[y] - movedX2) * l5 >> 16) << 9) \/ 50;\n\t\t\t\t\tyPosition[counter] = centreY + (movedY2 + ((vertexMovedY[y] - movedY2) * l5 >> 16) << 9) \/ 50;\n\t\t\t\t\tzPosition[counter++] = colour + ((triangleHSLB[triangle] - colour) * l5 >> 16);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(movedY >= 50)\n\t\t\t{\n\t\t\t\txPosition[counter] = vertexScreenX[y];\n\t\t\t\tyPosition[counter] = vertexScreenY[y];\n\t\t\t\tzPosition[counter++] = triangleHSLB[triangle];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint movedX2 = vertexMovedX[y];\n\t\t\t\tint movedY2 = vertexMovedY[y];\n\t\t\t\tint colour = triangleHSLB[triangle];\n\t\t\t\tif(movedX >= 50)\n\t\t\t\t{\n\t\t\t\t\tint i6 = (50 - movedY) * modelIntArray4[movedX - movedY];\n\t\t\t\t\txPosition[counter] = centreX + (movedX2 + ((vertexMovedX[x] - movedX2) * i6 >> 16) << 9) \/ 50;\n\t\t\t\t\tyPosition[counter] = centreY + (movedY2 + ((vertexMovedY[x] - movedY2) * i6 >> 16) << 9) \/ 50;\n\t\t\t\t\tzPosition[counter++] = colour + ((triangleHSLA[triangle] - colour) * i6 >> 16);\n\t\t\t\t}\n\n\t\t\t\tif(movedZ >= 50)\n\t\t\t\t{\n\t\t\t\t\tint j6 = (50 - movedY) * modelIntArray4[movedZ - movedY];\n\t\t\t\t\txPosition[counter] = centreX + (movedX2 + ((vertexMovedX[z] - movedX2) * j6 >> 16) << 9) \/ 50;\n\t\t\t\t\tyPosition[counter] = centreY + (movedY2 + ((vertexMovedY[z] - movedY2) * j6 >> 16) << 9) \/ 50;\n\t\t\t\t\tzPosition[counter++] = colour + ((triangleHSLC[triangle] - colour) * j6 >> 16);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(movedZ >= 50)\n\t\t\t{\n\t\t\t\txPosition[counter] = vertexScreenX[z];\n\t\t\t\tyPosition[counter] = vertexScreenY[z];\n\t\t\t\tzPosition[counter++] = triangleHSLC[triangle];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint movedX2 = vertexMovedX[z];\n\t\t\t\tint movedY2 = vertexMovedY[z];\n\t\t\t\tint colour = triangleHSLC[triangle];\n\t\t\t\tif(movedY >= 50)\n\t\t\t\t{\n\t\t\t\t\tint k6 = (50 - movedZ) * modelIntArray4[movedY - movedZ];\n\t\t\t\t\txPosition[counter] = centreX + (movedX2 + ((vertexMovedX[y] - movedX2) * k6 >> 16) << 9) \/ 50;\n\t\t\t\t\tyPosition[counter] = centreY + (movedY2 + ((vertexMovedY[y] - movedY2) * k6 >> 16) << 9) \/ 50;\n\t\t\t\t\tzPosition[counter++] = colour + ((triangleHSLB[triangle] - colour) * k6 >> 16);\n\t\t\t\t}\n\n\t\t\t\tif(movedX >= 50)\n\t\t\t\t{\n\t\t\t\t\tint l6 = (50 - movedZ) * modelIntArray4[movedX - movedZ];\n\t\t\t\t\txPosition[counter] = centreX + (movedX2 + ((vertexMovedX[x] - movedX2) * l6 >> 16) << 9) \/ 50;\n\t\t\t\t\tyPosition[counter] = centreY + (movedY2 + ((vertexMovedY[x] - movedY2) * l6 >> 16) << 9) \/ 50;\n\t\t\t\t\tzPosition[counter++] = colour + ((triangleHSLA[triangle] - colour) * l6 >> 16);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint xA = xPosition[0];\n\t\t\tint xB = xPosition[1];\n\t\t\tint xC = xPosition[2];\n\t\t\tint yA = yPosition[0];\n\t\t\tint yB = yPosition[1];\n\t\t\tint yC = yPosition[2];\n\t\t\tif((xA - xB) * (yC - yB) - (yA - yB) * (xC - xB) > 0)\n\t\t\t{\n\t\t\t\tRasterizer.restrictEdges = false;\n\t\t\t\tif(counter == 3)\n\t\t\t\t{\n\t\t\t\t\tif(xA < 0 || xB < 0 || xC < 0 || xA > DrawingArea.centerX || xB > DrawingArea.centerX\n\t\t\t\t\t\t|| xC > DrawingArea.centerX)\n\t\t\t\t\t\tRasterizer.restrictEdges = true;\n\t\t\t\t\tint drawType;\n\t\t\t\t\tif(triangleDrawType == null)\n\t\t\t\t\t\tdrawType = 0;\n\t\t\t\t\telse\n\t\t\t\t\t\tdrawType = triangleDrawType[triangle] & 3;\n\t\t\t\t\tif(drawType == 0)\n\t\t\t\t\t\tRasterizer.drawShadedTriangle(yA, yB, yC, xA, xB, xC, zPosition[0], zPosition[1], zPosition[2]);\n\t\t\t\t\telse if(drawType == 1)\n\t\t\t\t\t\tRasterizer.drawFlatTriangle(yA, yB, yC, xA, xB, xC, HSLtoRGB[triangleHSLA[triangle]]);\n\t\t\t\t\telse if(drawType == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tint tri = triangleDrawType[triangle] >> 2;\n\t\t\t\t\t\tint x2 = texturedTrianglePointsX[tri];\n\t\t\t\t\t\tint y2 = texturedTrianglePointsY[tri];\n\t\t\t\t\t\tint z2 = texturedTrianglePointsZ[tri];\n\t\t\t\t\t\tRasterizer.drawTexturedTriangle(yA, yB, yC, xA, xB, xC, zPosition[0], zPosition[1], zPosition[2],\n\t\t\t\t\t\t\tvertexMovedX[x2], vertexMovedX[y2], vertexMovedX[z2], vertexMovedY[x2], vertexMovedY[y2],\n\t\t\t\t\t\t\tvertexMovedY[z2], vertexMovedZ[x2], vertexMovedZ[y2], vertexMovedZ[z2],\n\t\t\t\t\t\t\ttriangleColours[triangle]);\n\t\t\t\t\t}\n\t\t\t\t\telse if(drawType == 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tint tri = triangleDrawType[triangle] >> 2;\n\t\t\t\t\t\tint x2 = texturedTrianglePointsX[tri];\n\t\t\t\t\t\tint y2 = texturedTrianglePointsY[tri];\n\t\t\t\t\t\tint z2 = texturedTrianglePointsZ[tri];\n\t\t\t\t\t\tRasterizer.drawTexturedTriangle(yA, yB, yC, xA, xB, xC, triangleHSLA[triangle],\n\t\t\t\t\t\t\ttriangleHSLA[triangle], triangleHSLA[triangle], vertexMovedX[x2], vertexMovedX[y2],\n\t\t\t\t\t\t\tvertexMovedX[z2], vertexMovedY[x2], vertexMovedY[y2], vertexMovedY[z2], vertexMovedZ[x2],\n\t\t\t\t\t\t\tvertexMovedZ[y2], vertexMovedZ[z2], triangleColours[triangle]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(counter == 4)\n\t\t\t\t{\n\t\t\t\t\tif(xA < 0 || xB < 0 || xC < 0 || xA > DrawingArea.centerX || xB > DrawingArea.centerX\n\t\t\t\t\t\t|| xC > DrawingArea.centerX || xPosition[3] < 0 || xPosition[3] > DrawingArea.centerX)\n\t\t\t\t\t\tRasterizer.restrictEdges = true;\n\t\t\t\t\tint drawType;\n\t\t\t\t\tif(triangleDrawType == null)\n\t\t\t\t\t\tdrawType = 0;\n\t\t\t\t\telse\n\t\t\t\t\t\tdrawType = triangleDrawType[triangle] & 3;\n\t\t\t\t\tif(drawType == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tRasterizer.drawShadedTriangle(yA, yB, yC, xA, xB, xC, zPosition[0], zPosition[1], zPosition[2]);\n\t\t\t\t\t\tRasterizer.drawShadedTriangle(yA, yC, yPosition[3], xA, xC, xPosition[3], zPosition[0],\n\t\t\t\t\t\t\tzPosition[2], zPosition[3]);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(drawType == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tint colour = HSLtoRGB[triangleHSLA[triangle]];\n\t\t\t\t\t\tRasterizer.drawFlatTriangle(yA, yB, yC, xA, xB, xC, colour);\n\t\t\t\t\t\tRasterizer.drawFlatTriangle(yA, yC, yPosition[3], xA, xC, xPosition[3], colour);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(drawType == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tint tri = triangleDrawType[triangle] >> 2;\n\t\t\t\t\t\tint x2 = texturedTrianglePointsX[tri];\n\t\t\t\t\t\tint y2 = texturedTrianglePointsY[tri];\n\t\t\t\t\t\tint z2 = texturedTrianglePointsZ[tri];\n\t\t\t\t\t\tRasterizer.drawTexturedTriangle(yA, yB, yC, xA, xB, xC, zPosition[0], zPosition[1], zPosition[2],\n\t\t\t\t\t\t\tvertexMovedX[x2], vertexMovedX[y2], vertexMovedX[z2], vertexMovedY[x2], vertexMovedY[y2],\n\t\t\t\t\t\t\tvertexMovedY[z2], vertexMovedZ[x2], vertexMovedZ[y2], vertexMovedZ[z2],\n\t\t\t\t\t\t\ttriangleColours[triangle]);\n\t\t\t\t\t\tRasterizer.drawTexturedTriangle(yA, yC, yPosition[3], xA, xC, xPosition[3], zPosition[0],\n\t\t\t\t\t\t\tzPosition[2], zPosition[3], vertexMovedX[x2], vertexMovedX[y2], vertexMovedX[z2],\n\t\t\t\t\t\t\tvertexMovedY[x2], vertexMovedY[y2], vertexMovedY[z2], vertexMovedZ[x2], vertexMovedZ[y2],\n\t\t\t\t\t\t\tvertexMovedZ[z2], triangleColours[triangle]);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(drawType == 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tint tri = triangleDrawType[triangle] >> 2;\n\t\t\t\t\t\tint x2 = texturedTrianglePointsX[tri];\n\t\t\t\t\t\tint y2 = texturedTrianglePointsY[tri];\n\t\t\t\t\t\tint z2 = texturedTrianglePointsZ[tri];\n\t\t\t\t\t\tRasterizer.drawTexturedTriangle(yA, yB, yC, xA, xB, xC, triangleHSLA[triangle],\n\t\t\t\t\t\t\ttriangleHSLA[triangle], triangleHSLA[triangle], vertexMovedX[x2], vertexMovedX[y2],\n\t\t\t\t\t\t\tvertexMovedX[z2], vertexMovedY[x2], vertexMovedY[y2], vertexMovedY[z2], vertexMovedZ[x2],\n\t\t\t\t\t\t\tvertexMovedZ[y2], vertexMovedZ[z2], triangleColours[triangle]);\n\t\t\t\t\t\tRasterizer.drawTexturedTriangle(yA, yC, yPosition[3], xA, xC, xPosition[3], triangleHSLA[triangle],\n\t\t\t\t\t\t\ttriangleHSLA[triangle], triangleHSLA[triangle], vertexMovedX[x2], vertexMovedX[y2],\n\t\t\t\t\t\t\tvertexMovedX[z2], vertexMovedY[x2], vertexMovedY[y2], vertexMovedY[z2], vertexMovedZ[x2],\n\t\t\t\t\t\t\tvertexMovedZ[y2], vertexMovedZ[z2], triangleColours[triangle]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate bool method486(int i, int j, int k, int l, int i1, int j1, int k1, int l1)\n\t\t{\n\t\t\tif(j < k && j < l && j < i1)\n\t\t\t\treturn false;\n\t\t\tif(j > k && j > l && j > i1)\n\t\t\t\treturn false;\n\t\t\treturn !(i < j1 && i < k1 && i < l1) && (i <= j1 || i <= k1 || i <= l1);\n\t\t}\n\n\t\tpublic void mirror()\n\t\t{\n\t\t\tfor(int vertex = 0; vertex < vertexCount; vertex++)\n\t\t\t\tverticesZ[vertex] = -verticesZ[vertex];\n\n\t\t\tfor(int triangle = 0; triangle < triangleCount; triangle++)\n\t\t\t{\n\t\t\t\tint newTriangleC = triangleX[triangle];\n\t\t\t\ttriangleX[triangle] = triangleZ[triangle];\n\t\t\t\ttriangleZ[triangle] = newTriangleC;\n\t\t\t}\n\t\t}\n\n\t\tpublic void mixAnimationFrames(int[] framesFrom2, int frameId2, int frameId1)\n\t\t{\n\t\t\tif(frameId1 == -1)\n\t\t\t\treturn;\n\t\t\tif(framesFrom2 == null || frameId2 == -1)\n\t\t\t{\n\t\t\t\tapplyTransformation(frameId1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tAnimation animationFrame1 = Animation.forFrameId(frameId1);\n\t\t\tif(animationFrame1 == null)\n\t\t\t\treturn;\n\t\t\tAnimation animationFrame2 = Animation.forFrameId(frameId2);\n\t\t\tif(animationFrame2 == null)\n\t\t\t{\n\t\t\t\tapplyTransformation(frameId1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tSkins skins = animationFrame1.animationSkins;\n\t\t\tvertexModifierX = 0;\n\t\t\tvertexModifierY = 0;\n\t\t\tvertexModifierZ = 0;\n\t\t\tint counter = 0;\n\t\t\tint frameCount = framesFrom2[counter++];\n\t\t\tfor(int frame = 0; frame < animationFrame1.frameCount; frame++)\n\t\t\t{\n\t\t\t\tint skin;\n\t\t\t\tfor(skin = animationFrame1.opcodeTable[frame]; skin > frameCount; frameCount = framesFrom2[counter++])\n\t\t\t\t\t;\n\t\t\t\tif(skin != frameCount || skins.opcodes[skin] == 0)\n\t\t\t\t\ttransformFrame(skins.opcodes[skin], skins.skinList[skin], animationFrame1.transformationX[frame],\n\t\t\t\t\t\tanimationFrame1.transformationY[frame], animationFrame1.transformationZ[frame]);\n\t\t\t}\n\n\t\t\tvertexModifierX = 0;\n\t\t\tvertexModifierY = 0;\n\t\t\tvertexModifierZ = 0;\n\t\t\tcounter = 0;\n\t\t\tframeCount = framesFrom2[counter++];\n\t\t\tfor(int frame = 0; frame < animationFrame2.frameCount; frame++)\n\t\t\t{\n\t\t\t\tint skin;\n\t\t\t\tfor(skin = animationFrame2.opcodeTable[frame]; skin > frameCount; frameCount = framesFrom2[counter++])\n\t\t\t\t\t;\n\t\t\t\tif(skin == frameCount || skins.opcodes[skin] == 0)\n\t\t\t\t\ttransformFrame(skins.opcodes[skin], skins.skinList[skin], animationFrame2.transformationX[frame],\n\t\t\t\t\t\tanimationFrame2.transformationY[frame], animationFrame2.transformationZ[frame]);\n\t\t\t}\n\n\t\t}\n\n\t\tpublic void normalise()\n\t\t{\n\t\t\tbase.modelHeight = 0;\n\t\t\tmaxY = 0;\n\t\t\tfor(int vertex = 0; vertex < vertexCount; vertex++)\n\t\t\t{\n\t\t\t\tint y = verticesY[vertex];\n\t\t\t\tif(-y > base.modelHeight)\n\t\t\t\t\tbase.modelHeight = -y;\n\t\t\t\tif(y > maxY)\n\t\t\t\t\tmaxY = y;\n\t\t\t}\n\n\t\t\tdiagonal3DAboveOrigin = (int)(Math.Sqrt(diagonal2DAboveOrigin * diagonal2DAboveOrigin + base.modelHeight * base.modelHeight)\n\t\t\t\t\t\t\t\t\t\t   + 0.98999999999999999D);\n\t\t\tdiagonal3D = diagonal3DAboveOrigin\n\t\t\t\t\t\t + (int)(Math.Sqrt(diagonal2DAboveOrigin * diagonal2DAboveOrigin + maxY * maxY) + 0.98999999999999999D);\n\t\t}\n\n\t\tprivate void rasterise(int i)\n\t\t{\n\t\t\tif(aboolArray1664[i])\n\t\t\t{\n\t\t\t\tmethod485(i);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tint x = triangleX[i];\n\t\t\tint y = triangleY[i];\n\t\t\tint z = triangleZ[i];\n\t\t\tRasterizer.restrictEdges = restrictEdges[i];\n\t\t\tif(triangleAlpha == null)\n\t\t\t\tRasterizer.alpha = 0;\n\t\t\telse\n\t\t\t\tRasterizer.alpha = triangleAlpha[i];\n\t\t\tint drawType;\n\t\t\tif(triangleDrawType == null)\n\t\t\t\tdrawType = 0;\n\t\t\telse\n\t\t\t\tdrawType = triangleDrawType[i] & 3;\n\t\t\tif(drawType == 0)\n\t\t\t{\n\t\t\t\tRasterizer.drawShadedTriangle(vertexScreenY[x], vertexScreenY[y], vertexScreenY[z], vertexScreenX[x],\n\t\t\t\t\tvertexScreenX[y], vertexScreenX[z], triangleHSLA[i], triangleHSLB[i], triangleHSLC[i]);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(drawType == 1)\n\t\t\t{\n\t\t\t\tRasterizer.drawFlatTriangle(vertexScreenY[x], vertexScreenY[y], vertexScreenY[z], vertexScreenX[x],\n\t\t\t\t\tvertexScreenX[y], vertexScreenX[z], HSLtoRGB[triangleHSLA[i]]);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(drawType == 2)\n\t\t\t{\n\t\t\t\tint triangle = triangleDrawType[i] >> 2;\n\t\t\t\tint x2 = texturedTrianglePointsX[triangle];\n\t\t\t\tint y2 = texturedTrianglePointsY[triangle];\n\t\t\t\tint z2 = texturedTrianglePointsZ[triangle];\n\t\t\t\tRasterizer.drawTexturedTriangle(vertexScreenY[x], vertexScreenY[y], vertexScreenY[z], vertexScreenX[x],\n\t\t\t\t\tvertexScreenX[y], vertexScreenX[z], triangleHSLA[i], triangleHSLB[i], triangleHSLC[i],\n\t\t\t\t\tvertexMovedX[x2], vertexMovedX[y2], vertexMovedX[z2], vertexMovedY[x2], vertexMovedY[y2],\n\t\t\t\t\tvertexMovedY[z2], vertexMovedZ[x2], vertexMovedZ[y2], vertexMovedZ[z2], triangleColours[i]);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(drawType == 3)\n\t\t\t{\n\t\t\t\tint triangle = triangleDrawType[i] >> 2;\n\t\t\t\tint x2 = texturedTrianglePointsX[triangle];\n\t\t\t\tint y2 = texturedTrianglePointsY[triangle];\n\t\t\t\tint z2 = texturedTrianglePointsZ[triangle];\n\t\t\t\tRasterizer.drawTexturedTriangle(vertexScreenY[x], vertexScreenY[y], vertexScreenY[z], vertexScreenX[x],\n\t\t\t\t\tvertexScreenX[y], vertexScreenX[z], triangleHSLA[i], triangleHSLA[i], triangleHSLA[i],\n\t\t\t\t\tvertexMovedX[x2], vertexMovedX[y2], vertexMovedX[z2], vertexMovedY[x2], vertexMovedY[y2],\n\t\t\t\t\tvertexMovedY[z2], vertexMovedZ[x2], vertexMovedZ[y2], vertexMovedZ[z2], triangleColours[i]);\n\t\t\t}\n\t\t}\n\n\t\tpublic void recolour(int targetColour, int replacementColour)\n\t\t{\n\t\t\tfor(int triangle = 0; triangle < triangleCount; triangle++)\n\t\t\t\tif(triangleColours[triangle] == targetColour)\n\t\t\t\t\ttriangleColours[triangle] = replacementColour;\n\n\t\t}\n\n\t\tpublic override void renderAtPoint(int i, int yCameraSine, int yCameraCosine, int xCameraSine, int xCameraCosine, int x,\n\t\t\tint y, int z, int i2)\n\t\t{\n\t\t\tunchecked\n\t\t\t{\n\t\t\t\tint j2 = z * xCameraCosine - x * xCameraSine >> 16;\n\t\t\t\tint k2 = y * yCameraSine + j2 * yCameraCosine >> 16;\n\t\t\t\tint l2 = diagonal2DAboveOrigin * yCameraCosine >> 16;\n\t\t\t\tint i3 = k2 + l2;\n\t\t\t\tif(i3 <= 50 || k2 >= 3500)\n\t\t\t\t\treturn;\n\t\t\t\tint j3 = z * xCameraSine + x * xCameraCosine >> 16;\n\t\t\t\tint k3 = j3 - diagonal2DAboveOrigin << 9;\n\t\t\t\tif(k3 \/ i3 >= DrawingArea.viewportCentreX)\n\t\t\t\t\treturn;\n\t\t\t\tint l3 = j3 + diagonal2DAboveOrigin << 9;\n\t\t\t\tif(l3 \/ i3 <= -DrawingArea.viewportCentreX)\n\t\t\t\t\treturn;\n\t\t\t\tint i4 = y * yCameraCosine - j2 * yCameraSine >> 16;\n\t\t\t\tint j4 = diagonal2DAboveOrigin * yCameraSine >> 16;\n\t\t\t\tint k4 = i4 + j4 << 9;\n\t\t\t\tif(k4 \/ i3 <= -DrawingArea.viewportCentreY)\n\t\t\t\t\treturn;\n\t\t\t\tint l4 = j4 + (base.modelHeight * yCameraCosine >> 16);\n\t\t\t\tint i5 = i4 - l4 << 9;\n\t\t\t\tif(i5 \/ i3 >= DrawingArea.viewportCentreY)\n\t\t\t\t\treturn;\n\t\t\t\tint j5 = l2 + (base.modelHeight * yCameraSine >> 16);\n\t\t\t\tbool flag = false;\n\t\t\t\tif(k2 - j5 <= 50)\n\t\t\t\t\tflag = true;\n\t\t\t\tbool flag1 = false;\n\t\t\t\tif(i2 > 0 && abool1684)\n\t\t\t\t{\n\t\t\t\t\tint k5 = k2 - l2;\n\t\t\t\t\tif(k5 <= 50)\n\t\t\t\t\t\tk5 = 50;\n\t\t\t\t\tif(j3 > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tk3 \/= i3;\n\t\t\t\t\t\tl3 \/= k5;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tl3 \/= i3;\n\t\t\t\t\t\tk3 \/= k5;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(i4 > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\ti5 \/= i3;\n\t\t\t\t\t\tk4 \/= k5;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tk4 \/= i3;\n\t\t\t\t\t\ti5 \/= k5;\n\t\t\t\t\t}\n\n\t\t\t\t\tint i6 = cursorX - Rasterizer.centreX;\n\t\t\t\t\tint k6 = cursorY - Rasterizer.centreY;\n\t\t\t\t\tif(i6 > k3 && i6 < l3 && k6 > i5 && k6 < k4)\n\t\t\t\t\t\tif(singleTile)\n\t\t\t\t\t\t\tresourceId[resourceCount++] = i2;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tflag1 = true;\n\t\t\t\t}\n\n\t\t\t\tint centreX = Rasterizer.centreX;\n\t\t\t\tint centreY = Rasterizer.centreY;\n\t\t\t\tint sine = 0;\n\t\t\t\tint cosine = 0;\n\t\t\t\tif(i != 0)\n\t\t\t\t{\n\t\t\t\t\tsine = SINE[i];\n\t\t\t\t\tcosine = COSINE[i];\n\t\t\t\t}\n\n\t\t\t\tfor(int vertex = 0; vertex < vertexCount; vertex++)\n\t\t\t\t{\n\t\t\t\t\tint x2 = verticesX[vertex];\n\t\t\t\t\tint y2 = verticesY[vertex];\n\t\t\t\t\tint z2 = verticesZ[vertex];\n\t\t\t\t\tif(i != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tint newX2 = z2 * sine + x2 * cosine >> 16;\n\t\t\t\t\t\tz2 = z2 * cosine - x2 * sine >> 16;\n\t\t\t\t\t\tx2 = newX2;\n\t\t\t\t\t}\n\n\t\t\t\t\tx2 += x;\n\t\t\t\t\ty2 += y;\n\t\t\t\t\tz2 += z;\n\t\t\t\t\tint translation = z2 * xCameraSine + x2 * xCameraCosine >> 16;\n\t\t\t\t\tz2 = z2 * xCameraCosine - x2 * xCameraSine >> 16;\n\t\t\t\t\tx2 = translation;\n\n\t\t\t\t\ttranslation = y2 * yCameraCosine - z2 * yCameraSine >> 16;\n\t\t\t\t\tz2 = y2 * yCameraSine + z2 * yCameraCosine >> 16;\n\t\t\t\t\ty2 = translation;\n\t\t\t\t\tvertexScreenZ[vertex] = z2 - k2;\n\t\t\t\t\tif(z2 >= 50)\n\t\t\t\t\t{\n\t\t\t\t\t\tvertexScreenX[vertex] = centreX + (x2 << 9) \/ z2;\n\t\t\t\t\t\tvertexScreenY[vertex] = centreY + (y2 << 9) \/ z2;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvertexScreenX[vertex] = -5000;\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(flag || texturedTriangleCount > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tvertexMovedX[vertex] = x2;\n\t\t\t\t\t\tvertexMovedY[vertex] = y2;\n\t\t\t\t\t\tvertexMovedZ[vertex] = z2;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tmethod483(flag, flag1, i2);\n\t\t\t\t}\n\t\t\t\tcatch(Exception _ex)\n\t\t\t\t{\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void renderSingle(int rotationY, int rotationZ, int rotationXW, int translationX, int translationY,\n\t\t\tint translationZ)\n\t\t{\n\t\t\tint rotationX = 0; \/\/ was a parameter\n\t\t\tint centerX = Rasterizer.centreX;\n\t\t\tint centerY = Rasterizer.centreY;\n\t\t\tint sineX = SINE[rotationX];\n\t\t\tint cosineX = COSINE[rotationX];\n\t\t\tint sineY = SINE[rotationY];\n\t\t\tint cosineY = COSINE[rotationY];\n\t\t\tint sineZ = SINE[rotationZ];\n\t\t\tint cosineZ = COSINE[rotationZ];\n\t\t\tint sineXW = SINE[rotationXW];\n\t\t\tint cosineXW = COSINE[rotationXW];\n\t\t\tint transformation = translationY * sineXW + translationZ * cosineXW >> 16;\n\t\t\tfor(int vertex = 0; vertex < vertexCount; vertex++)\n\t\t\t{\n\t\t\t\tint x = verticesX[vertex];\n\t\t\t\tint y = verticesY[vertex];\n\t\t\t\tint z = verticesZ[vertex];\n\t\t\t\tif(rotationZ != 0)\n\t\t\t\t{\n\t\t\t\t\tint newX = y * sineZ + x * cosineZ >> 16;\n\t\t\t\t\ty = y * cosineZ - x * sineZ >> 16;\n\t\t\t\t\tx = newX;\n\t\t\t\t}\n\n\t\t\t\tint newY;\n\n\t\t\t\tif(rotationX != 0)\n\t\t\t\t{\n\t\t\t\t\tnewY = y * cosineX - z * sineX >> 16;\n\t\t\t\t\tz = y * sineX + z * cosineX >> 16;\n\t\t\t\t\ty = newY;\n\t\t\t\t}\n\n\t\t\t\tif(rotationY != 0)\n\t\t\t\t{\n\t\t\t\t\tint newX = z * sineY + x * cosineY >> 16;\n\t\t\t\t\tz = z * cosineY - x * sineY >> 16;\n\t\t\t\t\tx = newX;\n\t\t\t\t}\n\n\t\t\t\tx += translationX;\n\t\t\t\ty += translationY;\n\t\t\t\tz += translationZ;\n\t\t\t\tnewY = y * cosineXW - z * sineXW >> 16;\n\t\t\t\tz = y * sineXW + z * cosineXW >> 16;\n\t\t\t\ty = newY;\n\t\t\t\tvertexScreenZ[vertex] = z - transformation;\n\t\t\t\tvertexScreenX[vertex] = centerX + (x << 9) \/ z;\n\t\t\t\tvertexScreenY[vertex] = centerY + (y << 9) \/ z;\n\t\t\t\tif(texturedTriangleCount > 0)\n\t\t\t\t{\n\t\t\t\t\tvertexMovedX[vertex] = x;\n\t\t\t\t\tvertexMovedY[vertex] = y;\n\t\t\t\t\tvertexMovedZ[vertex] = z;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tmethod483(false, false, 0);\n\t\t\t}\n\t\t\tcatch(Exception _ex)\n\t\t\t{\n\t\t\t}\n\t\t}\n\n\t\tpublic void replaceWithModel(Model model, bool replaceAlpha)\n\t\t{\n\t\t\tvertexCount = model.vertexCount;\n\t\t\ttriangleCount = model.triangleCount;\n\t\t\ttexturedTriangleCount = model.texturedTriangleCount;\n\t\t\tif(anIntArray1622.Length < vertexCount)\n\t\t\t{\n\t\t\t\tanIntArray1622 = new int[vertexCount + 100];\n\t\t\t\tanIntArray1623 = new int[vertexCount + 100];\n\t\t\t\tanIntArray1624 = new int[vertexCount + 100];\n\t\t\t}\n\n\t\t\tverticesX = anIntArray1622;\n\t\t\tverticesY = anIntArray1623;\n\t\t\tverticesZ = anIntArray1624;\n\t\t\tfor(int vertex = 0; vertex < vertexCount; vertex++)\n\t\t\t{\n\t\t\t\tverticesX[vertex] = model.verticesX[vertex];\n\t\t\t\tverticesY[vertex] = model.verticesY[vertex];\n\t\t\t\tverticesZ[vertex] = model.verticesZ[vertex];\n\t\t\t}\n\n\t\t\tif(replaceAlpha)\n\t\t\t{\n\t\t\t\ttriangleAlpha = model.triangleAlpha;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(anIntArray1625.Length < triangleCount)\n\t\t\t\t\tanIntArray1625 = new int[triangleCount + 100];\n\t\t\t\ttriangleAlpha = anIntArray1625;\n\t\t\t\tif(model.triangleAlpha == null)\n\t\t\t\t{\n\t\t\t\t\tfor(int triangle = 0; triangle < triangleCount; triangle++)\n\t\t\t\t\t\ttriangleAlpha[triangle] = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tSystem.Buffer.BlockCopy(model.triangleAlpha, 0, triangleAlpha, 0, sizeof(int) * triangleCount);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttriangleDrawType = model.triangleDrawType;\n\t\t\ttriangleColours = model.triangleColours;\n\t\t\ttrianglePriorities = model.trianglePriorities;\n\t\t\ttrianglePriority = model.trianglePriority;\n\t\t\ttriangleSkin = model.triangleSkin;\n\t\t\tvertexSkin = model.vertexSkin;\n\t\t\ttriangleX = model.triangleX;\n\t\t\ttriangleY = model.triangleY;\n\t\t\ttriangleZ = model.triangleZ;\n\t\t\ttriangleHSLA = model.triangleHSLA;\n\t\t\ttriangleHSLB = model.triangleHSLB;\n\t\t\ttriangleHSLC = model.triangleHSLC;\n\t\t\ttexturedTrianglePointsX = model.texturedTrianglePointsX;\n\t\t\ttexturedTrianglePointsY = model.texturedTrianglePointsY;\n\t\t\ttexturedTrianglePointsZ = model.texturedTrianglePointsZ;\n\t\t}\n\n\t\tpublic void rotate90Degrees()\n\t\t{\n\t\t\tfor(int vertex = 0; vertex < vertexCount; vertex++)\n\t\t\t{\n\t\t\t\tint vertexX = verticesX[vertex];\n\t\t\t\tverticesX[vertex] = verticesZ[vertex];\n\t\t\t\tverticesZ[vertex] = -vertexX;\n\t\t\t}\n\t\t}\n\n\t\tpublic void rotateX(int degrees)\n\t\t{\n\t\t\tint sine = SINE[degrees];\n\t\t\tint cosine = COSINE[degrees];\n\t\t\tfor(int vertex = 0; vertex < vertexCount; vertex++)\n\t\t\t{\n\t\t\t\tint newVertexY = verticesY[vertex] * cosine - verticesZ[vertex] * sine >> 16;\n\t\t\t\tverticesZ[vertex] = verticesY[vertex] * sine + verticesZ[vertex] * cosine >> 16;\n\t\t\t\tverticesY[vertex] = newVertexY;\n\t\t\t}\n\t\t}\n\n\t\tpublic void scaleT(int x, int z, int y)\n\t\t{\n\t\t\tfor(int vertex = 0; vertex < vertexCount; vertex++)\n\t\t\t{\n\t\t\t\tverticesX[vertex] = (verticesX[vertex] * x) \/ 128;\n\t\t\t\tverticesY[vertex] = (verticesY[vertex] * y) \/ 128;\n\t\t\t\tverticesZ[vertex] = (verticesZ[vertex] * z) \/ 128;\n\t\t\t}\n\n\t\t}\n\n\t\tprivate void transformFrame(int opcode, int[] skinList, int vertexTransformationX, int vertexTransformationY,\n\t\t\tint vertexTransformationZ)\n\t\t{\n\t\t\tint skinListCount = skinList.Length;\n\t\t\tif(opcode == 0)\n\t\t\t{\n\t\t\t\tint affectedSkins = 0;\n\t\t\t\tvertexModifierX = 0;\n\t\t\t\tvertexModifierY = 0;\n\t\t\t\tvertexModifierZ = 0;\n\t\t\t\tfor(int skinListId = 0; skinListId < skinListCount; skinListId++)\n\t\t\t\t{\n\t\t\t\t\tint skinId = skinList[skinListId];\n\t\t\t\t\tif(skinId < vertexSkin.Length)\n\t\t\t\t\t{\n\t\t\t\t\t\tint[] vertexSkins = vertexSkin[skinId];\n\t\t\t\t\t\tfor(int skin = 0; skin < vertexSkins.Length; skin++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint vertex = vertexSkins[skin];\n\t\t\t\t\t\t\tvertexModifierX += verticesX[vertex];\n\t\t\t\t\t\t\tvertexModifierY += verticesY[vertex];\n\t\t\t\t\t\t\tvertexModifierZ += verticesZ[vertex];\n\t\t\t\t\t\t\taffectedSkins++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(affectedSkins > 0)\n\t\t\t\t{\n\t\t\t\t\tvertexModifierX = vertexModifierX \/ affectedSkins + vertexTransformationX;\n\t\t\t\t\tvertexModifierY = vertexModifierY \/ affectedSkins + vertexTransformationY;\n\t\t\t\t\tvertexModifierZ = vertexModifierZ \/ affectedSkins + vertexTransformationZ;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvertexModifierX = vertexTransformationX;\n\t\t\t\t\tvertexModifierY = vertexTransformationY;\n\t\t\t\t\tvertexModifierZ = vertexTransformationZ;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(opcode == 1)\n\t\t\t{\n\t\t\t\tfor(int skinListId = 0; skinListId < skinListCount; skinListId++)\n\t\t\t\t{\n\t\t\t\t\tint skinId = skinList[skinListId];\n\t\t\t\t\tif(skinId < vertexSkin.Length) \/\/WARNING: Rank is a lot less ambigious\n\t\t\t\t\t{\n\t\t\t\t\t\tint[] vertexSkins = vertexSkin[skinId];\n\t\t\t\t\t\tfor(int skin = 0; skin < vertexSkins.Length; skin++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint vertex = vertexSkins[skin];\n\t\t\t\t\t\t\tverticesX[vertex] += vertexTransformationX;\n\t\t\t\t\t\t\tverticesY[vertex] += vertexTransformationY;\n\t\t\t\t\t\t\tverticesZ[vertex] += vertexTransformationZ;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(opcode == 2)\n\t\t\t{\n\t\t\t\tfor(int skinListId = 0; skinListId < skinListCount; skinListId++)\n\t\t\t\t{\n\t\t\t\t\tint skinId = skinList[skinListId];\n\t\t\t\t\tif(skinId < vertexSkin.Length) \/\/WARNING: Rank is a lot less ambigious\n\t\t\t\t\t{\n\t\t\t\t\t\tint[] vertexSkins = vertexSkin[skinId];\n\t\t\t\t\t\tfor(int skin = 0; skin < vertexSkins.Length; skin++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint vertex = vertexSkins[skin];\n\t\t\t\t\t\t\tverticesX[vertex] -= vertexModifierX;\n\t\t\t\t\t\t\tverticesY[vertex] -= vertexModifierY;\n\t\t\t\t\t\t\tverticesZ[vertex] -= vertexModifierZ;\n\t\t\t\t\t\t\tint rotationX = (vertexTransformationX & 0xff) * 8;\n\t\t\t\t\t\t\tint rotationY = (vertexTransformationY & 0xff) * 8;\n\t\t\t\t\t\t\tint rotationZ = (vertexTransformationZ & 0xff) * 8;\n\t\t\t\t\t\t\tif(rotationZ != 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint sine = SINE[rotationZ];\n\t\t\t\t\t\t\t\tint cosine = COSINE[rotationZ];\n\t\t\t\t\t\t\t\tint newVertexX = verticesY[vertex] * sine + verticesX[vertex] * cosine >> 16;\n\t\t\t\t\t\t\t\tverticesY[vertex] = verticesY[vertex] * cosine - verticesX[vertex] * sine >> 16;\n\t\t\t\t\t\t\t\tverticesX[vertex] = newVertexX;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(rotationX != 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint sine = SINE[rotationX];\n\t\t\t\t\t\t\t\tint cosine = COSINE[rotationX];\n\t\t\t\t\t\t\t\tint newVertexY = verticesY[vertex] * cosine - verticesZ[vertex] * sine >> 16;\n\t\t\t\t\t\t\t\tverticesZ[vertex] = verticesY[vertex] * sine + verticesZ[vertex] * cosine >> 16;\n\t\t\t\t\t\t\t\tverticesY[vertex] = newVertexY;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(rotationY != 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint sine = SINE[rotationY];\n\t\t\t\t\t\t\t\tint cosine = COSINE[rotationY];\n\t\t\t\t\t\t\t\tint newVertexZ = verticesZ[vertex] * sine + verticesX[vertex] * cosine >> 16;\n\t\t\t\t\t\t\t\tverticesZ[vertex] = verticesZ[vertex] * cosine - verticesX[vertex] * sine >> 16;\n\t\t\t\t\t\t\t\tverticesX[vertex] = newVertexZ;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tverticesX[vertex] += vertexModifierX;\n\t\t\t\t\t\t\tverticesY[vertex] += vertexModifierY;\n\t\t\t\t\t\t\tverticesZ[vertex] += vertexModifierZ;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(opcode == 3)\n\t\t\t{\n\t\t\t\tfor(int skinListId = 0; skinListId < skinListCount; skinListId++)\n\t\t\t\t{\n\t\t\t\t\tint skinId = skinList[skinListId];\n\t\t\t\t\tif(skinId < vertexSkin.Length) \/\/Rank is less ambigious\n\t\t\t\t\t{\n\t\t\t\t\t\tint[] vertexSkins = vertexSkin[skinId];\n\t\t\t\t\t\tfor(int skin = 0; skin < vertexSkins.Length; skin++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint vertex = vertexSkins[skin];\n\t\t\t\t\t\t\tverticesX[vertex] -= vertexModifierX;\n\t\t\t\t\t\t\tverticesY[vertex] -= vertexModifierY;\n\t\t\t\t\t\t\tverticesZ[vertex] -= vertexModifierZ;\n\t\t\t\t\t\t\tverticesX[vertex] = (verticesX[vertex] * vertexTransformationX) \/ 128;\n\t\t\t\t\t\t\tverticesY[vertex] = (verticesY[vertex] * vertexTransformationY) \/ 128;\n\t\t\t\t\t\t\tverticesZ[vertex] = (verticesZ[vertex] * vertexTransformationZ) \/ 128;\n\t\t\t\t\t\t\tverticesX[vertex] += vertexModifierX;\n\t\t\t\t\t\t\tverticesY[vertex] += vertexModifierY;\n\t\t\t\t\t\t\tverticesZ[vertex] += vertexModifierZ;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif(opcode == 5 && triangleSkin != null && triangleAlpha != null)\n\t\t\t{\n\t\t\t\tfor(int skinListId = 0; skinListId < skinListCount; skinListId++)\n\t\t\t\t{\n\t\t\t\t\tint skinId = skinList[skinListId];\n\t\t\t\t\tif(skinId < triangleSkin.Length) \/\/Rank is less ambigious\n\t\t\t\t\t{\n\t\t\t\t\t\tint[] triangleSkins = triangleSkin[skinId];\n\t\t\t\t\t\tfor(int skin = 0; skin < triangleSkins.Length; skin++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint triangle = triangleSkins[skin];\n\t\t\t\t\t\t\ttriangleAlpha[triangle] += vertexTransformationX * 8;\n\t\t\t\t\t\t\tif(triangleAlpha[triangle] < 0)\n\t\t\t\t\t\t\t\ttriangleAlpha[triangle] = 0;\n\t\t\t\t\t\t\tif(triangleAlpha[triangle] > 255)\n\t\t\t\t\t\t\t\ttriangleAlpha[triangle] = 255;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tpublic void translate(int x, int y, int z)\n\t\t{\n\t\t\tfor(int vertex = 0; vertex < vertexCount; vertex++)\n\t\t\t{\n\t\t\t\tverticesX[vertex] += x;\n\t\t\t\tverticesY[vertex] += y;\n\t\t\t\tverticesZ[vertex] += z;\n\t\t\t}\n\n\t\t}\n\t}\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"cb2cd4e93ffb7a845a1013f5949fb2dd727ebd0e","subject":"cai-nav-rcn-interop: Add to source. Early\/Unstable","message":"cai-nav-rcn-interop: Add to source. Early\/Unstable","repos":"stevefsp\/critterai,stevefsp\/critterai,stevefsp\/critterai,stevefsp\/critterai,stevefsp\/critterai","old_file":"nav\/rcn-interop\/Properties\/AssemblyInfo.cs","new_file":"nav\/rcn-interop\/Properties\/AssemblyInfo.cs","new_contents":"\ufeff\/*\r\n * Copyright (c) 2011 Stephen A. Pratt\r\n * \r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n * \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n * \r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n *\/\r\nusing System.Reflection;\r\nusing System.Runtime.CompilerServices;\r\nusing System.Runtime.InteropServices;\r\n\r\n\/\/ General Information about an assembly is controlled through the following \r\n\/\/ set of attributes. Change these attribute values to modify the information\r\n\/\/ associated with an assembly.\r\n[assembly: AssemblyTitle(\"cai-nav-rcn-interop\")]\r\n[assembly: AssemblyDescription(\"\")]\r\n[assembly: AssemblyConfiguration(\"\")]\r\n[assembly: AssemblyCompany(\"CritterAI\")]\r\n[assembly: AssemblyProduct(\"cai-nav-rcn-interop\")]\r\n[assembly: AssemblyCopyright(\"Copyright \u00a9 Stephen Pratt 2011\")]\r\n[assembly: AssemblyTrademark(\"\")]\r\n[assembly: AssemblyCulture(\"\")]\r\n\r\n\/\/ Setting ComVisible to false makes the types in this assembly not visible \r\n\/\/ to COM components.  If you need to access a type in this assembly from \r\n\/\/ COM, set the ComVisible attribute to true on that type.\r\n[assembly: ComVisible(false)]\r\n\r\n\/\/ The following GUID is for the ID of the typelib if this project is exposed to COM\r\n[assembly: Guid(\"137f5997-0d1c-4cb0-b00c-e6d5f68a5f0c\")]\r\n\r\n\/\/ Version information for an assembly consists of the following four values:\r\n\/\/\r\n\/\/      Major Version\r\n\/\/      Minor Version \r\n\/\/      Build Number\r\n\/\/      Revision\r\n\/\/\r\n\/\/ You can specify all the values or you can default the Build and Revision Numbers \r\n\/\/ by using the '*' as shown below:\r\n\/\/ [assembly: AssemblyVersion(\"1.0.*\")]\r\n[assembly: AssemblyVersion(\"0.1.0.0\")]\r\n[assembly: AssemblyFileVersion(\"0.1.0.0\")]\r\n","old_contents":"\ufeffusing System.Reflection;\r\nusing System.Runtime.CompilerServices;\r\nusing System.Runtime.InteropServices;\r\n\r\n\/\/ General Information about an assembly is controlled through the following \r\n\/\/ set of attributes. Change these attribute values to modify the information\r\n\/\/ associated with an assembly.\r\n[assembly: AssemblyTitle(\"cai-nav-rcn-interop\")]\r\n[assembly: AssemblyDescription(\"\")]\r\n[assembly: AssemblyConfiguration(\"\")]\r\n[assembly: AssemblyCompany(\"CritterAI\")]\r\n[assembly: AssemblyProduct(\"cai-nav-rcn-interop\")]\r\n[assembly: AssemblyCopyright(\"Copyright \u00a9 Stephen Pratt 2011\")]\r\n[assembly: AssemblyTrademark(\"\")]\r\n[assembly: AssemblyCulture(\"\")]\r\n\r\n\/\/ Setting ComVisible to false makes the types in this assembly not visible \r\n\/\/ to COM components.  If you need to access a type in this assembly from \r\n\/\/ COM, set the ComVisible attribute to true on that type.\r\n[assembly: ComVisible(false)]\r\n\r\n\/\/ The following GUID is for the ID of the typelib if this project is exposed to COM\r\n[assembly: Guid(\"137f5997-0d1c-4cb0-b00c-e6d5f68a5f0c\")]\r\n\r\n\/\/ Version information for an assembly consists of the following four values:\r\n\/\/\r\n\/\/      Major Version\r\n\/\/      Minor Version \r\n\/\/      Build Number\r\n\/\/      Revision\r\n\/\/\r\n\/\/ You can specify all the values or you can default the Build and Revision Numbers \r\n\/\/ by using the '*' as shown below:\r\n\/\/ [assembly: AssemblyVersion(\"1.0.*\")]\r\n[assembly: AssemblyVersion(\"0.1.0.0\")]\r\n[assembly: AssemblyFileVersion(\"0.1.0.0\")]\r\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"47e647c5528fc204322d00ebc0796ce81b10661e","subject":"Animated console defaults to not using the mouse.","message":"Animated console defaults to not using the mouse.\n","repos":"Thraka\/SadConsole","old_file":"src\/SadConsole\/AnimatedConsole.cs","new_file":"src\/SadConsole\/AnimatedConsole.cs","new_contents":"\ufeff#if XNA\nusing Microsoft.Xna.Framework;\n#endif\n\nnamespace SadConsole\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Collections.ObjectModel;\n    using Newtonsoft.Json;\n\n    \/\/\/ <summary>\n    \/\/\/ Animates a list of frames.\n    \/\/\/ <\/summary>\n    [System.Diagnostics.DebuggerDisplay(\"Console (Animated)\")]\n    [JsonConverter(typeof(SerializedTypes.AnimatedConsoleConverterJson))]\n    public class AnimatedConsole : Console\n    {\n        private float _animatedTime;\n        private AnimationState _state;\n\n        \/\/\/ <summary>\n        \/\/\/ Raised when the <see cref=\"AnimationState\"\/> changes.\n        \/\/\/ <\/summary>\n        public event EventHandler<AnimationStateChangedEventArgs> AnimationStateChanged;\n\n        \/\/\/ <summary>\n        \/\/\/ The frames of animation.\n        \/\/\/ <\/summary>\n        \/\/\/ <remarks>If this collection changes, <see cref=\"CurrentFrameIndexValue\"\/>, <see cref=\"UpdateFrameReferences\"\/>, and <see cref=\"TimePerFrame\"\/> should all be recalculated.<\/remarks>\n        protected internal List<CellSurface> FramesList = new List<CellSurface>();\n\n        \/\/\/ <summary>\n        \/\/\/ Time counter for the animation\n        \/\/\/ <\/summary>\n        protected double AddedTime;\n\n        \/\/\/ <summary>\n        \/\/\/ The current frame index being animated.\n        \/\/\/ <\/summary>\n        protected int CurrentFrameIndexValue;\n\n        \/\/\/ <summary>\n        \/\/\/ How much time per animated frame should be used.\n        \/\/\/ <\/summary>\n        protected float TimePerFrame;\n\n        \/\/\/ <summary>\n        \/\/\/ All frames of the animation\n        \/\/\/ <\/summary>\n        public ReadOnlyCollection<CellSurface> Frames => FramesList.AsReadOnly();\n\n        \/\/\/ <summary>\n        \/\/\/ Center of the animation used in positioning.\n        \/\/\/ <\/summary>\n        public Point Center { get; set; }\n\n        \/\/\/ <summary>\n        \/\/\/ Indicates whether or not this animation will repeat once it has finished animating.\n        \/\/\/ <\/summary>\n        public bool Repeat { get; set; }\n\n        \/\/\/ <summary>\n        \/\/\/ When true, Indicates the animation is currently animating. The <see cref=\"Update\"\/> method will advance the frames.\n        \/\/\/ <\/summary>\n        public bool IsPlaying { get; protected set; }\n\n        \/\/\/ <summary>\n        \/\/\/ The length of the animation.\n        \/\/\/ <\/summary>\n        public float AnimationDuration\n        {\n            get => _animatedTime;\n            set { _animatedTime = value; CalculateFrameDuration(); }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the current frame index to animate.\n        \/\/\/ <\/summary>\n        public int CurrentFrameIndex\n        {\n            get => CurrentFrameIndexValue;\n            set\n            {\n                if (value < 0 || value >= FramesList.Count)\n                {\n                    CurrentFrameIndexValue = 0;\n                }\n                else\n                {\n                    CurrentFrameIndexValue = value;\n                }\n\n                UpdateFrameReferences();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Indicates the animation is empty.\n        \/\/\/ <\/summary>\n        public bool IsEmpty => FramesList.Count == 0;\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the name of this animation.\n        \/\/\/ <\/summary>\n        public string Name { get; set; }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the currently frame being animated.\n        \/\/\/ <\/summary>\n        public CellSurface CurrentFrame => FramesList[CurrentFrameIndexValue];\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the current animation state.\n        \/\/\/ <\/summary>\n        public AnimationState State\n        {\n            get => _state;\n            set\n            {\n                AnimationState oldState = _state;\n\n                if (value != _state)\n                {\n                    _state = value;\n                    AnimationStateChanged?.Invoke(this, new AnimationStateChangedEventArgs(oldState, _state));\n                }\n            }\n        }\n\n        #region Constructors\n        \/\/\/ <summary>\n        \/\/\/ Creates a new animation with the specified name, width, and height.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\">The name of the animation.<\/param>\n        \/\/\/ <param name=\"width\">The width of each frame this animation will have.<\/param>\n        \/\/\/ <param name=\"height\">The height of each frame this animation will have.<\/param>\n        public AnimatedConsole(string name, int width, int height) : this(name, width, height, Global.FontDefault)\n        {\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Creates a new animation with the specified name, width, and height.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\">The name of the animation.<\/param>\n        \/\/\/ <param name=\"width\">The width of each frame this animation will have.<\/param>\n        \/\/\/ <param name=\"height\">The height of each frame this animation will have.<\/param>\n        \/\/\/ <param name=\"font\">The font used with this animation.<\/param>\n        public AnimatedConsole(string name, int width, int height, Font font) : base(width, height, font)\n        {\n            UseMouse = false;\n            Name = name;\n        }\n        #endregion\n\n        \/\/\/ <summary>\n        \/\/\/ Forces the area of this text surface to always be the full width and height.\n        \/\/\/ <\/summary>\n        public override void SetRenderCells()\n        {\n            base.SetRenderCells();\n\n            if (FramesList.Count > 0)\n            {\n                UpdateFrameReferences();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Updates the base <see cref=\"CellSurface.Cells\"\/> references to the current frame.\n        \/\/\/ <\/summary>\n        protected void UpdateFrameReferences()\n        {\n            CellSurface frame = FramesList[CurrentFrameIndexValue];\n            Cells = RenderCells = frame.Cells;\n            DefaultBackground = frame.DefaultBackground;\n            DefaultForeground = frame.DefaultForeground;\n            IsDirty = true;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Creates a new frame with the same dimensions as this entity and adds it to the Frames collection of the entity.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The created frame.<\/returns>\n        public CellSurface CreateFrame()\n        {\n            if (FramesList == null)\n            {\n                FramesList = new List<CellSurface>();\n            }\n\n            var frame = new CellSurface(Width, Height) { DefaultBackground = DefaultBackground, DefaultForeground = DefaultForeground };\n            frame.Clear();\n            FramesList.Add(frame);\n            UpdateFrameReferences();\n            return frame;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Calculates the time needed per frame for rendering.\n        \/\/\/ <\/summary>\n        private void CalculateFrameDuration()\n        {\n            if (IsEmpty || _animatedTime == 0)\n            {\n                TimePerFrame = 0f;\n            }\n            else\n            {\n                TimePerFrame = _animatedTime \/ FramesList.Count;\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Stops animating.\n        \/\/\/ <\/summary>\n        public void Stop()\n        {\n            IsPlaying = false;\n            State = AnimationState.Stopped;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Starts animating the frames.\n        \/\/\/ <\/summary>\n        public void Start()\n        {\n            CalculateFrameDuration();\n            IsPlaying = true;\n            State = AnimationState.Playing;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Restarts the animation from the first frame.\n        \/\/\/ <\/summary>\n        public void Restart()\n        {\n            CalculateFrameDuration();\n            IsPlaying = true;\n            CurrentFrameIndex = 0;\n            State = AnimationState.Restarted;\n            State = AnimationState.Playing;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Updates the animation frames and calls update on the base class.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"timeElapsed\">The time elapsed since the last call in seconds.<\/param>\n        public override void Update(TimeSpan timeElapsed)\n        {\n            if (IsPlaying && TimePerFrame != 0)\n            {\n                \/\/ TODO: Evaluate if we should change this to calculate current frame based on total time passed, \\\\not calculate frame based on individual frame duration on screen.\n                AddedTime += timeElapsed.TotalSeconds;\n\n                if (AddedTime > TimePerFrame)\n                {\n                    AddedTime = 0f;\n                    CurrentFrameIndexValue++;\n\n                    if (CurrentFrameIndexValue >= FramesList.Count)\n                    {\n                        if (Repeat)\n                        {\n                            CurrentFrameIndexValue = 0;\n                            State = AnimationState.Restarted;\n                            State = AnimationState.Playing;\n                        }\n                        else\n                        {\n                            IsPlaying = false;\n                            CurrentFrameIndexValue--;\n                            State = AnimationState.Finished;\n                        }\n                    }\n\n                    UpdateFrameReferences();\n                }\n            }\n\n            base.Update(timeElapsed);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Returns the name of the animation.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The name.<\/returns>\n        public override string ToString() => Name;\n\n        \/\/\/ <inheritdoc \/>\n        public override void OnCalculateRenderPosition()\n        {\n            if (UsePixelPositioning)\n            {\n                CalculatedPosition = Position - Center + (Parent?.CalculatedPosition ?? Point.Zero);\n            }\n            else\n            {\n                CalculatedPosition = Position.ConsoleLocationToPixel(Font) - Center.ConsoleLocationToPixel(Font) + (Parent?.CalculatedPosition ?? Point.Zero);\n            }\n\n            foreach (Console child in Children)\n            {\n                child.OnCalculateRenderPosition();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Creates an animated surface that looks like static.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"width\">The width of the surface.<\/param>\n        \/\/\/ <param name=\"height\">The height of the surface.<\/param>\n        \/\/\/ <param name=\"frames\">How many frames the animation should have.<\/param>\n        \/\/\/ <param name=\"blankChance\">Chance a character will be blank. Characters are between index 48-158. Chance is evaluated versus <see cref=\"System.Random.NextDouble\"\/>.<\/param>\n        \/\/\/ <returns>An animation.<\/returns>\n        public static AnimatedConsole CreateStatic(int width, int height, int frames, double blankChance)\n        {\n            var animation = new AnimatedConsole(\"default\", width, height, Global.FontDefault)\n            {\n                DefaultBackground = Color.Black\n            };\n            for (int f = 0; f < frames; f++)\n            {\n                CellSurface frame = animation.CreateFrame();\n\n                for (int x = 0; x < width; x++)\n                {\n                    for (int y = 0; y < height; y++)\n                    {\n                        int character = Global.Random.Next(48, 168);\n\n                        if (Global.Random.NextDouble() <= blankChance)\n                        {\n                            character = 32;\n                        }\n\n                        frame.SetGlyph(x, y, character);\n                        frame.SetForeground(x, y, Color.White * (float)(Global.Random.NextDouble() * (1.0d - 0.5d) + 0.5d));\n                    }\n                }\n\n            }\n\n            animation.AnimationDuration = 1;\n            animation.Repeat = true;\n\n            animation.Start();\n\n            return animation;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Saves the <see cref=\"AnimatedConsole\"\/> to a file.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"file\">The destination file.<\/param>\n        public new void Save(string file) => Serializer.Save(this, file, Settings.SerializationIsCompressed);\n\n        \/\/\/ <summary>\n        \/\/\/ Loads a <see cref=\"AnimatedConsole\"\/> from a file.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"file\">The source file.<\/param>\n        \/\/\/ <returns><\/returns>\n        public static new AnimatedConsole Load(string file) => Serializer.Load<AnimatedConsole>(file, Settings.SerializationIsCompressed);\n\n        \/\/\/ <summary>\n        \/\/\/ Event args for when the animation state changes\n        \/\/\/ <\/summary>\n        public class AnimationStateChangedEventArgs : EventArgs\n        {\n            \/\/\/ <summary>\n            \/\/\/ The previous state.\n            \/\/\/ <\/summary>\n            public readonly AnimationState PreviousState;\n\n            \/\/\/ <summary>\n            \/\/\/ The new state.\n            \/\/\/ <\/summary>\n            public readonly AnimationState NewState;\n\n            \/\/\/ <summary>\n            \/\/\/ Creates a new instance of the event args.\n            \/\/\/ <\/summary>\n            \/\/\/ <param name=\"previousState\">The previous state.<\/param>\n            \/\/\/ <param name=\"newState\">The new state.<\/param>\n            public AnimationStateChangedEventArgs(AnimationState previousState, AnimationState newState)\n            {\n                PreviousState = previousState;\n                NewState = newState;\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Represents what state the animation is in.\n        \/\/\/ <\/summary>\n        public enum AnimationState\n        {\n            \/\/\/ <summary>\n            \/\/\/ The animation has never been played or was forcibly stopped.\n            \/\/\/ <\/summary>\n            Stopped,\n\n            \/\/\/ <summary>\n            \/\/\/ The animation is currently playing.\n            \/\/\/ <\/summary>\n            Playing,\n\n            \/\/\/ <summary>\n            \/\/\/ The animation was either manually restarted or repeated.\n            \/\/\/ <\/summary>\n            Restarted,\n\n            \/\/\/ <summary>\n            \/\/\/ The animation was played and completed.\n            \/\/\/ <\/summary>\n            Finished,\n\n            \/\/\/ <summary>\n            \/\/\/ The animation is now the current animation for an entity.\n            \/\/\/ <\/summary>\n            Activated,\n\n            \/\/\/ <summary>\n            \/\/\/ The animation is no longer the current animation for an entity.\n            \/\/\/ <\/summary>\n            Deactivated\n        }\n    }\n}\n","old_contents":"\ufeff#if XNA\nusing Microsoft.Xna.Framework;\n#endif\n\nnamespace SadConsole\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Collections.ObjectModel;\n    using Newtonsoft.Json;\n\n    \/\/\/ <summary>\n    \/\/\/ Animates a list of frames.\n    \/\/\/ <\/summary>\n    [System.Diagnostics.DebuggerDisplay(\"Console (Animated)\")]\n    [JsonConverter(typeof(SerializedTypes.AnimatedConsoleConverterJson))]\n    public class AnimatedConsole : Console\n    {\n        private float _animatedTime;\n        private AnimationState _state;\n\n        \/\/\/ <summary>\n        \/\/\/ Raised when the <see cref=\"AnimationState\"\/> changes.\n        \/\/\/ <\/summary>\n        public event EventHandler<AnimationStateChangedEventArgs> AnimationStateChanged;\n\n        \/\/\/ <summary>\n        \/\/\/ The frames of animation.\n        \/\/\/ <\/summary>\n        \/\/\/ <remarks>If this collection changes, <see cref=\"CurrentFrameIndexValue\"\/>, <see cref=\"UpdateFrameReferences\"\/>, and <see cref=\"TimePerFrame\"\/> should all be recalculated.<\/remarks>\n        protected internal List<CellSurface> FramesList = new List<CellSurface>();\n\n        \/\/\/ <summary>\n        \/\/\/ Time counter for the animation\n        \/\/\/ <\/summary>\n        protected double AddedTime;\n\n        \/\/\/ <summary>\n        \/\/\/ The current frame index being animated.\n        \/\/\/ <\/summary>\n        protected int CurrentFrameIndexValue;\n\n        \/\/\/ <summary>\n        \/\/\/ How much time per animated frame should be used.\n        \/\/\/ <\/summary>\n        protected float TimePerFrame;\n\n        \/\/\/ <summary>\n        \/\/\/ All frames of the animation\n        \/\/\/ <\/summary>\n        public ReadOnlyCollection<CellSurface> Frames => FramesList.AsReadOnly();\n\n        \/\/\/ <summary>\n        \/\/\/ Center of the animation used in positioning.\n        \/\/\/ <\/summary>\n        public Point Center { get; set; }\n\n        \/\/\/ <summary>\n        \/\/\/ Indicates whether or not this animation will repeat once it has finished animating.\n        \/\/\/ <\/summary>\n        public bool Repeat { get; set; }\n\n        \/\/\/ <summary>\n        \/\/\/ When true, Indicates the animation is currently animating. The <see cref=\"Update\"\/> method will advance the frames.\n        \/\/\/ <\/summary>\n        public bool IsPlaying { get; protected set; }\n\n        \/\/\/ <summary>\n        \/\/\/ The length of the animation.\n        \/\/\/ <\/summary>\n        public float AnimationDuration\n        {\n            get => _animatedTime;\n            set { _animatedTime = value; CalculateFrameDuration(); }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets or sets the current frame index to animate.\n        \/\/\/ <\/summary>\n        public int CurrentFrameIndex\n        {\n            get => CurrentFrameIndexValue;\n            set\n            {\n                if (value < 0 || value >= FramesList.Count)\n                {\n                    CurrentFrameIndexValue = 0;\n                }\n                else\n                {\n                    CurrentFrameIndexValue = value;\n                }\n\n                UpdateFrameReferences();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Indicates the animation is empty.\n        \/\/\/ <\/summary>\n        public bool IsEmpty => FramesList.Count == 0;\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the name of this animation.\n        \/\/\/ <\/summary>\n        public string Name { get; set; }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the currently frame being animated.\n        \/\/\/ <\/summary>\n        public CellSurface CurrentFrame => FramesList[CurrentFrameIndexValue];\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the current animation state.\n        \/\/\/ <\/summary>\n        public AnimationState State\n        {\n            get => _state;\n            set\n            {\n                AnimationState oldState = _state;\n\n                if (value != _state)\n                {\n                    _state = value;\n                    AnimationStateChanged?.Invoke(this, new AnimationStateChangedEventArgs(oldState, _state));\n                }\n            }\n        }\n\n        #region Constructors\n        \/\/\/ <summary>\n        \/\/\/ Creates a new animation with the specified name, width, and height.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\">The name of the animation.<\/param>\n        \/\/\/ <param name=\"width\">The width of each frame this animation will have.<\/param>\n        \/\/\/ <param name=\"height\">The height of each frame this animation will have.<\/param>\n        public AnimatedConsole(string name, int width, int height) : this(name, width, height, Global.FontDefault)\n        {\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Creates a new animation with the specified name, width, and height.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\">The name of the animation.<\/param>\n        \/\/\/ <param name=\"width\">The width of each frame this animation will have.<\/param>\n        \/\/\/ <param name=\"height\">The height of each frame this animation will have.<\/param>\n        \/\/\/ <param name=\"font\">The font used with this animation.<\/param>\n        public AnimatedConsole(string name, int width, int height, Font font) : base(width, height, font) => Name = name;\n        #endregion\n\n        \/\/\/ <summary>\n        \/\/\/ Forces the area of this text surface to always be the full width and height.\n        \/\/\/ <\/summary>\n        public override void SetRenderCells()\n        {\n            base.SetRenderCells();\n\n            if (FramesList.Count > 0)\n            {\n                UpdateFrameReferences();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Updates the base <see cref=\"CellSurface.Cells\"\/> references to the current frame.\n        \/\/\/ <\/summary>\n        protected void UpdateFrameReferences()\n        {\n            CellSurface frame = FramesList[CurrentFrameIndexValue];\n            Cells = RenderCells = frame.Cells;\n            DefaultBackground = frame.DefaultBackground;\n            DefaultForeground = frame.DefaultForeground;\n            IsDirty = true;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Creates a new frame with the same dimensions as this entity and adds it to the Frames collection of the entity.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The created frame.<\/returns>\n        public CellSurface CreateFrame()\n        {\n            if (FramesList == null)\n            {\n                FramesList = new List<CellSurface>();\n            }\n\n            var frame = new CellSurface(Width, Height) { DefaultBackground = DefaultBackground, DefaultForeground = DefaultForeground };\n            frame.Clear();\n            FramesList.Add(frame);\n            UpdateFrameReferences();\n            return frame;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Calculates the time needed per frame for rendering.\n        \/\/\/ <\/summary>\n        private void CalculateFrameDuration()\n        {\n            if (IsEmpty || _animatedTime == 0)\n            {\n                TimePerFrame = 0f;\n            }\n            else\n            {\n                TimePerFrame = _animatedTime \/ FramesList.Count;\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Stops animating.\n        \/\/\/ <\/summary>\n        public void Stop()\n        {\n            IsPlaying = false;\n            State = AnimationState.Stopped;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Starts animating the frames.\n        \/\/\/ <\/summary>\n        public void Start()\n        {\n            CalculateFrameDuration();\n            IsPlaying = true;\n            State = AnimationState.Playing;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Restarts the animation from the first frame.\n        \/\/\/ <\/summary>\n        public void Restart()\n        {\n            CalculateFrameDuration();\n            IsPlaying = true;\n            CurrentFrameIndex = 0;\n            State = AnimationState.Restarted;\n            State = AnimationState.Playing;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Updates the animation frames and calls update on the base class.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"timeElapsed\">The time elapsed since the last call in seconds.<\/param>\n        public override void Update(TimeSpan timeElapsed)\n        {\n            if (IsPlaying && TimePerFrame != 0)\n            {\n                \/\/ TODO: Evaluate if we should change this to calculate current frame based on total time passed, \\\\not calculate frame based on individual frame duration on screen.\n                AddedTime += timeElapsed.TotalSeconds;\n\n                if (AddedTime > TimePerFrame)\n                {\n                    AddedTime = 0f;\n                    CurrentFrameIndexValue++;\n\n                    if (CurrentFrameIndexValue >= FramesList.Count)\n                    {\n                        if (Repeat)\n                        {\n                            CurrentFrameIndexValue = 0;\n                            State = AnimationState.Restarted;\n                            State = AnimationState.Playing;\n                        }\n                        else\n                        {\n                            IsPlaying = false;\n                            CurrentFrameIndexValue--;\n                            State = AnimationState.Finished;\n                        }\n                    }\n\n                    UpdateFrameReferences();\n                }\n            }\n\n            base.Update(timeElapsed);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Returns the name of the animation.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The name.<\/returns>\n        public override string ToString() => Name;\n\n        \/\/\/ <inheritdoc \/>\n        public override void OnCalculateRenderPosition()\n        {\n            if (UsePixelPositioning)\n            {\n                CalculatedPosition = Position - Center + (Parent?.CalculatedPosition ?? Point.Zero);\n            }\n            else\n            {\n                CalculatedPosition = Position.ConsoleLocationToPixel(Font) - Center.ConsoleLocationToPixel(Font) + (Parent?.CalculatedPosition ?? Point.Zero);\n            }\n\n            foreach (Console child in Children)\n            {\n                child.OnCalculateRenderPosition();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Creates an animated surface that looks like static.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"width\">The width of the surface.<\/param>\n        \/\/\/ <param name=\"height\">The height of the surface.<\/param>\n        \/\/\/ <param name=\"frames\">How many frames the animation should have.<\/param>\n        \/\/\/ <param name=\"blankChance\">Chance a character will be blank. Characters are between index 48-158. Chance is evaluated versus <see cref=\"System.Random.NextDouble\"\/>.<\/param>\n        \/\/\/ <returns>An animation.<\/returns>\n        public static AnimatedConsole CreateStatic(int width, int height, int frames, double blankChance)\n        {\n            var animation = new AnimatedConsole(\"default\", width, height, Global.FontDefault)\n            {\n                DefaultBackground = Color.Black\n            };\n            for (int f = 0; f < frames; f++)\n            {\n                CellSurface frame = animation.CreateFrame();\n\n                for (int x = 0; x < width; x++)\n                {\n                    for (int y = 0; y < height; y++)\n                    {\n                        int character = Global.Random.Next(48, 168);\n\n                        if (Global.Random.NextDouble() <= blankChance)\n                        {\n                            character = 32;\n                        }\n\n                        frame.SetGlyph(x, y, character);\n                        frame.SetForeground(x, y, Color.White * (float)(Global.Random.NextDouble() * (1.0d - 0.5d) + 0.5d));\n                    }\n                }\n\n            }\n\n            animation.AnimationDuration = 1;\n            animation.Repeat = true;\n\n            animation.Start();\n\n            return animation;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Saves the <see cref=\"AnimatedConsole\"\/> to a file.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"file\">The destination file.<\/param>\n        public new void Save(string file) => Serializer.Save(this, file, Settings.SerializationIsCompressed);\n\n        \/\/\/ <summary>\n        \/\/\/ Loads a <see cref=\"AnimatedConsole\"\/> from a file.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"file\">The source file.<\/param>\n        \/\/\/ <returns><\/returns>\n        public static new AnimatedConsole Load(string file) => Serializer.Load<AnimatedConsole>(file, Settings.SerializationIsCompressed);\n\n        \/\/\/ <summary>\n        \/\/\/ Event args for when the animation state changes\n        \/\/\/ <\/summary>\n        public class AnimationStateChangedEventArgs : EventArgs\n        {\n            \/\/\/ <summary>\n            \/\/\/ The previous state.\n            \/\/\/ <\/summary>\n            public readonly AnimationState PreviousState;\n\n            \/\/\/ <summary>\n            \/\/\/ The new state.\n            \/\/\/ <\/summary>\n            public readonly AnimationState NewState;\n\n            \/\/\/ <summary>\n            \/\/\/ Creates a new instance of the event args.\n            \/\/\/ <\/summary>\n            \/\/\/ <param name=\"previousState\">The previous state.<\/param>\n            \/\/\/ <param name=\"newState\">The new state.<\/param>\n            public AnimationStateChangedEventArgs(AnimationState previousState, AnimationState newState)\n            {\n                PreviousState = previousState;\n                NewState = newState;\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Represents what state the animation is in.\n        \/\/\/ <\/summary>\n        public enum AnimationState\n        {\n            \/\/\/ <summary>\n            \/\/\/ The animation has never been played or was forcibly stopped.\n            \/\/\/ <\/summary>\n            Stopped,\n\n            \/\/\/ <summary>\n            \/\/\/ The animation is currently playing.\n            \/\/\/ <\/summary>\n            Playing,\n\n            \/\/\/ <summary>\n            \/\/\/ The animation was either manually restarted or repeated.\n            \/\/\/ <\/summary>\n            Restarted,\n\n            \/\/\/ <summary>\n            \/\/\/ The animation was played and completed.\n            \/\/\/ <\/summary>\n            Finished,\n\n            \/\/\/ <summary>\n            \/\/\/ The animation is now the current animation for an entity.\n            \/\/\/ <\/summary>\n            Activated,\n\n            \/\/\/ <summary>\n            \/\/\/ The animation is no longer the current animation for an entity.\n            \/\/\/ <\/summary>\n            Deactivated\n        }\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"c23144db075c5c3fe8e4939873b19147c7346322","subject":"LiftExport handle case with more than 1 homograph with no \"orderNumber\", used to throw","message":"LiftExport handle case with more than 1 homograph with no \"orderNumber\", used to throw\n","repos":"sillsdev\/solid,sillsdev\/solid,sillsdev\/solid","old_file":"src\/SolidGui\/Export\/ExportLift.cs","new_file":"src\/SolidGui\/Export\/ExportLift.cs","new_contents":"\ufeffusing System;\r\nusing System.Collections.Generic;\r\nusing System.ComponentModel;\r\nusing System.IO;\r\nusing System.Text;\r\nusing Palaso.DictionaryServices.Lift;\r\nusing Palaso.DictionaryServices.Model;\r\nusing Palaso.Progress;\r\nusing Palaso.Progress.LogBox;\r\nusing SolidGui.Engine;\r\nusing SolidGui.Model;\r\nusing System.Linq;\r\n\r\nnamespace SolidGui.Export\r\n{\r\n    public class ExportLift : IExporter\r\n    {\r\n\r\n        public void Export(IEnumerable<Record> sfmLexEntries, SolidSettings solidSettings, string outputFilePath, IProgress outerProgress)\r\n        {\r\n            var index = new Dictionary<string, SfmLiftLexEntryAdapter>();\r\n            var liftLexEntries = new List<SfmLiftLexEntryAdapter>();\r\n            var logPath = outputFilePath+ \".exportErrors.txt\";\r\n            if (File.Exists(outputFilePath))\r\n            {\r\n                File.Delete(outputFilePath);\r\n            }\r\n            if (File.Exists(logPath))\r\n            {\r\n                File.Delete(logPath);\r\n            }\r\n\r\n            var stringBuilderProgress = new StringBuilderProgress();\r\n            \/\/our overal progress reports both to the UI and to this file we want to write out\r\n            var progress = new MultiProgress(new IProgress[]{outerProgress, stringBuilderProgress});\r\n\r\n            using (var dm = new LiftDataMapper(outputFilePath))\r\n            {\r\n                \/\/REVIEW: If I'm (jh) reading this right, it will need a restructuring in order to support\r\n                \/\/relations which point from a sense to... anything.  That's becuase until the index\r\n                \/\/is build, we can't come up with the target id. Seems like we need to introduce a \r\n                \/\/pre-pass, which only creates the index.  Then, make senses be able to output lexical\r\n                \/\/relations, at least to entries (pointing at specific senses would be harder still).\r\n\r\n                \/\/ first pass\r\n                foreach (var sfmLexEntry in sfmLexEntries)\r\n                {\r\n                    try\r\n                    {\r\n                        var adaptedEntry = new SfmLiftLexEntryAdapter(dm, sfmLexEntry.LexEntry, solidSettings);\r\n                        liftLexEntries.Add(adaptedEntry);\r\n                        adaptedEntry.PopulateEntry(progress);\r\n\r\n  \/* this worked for one homograph with no actual ordernumber, but would crash when you hit a second one \r\n   * \r\n   *                       if (index.ContainsKey(sfmId)) \/\/ is a duplicate\r\n                        {\r\n                            \/\/ get the duplicated entry from index and change its name to SfmID_HomonymNumber\r\n                            var entry = index[sfmId];\r\n                            entry.SfmID = entry.SfmID + \"_\" + entry.HomonymNumber;\r\n\r\n                            \/\/ add the new adapted entry to the index with name SfmID_HomonymNumber\r\n                            index.Add(sfmId + \"_\" + adaptedEntry.HomonymNumber, adaptedEntry);\r\n                        }\r\n   *\/ \r\n                        var sfmId = adaptedEntry.SfmID;\r\n                        var homograph = 0;\r\n                        while (index.ContainsKey(sfmId)) \/\/ is a duplicate\r\n                        {\r\n                            ++homograph;\r\n                            sfmId = adaptedEntry.SfmID + \"_\" + homograph;\r\n                        }\r\n\r\n                        \/\/ add to dictionary\r\n                        index.Add(sfmId, adaptedEntry);\r\n                        \r\n                    }\r\n                    catch (Exception error)\r\n                    {\r\n                        progress.WriteError(sfmLexEntry.LexEntry.Name + \": \" + error);\r\n                    }\r\n                }\r\n                SfmLiftLexEntryAdapter targetLexEntry;\r\n\r\n                \/\/ second pass\r\n                foreach (var adaptedEntry in liftLexEntries)\r\n                {\r\n                    try\r\n                    {\r\n                        foreach (var relation in adaptedEntry.Relations)\r\n                        {\r\n                            \/\/ if the target is in the dictionary, add the relation, else post a note\r\n                            if (index.ContainsKey(relation.TargetID))\r\n                            {\r\n                                targetLexEntry = index[relation.TargetID];\r\n                                string guidOfTargetEntry = targetLexEntry.GUID;\r\n                                adaptedEntry.MakeRelation(guidOfTargetEntry, relation.Type);\r\n\r\n                            }\r\n                            else\r\n                            {\r\n                                \/\/ add an error note\r\n                                adaptedEntry.AddSolidNote(String.Format(\"Cannot find target: {0}\", relation.TargetID));\r\n                                \/\/ add a note\r\n                                \/\/adaptedEntry.LiftLexEntry.\r\n                            }\r\n                        }\r\n\r\n                    \/\/    dm.SaveItem(adaptedEntry.LiftLexEntry);\r\n\r\n                        foreach (var subEntry in adaptedEntry.SubEntries)\r\n                        {\r\n                            foreach (var relation in subEntry.Relations)\r\n                            {\r\n                                \/\/ if the target is in the dictionary, add the relation, else post a note\r\n                                if (index.ContainsKey(relation.TargetID))\r\n                                {\r\n                                    targetLexEntry = index[relation.TargetID];\r\n                                    string guidOfTargetEntry = targetLexEntry.GUID;\r\n                                    adaptedEntry.MakeRelation(guidOfTargetEntry, relation.Type);\r\n\r\n                                }\r\n                                else\r\n                                {\r\n                                    \/\/ add a note\r\n                                    \/\/adaptedEntry.LiftLexEntry.\r\n                                }\r\n                            }\r\n\r\n                           \/\/ dm.SaveItem(subEntry.LiftLexEntry);\r\n                        }\r\n\r\n                        \/\/ Got any potential relations?\r\n                        \/\/ if so\r\n                        \/\/ foreach one find your target in the index, get it's id, and make the relation\r\n\r\n\r\n                    }\r\n                    catch (Exception error)\r\n                    {\r\n                        progress.WriteError(adaptedEntry.SfmID + \": \"+ error);\r\n                    }\r\n                    \r\n                }\r\n                dm.SaveItems(from x in dm.GetAllItems() select dm.GetItem(x));\r\n            }\r\n\r\n            if (!string.IsNullOrEmpty(stringBuilderProgress.Text))\r\n            {\r\n                using (var log = System.IO.File.AppendText(logPath))\r\n                {\r\n                    log.WriteLine(stringBuilderProgress.Text);\r\n                }\r\n            }\r\n            outerProgress.WriteMessage(\"\");\r\n            outerProgress.WriteMessage(\"Done\");\r\n        }\r\n\r\n\r\n        public void ExportAsync(object sender, DoWorkEventArgs args)\r\n        {\r\n             var exportArguments = (ExportArguments)args.Argument;\r\n\r\n            var dictionary = new SfmDictionary();\r\n            var solidSettings = SolidSettings.OpenSolidFile(SolidSettings.GetSettingsFilePathFromDictionaryPath(exportArguments.inputFilePath));\r\n            dictionary.Open(exportArguments.inputFilePath, solidSettings, new RecordFilterSet());\r\n            Export(dictionary.AllRecords, solidSettings, exportArguments.outputFilePath, exportArguments.progress);\r\n        }\r\n\r\n        public static IExporter Create()\r\n        {\r\n            return new ExportLift();\r\n        }\r\n\r\n        public const string DriverName = \"Lift\";\r\n\r\n    }\r\n}\r\n","old_contents":"\ufeffusing System;\r\nusing System.Collections.Generic;\r\nusing System.ComponentModel;\r\nusing System.IO;\r\nusing System.Text;\r\nusing Palaso.DictionaryServices.Lift;\r\nusing Palaso.DictionaryServices.Model;\r\nusing Palaso.Progress;\r\nusing Palaso.Progress.LogBox;\r\nusing SolidGui.Engine;\r\nusing SolidGui.Model;\r\nusing System.Linq;\r\n\r\nnamespace SolidGui.Export\r\n{\r\n    public class ExportLift : IExporter\r\n    {\r\n\r\n        public void Export(IEnumerable<Record> sfmLexEntries, SolidSettings solidSettings, string outputFilePath, IProgress outerProgress)\r\n        {\r\n            var index = new Dictionary<string, SfmLiftLexEntryAdapter>();\r\n            var liftLexEntries = new List<SfmLiftLexEntryAdapter>();\r\n            var logPath = outputFilePath+ \".exportErrors.txt\";\r\n            if (File.Exists(outputFilePath))\r\n            {\r\n                File.Delete(outputFilePath);\r\n            }\r\n            if (File.Exists(logPath))\r\n            {\r\n                File.Delete(logPath);\r\n            }\r\n\r\n            var stringBuilderProgress = new StringBuilderProgress();\r\n            \/\/our overal progress reports both to the UI and to this file we want to write out\r\n            var progress = new MultiProgress(new IProgress[]{outerProgress, stringBuilderProgress});\r\n\r\n            using (var dm = new LiftDataMapper(outputFilePath))\r\n            {\r\n                \/\/REVIEW: If I'm (jh) reading this right, it will need a restructuring in order to support\r\n                \/\/relations which point from a sense to... anything.  That's becuase until the index\r\n                \/\/is build, we can't come up with the target id. Seems like we need to introduce a \r\n                \/\/pre-pass, which only creates the index.  Then, make senses be able to output lexical\r\n                \/\/relations, at least to entries (pointing at specific senses would be harder still).\r\n\r\n                \/\/ first pass\r\n                foreach (var sfmLexEntry in sfmLexEntries)\r\n                {\r\n                    try\r\n                    {\r\n                        var adaptedEntry = new SfmLiftLexEntryAdapter(dm, sfmLexEntry.LexEntry, solidSettings);\r\n                        liftLexEntries.Add(adaptedEntry);\r\n                        adaptedEntry.PopulateEntry(progress);\r\n\r\n                        if (index.ContainsKey(adaptedEntry.SfmID)) \/\/ is a duplicate\r\n                        {\r\n                            \/\/ get the duplicated entry from index and change its name to SfmID_HomonymNumber\r\n                            var entry = index[adaptedEntry.SfmID];\r\n                            entry.SfmID = entry.SfmID + \"_\" + entry.HomonymNumber;\r\n\r\n                            \/\/ add the new adapted entry to the index with name SfmID_HomonymNumber\r\n                            index.Add(adaptedEntry.SfmID + \"_\" + adaptedEntry.HomonymNumber, adaptedEntry);\r\n                        }\r\n                        else\r\n                        {\r\n                            \/\/ add to dictionary\r\n                            index.Add(adaptedEntry.SfmID, adaptedEntry);\r\n                        }\r\n                    }\r\n                    catch (Exception error)\r\n                    {\r\n                        progress.WriteError(sfmLexEntry.LexEntry.Name + \": \" + error);\r\n                    }\r\n                }\r\n                SfmLiftLexEntryAdapter targetLexEntry;\r\n\r\n                \/\/ second pass\r\n                foreach (var adaptedEntry in liftLexEntries)\r\n                {\r\n                    try\r\n                    {\r\n                        foreach (var relation in adaptedEntry.Relations)\r\n                        {\r\n                            \/\/ if the target is in the dictionary, add the relation, else post a note\r\n                            if (index.ContainsKey(relation.TargetID))\r\n                            {\r\n                                targetLexEntry = index[relation.TargetID];\r\n                                string guidOfTargetEntry = targetLexEntry.GUID;\r\n                                adaptedEntry.MakeRelation(guidOfTargetEntry, relation.Type);\r\n\r\n                            }\r\n                            else\r\n                            {\r\n                                \/\/ add an error note\r\n                                adaptedEntry.AddSolidNote(String.Format(\"Cannot find target: {0}\", relation.TargetID));\r\n                                \/\/ add a note\r\n                                \/\/adaptedEntry.LiftLexEntry.\r\n                            }\r\n                        }\r\n\r\n                    \/\/    dm.SaveItem(adaptedEntry.LiftLexEntry);\r\n\r\n                        foreach (var subEntry in adaptedEntry.SubEntries)\r\n                        {\r\n                            foreach (var relation in subEntry.Relations)\r\n                            {\r\n                                \/\/ if the target is in the dictionary, add the relation, else post a note\r\n                                if (index.ContainsKey(relation.TargetID))\r\n                                {\r\n                                    targetLexEntry = index[relation.TargetID];\r\n                                    string guidOfTargetEntry = targetLexEntry.GUID;\r\n                                    adaptedEntry.MakeRelation(guidOfTargetEntry, relation.Type);\r\n\r\n                                }\r\n                                else\r\n                                {\r\n                                    \/\/ add a note\r\n                                    \/\/adaptedEntry.LiftLexEntry.\r\n                                }\r\n                            }\r\n\r\n                           \/\/ dm.SaveItem(subEntry.LiftLexEntry);\r\n                        }\r\n\r\n                        \/\/ Got any potential relations?\r\n                        \/\/ if so\r\n                        \/\/ foreach one find your target in the index, get it's id, and make the relation\r\n\r\n\r\n                    }\r\n                    catch (Exception error)\r\n                    {\r\n                        progress.WriteError(adaptedEntry.SfmID + \": \"+ error);\r\n                    }\r\n                    \r\n                }\r\n                dm.SaveItems(from x in dm.GetAllItems() select dm.GetItem(x));\r\n            }\r\n\r\n            if (!string.IsNullOrEmpty(stringBuilderProgress.Text))\r\n            {\r\n                using (var log = System.IO.File.AppendText(logPath))\r\n                {\r\n                    log.WriteLine(stringBuilderProgress.Text);\r\n                }\r\n            }\r\n            outerProgress.WriteMessage(\"\");\r\n            outerProgress.WriteMessage(\"Done\");\r\n        }\r\n\r\n\r\n        public void ExportAsync(object sender, DoWorkEventArgs args)\r\n        {\r\n             var exportArguments = (ExportArguments)args.Argument;\r\n\r\n            var dictionary = new SfmDictionary();\r\n            var solidSettings = SolidSettings.OpenSolidFile(SolidSettings.GetSettingsFilePathFromDictionaryPath(exportArguments.inputFilePath));\r\n            dictionary.Open(exportArguments.inputFilePath, solidSettings, new RecordFilterSet());\r\n            Export(dictionary.AllRecords, solidSettings, exportArguments.outputFilePath, exportArguments.progress);\r\n        }\r\n\r\n        public static IExporter Create()\r\n        {\r\n            return new ExportLift();\r\n        }\r\n\r\n        public const string DriverName = \"Lift\";\r\n\r\n    }\r\n}\r\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"c8387d58f5ae176f1520508aa445a571837521d4","subject":"Fix (expected!) merge problem.","message":"Fix (expected!) merge problem.\n","repos":"YsqEvilmax\/Umbraco-CMS,gkonings\/Umbraco-CMS,mstodd\/Umbraco-CMS,leekelleher\/Umbraco-CMS,Nicholas-Westby\/Umbraco-CMS,sargin48\/Umbraco-CMS,tcmorris\/Umbraco-CMS,VDBBjorn\/Umbraco-CMS,JimBobSquarePants\/Umbraco-CMS,qizhiyu\/Umbraco-CMS,ehornbostel\/Umbraco-CMS,zidad\/Umbraco-CMS,markoliver288\/Umbraco-CMS,Nicholas-Westby\/Umbraco-CMS,gkonings\/Umbraco-CMS,Scott-Herbert\/Umbraco-CMS,dawoe\/Umbraco-CMS,ehornbostel\/Umbraco-CMS,zidad\/Umbraco-CMS,mattbrailsford\/Umbraco-CMS,kgiszewski\/Umbraco-CMS,wtct\/Umbraco-CMS,romanlytvyn\/Umbraco-CMS,jchurchley\/Umbraco-CMS,Pyuuma\/Umbraco-CMS,mstodd\/Umbraco-CMS,rustyswayne\/Umbraco-CMS,corsjune\/Umbraco-CMS,YsqEvilmax\/Umbraco-CMS,JeffreyPerplex\/Umbraco-CMS,DaveGreasley\/Umbraco-CMS,romanlytvyn\/Umbraco-CMS,gavinfaux\/Umbraco-CMS,rasmuseeg\/Umbraco-CMS,kasperhhk\/Umbraco-CMS,nvisage-gf\/Umbraco-CMS,yannisgu\/Umbraco-CMS,JimBobSquarePants\/Umbraco-CMS,gavinfaux\/Umbraco-CMS,m0wo\/Umbraco-CMS,madsoulswe\/Umbraco-CMS,JeffreyPerplex\/Umbraco-CMS,AndyButland\/Umbraco-CMS,kasperhhk\/Umbraco-CMS,neilgaietto\/Umbraco-CMS,Phosworks\/Umbraco-CMS,MicrosoftEdge\/Umbraco-CMS,robertjf\/Umbraco-CMS,mittonp\/Umbraco-CMS,VDBBjorn\/Umbraco-CMS,countrywide\/Umbraco-CMS,Phosworks\/Umbraco-CMS,abjerner\/Umbraco-CMS,yannisgu\/Umbraco-CMS,Tronhus\/Umbraco-CMS,gregoriusxu\/Umbraco-CMS,kgiszewski\/Umbraco-CMS,JimBobSquarePants\/Umbraco-CMS,YsqEvilmax\/Umbraco-CMS,qizhiyu\/Umbraco-CMS,Pyuuma\/Umbraco-CMS,iahdevelop\/Umbraco-CMS,PeteDuncanson\/Umbraco-CMS,arknu\/Umbraco-CMS,Myster\/Umbraco-CMS,hfloyd\/Umbraco-CMS,Jeavon\/Umbraco-CMS-RollbackTweak,AzarinSergey\/Umbraco-CMS,ehornbostel\/Umbraco-CMS,gavinfaux\/Umbraco-CMS,hfloyd\/Umbraco-CMS,lingxyd\/Umbraco-CMS,zidad\/Umbraco-CMS,m0wo\/Umbraco-CMS,nul800sebastiaan\/Umbraco-CMS,gregoriusxu\/Umbraco-CMS,hfloyd\/Umbraco-CMS,KevinJump\/Umbraco-CMS,WebCentrum\/Umbraco-CMS,Tronhus\/Umbraco-CMS,abryukhov\/Umbraco-CMS,arvaris\/HRI-Umbraco,lingxyd\/Umbraco-CMS,tcmorris\/Umbraco-CMS,tcmorris\/Umbraco-CMS,Tronhus\/Umbraco-CMS,AndyButland\/Umbraco-CMS,dawoe\/Umbraco-CMS,VDBBjorn\/Umbraco-CMS,yannisgu\/Umbraco-CMS,Door3Dev\/HRI-Umbraco,mattbrailsford\/Umbraco-CMS,rasmusfjord\/Umbraco-CMS,NikRimington\/Umbraco-CMS,romanlytvyn\/Umbraco-CMS,zidad\/Umbraco-CMS,iahdevelop\/Umbraco-CMS,Khamull\/Umbraco-CMS,lars-erik\/Umbraco-CMS,arvaris\/HRI-Umbraco,countrywide\/Umbraco-CMS,mattbrailsford\/Umbraco-CMS,Nicholas-Westby\/Umbraco-CMS,kasperhhk\/Umbraco-CMS,timothyleerussell\/Umbraco-CMS,markoliver288\/Umbraco-CMS,qizhiyu\/Umbraco-CMS,Pyuuma\/Umbraco-CMS,engern\/Umbraco-CMS,jchurchley\/Umbraco-CMS,markoliver288\/Umbraco-CMS,Jeavon\/Umbraco-CMS-RollbackTweak,abjerner\/Umbraco-CMS,aadfPT\/Umbraco-CMS,KevinJump\/Umbraco-CMS,Door3Dev\/HRI-Umbraco,corsjune\/Umbraco-CMS,leekelleher\/Umbraco-CMS,MicrosoftEdge\/Umbraco-CMS,nvisage-gf\/Umbraco-CMS,JimBobSquarePants\/Umbraco-CMS,neilgaietto\/Umbraco-CMS,corsjune\/Umbraco-CMS,Nicholas-Westby\/Umbraco-CMS,tcmorris\/Umbraco-CMS,arvaris\/HRI-Umbraco,TimoPerplex\/Umbraco-CMS,NikRimington\/Umbraco-CMS,VDBBjorn\/Umbraco-CMS,Scott-Herbert\/Umbraco-CMS,countrywide\/Umbraco-CMS,marcemarc\/Umbraco-CMS,Myster\/Umbraco-CMS,Spijkerboer\/Umbraco-CMS,rasmusfjord\/Umbraco-CMS,Scott-Herbert\/Umbraco-CMS,christopherbauer\/Umbraco-CMS,Spijkerboer\/Umbraco-CMS,KevinJump\/Umbraco-CMS,madsoulswe\/Umbraco-CMS,arknu\/Umbraco-CMS,umbraco\/Umbraco-CMS,Phosworks\/Umbraco-CMS,nvisage-gf\/Umbraco-CMS,lars-erik\/Umbraco-CMS,dampee\/Umbraco-CMS,m0wo\/Umbraco-CMS,sargin48\/Umbraco-CMS,dawoe\/Umbraco-CMS,ordepdev\/Umbraco-CMS,dawoe\/Umbraco-CMS,wtct\/Umbraco-CMS,markoliver288\/Umbraco-CMS,KevinJump\/Umbraco-CMS,WebCentrum\/Umbraco-CMS,bjarnef\/Umbraco-CMS,marcemarc\/Umbraco-CMS,tompipe\/Umbraco-CMS,mittonp\/Umbraco-CMS,m0wo\/Umbraco-CMS,gkonings\/Umbraco-CMS,robertjf\/Umbraco-CMS,hfloyd\/Umbraco-CMS,Myster\/Umbraco-CMS,markoliver288\/Umbraco-CMS,Spijkerboer\/Umbraco-CMS,rustyswayne\/Umbraco-CMS,rajendra1809\/Umbraco-CMS,Myster\/Umbraco-CMS,dampee\/Umbraco-CMS,TimoPerplex\/Umbraco-CMS,base33\/Umbraco-CMS,TimoPerplex\/Umbraco-CMS,christopherbauer\/Umbraco-CMS,qizhiyu\/Umbraco-CMS,TimoPerplex\/Umbraco-CMS,wtct\/Umbraco-CMS,AzarinSergey\/Umbraco-CMS,leekelleher\/Umbraco-CMS,DaveGreasley\/Umbraco-CMS,gavinfaux\/Umbraco-CMS,Scott-Herbert\/Umbraco-CMS,dampee\/Umbraco-CMS,Door3Dev\/HRI-Umbraco,christopherbauer\/Umbraco-CMS,aadfPT\/Umbraco-CMS,Spijkerboer\/Umbraco-CMS,Tronhus\/Umbraco-CMS,MicrosoftEdge\/Umbraco-CMS,Khamull\/Umbraco-CMS,KevinJump\/Umbraco-CMS,m0wo\/Umbraco-CMS,NikRimington\/Umbraco-CMS,neilgaietto\/Umbraco-CMS,umbraco\/Umbraco-CMS,sargin48\/Umbraco-CMS,rustyswayne\/Umbraco-CMS,rasmusfjord\/Umbraco-CMS,gavinfaux\/Umbraco-CMS,iahdevelop\/Umbraco-CMS,markoliver288\/Umbraco-CMS,rasmusfjord\/Umbraco-CMS,wtct\/Umbraco-CMS,madsoulswe\/Umbraco-CMS,gkonings\/Umbraco-CMS,rustyswayne\/Umbraco-CMS,umbraco\/Umbraco-CMS,nvisage-gf\/Umbraco-CMS,leekelleher\/Umbraco-CMS,countrywide\/Umbraco-CMS,Nicholas-Westby\/Umbraco-CMS,WebCentrum\/Umbraco-CMS,kasperhhk\/Umbraco-CMS,hfloyd\/Umbraco-CMS,arknu\/Umbraco-CMS,Pyuuma\/Umbraco-CMS,rustyswayne\/Umbraco-CMS,robertjf\/Umbraco-CMS,mittonp\/Umbraco-CMS,aadfPT\/Umbraco-CMS,abryukhov\/Umbraco-CMS,mstodd\/Umbraco-CMS,gregoriusxu\/Umbraco-CMS,ordepdev\/Umbraco-CMS,yannisgu\/Umbraco-CMS,Khamull\/Umbraco-CMS,lars-erik\/Umbraco-CMS,YsqEvilmax\/Umbraco-CMS,DaveGreasley\/Umbraco-CMS,abryukhov\/Umbraco-CMS,mstodd\/Umbraco-CMS,sargin48\/Umbraco-CMS,aaronpowell\/Umbraco-CMS,Spijkerboer\/Umbraco-CMS,jchurchley\/Umbraco-CMS,timothyleerussell\/Umbraco-CMS,MicrosoftEdge\/Umbraco-CMS,christopherbauer\/Umbraco-CMS,lingxyd\/Umbraco-CMS,engern\/Umbraco-CMS,AzarinSergey\/Umbraco-CMS,christopherbauer\/Umbraco-CMS,dawoe\/Umbraco-CMS,PeteDuncanson\/Umbraco-CMS,sargin48\/Umbraco-CMS,corsjune\/Umbraco-CMS,PeteDuncanson\/Umbraco-CMS,JimBobSquarePants\/Umbraco-CMS,robertjf\/Umbraco-CMS,TimoPerplex\/Umbraco-CMS,countrywide\/Umbraco-CMS,VDBBjorn\/Umbraco-CMS,nvisage-gf\/Umbraco-CMS,Phosworks\/Umbraco-CMS,marcemarc\/Umbraco-CMS,Tronhus\/Umbraco-CMS,romanlytvyn\/Umbraco-CMS,rajendra1809\/Umbraco-CMS,MicrosoftEdge\/Umbraco-CMS,arvaris\/HRI-Umbraco,aaronpowell\/Umbraco-CMS,corsjune\/Umbraco-CMS,iahdevelop\/Umbraco-CMS,dampee\/Umbraco-CMS,wtct\/Umbraco-CMS,ordepdev\/Umbraco-CMS,neilgaietto\/Umbraco-CMS,AndyButland\/Umbraco-CMS,timothyleerussell\/Umbraco-CMS,rasmuseeg\/Umbraco-CMS,Scott-Herbert\/Umbraco-CMS,dampee\/Umbraco-CMS,gregoriusxu\/Umbraco-CMS,kgiszewski\/Umbraco-CMS,tcmorris\/Umbraco-CMS,base33\/Umbraco-CMS,tompipe\/Umbraco-CMS,rajendra1809\/Umbraco-CMS,rasmuseeg\/Umbraco-CMS,mittonp\/Umbraco-CMS,robertjf\/Umbraco-CMS,yannisgu\/Umbraco-CMS,ehornbostel\/Umbraco-CMS,JeffreyPerplex\/Umbraco-CMS,iahdevelop\/Umbraco-CMS,Jeavon\/Umbraco-CMS-RollbackTweak,nul800sebastiaan\/Umbraco-CMS,engern\/Umbraco-CMS,ordepdev\/Umbraco-CMS,arknu\/Umbraco-CMS,Door3Dev\/HRI-Umbraco,umbraco\/Umbraco-CMS,gregoriusxu\/Umbraco-CMS,lingxyd\/Umbraco-CMS,YsqEvilmax\/Umbraco-CMS,bjarnef\/Umbraco-CMS,zidad\/Umbraco-CMS,rajendra1809\/Umbraco-CMS,Khamull\/Umbraco-CMS,Myster\/Umbraco-CMS,AndyButland\/Umbraco-CMS,leekelleher\/Umbraco-CMS,abjerner\/Umbraco-CMS,aaronpowell\/Umbraco-CMS,tcmorris\/Umbraco-CMS,lars-erik\/Umbraco-CMS,neilgaietto\/Umbraco-CMS,mattbrailsford\/Umbraco-CMS,timothyleerussell\/Umbraco-CMS,mittonp\/Umbraco-CMS,bjarnef\/Umbraco-CMS,lingxyd\/Umbraco-CMS,Jeavon\/Umbraco-CMS-RollbackTweak,nul800sebastiaan\/Umbraco-CMS,Phosworks\/Umbraco-CMS,mstodd\/Umbraco-CMS,abjerner\/Umbraco-CMS,bjarnef\/Umbraco-CMS,marcemarc\/Umbraco-CMS,DaveGreasley\/Umbraco-CMS,marcemarc\/Umbraco-CMS,abryukhov\/Umbraco-CMS,Jeavon\/Umbraco-CMS-RollbackTweak,Door3Dev\/HRI-Umbraco,gkonings\/Umbraco-CMS,ordepdev\/Umbraco-CMS,base33\/Umbraco-CMS,qizhiyu\/Umbraco-CMS,rajendra1809\/Umbraco-CMS,Khamull\/Umbraco-CMS,rasmusfjord\/Umbraco-CMS,Pyuuma\/Umbraco-CMS,AndyButland\/Umbraco-CMS,engern\/Umbraco-CMS,AzarinSergey\/Umbraco-CMS,DaveGreasley\/Umbraco-CMS,kasperhhk\/Umbraco-CMS,timothyleerussell\/Umbraco-CMS,ehornbostel\/Umbraco-CMS,engern\/Umbraco-CMS,lars-erik\/Umbraco-CMS,tompipe\/Umbraco-CMS,AzarinSergey\/Umbraco-CMS,romanlytvyn\/Umbraco-CMS","old_file":"src\/Umbraco.Core\/PluginManager.cs","new_file":"src\/Umbraco.Core\/PluginManager.cs","new_contents":"\ufeffusing System;\r\nusing System.Collections.Generic;\r\nusing System.Globalization;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing System.Reflection;\r\nusing System.Text;\r\nusing System.Threading;\r\nusing System.Web.Compilation;\r\nusing System.Xml.Linq;\r\nusing Umbraco.Core.IO;\r\nusing Umbraco.Core.Logging;\r\nusing Umbraco.Core.Models;\r\nusing Umbraco.Core.PropertyEditors;\r\nusing umbraco.interfaces;\r\nusing File = System.IO.File;\r\n\r\nnamespace Umbraco.Core\r\n{\r\n\r\n    \/\/\/ <summary>\r\n    \/\/\/ Used to resolve all plugin types and cache them and is also used to instantiate plugin types\r\n    \/\/\/ <\/summary>\r\n    \/\/\/ <remarks>\r\n    \/\/\/ \r\n    \/\/\/ This class should be used to resolve all plugin types, the TypeFinder should not be used directly!\r\n    \/\/\/ \r\n    \/\/\/ This class can expose extension methods to resolve custom plugins\r\n    \/\/\/ \r\n    \/\/\/ Before this class resolves any plugins it checks if the hash has changed for the DLLs in the \/bin folder, if it hasn't\r\n    \/\/\/ it will use the cached resolved plugins that it has already found which means that no assembly scanning is necessary. This leads\r\n    \/\/\/ to much faster startup times.\r\n    \/\/\/ <\/remarks>\r\n    internal class PluginManager\r\n    {\r\n        private readonly ApplicationContext _appContext;\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Creates a new PluginManager with an ApplicationContext instance which ensures that the plugin xml \r\n        \/\/\/ file is cached temporarily until app startup completes.\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <param name=\"appContext\"><\/param>\r\n        \/\/\/ <param name=\"detectBinChanges\"><\/param>\r\n        internal PluginManager(ApplicationContext appContext, bool detectBinChanges = true)\r\n            : this(detectBinChanges)\r\n        {\r\n            if (appContext == null) throw new ArgumentNullException(\"appContext\");\r\n            _appContext = appContext;\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Creates a new PluginManager\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <param name=\"detectCodeChanges\">\r\n        \/\/\/ If true will detect changes in the \/bin folder and therefor load plugins from the \r\n        \/\/\/ cached plugins file if one is found. If false will never use the cache file for plugins\r\n        \/\/\/ <\/param>\r\n        internal PluginManager(bool detectCodeChanges = true)\r\n        {\r\n            _tempFolder = IOHelper.MapPath(\"~\/App_Data\/TEMP\/PluginCache\");\r\n            \/\/create the folder if it doesn't exist\r\n            if (!Directory.Exists(_tempFolder))\r\n            {\r\n                Directory.CreateDirectory(_tempFolder);\r\n            }\r\n\r\n            \/\/this is a check for legacy changes, before we didn't store the TypeResolutionKind in the file which was a mistake,\r\n            \/\/so we need to detect if the old file is there without this attribute, if it is then we delete it\r\n            if (DetectLegacyPluginListFile())\r\n            {\r\n                var filePath = GetPluginListFilePath();\r\n                File.Delete(filePath);\r\n            }\r\n\r\n            if (detectCodeChanges)\r\n            {\r\n                \/\/first check if the cached hash is 0, if it is then we ne\r\n                \/\/do the check if they've changed\r\n                HaveAssembliesChanged = (CachedAssembliesHash != CurrentAssembliesHash) || CachedAssembliesHash == 0;\r\n                \/\/if they have changed, we need to write the new file\r\n                if (HaveAssembliesChanged)\r\n                {\r\n                    WriteCachePluginsHash();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                \/\/always set to true if we're not detecting (generally only for testing)\r\n                HaveAssembliesChanged = true;\r\n            }\r\n\r\n        }\r\n\r\n        static PluginManager _resolver;\r\n        static readonly ReaderWriterLockSlim Lock = new ReaderWriterLockSlim();\r\n        private readonly string _tempFolder;\r\n        private long _cachedAssembliesHash = -1;\r\n        private long _currentAssembliesHash = -1;\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ We will ensure that no matter what, only one of these is created, this is to ensure that caching always takes place\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <remarks>\r\n        \/\/\/ The setter is generally only used for unit tests\r\n        \/\/\/ <\/remarks>\r\n        internal static PluginManager Current\r\n        {\r\n            get\r\n            {\r\n                using (var l = new UpgradeableReadLock(Lock))\r\n                {\r\n                    if (_resolver == null)\r\n                    {\r\n                        l.UpgradeToWriteLock();\r\n                        _resolver = ApplicationContext.Current == null\r\n                            ? new PluginManager()\r\n                            : new PluginManager(ApplicationContext.Current);\r\n                    }\r\n                    return _resolver;\r\n                }\r\n            }\r\n            set { _resolver = value; }\r\n        }\r\n\r\n        #region Hash checking methods\r\n\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Returns a bool if the assemblies in the \/bin have changed since they were last hashed.\r\n        \/\/\/ <\/summary>\r\n        internal bool HaveAssembliesChanged { get; private set; }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Returns the currently cached hash value of the scanned assemblies in the \/bin folder. Returns 0 \r\n        \/\/\/ if no cache is found.\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <value> <\/value>\r\n        internal long CachedAssembliesHash\r\n        {\r\n            get\r\n            {\r\n                if (_cachedAssembliesHash != -1)\r\n                    return _cachedAssembliesHash;\r\n\r\n                var filePath = Path.Combine(_tempFolder, \"umbraco-plugins.hash\");\r\n                if (!File.Exists(filePath))\r\n                    return 0;\r\n                var hash = File.ReadAllText(filePath, Encoding.UTF8);\r\n                Int64 val;\r\n                if (Int64.TryParse(hash, out val))\r\n                {\r\n                    _cachedAssembliesHash = val;\r\n                    return _cachedAssembliesHash;\r\n                }\r\n                \/\/it could not parse for some reason so we'll return 0.\r\n                return 0;\r\n            }\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Returns the current assemblies hash based on creating a hash from the assemblies in the \/bin\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <value> <\/value>\r\n        internal long CurrentAssembliesHash\r\n        {\r\n            get\r\n            {\r\n                if (_currentAssembliesHash != -1)\r\n                    return _currentAssembliesHash;\r\n\r\n                _currentAssembliesHash = GetAssembliesHash(\r\n                    new FileSystemInfo[]\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\/\/add the bin folder and everything in it\r\n\t\t\t\t\t\t\tnew DirectoryInfo(IOHelper.MapPath(SystemDirectories.Bin)),\r\n\t\t\t\t\t\t\t\/\/add the app code folder and everything in it\r\n\t\t\t\t\t\t\tnew DirectoryInfo(IOHelper.MapPath(\"~\/App_Code\")),\r\n\t\t\t\t\t\t\t\/\/add the global.asax (the app domain also monitors this, if it changes will do a full restart)\r\n\t\t\t\t\t\t\tnew FileInfo(IOHelper.MapPath(\"~\/global.asax\")),\r\n                            \/\/add the trees.config\r\n                            new FileInfo(IOHelper.MapPath(SystemDirectories.Config + \"\/trees.config\"))\r\n\t\t\t\t\t\t}\r\n                    );\r\n                return _currentAssembliesHash;\r\n            }\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Writes the assembly hash file\r\n        \/\/\/ <\/summary>\r\n        private void WriteCachePluginsHash()\r\n        {\r\n            var filePath = Path.Combine(_tempFolder, \"umbraco-plugins.hash\");\r\n            File.WriteAllText(filePath, CurrentAssembliesHash.ToString(), Encoding.UTF8);\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Returns a unique hash for the combination of FileInfo objects passed in\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <param name=\"filesAndFolders\"><\/param>\r\n        \/\/\/ <returns><\/returns>\r\n        internal static long GetAssembliesHash(IEnumerable<FileSystemInfo> filesAndFolders)\r\n        {\r\n            using (DisposableTimer.TraceDuration<PluginManager>(\"Determining hash of code files on disk\", \"Hash determined\"))\r\n            {\r\n                var hashCombiner = new HashCodeCombiner();\r\n                \/\/add each unique folder to the hash\r\n                foreach (var i in filesAndFolders.DistinctBy(x => x.FullName))\r\n                {\r\n                    hashCombiner.AddFileSystemItem(i);\r\n                }\r\n                return ConvertPluginsHashFromHex(hashCombiner.GetCombinedHashCode());\r\n            }\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Converts the hash value of current plugins to long from string\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <param name=\"val\"><\/param>\r\n        \/\/\/ <returns><\/returns>\r\n        internal static long ConvertPluginsHashFromHex(string val)\r\n        {\r\n            long outVal;\r\n            if (Int64.TryParse(val, NumberStyles.AllowHexSpecifier, CultureInfo.InvariantCulture, out outVal))\r\n            {\r\n                return outVal;\r\n            }\r\n            return 0;\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Attempts to resolve the list of plugin + assemblies found in the runtime for the base type 'T' passed in.\r\n        \/\/\/ If the cache file doesn't exist, fails to load, is corrupt or the type 'T' element is not found then \r\n        \/\/\/ a false attempt is returned.\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <typeparam name=\"T\"><\/typeparam>\r\n        \/\/\/ <returns><\/returns>\r\n        internal Attempt<IEnumerable<string>> TryGetCachedPluginsFromFile<T>(TypeResolutionKind resolutionType)\r\n        {\r\n            var filePath = GetPluginListFilePath();\r\n            if (!File.Exists(filePath))\r\n                return Attempt<IEnumerable<string>>.False;\r\n\r\n            try\r\n            {\r\n                \/\/we will load the xml document, if the app context exist, we will load it from the cache (which is only around for 5 minutes)\r\n                \/\/while the app boots up, this should save some IO time on app startup when the app context is there (which is always unless in unit tests)\r\n                XDocument xml;\r\n                if (_appContext != null)\r\n                {\r\n                    xml = _appContext.ApplicationCache.GetCacheItem(\"umbraco-plugins.list\",\r\n                        new TimeSpan(0, 0, 5, 0),\r\n                        () => XDocument.Load(filePath));\r\n                }\r\n                else\r\n                {\r\n                    xml = XDocument.Load(filePath);\r\n                }\r\n\r\n\r\n                if (xml.Root == null)\r\n                    return Attempt<IEnumerable<string>>.False;\r\n\r\n                var typeElement = xml.Root.Elements()\r\n                    .SingleOrDefault(x =>\r\n                                     x.Name.LocalName == \"baseType\"\r\n                                     && ((string)x.Attribute(\"type\")) == typeof(T).FullName\r\n                                     && ((string)x.Attribute(\"resolutionType\")) == resolutionType.ToString());\r\n\r\n                \/\/return false but specify this exception type so we can detect it\r\n                if (typeElement == null)\r\n                    return new Attempt<IEnumerable<string>>(new CachedPluginNotFoundInFile());\r\n\r\n                \/\/return success\r\n                return new Attempt<IEnumerable<string>>(\r\n                    true,\r\n                    typeElement.Elements(\"add\")\r\n                        .Select(x => (string)x.Attribute(\"type\")));\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                \/\/if the file is corrupted, etc... return false\r\n                return new Attempt<IEnumerable<string>>(ex);\r\n            }\r\n        }\r\n\r\n        private string GetPluginListFilePath()\r\n        {\r\n            return Path.Combine(_tempFolder, \"umbraco-plugins.list\");\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ This will return true if the plugin list file is a legacy one\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <returns><\/returns>\r\n        \/\/\/ <remarks>\r\n        \/\/\/ This method exists purely due to an error in 4.11. We were writing the plugin list file without the \r\n        \/\/\/ type resolution kind which will have caused some problems. Now we detect this legacy file and if it is detected\r\n        \/\/\/ we remove it so it can be recreated properly.\r\n        \/\/\/ <\/remarks>\r\n        internal bool DetectLegacyPluginListFile()\r\n        {\r\n            var filePath = GetPluginListFilePath();\r\n            if (!File.Exists(filePath))\r\n                return false;\r\n\r\n            try\r\n            {\r\n                var xml = XDocument.Load(filePath);\r\n                if (xml.Root == null)\r\n                    return false;\r\n\r\n                var typeElement = xml.Root.Elements()\r\n                    .FirstOrDefault(x => x.Name.LocalName == \"baseType\");\r\n\r\n                if (typeElement == null)\r\n                    return false;\r\n\r\n                \/\/now check if the typeElement is missing the resolutionType attribute\r\n                return typeElement.Attributes().All(x => x.Name.LocalName != \"resolutionType\");\r\n            }\r\n            catch (Exception)\r\n            {\r\n                \/\/if the file is corrupted, etc... return true so it is removed\r\n                return true;\r\n            }\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Adds\/Updates the type list for the base type 'T' in the cached file\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <typeparam name=\"T\"><\/typeparam>\r\n        \/\/\/ <param name=\"typesFound\"><\/param>\r\n        \/\/\/<param name=\"resolutionType\"> <\/param>\r\n        \/\/\/<remarks>\r\n        \/\/\/ THIS METHOD IS NOT THREAD SAFE\r\n        \/\/\/ <\/remarks>\r\n        \/\/\/ <example>\r\n        \/\/\/ <![CDATA[\r\n        \/\/\/ <plugins>\r\n        \/\/\/\t\t<baseType type=\"Test.Testing.Tester\">\r\n        \/\/\/\t\t\t<add type=\"My.Assembly.MyTester\" assembly=\"My.Assembly\" \/>\r\n        \/\/\/\t\t\t<add type=\"Your.Assembly.YourTester\" assembly=\"Your.Assembly\" \/>\r\n        \/\/\/\t\t<\/baseType>\r\n        \/\/\/ <\/plugins>\r\n        \/\/\/ ]]>\r\n        \/\/\/ <\/example>\r\n        internal void UpdateCachedPluginsFile<T>(IEnumerable<Type> typesFound, TypeResolutionKind resolutionType)\r\n        {\r\n            var filePath = GetPluginListFilePath();\r\n            XDocument xml;\r\n            try\r\n            {\r\n                xml = XDocument.Load(filePath);\r\n            }\r\n            catch\r\n            {\r\n                \/\/if there's an exception loading then this is somehow corrupt, we'll just replace it.\r\n                File.Delete(filePath);\r\n                \/\/create the document and the root\r\n                xml = new XDocument(new XElement(\"plugins\"));\r\n            }\r\n            if (xml.Root == null)\r\n            {\r\n                \/\/if for some reason there is no root, create it\r\n                xml.Add(new XElement(\"plugins\"));\r\n            }\r\n            \/\/find the type 'T' element to add or update\r\n            var typeElement = xml.Root.Elements()\r\n                .SingleOrDefault(x =>\r\n                                 x.Name.LocalName == \"baseType\"\r\n                                 && ((string)x.Attribute(\"type\")) == typeof(T).FullName\r\n                                 && ((string)x.Attribute(\"resolutionType\")) == resolutionType.ToString());\r\n\r\n            if (typeElement == null)\r\n            {\r\n                \/\/create the type element\r\n                typeElement = new XElement(\"baseType\",\r\n                    new XAttribute(\"type\", typeof(T).FullName),\r\n                    new XAttribute(\"resolutionType\", resolutionType.ToString()));\r\n                \/\/then add it to the root\r\n                xml.Root.Add(typeElement);\r\n            }\r\n\r\n\r\n            \/\/now we have the type element, we need to clear any previous types as children and add\/update it with new ones\r\n            typeElement.ReplaceNodes(typesFound.Select(x => new XElement(\"add\", new XAttribute(\"type\", x.AssemblyQualifiedName))));\r\n            \/\/save the xml file\r\n            xml.Save(filePath);\r\n        }\r\n\r\n        #endregion\r\n\r\n        private readonly ReaderWriterLockSlim _lock = new ReaderWriterLockSlim();\r\n        private readonly HashSet<TypeList> _types = new HashSet<TypeList>();\r\n        private IEnumerable<Assembly> _assemblies;\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Returns all classes attributed with XsltExtensionAttribute attribute\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <returns><\/returns>\r\n        internal IEnumerable<Type> ResolveCacheRefreshers()\r\n        {\r\n            return ResolveTypes<ICacheRefresher>();\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Returns all available IPropertyEditorValueConverter\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <returns><\/returns>\r\n        internal IEnumerable<Type> ResolvePropertyEditorValueConverters()\r\n        {\r\n            return ResolveTypes<IPropertyEditorValueConverter>();\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Returns all available IDataType in application\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <returns><\/returns>\r\n        internal IEnumerable<Type> ResolveDataTypes()\r\n        {\r\n            return ResolveTypes<IDataType>();\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Returns all available IMacroGuiRendering in application\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <returns><\/returns>\r\n        internal IEnumerable<Type> ResolveMacroRenderings()\r\n        {\r\n            return ResolveTypes<IMacroGuiRendering>();\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Returns all available IPackageAction in application\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <returns><\/returns>\r\n        internal IEnumerable<Type> ResolvePackageActions()\r\n        {\r\n            return ResolveTypes<IPackageAction>();\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Returns all available IAction in application\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <returns><\/returns>\r\n        internal IEnumerable<Type> ResolveActions()\r\n        {\r\n            return ResolveTypes<IAction>();\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Returns all available IMacroPropertyTypes in application\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <returns><\/returns>\r\n        internal IEnumerable<Type> ResolveMacroPropertyTypes()\r\n        {\r\n            return ResolveTypes<IMacroPropertyType>();\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Gets\/sets which assemblies to scan when type finding, generally used for unit testing, if not explicitly set\r\n        \/\/\/ this will search all assemblies known to have plugins and exclude ones known to not have them.\r\n        \/\/\/ <\/summary>\r\n        internal IEnumerable<Assembly> AssembliesToScan\r\n        {\r\n            get { return _assemblies ?? (_assemblies = TypeFinder.GetAssembliesWithKnownExclusions()); }\r\n            set { _assemblies = value; }\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Used to resolve and create instances of the specified type based on the resolved\/cached plugin types\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <typeparam name=\"T\"><\/typeparam>\r\n        \/\/\/ <param name=\"throwException\">set to true if an exception is to be thrown if there is an error during instantiation<\/param>\r\n        \/\/\/ <returns><\/returns>\r\n        internal IEnumerable<T> FindAndCreateInstances<T>(bool throwException = false)\r\n        {\r\n            var types = ResolveTypes<T>();\r\n            return CreateInstances<T>(types, throwException);\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Used to create instances of the specified type based on the resolved\/cached plugin types\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <typeparam name=\"T\"><\/typeparam>\r\n        \/\/\/ <param name=\"types\"><\/param>\r\n        \/\/\/ <param name=\"throwException\">set to true if an exception is to be thrown if there is an error during instantiation<\/param>\r\n        \/\/\/ <returns><\/returns>\r\n        internal IEnumerable<T> CreateInstances<T>(IEnumerable<Type> types, bool throwException = false)\r\n        {\r\n            \/\/Have removed logging because it doesn't really need to be logged since the time taken is generally 0ms.\r\n            \/\/we want to know if it fails ever, not how long it took if it is only 0.\r\n\r\n            var typesAsArray = types.ToArray();\r\n            \/\/using (DisposableTimer.DebugDuration<PluginManager>(\r\n            \/\/\tString.Format(\"Starting instantiation of {0} objects of type {1}\", typesAsArray.Length, typeof(T).FullName),\r\n            \/\/\tString.Format(\"Completed instantiation of {0} objects of type {1}\", typesAsArray.Length, typeof(T).FullName)))\r\n            \/\/{\r\n            var instances = new List<T>();\r\n            foreach (var t in typesAsArray)\r\n            {\r\n                try\r\n                {\r\n                    var typeInstance = (T)Activator.CreateInstance(t);\r\n                    instances.Add(typeInstance);\r\n                }\r\n                catch (Exception ex)\r\n                {\r\n\r\n                    LogHelper.Error<PluginManager>(String.Format(\"Error creating type {0}\", t.FullName), ex);\r\n\r\n                    if (throwException)\r\n                    {\r\n                        throw ex;\r\n                    }\r\n                }\r\n            }\r\n            return instances;\r\n            \/\/}\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Used to create an instance of the specified type based on the resolved\/cached plugin types\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <typeparam name=\"T\"><\/typeparam>\r\n        \/\/\/ <param name=\"type\"><\/param>\r\n        \/\/\/ <param name=\"throwException\"><\/param>\r\n        \/\/\/ <returns><\/returns>\r\n        internal T CreateInstance<T>(Type type, bool throwException = false)\r\n        {\r\n            var instances = CreateInstances<T>(new[] { type }, throwException);\r\n            return instances.FirstOrDefault();\r\n        }\r\n\r\n        private IEnumerable<Type> ResolveTypes<T>(\r\n            Func<IEnumerable<Type>> finder,\r\n            TypeResolutionKind resolutionType,\r\n            bool cacheResult)\r\n        {\r\n            using (var readLock = new UpgradeableReadLock(_lock))\r\n            {\r\n                var typesFound = new List<Type>();\r\n\r\n                using (DisposableTimer.TraceDuration<PluginManager>(\r\n                    () => String.Format(\"Starting resolution types of {0}\", typeof(T).FullName),\r\n                    () => String.Format(\"Completed resolution of types of {0}, found {1}\", typeof(T).FullName, typesFound.Count)))\r\n                {\r\n                    \/\/check if the TypeList already exists, if so return it, if not we'll create it\r\n                    var typeList = _types.SingleOrDefault(x => x.IsTypeList<T>(resolutionType));\r\n                    \/\/if we're not caching the result then proceed, or if the type list doesn't exist then proceed\r\n                    if (!cacheResult || typeList == null)\r\n                    {\r\n                        \/\/upgrade to a write lock since we're adding to the collection\r\n                        readLock.UpgradeToWriteLock();\r\n\r\n                        typeList = new TypeList<T>(resolutionType);\r\n\r\n                        \/\/we first need to look into our cache file (this has nothing to do with the 'cacheResult' parameter which caches in memory).\r\n                        \/\/if assemblies have not changed and the cache file actually exists, then proceed to try to lookup by the cache file.\r\n                        if (!HaveAssembliesChanged && File.Exists(GetPluginListFilePath()))\r\n                        {\r\n                            var fileCacheResult = TryGetCachedPluginsFromFile<T>(resolutionType);\r\n\r\n                            \/\/here we need to identify if the CachedPluginNotFoundInFile was the exception, if it was then we need to re-scan\r\n                            \/\/in some cases the plugin will not have been scanned for on application startup, but the assemblies haven't changed\r\n                            \/\/so in this instance there will never be a result.\r\n                            if (fileCacheResult.Error != null && fileCacheResult.Error is CachedPluginNotFoundInFile)\r\n                            {\r\n                                \/\/we don't have a cache for this so proceed to look them up by scanning\r\n                                LoadViaScanningAndUpdateCacheFile<T>(typeList, resolutionType, finder);\r\n                            }\r\n                            else\r\n                            {\r\n                                if (fileCacheResult.Success)\r\n                                {\r\n                                    var successfullyLoadedFromCache = true;\r\n                                    \/\/we have a previous cache for this so we don't need to scan we just load what has been found in the file\r\n                                    foreach (var t in fileCacheResult.Result)\r\n                                    {\r\n                                        try\r\n                                        {\r\n                                            \/\/we use the build manager to ensure we get all types loaded, this is slightly slower than\r\n                                            \/\/Type.GetType but if the types in the assembly aren't loaded yet then we have problems with that.\r\n                                            var type = BuildManager.GetType(t, true);\r\n                                            typeList.AddType(type);\r\n                                        }\r\n                                        catch (Exception ex)\r\n                                        {\r\n                                            \/\/if there are any exceptions loading types, we have to exist, this should never happen so \r\n                                            \/\/we will need to revert to scanning for types.\r\n                                            successfullyLoadedFromCache = false;\r\n                                            LogHelper.Error<PluginManager>(\"Could not load a cached plugin type: \" + t + \" now reverting to re-scanning assemblies for the base type: \" + typeof(T).FullName, ex);\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                    if (!successfullyLoadedFromCache)\r\n                                    {\r\n                                        \/\/we need to manually load by scanning if loading from the file was not successful.\r\n                                        LoadViaScanningAndUpdateCacheFile<T>(typeList, resolutionType, finder);\r\n                                    }\r\n                                    else\r\n                                    {\r\n                                        LogHelper.Debug<PluginManager>(\"Loaded plugin types \" + typeof(T).FullName + \" from persisted cache\");\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        else\r\n                        {\r\n                            \/\/we don't have a cache for this so proceed to look them up by scanning\r\n                            LoadViaScanningAndUpdateCacheFile<T>(typeList, resolutionType, finder);\r\n                        }\r\n\r\n                        \/\/only add the cache if we are to cache the results\r\n                        if (cacheResult)\r\n                        {\r\n                            \/\/add the type list to the collection\r\n                            _types.Add(typeList);\r\n                        }\r\n                    }\r\n                    typesFound = typeList.GetTypes().ToList();\r\n                }\r\n\r\n                return typesFound;\r\n            }\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ This method invokes the finder which scans the assemblies for the types and then loads the result into the type finder.\r\n        \/\/\/ Once the results are loaded, we update the cached type xml file\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <param name=\"typeList\"><\/param>\r\n        \/\/\/ <param name=\"resolutionKind\"> <\/param>\r\n        \/\/\/ <param name=\"finder\"><\/param>\r\n        \/\/\/ <remarks>\r\n        \/\/\/ THIS METHODS IS NOT THREAD SAFE\r\n        \/\/\/ <\/remarks>\r\n        private void LoadViaScanningAndUpdateCacheFile<T>(TypeList typeList, TypeResolutionKind resolutionKind, Func<IEnumerable<Type>> finder)\r\n        {\r\n            \/\/we don't have a cache for this so proceed to look them up by scanning\r\n            foreach (var t in finder())\r\n            {\r\n                typeList.AddType(t);\r\n            }\r\n            UpdateCachedPluginsFile<T>(typeList.GetTypes(), resolutionKind);\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Generic method to find the specified type and cache the result\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <typeparam name=\"T\"><\/typeparam>\r\n        \/\/\/ <returns><\/returns>\r\n        internal IEnumerable<Type> ResolveTypes<T>(bool cacheResult = true)\r\n        {\r\n            return ResolveTypes<T>(\r\n                () => TypeFinder.FindClassesOfType<T>(AssembliesToScan),\r\n                TypeResolutionKind.FindAllTypes,\r\n                cacheResult);\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Generic method to find the specified type that has an attribute and cache the result\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <typeparam name=\"T\"><\/typeparam>\r\n        \/\/\/ <typeparam name=\"TAttribute\"><\/typeparam>\r\n        \/\/\/ <returns><\/returns>\r\n        internal IEnumerable<Type> ResolveTypesWithAttribute<T, TAttribute>(bool cacheResult = true)\r\n            where TAttribute : Attribute\r\n        {\r\n            return ResolveTypes<T>(\r\n                () => TypeFinder.FindClassesOfTypeWithAttribute<T, TAttribute>(AssembliesToScan),\r\n                TypeResolutionKind.FindTypesWithAttribute,\r\n                cacheResult);\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Generic method to find any type that has the specified attribute\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <typeparam name=\"TAttribute\"><\/typeparam>\r\n        \/\/\/ <returns><\/returns>\r\n        internal IEnumerable<Type> ResolveAttributedTypes<TAttribute>(bool cacheResult = true)\r\n            where TAttribute : Attribute\r\n        {\r\n            return ResolveTypes<TAttribute>(\r\n                () => TypeFinder.FindClassesWithAttribute<TAttribute>(AssembliesToScan),\r\n                TypeResolutionKind.FindAttributedTypes,\r\n                cacheResult);\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Used for unit tests\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <returns><\/returns>\r\n        internal HashSet<TypeList> GetTypeLists()\r\n        {\r\n            return _types;\r\n        }\r\n\r\n\r\n\r\n        #region Private classes\/Enums\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ The type of resolution being invoked\r\n        \/\/\/ <\/summary>\r\n        internal enum TypeResolutionKind\r\n        {\r\n            FindAllTypes,\r\n            FindAttributedTypes,\r\n            FindTypesWithAttribute\r\n        }\r\n\r\n        internal abstract class TypeList\r\n        {\r\n            public abstract void AddType(Type t);\r\n            public abstract bool IsTypeList<TLookup>(TypeResolutionKind resolutionType);\r\n            public abstract IEnumerable<Type> GetTypes();\r\n        }\r\n\r\n        internal class TypeList<T> : TypeList\r\n        {\r\n            private readonly TypeResolutionKind _resolutionType;\r\n\r\n            public TypeList(TypeResolutionKind resolutionType)\r\n            {\r\n                _resolutionType = resolutionType;\r\n            }\r\n\r\n            private readonly List<Type> _types = new List<Type>();\r\n\r\n            public override void AddType(Type t)\r\n            {\r\n                \/\/if the type is an attribute type we won't do the type check because typeof<T> is going to be the \r\n                \/\/attribute type whereas the 't' type is the object type found with the attribute.\r\n                if (_resolutionType == TypeResolutionKind.FindAttributedTypes || t.IsType<T>())\r\n                {\r\n                    _types.Add(t);\r\n                }\r\n            }\r\n\r\n            \/\/\/ <summary>\r\n            \/\/\/ Returns true if the current TypeList is of the same type and of the same type\r\n            \/\/\/ <\/summary>\r\n            \/\/\/ <typeparam name=\"TLookup\"><\/typeparam>\r\n            \/\/\/ <param name=\"resolutionType\"><\/param>\r\n            \/\/\/ <returns><\/returns>\r\n            public override bool IsTypeList<TLookup>(TypeResolutionKind resolutionType)\r\n            {\r\n                return _resolutionType == resolutionType && (typeof(T)).IsType<TLookup>();\r\n            }\r\n\r\n            public override IEnumerable<Type> GetTypes()\r\n            {\r\n                return _types;\r\n            }\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ This class is used simply to determine that a plugin was not found in the cache plugin list with the specified\r\n        \/\/\/ TypeResolutionKind.\r\n        \/\/\/ <\/summary>\r\n        internal class CachedPluginNotFoundInFile : Exception\r\n        {\r\n\r\n        }\r\n\r\n        #endregion\r\n    }\r\n}\r\n","old_contents":"\ufeffusing System;\r\nusing System.Collections.Generic;\r\nusing System.Globalization;\r\nusing System.IO;\r\nusing System.Linq;\r\nusing System.Reflection;\r\nusing System.Text;\r\nusing System.Threading;\r\nusing System.Web.Compilation;\r\nusing System.Xml.Linq;\r\nusing Umbraco.Core.IO;\r\nusing Umbraco.Core.Logging;\r\nusing Umbraco.Core.PropertyEditors;\r\nusing umbraco.interfaces;\r\nusing File = System.IO.File;\r\n\r\nnamespace Umbraco.Core\r\n{\r\n\r\n    \/\/\/ <summary>\r\n    \/\/\/ Used to resolve all plugin types and cache them and is also used to instantiate plugin types\r\n    \/\/\/ <\/summary>\r\n    \/\/\/ <remarks>\r\n    \/\/\/ \r\n    \/\/\/ This class should be used to resolve all plugin types, the TypeFinder should not be used directly!\r\n    \/\/\/ \r\n    \/\/\/ This class can expose extension methods to resolve custom plugins\r\n    \/\/\/ \r\n    \/\/\/ Before this class resolves any plugins it checks if the hash has changed for the DLLs in the \/bin folder, if it hasn't\r\n    \/\/\/ it will use the cached resolved plugins that it has already found which means that no assembly scanning is necessary. This leads\r\n    \/\/\/ to much faster startup times.\r\n    \/\/\/ <\/remarks>\r\n    internal class PluginManager\r\n    {\r\n        private readonly ApplicationContext _appContext;\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Creates a new PluginManager with an ApplicationContext instance which ensures that the plugin xml \r\n        \/\/\/ file is cached temporarily until app startup completes.\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <param name=\"appContext\"><\/param>\r\n        \/\/\/ <param name=\"detectBinChanges\"><\/param>\r\n        internal PluginManager(ApplicationContext appContext, bool detectBinChanges = true)\r\n            : this(detectBinChanges)\r\n        {\r\n            if (appContext == null) throw new ArgumentNullException(\"appContext\");\r\n            _appContext = appContext;\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Creates a new PluginManager\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <param name=\"detectCodeChanges\">\r\n        \/\/\/ If true will detect changes in the \/bin folder and therefor load plugins from the \r\n        \/\/\/ cached plugins file if one is found. If false will never use the cache file for plugins\r\n        \/\/\/ <\/param>\r\n        internal PluginManager(bool detectCodeChanges = true)\r\n        {\r\n            _tempFolder = IOHelper.MapPath(\"~\/App_Data\/TEMP\/PluginCache\");\r\n            \/\/create the folder if it doesn't exist\r\n            if (!Directory.Exists(_tempFolder))\r\n            {\r\n                Directory.CreateDirectory(_tempFolder);\r\n            }\r\n\r\n            \/\/this is a check for legacy changes, before we didn't store the TypeResolutionKind in the file which was a mistake,\r\n            \/\/so we need to detect if the old file is there without this attribute, if it is then we delete it\r\n            if (DetectLegacyPluginListFile())\r\n            {\r\n                var filePath = GetPluginListFilePath();\r\n                File.Delete(filePath);\r\n            }\r\n\r\n            if (detectCodeChanges)\r\n            {\r\n                \/\/first check if the cached hash is 0, if it is then we ne\r\n                \/\/do the check if they've changed\r\n                HaveAssembliesChanged = (CachedAssembliesHash != CurrentAssembliesHash) || CachedAssembliesHash == 0;\r\n                \/\/if they have changed, we need to write the new file\r\n                if (HaveAssembliesChanged)\r\n                {\r\n                    WriteCachePluginsHash();\r\n                }\r\n            }\r\n            else\r\n            {\r\n                \/\/always set to true if we're not detecting (generally only for testing)\r\n                HaveAssembliesChanged = true;\r\n            }\r\n\r\n        }\r\n\r\n        static PluginManager _resolver;\r\n        static readonly ReaderWriterLockSlim Lock = new ReaderWriterLockSlim();\r\n        private readonly string _tempFolder;\r\n        private long _cachedAssembliesHash = -1;\r\n        private long _currentAssembliesHash = -1;\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ We will ensure that no matter what, only one of these is created, this is to ensure that caching always takes place\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <remarks>\r\n        \/\/\/ The setter is generally only used for unit tests\r\n        \/\/\/ <\/remarks>\r\n        internal static PluginManager Current\r\n        {\r\n            get\r\n            {\r\n                using (var l = new UpgradeableReadLock(Lock))\r\n                {\r\n                    if (_resolver == null)\r\n                    {\r\n                        l.UpgradeToWriteLock();\r\n                        _resolver = ApplicationContext.Current == null\r\n                            ? new PluginManager()\r\n                            : new PluginManager(ApplicationContext.Current);\r\n                    }\r\n                    return _resolver;\r\n                }\r\n            }\r\n            set { _resolver = value; }\r\n        }\r\n\r\n        #region Hash checking methods\r\n\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Returns a bool if the assemblies in the \/bin have changed since they were last hashed.\r\n        \/\/\/ <\/summary>\r\n        internal bool HaveAssembliesChanged { get; private set; }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Returns the currently cached hash value of the scanned assemblies in the \/bin folder. Returns 0 \r\n        \/\/\/ if no cache is found.\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <value> <\/value>\r\n        internal long CachedAssembliesHash\r\n        {\r\n            get\r\n            {\r\n                if (_cachedAssembliesHash != -1)\r\n                    return _cachedAssembliesHash;\r\n\r\n                var filePath = Path.Combine(_tempFolder, \"umbraco-plugins.hash\");\r\n                if (!File.Exists(filePath))\r\n                    return 0;\r\n                var hash = File.ReadAllText(filePath, Encoding.UTF8);\r\n                Int64 val;\r\n                if (Int64.TryParse(hash, out val))\r\n                {\r\n                    _cachedAssembliesHash = val;\r\n                    return _cachedAssembliesHash;\r\n                }\r\n                \/\/it could not parse for some reason so we'll return 0.\r\n                return 0;\r\n            }\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Returns the current assemblies hash based on creating a hash from the assemblies in the \/bin\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <value> <\/value>\r\n        internal long CurrentAssembliesHash\r\n        {\r\n            get\r\n            {\r\n                if (_currentAssembliesHash != -1)\r\n                    return _currentAssembliesHash;\r\n\r\n                _currentAssembliesHash = GetAssembliesHash(\r\n                    new FileSystemInfo[]\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\/\/add the bin folder and everything in it\r\n\t\t\t\t\t\t\tnew DirectoryInfo(IOHelper.MapPath(SystemDirectories.Bin)),\r\n\t\t\t\t\t\t\t\/\/add the app code folder and everything in it\r\n\t\t\t\t\t\t\tnew DirectoryInfo(IOHelper.MapPath(\"~\/App_Code\")),\r\n\t\t\t\t\t\t\t\/\/add the global.asax (the app domain also monitors this, if it changes will do a full restart)\r\n\t\t\t\t\t\t\tnew FileInfo(IOHelper.MapPath(\"~\/global.asax\")),\r\n                            \/\/add the trees.config\r\n                            new FileInfo(IOHelper.MapPath(SystemDirectories.Config + \"\/trees.config\"))\r\n\t\t\t\t\t\t}\r\n                    );\r\n                return _currentAssembliesHash;\r\n            }\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Writes the assembly hash file\r\n        \/\/\/ <\/summary>\r\n        private void WriteCachePluginsHash()\r\n        {\r\n            var filePath = Path.Combine(_tempFolder, \"umbraco-plugins.hash\");\r\n            File.WriteAllText(filePath, CurrentAssembliesHash.ToString(), Encoding.UTF8);\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Returns a unique hash for the combination of FileInfo objects passed in\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <param name=\"filesAndFolders\"><\/param>\r\n        \/\/\/ <returns><\/returns>\r\n        internal static long GetAssembliesHash(IEnumerable<FileSystemInfo> filesAndFolders)\r\n        {\r\n            using (DisposableTimer.TraceDuration<PluginManager>(\"Determining hash of code files on disk\", \"Hash determined\"))\r\n            {\r\n                var hashCombiner = new HashCodeCombiner();\r\n                \/\/add each unique folder to the hash\r\n                foreach (var i in filesAndFolders.DistinctBy(x => x.FullName))\r\n                {\r\n                    hashCombiner.AddFileSystemItem(i);\r\n                }\r\n                return ConvertPluginsHashFromHex(hashCombiner.GetCombinedHashCode());\r\n            }\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Converts the hash value of current plugins to long from string\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <param name=\"val\"><\/param>\r\n        \/\/\/ <returns><\/returns>\r\n        internal static long ConvertPluginsHashFromHex(string val)\r\n        {\r\n            long outVal;\r\n            if (Int64.TryParse(val, NumberStyles.AllowHexSpecifier, CultureInfo.InvariantCulture, out outVal))\r\n            {\r\n                return outVal;\r\n            }\r\n            return 0;\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Attempts to resolve the list of plugin + assemblies found in the runtime for the base type 'T' passed in.\r\n        \/\/\/ If the cache file doesn't exist, fails to load, is corrupt or the type 'T' element is not found then \r\n        \/\/\/ a false attempt is returned.\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <typeparam name=\"T\"><\/typeparam>\r\n        \/\/\/ <returns><\/returns>\r\n        internal Attempt<IEnumerable<string>> TryGetCachedPluginsFromFile<T>(TypeResolutionKind resolutionType)\r\n        {\r\n            var filePath = GetPluginListFilePath();\r\n            if (!File.Exists(filePath))\r\n                return Attempt<IEnumerable<string>>.False;\r\n\r\n            try\r\n            {\r\n                \/\/we will load the xml document, if the app context exist, we will load it from the cache (which is only around for 5 minutes)\r\n                \/\/while the app boots up, this should save some IO time on app startup when the app context is there (which is always unless in unit tests)\r\n                XDocument xml;\r\n                if (_appContext != null)\r\n                {\r\n                    xml = _appContext.ApplicationCache.GetCacheItem(\"umbraco-plugins.list\",\r\n                        new TimeSpan(0, 0, 5, 0),\r\n                        () => XDocument.Load(filePath));\r\n                }\r\n                else\r\n                {\r\n                    xml = XDocument.Load(filePath);\r\n                }\r\n\r\n\r\n                if (xml.Root == null)\r\n                    return Attempt<IEnumerable<string>>.False;\r\n\r\n                var typeElement = xml.Root.Elements()\r\n                    .SingleOrDefault(x =>\r\n                                     x.Name.LocalName == \"baseType\"\r\n                                     && ((string)x.Attribute(\"type\")) == typeof(T).FullName\r\n                                     && ((string)x.Attribute(\"resolutionType\")) == resolutionType.ToString());\r\n\r\n                \/\/return false but specify this exception type so we can detect it\r\n                if (typeElement == null)\r\n                    return new Attempt<IEnumerable<string>>(new CachedPluginNotFoundInFile());\r\n\r\n                \/\/return success\r\n                return new Attempt<IEnumerable<string>>(\r\n                    true,\r\n                    typeElement.Elements(\"add\")\r\n                        .Select(x => (string)x.Attribute(\"type\")));\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                \/\/if the file is corrupted, etc... return false\r\n                return new Attempt<IEnumerable<string>>(ex);\r\n            }\r\n        }\r\n\r\n        private string GetPluginListFilePath()\r\n        {\r\n            return Path.Combine(_tempFolder, \"umbraco-plugins.list\");\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ This will return true if the plugin list file is a legacy one\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <returns><\/returns>\r\n        \/\/\/ <remarks>\r\n        \/\/\/ This method exists purely due to an error in 4.11. We were writing the plugin list file without the \r\n        \/\/\/ type resolution kind which will have caused some problems. Now we detect this legacy file and if it is detected\r\n        \/\/\/ we remove it so it can be recreated properly.\r\n        \/\/\/ <\/remarks>\r\n        internal bool DetectLegacyPluginListFile()\r\n        {\r\n            var filePath = GetPluginListFilePath();\r\n            if (!File.Exists(filePath))\r\n                return false;\r\n\r\n            try\r\n            {\r\n                var xml = XDocument.Load(filePath);\r\n                if (xml.Root == null)\r\n                    return false;\r\n\r\n                var typeElement = xml.Root.Elements()\r\n                    .FirstOrDefault(x => x.Name.LocalName == \"baseType\");\r\n\r\n                if (typeElement == null)\r\n                    return false;\r\n\r\n                \/\/now check if the typeElement is missing the resolutionType attribute\r\n                return typeElement.Attributes().All(x => x.Name.LocalName != \"resolutionType\");\r\n            }\r\n            catch (Exception)\r\n            {\r\n                \/\/if the file is corrupted, etc... return true so it is removed\r\n                return true;\r\n            }\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Adds\/Updates the type list for the base type 'T' in the cached file\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <typeparam name=\"T\"><\/typeparam>\r\n        \/\/\/ <param name=\"typesFound\"><\/param>\r\n        \/\/\/<param name=\"resolutionType\"> <\/param>\r\n        \/\/\/<remarks>\r\n        \/\/\/ THIS METHOD IS NOT THREAD SAFE\r\n        \/\/\/ <\/remarks>\r\n        \/\/\/ <example>\r\n        \/\/\/ <![CDATA[\r\n        \/\/\/ <plugins>\r\n        \/\/\/\t\t<baseType type=\"Test.Testing.Tester\">\r\n        \/\/\/\t\t\t<add type=\"My.Assembly.MyTester\" assembly=\"My.Assembly\" \/>\r\n        \/\/\/\t\t\t<add type=\"Your.Assembly.YourTester\" assembly=\"Your.Assembly\" \/>\r\n        \/\/\/\t\t<\/baseType>\r\n        \/\/\/ <\/plugins>\r\n        \/\/\/ ]]>\r\n        \/\/\/ <\/example>\r\n        internal void UpdateCachedPluginsFile<T>(IEnumerable<Type> typesFound, TypeResolutionKind resolutionType)\r\n        {\r\n            var filePath = GetPluginListFilePath();\r\n            XDocument xml;\r\n            try\r\n            {\r\n                xml = XDocument.Load(filePath);\r\n            }\r\n            catch\r\n            {\r\n                \/\/if there's an exception loading then this is somehow corrupt, we'll just replace it.\r\n                File.Delete(filePath);\r\n                \/\/create the document and the root\r\n                xml = new XDocument(new XElement(\"plugins\"));\r\n            }\r\n            if (xml.Root == null)\r\n            {\r\n                \/\/if for some reason there is no root, create it\r\n                xml.Add(new XElement(\"plugins\"));\r\n            }\r\n            \/\/find the type 'T' element to add or update\r\n            var typeElement = xml.Root.Elements()\r\n                .SingleOrDefault(x =>\r\n                                 x.Name.LocalName == \"baseType\"\r\n                                 && ((string)x.Attribute(\"type\")) == typeof(T).FullName\r\n                                 && ((string)x.Attribute(\"resolutionType\")) == resolutionType.ToString());\r\n\r\n            if (typeElement == null)\r\n            {\r\n                \/\/create the type element\r\n                typeElement = new XElement(\"baseType\",\r\n                    new XAttribute(\"type\", typeof(T).FullName),\r\n                    new XAttribute(\"resolutionType\", resolutionType.ToString()));\r\n                \/\/then add it to the root\r\n                xml.Root.Add(typeElement);\r\n            }\r\n\r\n\r\n            \/\/now we have the type element, we need to clear any previous types as children and add\/update it with new ones\r\n            typeElement.ReplaceNodes(typesFound.Select(x => new XElement(\"add\", new XAttribute(\"type\", x.AssemblyQualifiedName))));\r\n            \/\/save the xml file\r\n            xml.Save(filePath);\r\n        }\r\n\r\n        #endregion\r\n\r\n        private readonly ReaderWriterLockSlim _lock = new ReaderWriterLockSlim();\r\n        private readonly HashSet<TypeList> _types = new HashSet<TypeList>();\r\n        private IEnumerable<Assembly> _assemblies;\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Returns all classes attributed with XsltExtensionAttribute attribute\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <returns><\/returns>\r\n        internal IEnumerable<Type> ResolveCacheRefreshers()\r\n        {\r\n            return ResolveTypes<ICacheRefresher>();\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Returns all available IPropertyEditorValueConverter\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <returns><\/returns>\r\n        internal IEnumerable<Type> ResolvePropertyEditorValueConverters()\r\n        {\r\n            return ResolveTypes<IPropertyEditorValueConverter>();\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Returns all available IDataType in application\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <returns><\/returns>\r\n        internal IEnumerable<Type> ResolveDataTypes()\r\n        {\r\n            return ResolveTypes<IDataType>();\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Returns all available IMacroGuiRendering in application\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <returns><\/returns>\r\n        internal IEnumerable<Type> ResolveMacroRenderings()\r\n        {\r\n            return ResolveTypes<IMacroGuiRendering>();\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Returns all available IPackageAction in application\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <returns><\/returns>\r\n        internal IEnumerable<Type> ResolvePackageActions()\r\n        {\r\n            return ResolveTypes<IPackageAction>();\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Returns all available IAction in application\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <returns><\/returns>\r\n        internal IEnumerable<Type> ResolveActions()\r\n        {\r\n            return ResolveTypes<IAction>();\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Gets\/sets which assemblies to scan when type finding, generally used for unit testing, if not explicitly set\r\n        \/\/\/ this will search all assemblies known to have plugins and exclude ones known to not have them.\r\n        \/\/\/ <\/summary>\r\n        internal IEnumerable<Assembly> AssembliesToScan\r\n        {\r\n            get { return _assemblies ?? (_assemblies = TypeFinder.GetAssembliesWithKnownExclusions()); }\r\n            set { _assemblies = value; }\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Used to resolve and create instances of the specified type based on the resolved\/cached plugin types\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <typeparam name=\"T\"><\/typeparam>\r\n        \/\/\/ <param name=\"throwException\">set to true if an exception is to be thrown if there is an error during instantiation<\/param>\r\n        \/\/\/ <returns><\/returns>\r\n        internal IEnumerable<T> FindAndCreateInstances<T>(bool throwException = false)\r\n        {\r\n            var types = ResolveTypes<T>();\r\n            return CreateInstances<T>(types, throwException);\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Used to create instances of the specified type based on the resolved\/cached plugin types\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <typeparam name=\"T\"><\/typeparam>\r\n        \/\/\/ <param name=\"types\"><\/param>\r\n        \/\/\/ <param name=\"throwException\">set to true if an exception is to be thrown if there is an error during instantiation<\/param>\r\n        \/\/\/ <returns><\/returns>\r\n        internal IEnumerable<T> CreateInstances<T>(IEnumerable<Type> types, bool throwException = false)\r\n        {\r\n            \/\/Have removed logging because it doesn't really need to be logged since the time taken is generally 0ms.\r\n            \/\/we want to know if it fails ever, not how long it took if it is only 0.\r\n\r\n            var typesAsArray = types.ToArray();\r\n            \/\/using (DisposableTimer.DebugDuration<PluginManager>(\r\n            \/\/\tString.Format(\"Starting instantiation of {0} objects of type {1}\", typesAsArray.Length, typeof(T).FullName),\r\n            \/\/\tString.Format(\"Completed instantiation of {0} objects of type {1}\", typesAsArray.Length, typeof(T).FullName)))\r\n            \/\/{\r\n            var instances = new List<T>();\r\n            foreach (var t in typesAsArray)\r\n            {\r\n                try\r\n                {\r\n                    var typeInstance = (T)Activator.CreateInstance(t);\r\n                    instances.Add(typeInstance);\r\n                }\r\n                catch (Exception ex)\r\n                {\r\n\r\n                    LogHelper.Error<PluginManager>(String.Format(\"Error creating type {0}\", t.FullName), ex);\r\n\r\n                    if (throwException)\r\n                    {\r\n                        throw ex;\r\n                    }\r\n                }\r\n            }\r\n            return instances;\r\n            \/\/}\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Used to create an instance of the specified type based on the resolved\/cached plugin types\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <typeparam name=\"T\"><\/typeparam>\r\n        \/\/\/ <param name=\"type\"><\/param>\r\n        \/\/\/ <param name=\"throwException\"><\/param>\r\n        \/\/\/ <returns><\/returns>\r\n        internal T CreateInstance<T>(Type type, bool throwException = false)\r\n        {\r\n            var instances = CreateInstances<T>(new[] { type }, throwException);\r\n            return instances.FirstOrDefault();\r\n        }\r\n\r\n        private IEnumerable<Type> ResolveTypes<T>(\r\n            Func<IEnumerable<Type>> finder,\r\n            TypeResolutionKind resolutionType,\r\n            bool cacheResult)\r\n        {\r\n            using (var readLock = new UpgradeableReadLock(_lock))\r\n            {\r\n                var typesFound = new List<Type>();\r\n\r\n                using (DisposableTimer.TraceDuration<PluginManager>(\r\n                    () => String.Format(\"Starting resolution types of {0}\", typeof(T).FullName),\r\n                    () => String.Format(\"Completed resolution of types of {0}, found {1}\", typeof(T).FullName, typesFound.Count)))\r\n                {\r\n                    \/\/check if the TypeList already exists, if so return it, if not we'll create it\r\n                    var typeList = _types.SingleOrDefault(x => x.IsTypeList<T>(resolutionType));\r\n                    \/\/if we're not caching the result then proceed, or if the type list doesn't exist then proceed\r\n                    if (!cacheResult || typeList == null)\r\n                    {\r\n                        \/\/upgrade to a write lock since we're adding to the collection\r\n                        readLock.UpgradeToWriteLock();\r\n\r\n                        typeList = new TypeList<T>(resolutionType);\r\n\r\n                        \/\/we first need to look into our cache file (this has nothing to do with the 'cacheResult' parameter which caches in memory).\r\n                        \/\/if assemblies have not changed and the cache file actually exists, then proceed to try to lookup by the cache file.\r\n                        if (!HaveAssembliesChanged && File.Exists(GetPluginListFilePath()))\r\n                        {\r\n                            var fileCacheResult = TryGetCachedPluginsFromFile<T>(resolutionType);\r\n\r\n                            \/\/here we need to identify if the CachedPluginNotFoundInFile was the exception, if it was then we need to re-scan\r\n                            \/\/in some cases the plugin will not have been scanned for on application startup, but the assemblies haven't changed\r\n                            \/\/so in this instance there will never be a result.\r\n                            if (fileCacheResult.Error != null && fileCacheResult.Error is CachedPluginNotFoundInFile)\r\n                            {\r\n                                \/\/we don't have a cache for this so proceed to look them up by scanning\r\n                                LoadViaScanningAndUpdateCacheFile<T>(typeList, resolutionType, finder);\r\n                            }\r\n                            else\r\n                            {\r\n                                if (fileCacheResult.Success)\r\n                                {\r\n                                    var successfullyLoadedFromCache = true;\r\n                                    \/\/we have a previous cache for this so we don't need to scan we just load what has been found in the file\r\n                                    foreach (var t in fileCacheResult.Result)\r\n                                    {\r\n                                        try\r\n                                        {\r\n                                            \/\/we use the build manager to ensure we get all types loaded, this is slightly slower than\r\n                                            \/\/Type.GetType but if the types in the assembly aren't loaded yet then we have problems with that.\r\n                                            var type = BuildManager.GetType(t, true);\r\n                                            typeList.AddType(type);\r\n                                        }\r\n                                        catch (Exception ex)\r\n                                        {\r\n                                            \/\/if there are any exceptions loading types, we have to exist, this should never happen so \r\n                                            \/\/we will need to revert to scanning for types.\r\n                                            successfullyLoadedFromCache = false;\r\n                                            LogHelper.Error<PluginManager>(\"Could not load a cached plugin type: \" + t + \" now reverting to re-scanning assemblies for the base type: \" + typeof(T).FullName, ex);\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                    if (!successfullyLoadedFromCache)\r\n                                    {\r\n                                        \/\/we need to manually load by scanning if loading from the file was not successful.\r\n                                        LoadViaScanningAndUpdateCacheFile<T>(typeList, resolutionType, finder);\r\n                                    }\r\n                                    else\r\n                                    {\r\n                                        LogHelper.Debug<PluginManager>(\"Loaded plugin types \" + typeof(T).FullName + \" from persisted cache\");\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        else\r\n                        {\r\n                            \/\/we don't have a cache for this so proceed to look them up by scanning\r\n                            LoadViaScanningAndUpdateCacheFile<T>(typeList, resolutionType, finder);\r\n                        }\r\n\r\n                        \/\/only add the cache if we are to cache the results\r\n                        if (cacheResult)\r\n                        {\r\n                            \/\/add the type list to the collection\r\n                            _types.Add(typeList);\r\n                        }\r\n                    }\r\n                    typesFound = typeList.GetTypes().ToList();\r\n                }\r\n\r\n                return typesFound;\r\n            }\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ This method invokes the finder which scans the assemblies for the types and then loads the result into the type finder.\r\n        \/\/\/ Once the results are loaded, we update the cached type xml file\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <param name=\"typeList\"><\/param>\r\n        \/\/\/ <param name=\"resolutionKind\"> <\/param>\r\n        \/\/\/ <param name=\"finder\"><\/param>\r\n        \/\/\/ <remarks>\r\n        \/\/\/ THIS METHODS IS NOT THREAD SAFE\r\n        \/\/\/ <\/remarks>\r\n        private void LoadViaScanningAndUpdateCacheFile<T>(TypeList typeList, TypeResolutionKind resolutionKind, Func<IEnumerable<Type>> finder)\r\n        {\r\n            \/\/we don't have a cache for this so proceed to look them up by scanning\r\n            foreach (var t in finder())\r\n            {\r\n                typeList.AddType(t);\r\n            }\r\n            UpdateCachedPluginsFile<T>(typeList.GetTypes(), resolutionKind);\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Generic method to find the specified type and cache the result\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <typeparam name=\"T\"><\/typeparam>\r\n        \/\/\/ <returns><\/returns>\r\n        internal IEnumerable<Type> ResolveTypes<T>(bool cacheResult = true)\r\n        {\r\n            return ResolveTypes<T>(\r\n                () => TypeFinder.FindClassesOfType<T>(AssembliesToScan),\r\n                TypeResolutionKind.FindAllTypes,\r\n                cacheResult);\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Generic method to find the specified type that has an attribute and cache the result\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <typeparam name=\"T\"><\/typeparam>\r\n        \/\/\/ <typeparam name=\"TAttribute\"><\/typeparam>\r\n        \/\/\/ <returns><\/returns>\r\n        internal IEnumerable<Type> ResolveTypesWithAttribute<T, TAttribute>(bool cacheResult = true)\r\n            where TAttribute : Attribute\r\n        {\r\n            return ResolveTypes<T>(\r\n                () => TypeFinder.FindClassesOfTypeWithAttribute<T, TAttribute>(AssembliesToScan),\r\n                TypeResolutionKind.FindTypesWithAttribute,\r\n                cacheResult);\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Generic method to find any type that has the specified attribute\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <typeparam name=\"TAttribute\"><\/typeparam>\r\n        \/\/\/ <returns><\/returns>\r\n        internal IEnumerable<Type> ResolveAttributedTypes<TAttribute>(bool cacheResult = true)\r\n            where TAttribute : Attribute\r\n        {\r\n            return ResolveTypes<TAttribute>(\r\n                () => TypeFinder.FindClassesWithAttribute<TAttribute>(AssembliesToScan),\r\n                TypeResolutionKind.FindAttributedTypes,\r\n                cacheResult);\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Used for unit tests\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <returns><\/returns>\r\n        internal HashSet<TypeList> GetTypeLists()\r\n        {\r\n            return _types;\r\n        }\r\n\r\n\r\n\r\n        #region Private classes\/Enums\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ The type of resolution being invoked\r\n        \/\/\/ <\/summary>\r\n        internal enum TypeResolutionKind\r\n        {\r\n            FindAllTypes,\r\n            FindAttributedTypes,\r\n            FindTypesWithAttribute\r\n        }\r\n\r\n        internal abstract class TypeList\r\n        {\r\n            public abstract void AddType(Type t);\r\n            public abstract bool IsTypeList<TLookup>(TypeResolutionKind resolutionType);\r\n            public abstract IEnumerable<Type> GetTypes();\r\n        }\r\n\r\n        internal class TypeList<T> : TypeList\r\n        {\r\n            private readonly TypeResolutionKind _resolutionType;\r\n\r\n            public TypeList(TypeResolutionKind resolutionType)\r\n            {\r\n                _resolutionType = resolutionType;\r\n            }\r\n\r\n            private readonly List<Type> _types = new List<Type>();\r\n\r\n            public override void AddType(Type t)\r\n            {\r\n                \/\/if the type is an attribute type we won't do the type check because typeof<T> is going to be the \r\n                \/\/attribute type whereas the 't' type is the object type found with the attribute.\r\n                if (_resolutionType == TypeResolutionKind.FindAttributedTypes || t.IsType<T>())\r\n                {\r\n                    _types.Add(t);\r\n                }\r\n            }\r\n\r\n            \/\/\/ <summary>\r\n            \/\/\/ Returns true if the current TypeList is of the same type and of the same type\r\n            \/\/\/ <\/summary>\r\n            \/\/\/ <typeparam name=\"TLookup\"><\/typeparam>\r\n            \/\/\/ <param name=\"resolutionType\"><\/param>\r\n            \/\/\/ <returns><\/returns>\r\n            public override bool IsTypeList<TLookup>(TypeResolutionKind resolutionType)\r\n            {\r\n                return _resolutionType == resolutionType && (typeof(T)).IsType<TLookup>();\r\n            }\r\n\r\n            public override IEnumerable<Type> GetTypes()\r\n            {\r\n                return _types;\r\n            }\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ This class is used simply to determine that a plugin was not found in the cache plugin list with the specified\r\n        \/\/\/ TypeResolutionKind.\r\n        \/\/\/ <\/summary>\r\n        internal class CachedPluginNotFoundInFile : Exception\r\n        {\r\n\r\n        }\r\n\r\n        #endregion\r\n    }\r\n}\r\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"3354c9c1f431e24caa523a480b7e45cbb4402212","subject":"Supported argument parsing to run startup actions (but no actions yet available).","message":"Supported argument parsing to run startup actions (but no actions yet available).\n","repos":"per-samuelsson\/WhatsNotReferenced","old_file":"src\/WhatsNotReferenced\/Program.cs","new_file":"src\/WhatsNotReferenced\/Program.cs","new_contents":"\ufeff\nusing System;\nusing Starcounter;\nusing System.Linq;\n\nnamespace WhatsNotReferenced\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            RunStartupActions(args);\n\n            Handle.GET(\"\/whatsnotreferenced\", () =>\n            {\n                var assets = UnreferencedAssets.Detect();\n\n                var apps = string.Join(Environment.NewLine, assets.Apps.Select(a => a.DisplayName));\n                var tables = string.Join(Environment.NewLine, assets.Tables.Select(c => c.FullName));\n                var columns = string.Join(Environment.NewLine, assets.Columns.Select(c => c.TableName + \".\" + c.Name));\n\n                var result = \"Apps (exluding this):\";\n                result += Environment.NewLine + apps;\n                result += Environment.NewLine + Environment.NewLine + \"Tables:\";\n                result += Environment.NewLine + tables;\n                result += Environment.NewLine + Environment.NewLine + \"Columns:\";\n                result += Environment.NewLine + columns;\n\n                return result;\n            });\n        }\n\n        static void RunStartupActions(string[] args)\n        {\n            \/\/ Eventually:\n            \/\/ args[n]: please:[action] supporting `star WhatsNotReferenced please:drop`\n\n            var actions = args.Select(a =>\n            {\n                if (!a.StartsWith(\"please:\")) throw new ArgumentException($\"Invalid argument: {a}\");\n                return a.Substring(\"please:\".Length);\n            });\n\n            foreach (var action in actions)\n            {\n                switch (action.ToLowerInvariant())\n                {\n                    case \"drop\":\n                        throw new NotImplementedException(\"Dropping will be supported soon\");\n                    default:\n                        throw new ArgumentOutOfRangeException(action, $\"Don't know how to perform action {action}\");\n                }\n            }\n        }\n    }\n}","old_contents":"\ufeff\nusing System;\nusing Starcounter;\nusing System.Linq;\n\nnamespace WhatsNotReferenced\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            \/\/ Eventually:\n            \/\/ args[n]: please:[action] supporting `star WhatsNotReferenced please:drop`\n\n            Handle.GET(\"\/whatsnotreferenced\", () =>\n            {\n                var assets = UnreferencedAssets.Detect();\n\n                var apps = string.Join(Environment.NewLine, assets.Apps.Select(a => a.DisplayName));\n                var tables = string.Join(Environment.NewLine, assets.Tables.Select(c => c.FullName));\n                var columns = string.Join(Environment.NewLine, assets.Columns.Select(c => c.TableName + \".\" + c.Name));\n\n                var result = \"Apps (exluding this):\";\n                result += Environment.NewLine + apps;\n                result += Environment.NewLine + Environment.NewLine + \"Tables:\";\n                result += Environment.NewLine + tables;\n                result += Environment.NewLine + Environment.NewLine + \"Columns:\";\n                result += Environment.NewLine + columns;\n\n                return result;\n            });\n        }\n    }\n}","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"1aa85246695d4fc6d62571ed0f359ed60505a2a8","subject":"Oops, reversed the subtraction operands.","message":"Oops, reversed the subtraction operands.\n","repos":"rhythmagency\/whodunit,rhythmagency\/whodunit,rhythmagency\/whodunit","old_file":"src\/Whodunit.app\/HistoryHelper.cs","new_file":"src\/Whodunit.app\/HistoryHelper.cs","new_contents":"\ufeffnamespace Whodunit.app\n{\n\n    \/\/ Namespaces.\n    using System;\n    using System.Collections.Generic;\n    using Umbraco.Core;\n    using Umbraco.Core.Logging;\n    using Umbraco.Core.Persistence;\n    using Whodunit.app.Models;\n\n\n    \/\/\/ <summary>\n    \/\/\/ Helps with history items in the database.\n    \/\/\/ <\/summary>\n    public class HistoryHelper\n    {\n\n        #region Variables\n\n        private static Database _sqlHelper;\n\n        #endregion\n\n\n        #region Constructors\n\n        \/\/\/ <summary>\n        \/\/\/ Static constructor.\n        \/\/\/ <\/summary>\n        static HistoryHelper()\n        {\n            _sqlHelper = ApplicationContext.Current.DatabaseContext.Database;\n        }\n\n        #endregion\n\n\n        #region Methods\n\n        \/\/\/ <summary>\n        \/\/\/ Gets all history items in the specified date range from the database.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"startDate\">\n        \/\/\/ The start of the date range, inclusive.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"endDate\">\n        \/\/\/ The end of the date range, exclusive.\n        \/\/\/ <\/param>\n        \/\/\/ <returns>\n        \/\/\/ The history items.\n        \/\/\/ <\/returns>\n        public static List<HistoryItem> GetHistoryItems(DateTime startDate, DateTime endDate)\n        {\n            var query = $\"SELECT * FROM {HistoryItem.TableName} WHERE Timestamp >= @0 AND Timestamp < @1\";\n            return _sqlHelper.Fetch<HistoryItem>(query, startDate, endDate);\n        }\n\n\n        \/\/\/ <summary>\n        \/\/\/ Adds a history item to the databse.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"message\">\n        \/\/\/ The message to add to the history item.\n        \/\/\/ <\/param>\n        public static void AddHistoryItem(string message)\n        {\n\n            \/\/ Variables.\n            var now = DateTime.Now;\n            var parts = new List<string>();\n\n\n            \/\/ Split message into parts to avoid SQL errors.\n            for (var i = 0; i < message.Length; i += 3000)\n            {\n                var length = Math.Min(3000, message.Length - i);\n                var part = message.Substring(i, length);\n                if (parts.Count > 0)\n                {\n                    part = \"(Truncated message continued) \" + part;\n                }\n                parts.Add(part);\n            }\n\n\n            \/\/ Log each message part.\n            for (var i = 0; i < parts.Count; i++)\n            {\n                HistoryItem newItem = new HistoryItem()\n                {\n                    Message = parts[i],\n                    Timestamp = now\n                };\n\n\n                \/\/ Attempt to insert history message.\n                try\n                {\n                    _sqlHelper.Insert(\n                        HistoryItem.TableName,\n                        HistoryItem.PrimaryKeyName,\n                        true,\n                        newItem\n                    );\n                }\n                catch (Exception ex)\n                {\n                    LogHelper.Error<HistoryHelper>(\"Error inserting history message.\", ex);\n                }\n\n            }\n\n        }\n\n        #endregion\n\n    }\n\n}","old_contents":"\ufeffnamespace Whodunit.app\n{\n\n    \/\/ Namespaces.\n    using System;\n    using System.Collections.Generic;\n    using Umbraco.Core;\n    using Umbraco.Core.Logging;\n    using Umbraco.Core.Persistence;\n    using Whodunit.app.Models;\n\n\n    \/\/\/ <summary>\n    \/\/\/ Helps with history items in the database.\n    \/\/\/ <\/summary>\n    public class HistoryHelper\n    {\n\n        #region Variables\n\n        private static Database _sqlHelper;\n\n        #endregion\n\n\n        #region Constructors\n\n        \/\/\/ <summary>\n        \/\/\/ Static constructor.\n        \/\/\/ <\/summary>\n        static HistoryHelper()\n        {\n            _sqlHelper = ApplicationContext.Current.DatabaseContext.Database;\n        }\n\n        #endregion\n\n\n        #region Methods\n\n        \/\/\/ <summary>\n        \/\/\/ Gets all history items in the specified date range from the database.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"startDate\">\n        \/\/\/ The start of the date range, inclusive.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"endDate\">\n        \/\/\/ The end of the date range, exclusive.\n        \/\/\/ <\/param>\n        \/\/\/ <returns>\n        \/\/\/ The history items.\n        \/\/\/ <\/returns>\n        public static List<HistoryItem> GetHistoryItems(DateTime startDate, DateTime endDate)\n        {\n            var query = $\"SELECT * FROM {HistoryItem.TableName} WHERE Timestamp >= @0 AND Timestamp < @1\";\n            return _sqlHelper.Fetch<HistoryItem>(query, startDate, endDate);\n        }\n\n\n        \/\/\/ <summary>\n        \/\/\/ Adds a history item to the databse.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"message\">\n        \/\/\/ The message to add to the history item.\n        \/\/\/ <\/param>\n        public static void AddHistoryItem(string message)\n        {\n\n            \/\/ Variables.\n            var now = DateTime.Now;\n            var parts = new List<string>();\n\n\n            \/\/ Split message into parts to avoid SQL errors.\n            for (var i = 0; i < message.Length; i += 3000)\n            {\n                var length = Math.Min(3000, i - message.Length);\n                var part = message.Substring(i, length);\n                if (parts.Count > 0)\n                {\n                    part = \"(Truncated message continued) \" + part;\n                }\n                parts.Add(part);\n            }\n\n\n            \/\/ Log each message part.\n            for (var i = 0; i < parts.Count; i++)\n            {\n                HistoryItem newItem = new HistoryItem()\n                {\n                    Message = parts[i],\n                    Timestamp = now\n                };\n\n\n                \/\/ Attempt to insert history message.\n                try\n                {\n                    _sqlHelper.Insert(\n                        HistoryItem.TableName,\n                        HistoryItem.PrimaryKeyName,\n                        true,\n                        newItem\n                    );\n                }\n                catch (Exception ex)\n                {\n                    LogHelper.Error<HistoryHelper>(\"Error inserting history message.\", ex);\n                }\n\n            }\n\n        }\n\n        #endregion\n\n    }\n\n}","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"01e16c56d0bc35c5e5af8ed449d7a7f6fcda8b7e","subject":"perfectly reproduce korf 2002 numbers","message":"perfectly reproduce korf 2002 numbers\n","repos":"NickLarsen\/heuristic-search","old_file":"src\/npuzzle\/Program.cs","new_file":"src\/npuzzle\/Program.cs","new_contents":"\ufeffusing System;\r\nusing System.Collections;\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics;\r\nusing System.IO;\r\nusing System.Linq;\r\n\r\nnamespace npuzzle\r\n{\r\n    class Program\r\n    {\r\n        private const string timerFormat = @\"hh\\:mm\\:ss\\.fff\";\r\n        private static Stopwatch timer;\r\n        private static long lastMillis;\r\n        private static ulong nodeCounter;\r\n        private static string outputFormat;\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            \/\/CreatePDB(new[] { \"build-pdb\", \"15dj-vl.data\", \"4\", \"4\", \"1,4,5,8,9,12,13\" });\r\n            \/\/CreatePDB(new[] { \"build-pdb\", \"15dj-vr.data\", \"4\", \"4\", \"2,3,6,7,10,11,14,15\" });\r\n            \/\/CreatePDB(new[] { \"build-pdb\", \"24dj2-tr.data\", \"5\", \"5\", \"2,3,4,7,8,9\" });\r\n            \/\/CreatePDB(new[] { \"build-pdb\", \"24dj2-br.data\", \"5\", \"5\", \"13,14,18,19,23,24\" });\r\n            \/\/CreatePDB(new[] { \"build-pdb\", \"24dj2-bl.data\", \"5\", \"5\", \"15,16,17,20,21,22\" });\r\n            \/\/CreatePDB(new[] { \"build-pdb\", \"24dj2-tl.data\", \"5\", \"5\", \"1,5,6,10,11,12\" });\r\n            \/\/FastIDAStar(Convert.ToInt32(args[0]));\r\n            FastIDAStar(40);\r\n            \/\/DoIDAStar(new [] { \"korf-dj15-{0}.txt\" });\r\n            \/\/BreakdownPdbs(\"24dj-tr.data\", \"24dj-br.data\", \"24dj-bl.data\", \"24dj-tl.data\");\r\n            \/\/BreakdownPdbs(\"15dj-vl.data\");\r\n        }\r\n\r\n        static void BreakdownPdbs(params string[] filenames)\r\n        {\r\n            foreach (var filename in filenames)\r\n            {\r\n                Console.WriteLine(\"\\n\" + filename);\r\n                var pdb = new PatternDatabase(filename);\r\n                var breakdown = pdb.GetValueCounts().OrderBy(m => m.Key).ToArray();\r\n                foreach (var kvp in breakdown)\r\n                {\r\n                    Console.WriteLine(\"{0}: {1}\", kvp.Key, kvp.Value);\r\n                }\r\n            }\r\n        }\r\n\r\n        static void FastIDAStar(int puzzleNumber)\r\n        {\r\n            var puzzle = KorfPuzzles.Puzzles24.Single(m => m.Number == puzzleNumber);\r\n            Console.WriteLine(\"\\n\\n{0}: < {1} >\", puzzle.Number, string.Join(\",\", puzzle.InitialState));\r\n            Console.WriteLine(\"actual solution length: {0}, korf nodes evaluated: {1:n0}\", puzzle.Actual, puzzle.KorfNodesExpanded);\r\n            var heuristic = GetIDAStarHeuristicWithMirror24();\r\n            timer = Stopwatch.StartNew();\r\n            var solution = IDAStarDriver(puzzle.InitialState, puzzle.Goal, heuristic);\r\n            timer.Stop();\r\n            if (solution.Length > 0)\r\n            {\r\n                PrintSolution(solution, Console.Out);\r\n            }\r\n            else\r\n            {\r\n                Console.WriteLine(\"\\nNo solution possible.\");\r\n            }\r\n        }\r\n\r\n        static void CreatePDB(string[] args)\r\n        {\r\n            if (args.Length > 1)\r\n            {\r\n                outputFormat = args[1];\r\n            }\r\n            uint rows = Convert.ToUInt32(args[2]);\r\n            uint cols = Convert.ToUInt32(args[3]);\r\n            byte[] pattern = args[4].Split(',').Select(m => Convert.ToByte(m)).ToArray();\r\n            byte[] goal = Enumerable.Range(0, (int)(rows * cols)).Select(Convert.ToByte).ToArray();\r\n            lastMillis = 0;\r\n            timer = Stopwatch.StartNew();\r\n            var pdb = PatternDatabase.Create(rows, cols, pattern, goal, ShowCreateStats, ExpandCreateState);\r\n            timer.Stop();\r\n            Console.WriteLine();\r\n            Console.WriteLine(\"Completed building Pattern Database.  Saving to {0}\", outputFormat);\r\n            pdb.Save(outputFormat);\r\n        }\r\n\r\n        static void ShowCreateStats(PatternDatabase.CreateStats stats)\r\n        {\r\n            if (stats.IsFinished || (timer.ElapsedMilliseconds - lastMillis) > 1000)\r\n            {\r\n                Console.Write(\"\\rtime: {0}, total-states: {1}, depth: {2}, eval: {3:n0}\", timer.Elapsed.ToString(timerFormat), stats.TotalStates, stats.CurrentDepth, stats.StatesCalculated);\r\n                lastMillis = timer.ElapsedMilliseconds;\r\n            }\r\n        }\r\n\r\n        static void DoIDAStar15(string[] args)\r\n        {\r\n            if (args.Length > 0)\r\n            {\r\n                outputFormat = args[0];\r\n            }\r\n            DoPuzzles(KorfPuzzles.Puzzles15, IDAStarDriver, GetIDAStarHeuristicWithMirror15());\r\n        }\r\n\r\n        static void DoPuzzles(KorfPuzzle[] puzzles, Func<byte[], byte[], Func<byte[], uint>, byte[][]> algorithm, Func<byte[], uint> heuristic)\r\n        {\r\n            ulong totalNodesExpanded = 0;\r\n            foreach (var korfPuzzle in puzzles)\r\n            {\r\n                if (outputFormat != null)\r\n                {\r\n                    string filename = string.Format(outputFormat, korfPuzzle.Number);\r\n                    if (File.Exists(filename)) continue;\r\n                }\r\n                nodeCounter = 0;\r\n                lastMillis = 0;\r\n                Console.WriteLine(\"\\n\\n{0}: < {1} >\", korfPuzzle.Number, string.Join(\",\", korfPuzzle.InitialState));\r\n                Console.WriteLine(\"actual solution length: {0}, korf nodes evaluated: {1:n0}\", korfPuzzle.Actual, korfPuzzle.KorfNodesExpanded);\r\n                timer = Stopwatch.StartNew();\r\n                var solution = algorithm(korfPuzzle.InitialState, korfPuzzle.Goal, heuristic);\r\n                timer.Stop();\r\n                if (solution.Length > 0)\r\n                {\r\n                    PrintSolution(solution, Console.Out);\r\n                    if (outputFormat != null)\r\n                    {\r\n                        string filename = string.Format(outputFormat, korfPuzzle.Number);\r\n                        using (var writer = new StreamWriter(filename))\r\n                        {\r\n                            PrintSolution(solution, writer);\r\n                        }\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    Console.WriteLine(\"\\nNo solution possible.\");\r\n                }\r\n                totalNodesExpanded += nodeCounter;\r\n            }\r\n            Console.WriteLine(\"\\n\\n\\nTotal nodes expanded: \" + totalNodesExpanded);\r\n        }\r\n\r\n        static Func<byte[], uint> GetIDAStarHeuristicWithMirror15()\r\n        {\r\n            var vl15 = new PatternDatabase(\"15dj-vl.data\");\r\n            var vr15 = new PatternDatabase(\"15dj-vr.data\");\r\n            var hPDB = AdditivePdbHeuristic(null, vl15, vr15);\r\n            var hPDB2 = AdditivePdbHeuristic(MirrorState15, vl15, vr15);\r\n            return state =>\r\n            {\r\n                var hOrig = hPDB(state);\r\n                var hMirror = hPDB2(state);\r\n                return Math.Max(hOrig, hMirror);\r\n            };\r\n        }\r\n\r\n        static Func<byte[], uint> GetIDAStarHeuristicWithMirror24()\r\n        {\r\n            var tr24 = new PatternDatabase(\"24dj-tr.data\");\r\n            var br24 = new PatternDatabase(\"24dj-br.data\");\r\n            var bl24 = new PatternDatabase(\"24dj-bl.data\");\r\n            var tl24 = new PatternDatabase(\"24dj-tl.data\");\r\n            var hPDB = AdditivePdbHeuristic(null, tr24, br24, bl24, tl24);\r\n            var hPDB2 = AdditivePdbHeuristic(MirrorState24, tr24, br24, bl24, tl24);\r\n            return state =>\r\n            {\r\n                var hOrig = hPDB(state);\r\n                var hMirror = hPDB2(state);\r\n                return Math.Max(hOrig, hMirror);\r\n            };\r\n        }\r\n\r\n        static void PrintSolution(byte[][] solution, TextWriter writeLocation)\r\n        {\r\n            writeLocation.WriteLine(\"\\nSolution found! time: {0}, length: {1}, eval: {2}\", timer.Elapsed.ToString(timerFormat), solution.Length - 1, nodeCounter);\r\n            foreach (var step in solution)\r\n            {\r\n                writeLocation.WriteLine(string.Join(\" \", step));\r\n            }\r\n        }\r\n\r\n        private static readonly Stack<byte[]> noSolution = new Stack<byte[]>(); \r\n        private static uint nextBest;\r\n        private static Func<byte[], uint> idash;\r\n        private static byte[] noParent;\r\n        private static SuccessorList successorList;\r\n        static byte[][] IDAStarDriver(byte[] initialState, byte[] goal, Func<byte[], uint> h)\r\n        {\r\n            idash = h;\r\n            nextBest = idash(initialState);\r\n            nodeCounter = 0;\r\n            int boxSize = (int)Math.Sqrt(initialState.Length);\r\n            noParent = new byte[initialState.Length];\r\n            var bestPath = noSolution;\r\n            successorList = new SuccessorList(initialState.Length);\r\n            while (bestPath == noSolution && nextBest != uint.MaxValue)\r\n            {\r\n                uint threshold = nextBest;\r\n                nextBest = uint.MaxValue;\r\n                bestPath = IDAStar(initialState, boxSize, noParent, goal, 0u, threshold, successorList);\r\n                Console.WriteLine();\r\n            }\r\n            return bestPath.ToArray();\r\n        }\r\n        static Stack<byte[]> IDAStar(byte[] current, int boxSize, byte[] parent, byte[] goal, uint cost, uint upperbound, SuccessorList successors)\r\n        {\r\n            if (AreSame(current, goal)) return new Stack<byte[]>(new[] { current });\r\n            var newCost = cost + 1;\r\n            ExpandStateOneBlank(boxSize, current, successors);\r\n            while (successors.Size > 0)\r\n            {\r\n                var successor = successors.Pop();\r\n                if (AreSame(successor, parent)) continue;\r\n                nodeCounter += 1;\r\n                var h = idash(successor);\r\n                var newF = newCost + h;\r\n                if (newF > upperbound)\r\n                {\r\n                    if (newF < nextBest) nextBest = newF;\r\n                }\r\n                else\r\n                {\r\n                    var p = IDAStar(successor, boxSize, current, goal, newCost, upperbound, successors.Next);\r\n                    if (p != noSolution)\r\n                    {\r\n                        p.Push(current);\r\n                        return p;\r\n                    }\r\n                }\r\n            }\r\n            if (parent == noParent || (timer.ElapsedMilliseconds - lastMillis) > 1000)\r\n            {\r\n                var nextBestDisplay = nextBest == uint.MaxValue ? \"inf\" : nextBest.ToString();\r\n                Console.Write(\"\\rtime: {0}, upperbound: {1}, nextBest: {2}, eval: {3:n0}\", timer.Elapsed.ToString(timerFormat), upperbound, nextBestDisplay, nodeCounter);\r\n                lastMillis = timer.ElapsedMilliseconds;\r\n            }\r\n            return noSolution;\r\n        }\r\n\r\n        static bool AreSame(byte[] a, byte[] b)\r\n        {\r\n            for (int i = 0; i < a.Length; i += 1)\r\n            {\r\n                if (a[i] != b[i]) return false;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        static void ExpandStateOneBlank(int boxSize, byte[] state, SuccessorList successors)\r\n        {\r\n            int e = 0;\r\n            while (state[e] != 0) e += 1;\r\n            if (e < (state.Length - boxSize)) CreateSuccessor(state, successors.Push(), e, e + boxSize); \/\/ down\r\n            if (e % boxSize < (boxSize - 1)) CreateSuccessor(state, successors.Push(), e, e + 1); \/\/ right\r\n            if (e % boxSize > 0) CreateSuccessor(state, successors.Push(), e, e - 1); \/\/ left\r\n            if (e > (boxSize - 1)) CreateSuccessor(state, successors.Push(), e, e - boxSize); \/\/ up\r\n        }\r\n        static void CreateSuccessor(byte[] state, byte[] successor, int a, int b)\r\n        {\r\n            for (int i = 0; i < successor.Length; i += 1)\r\n            {\r\n                successor[i] = state[i];\r\n            }\r\n            successor.Swap(a, b);\r\n        }\r\n\r\n        static List<Tuple<byte[], bool>> ExpandCreateState(uint rows, uint cols, byte[] state)\r\n        {\r\n            int e = 0;\r\n            while (state[e] != 0) e += 1;\r\n            int boxSize = (int)rows;\r\n            var successors = new List<Tuple<byte[], bool>>(4);\r\n            if (e % boxSize > 0) successors.Add(CreateSuccessor(state, e, e - 1)); \/\/ left\r\n            if (e > (boxSize - 1)) successors.Add(CreateSuccessor(state, e, e - boxSize)); \/\/ up\r\n            if (e < (state.Length - boxSize)) successors.Add(CreateSuccessor(state, e, e + boxSize)); \/\/ down\r\n            if (e % boxSize < (boxSize - 1)) successors.Add(CreateSuccessor(state, e, e + 1)); \/\/ right\r\n            return successors;\r\n        }\r\n        static Tuple<byte[], bool> CreateSuccessor(byte[] state, int a, int b)\r\n        {\r\n            byte[] successor = new byte[state.Length];\r\n            for (int i = 0; i < successor.Length; i += 1)\r\n            {\r\n                successor[i] = state[i];\r\n            }\r\n            successor.Swap(a, b);\r\n            return Tuple.Create(successor, successor[a] == byte.MaxValue);\r\n        }\r\n\r\n        static Func<byte[], uint> AdditivePdbHeuristic(Action<byte[], byte[]> stateProcessor, params PatternDatabase[] pdbs)\r\n        {\r\n            return state =>\r\n            {\r\n                var s = state;\r\n                if (stateProcessor != null)\r\n                {\r\n                    s = new byte[state.Length];\r\n                    stateProcessor(state, s);\r\n                }\r\n                uint score = 0;\r\n                for (int i = 0; i < pdbs.Length; i += 1)\r\n                {\r\n                    score += pdbs[i].Evaluate(s);\r\n                }\r\n                return score;\r\n            };\r\n        }\r\n\r\n        private static readonly byte[] SymmetryMap15 = new byte[] { 0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15 };\r\n        private static readonly byte[] PathMap15 = new byte[] { 0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15 };\r\n        static void MirrorState15(byte[] state, byte[] symmetry)\r\n        {\r\n            for (int i = 0; i < symmetry.Length; i += 1)\r\n            {\r\n                symmetry[SymmetryMap15[i]] = PathMap15[state[i]];\r\n            }\r\n        }\r\n\r\n        private static readonly byte[] SymmetryMap24 = new byte[] { 0, 5, 10, 15, 20, 1, 6, 11, 16, 21, 2, 7, 12, 17, 22, 3, 8, 13, 18, 23, 4, 9, 14, 19, 24 };\r\n        private static readonly byte[] PathMap24 = new byte[] { 0, 5, 10, 15, 20, 1, 6, 11, 16, 21, 2, 7, 12, 17, 22, 3, 8, 13, 18, 23, 4, 9, 14, 19, 24 };\r\n        static void MirrorState24(byte[] state, byte[] symmetry)\r\n        {\r\n            for (int i = 0; i < symmetry.Length; i += 1)\r\n            {\r\n                symmetry[SymmetryMap24[i]] = PathMap24[state[i]];\r\n            }\r\n        }\r\n    }\r\n}\r\n","old_contents":"\ufeffusing System;\r\nusing System.Collections;\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics;\r\nusing System.IO;\r\nusing System.Linq;\r\n\r\nnamespace npuzzle\r\n{\r\n    class Program\r\n    {\r\n        private const string timerFormat = @\"hh\\:mm\\:ss\\.fff\";\r\n        private static Stopwatch timer;\r\n        private static long lastMillis;\r\n        private static ulong nodeCounter;\r\n        private static string outputFormat;\r\n\r\n        static void Main(string[] args)\r\n        {\r\n            \/\/CreatePDB(new[] { \"build-pdb\", \"15dj-vl.data\", \"4\", \"4\", \"1,4,5,8,9,12,13\" });\r\n            \/\/CreatePDB(new[] { \"build-pdb\", \"15dj-vr.data\", \"4\", \"4\", \"2,3,6,7,10,11,14,15\" });\r\n            CreatePDB(new[] { \"build-pdb\", \"24dj2-tr.data\", \"5\", \"5\", \"2,3,4,7,8,9\" });\r\n            \/\/CreatePDB(new[] { \"build-pdb\", \"24dj2-br.data\", \"5\", \"5\", \"13,14,18,19,23,24\" });\r\n            \/\/CreatePDB(new[] { \"build-pdb\", \"24dj2-bl.data\", \"5\", \"5\", \"15,16,17,20,21,22\" });\r\n            CreatePDB(new[] { \"build-pdb\", \"24dj2-tl.data\", \"5\", \"5\", \"1,5,6,10,11,12\" });\r\n            \/\/FastIDAStar(Convert.ToInt32(args[0]));\r\n            \/\/FastIDAStar(79);\r\n            \/\/DoIDAStar(new [] { \"korf-dj15-{0}.txt\" });\r\n            \/\/BreakdownPdbs(\"24dj-tr.data\", \"24dj-br.data\", \"24dj-bl.data\", \"24dj-tl.data\");\r\n            \/\/BreakdownPdbs(\"15dj-vl.data\");\r\n            \/\/QuickLook();\r\n        }\r\n\r\n        static void QuickLook()\r\n        {\r\n            var h = GetIDAStarHeuristic();\r\n            var a = KorfPuzzles.Puzzles15\r\n                .Average(m => (double)h(m.InitialState));\r\n            Console.WriteLine(a);\r\n        }\r\n\r\n        static void BreakdownPdbs(params string[] filenames)\r\n        {\r\n            foreach (var filename in filenames)\r\n            {\r\n                Console.WriteLine(\"\\n\" + filename);\r\n                var pdb = new PatternDatabase(filename);\r\n                var breakdown = pdb.GetValueCounts().OrderBy(m => m.Key).ToArray();\r\n                foreach (var kvp in breakdown)\r\n                {\r\n                    Console.WriteLine(\"{0}: {1}\", kvp.Key, kvp.Value);\r\n                }\r\n            }\r\n        }\r\n\r\n        static void FastIDAStar(int puzzleNumber)\r\n        {\r\n            var puzzle = KorfPuzzles.Puzzles15.Single(m => m.Number == puzzleNumber);\r\n            Console.WriteLine(\"\\n\\n{0}: < {1} >\", puzzle.Number, string.Join(\",\", puzzle.InitialState));\r\n            Console.WriteLine(\"actual solution length: {0}, korf nodes evaluated: {1:n0}\", puzzle.Actual, puzzle.KorfNodesExpanded);\r\n            var heuristic = GetIDAStarHeuristic();\r\n            timer = Stopwatch.StartNew();\r\n            var solution = IDAStarDriver(puzzle.InitialState, puzzle.Goal, heuristic);\r\n            timer.Stop();\r\n            if (solution.Length > 0)\r\n            {\r\n                PrintSolution(solution, Console.Out);\r\n            }\r\n            else\r\n            {\r\n                Console.WriteLine(\"\\nNo solution possible.\");\r\n            }\r\n        }\r\n\r\n        static void CreatePDB(string[] args)\r\n        {\r\n            if (args.Length > 1)\r\n            {\r\n                outputFormat = args[1];\r\n            }\r\n            uint rows = Convert.ToUInt32(args[2]);\r\n            uint cols = Convert.ToUInt32(args[3]);\r\n            byte[] pattern = args[4].Split(',').Select(m => Convert.ToByte(m)).ToArray();\r\n            byte[] goal = Enumerable.Range(0, (int)(rows * cols)).Select(Convert.ToByte).ToArray();\r\n            lastMillis = 0;\r\n            timer = Stopwatch.StartNew();\r\n            var pdb = PatternDatabase.Create(rows, cols, pattern, goal, ShowCreateStats, ExpandCreateState);\r\n            timer.Stop();\r\n            Console.WriteLine();\r\n            Console.WriteLine(\"Completed building Pattern Database.  Saving to {0}\", outputFormat);\r\n            pdb.Save(outputFormat);\r\n        }\r\n\r\n        static void ShowCreateStats(PatternDatabase.CreateStats stats)\r\n        {\r\n            if (stats.IsFinished || (timer.ElapsedMilliseconds - lastMillis) > 1000)\r\n            {\r\n                Console.Write(\"\\rtime: {0}, total-states: {1}, depth: {2}, eval: {3:n0}\", timer.Elapsed.ToString(timerFormat), stats.TotalStates, stats.CurrentDepth, stats.StatesCalculated);\r\n                lastMillis = timer.ElapsedMilliseconds;\r\n            }\r\n        }\r\n\r\n        static void DoIDAStar(string[] args)\r\n        {\r\n            if (args.Length > 0)\r\n            {\r\n                outputFormat = args[0];\r\n            }\r\n            DoPuzzles(KorfPuzzles.Puzzles15, IDAStarDriver);\r\n        }\r\n\r\n        static void DoPuzzles(KorfPuzzle[] puzzles, Func<byte[], byte[], Func<byte[], uint>, byte[][]> algorithm)\r\n        {\r\n            var heuristic = GetIDAStarHeuristic();\r\n            foreach (var korfPuzzle in puzzles)\r\n            {\r\n                if (outputFormat != null)\r\n                {\r\n                    string filename = string.Format(outputFormat, korfPuzzle.Number);\r\n                    if (File.Exists(filename)) continue;\r\n                }\r\n                nodeCounter = 0;\r\n                lastMillis = 0;\r\n                Console.WriteLine(\"\\n\\n{0}: < {1} >\", korfPuzzle.Number, string.Join(\",\", korfPuzzle.InitialState));\r\n                Console.WriteLine(\"actual solution length: {0}, korf nodes evaluated: {1:n0}\", korfPuzzle.Actual, korfPuzzle.KorfNodesExpanded);\r\n                timer = Stopwatch.StartNew();\r\n                var solution = algorithm(korfPuzzle.InitialState, korfPuzzle.Goal, heuristic);\r\n                timer.Stop();\r\n                if (solution.Length > 0)\r\n                {\r\n                    PrintSolution(solution, Console.Out);\r\n                    if (outputFormat != null)\r\n                    {\r\n                        string filename = string.Format(outputFormat, korfPuzzle.Number);\r\n                        using (var writer = new StreamWriter(filename))\r\n                        {\r\n                            PrintSolution(solution, writer);\r\n                        }\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    Console.WriteLine(\"\\nNo solution possible.\");\r\n                }\r\n            }\r\n        }\r\n\r\n        static Func<byte[], uint> GetIDAStarHeuristic()\r\n        {\r\n            \/\/return AdditivePdbHeuristic(\"24dj2-tr.data\", \"24dj2-br.data\", \"24dj2-bl.data\", \"24dj2-tl.data\");\r\n            return GetIDAStarHeuristicWithMirror();\r\n        }\r\n\r\n        static Func<byte[], uint> GetIDAStarHeuristicWithMirror()\r\n        {\r\n            \/\/var hPDB = AdditivePdbHeuristic(\"24dj-tr.data\", \"24dj-br.data\", \"24dj-bl.data\", \"24dj-tl.data\");\r\n            \/\/var hPDB2 = AdditivePdbHeuristic(\"24dj2-tr.data\", \"24dj2-br.data\", \"24dj2-bl.data\", \"24dj2-tl.data\");\r\n            var vl15 = new PatternDatabase(\"15dj-vl.data\");\r\n            var vr15 = new PatternDatabase(\"15dj-vr.data\");\r\n            var hPDB = AdditivePdbHeuristic(false, vl15, vr15);\r\n            var hPDB2 = AdditivePdbHeuristic(true, vl15, vr15);\r\n            \/\/return hPDB;\r\n            return state =>\r\n            {\r\n                var hOrig = hPDB(state);\r\n                var hMirror = hPDB2(state);\r\n                return Math.Max(hOrig, hMirror);\r\n            };\r\n        }\r\n\r\n        static void PrintSolution(byte[][] solution, TextWriter writeLocation)\r\n        {\r\n            writeLocation.WriteLine(\"\\nSolution found! time: {0}, length: {1}, eval: {2}\", timer.Elapsed.ToString(timerFormat), solution.Length - 1, nodeCounter);\r\n            foreach (var step in solution)\r\n            {\r\n                writeLocation.WriteLine(string.Join(\" \", step));\r\n            }\r\n        }\r\n\r\n        private static readonly Stack<byte[]> noSolution = new Stack<byte[]>(); \r\n        private static uint nextBest;\r\n        private static Func<byte[], uint> idash;\r\n        private static byte[] noParent;\r\n        private static SuccessorList successorList;\r\n        static byte[][] IDAStarDriver(byte[] initialState, byte[] goal, Func<byte[], uint> h)\r\n        {\r\n            idash = h;\r\n            nextBest = idash(initialState);\r\n            nodeCounter = 1;\r\n            int boxSize = (int)Math.Sqrt(initialState.Length);\r\n            noParent = new byte[initialState.Length];\r\n            var bestPath = noSolution;\r\n            successorList = new SuccessorList(initialState.Length);\r\n            while (bestPath == noSolution && nextBest != uint.MaxValue)\r\n            {\r\n                uint threshold = nextBest;\r\n                nextBest = uint.MaxValue;\r\n                bestPath = IDAStar(initialState, boxSize, noParent, goal, 0u, threshold, successorList);\r\n                Console.WriteLine();\r\n            }\r\n            return bestPath.ToArray();\r\n        }\r\n        static Stack<byte[]> IDAStar(byte[] current, int boxSize, byte[] parent, byte[] goal, uint cost, uint upperbound, SuccessorList successors)\r\n        {\r\n            if (AreSame(current, goal)) return new Stack<byte[]>(new[] { current });\r\n            var newCost = cost + 1;\r\n            ExpandStateOneBlank(boxSize, current, successors);\r\n            while (successors.Size > 0)\r\n            {\r\n                var successor = successors.Pop();\r\n                if (AreSame(successor, parent)) continue;\r\n                nodeCounter += 1;\r\n                var h = idash(successor);\r\n                var newF = newCost + h;\r\n                if (newF > upperbound)\r\n                {\r\n                    if (newF < nextBest) nextBest = newF;\r\n                }\r\n                else\r\n                {\r\n                    var p = IDAStar(successor, boxSize, current, goal, newCost, upperbound, successors.Next);\r\n                    if (p != noSolution)\r\n                    {\r\n                        p.Push(current);\r\n                        return p;\r\n                    }\r\n                }\r\n            }\r\n            if (parent == noParent || (timer.ElapsedMilliseconds - lastMillis) > 1000)\r\n            {\r\n                var nextBestDisplay = nextBest == uint.MaxValue ? \"inf\" : nextBest.ToString();\r\n                Console.Write(\"\\rtime: {0}, upperbound: {1}, nextBest: {2}, eval: {3:n0}\", timer.Elapsed.ToString(timerFormat), upperbound, nextBestDisplay, nodeCounter);\r\n                lastMillis = timer.ElapsedMilliseconds;\r\n            }\r\n            return noSolution;\r\n        }\r\n\r\n        static bool AreSame(byte[] a, byte[] b)\r\n        {\r\n            for (int i = 0; i < a.Length; i += 1)\r\n            {\r\n                if (a[i] != b[i]) return false;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        static void ExpandStateOneBlank(int boxSize, byte[] state, SuccessorList successors)\r\n        {\r\n            int e = 0;\r\n            while (state[e] != 0) e += 1;\r\n            if (e > (boxSize - 1)) CreateSuccessor(state, successors.Push(), e, e - boxSize); \/\/ up\r\n            if (e % boxSize > 0) CreateSuccessor(state, successors.Push(), e, e - 1); \/\/ left\r\n            if (e % boxSize < (boxSize - 1)) CreateSuccessor(state, successors.Push(), e, e + 1); \/\/ right\r\n            if (e < (state.Length - boxSize)) CreateSuccessor(state, successors.Push(), e, e + boxSize); \/\/ down\r\n        }\r\n        static void CreateSuccessor(byte[] state, byte[] successor, int a, int b)\r\n        {\r\n            for (int i = 0; i < successor.Length; i += 1)\r\n            {\r\n                successor[i] = state[i];\r\n            }\r\n            successor.Swap(a, b);\r\n        }\r\n\r\n        static List<Tuple<byte[], bool>> ExpandCreateState(uint rows, uint cols, byte[] state)\r\n        {\r\n            int e = 0;\r\n            while (state[e] != 0) e += 1;\r\n            int boxSize = (int)rows;\r\n            var successors = new List<Tuple<byte[], bool>>(4);\r\n            if (e > (boxSize - 1)) successors.Add(CreateSuccessor(state, e, e - boxSize)); \/\/ up\r\n            if (e % boxSize > 0) successors.Add(CreateSuccessor(state, e, e - 1)); \/\/ left\r\n            if (e % boxSize < (boxSize - 1)) successors.Add(CreateSuccessor(state, e, e + 1)); \/\/ right\r\n            if (e < (state.Length - boxSize)) successors.Add(CreateSuccessor(state, e, e + boxSize)); \/\/ down\r\n            return successors;\r\n        }\r\n        static Tuple<byte[], bool> CreateSuccessor(byte[] state, int a, int b)\r\n        {\r\n            byte[] successor = new byte[state.Length];\r\n            for (int i = 0; i < successor.Length; i += 1)\r\n            {\r\n                successor[i] = state[i];\r\n            }\r\n            successor.Swap(a, b);\r\n            return Tuple.Create(successor, successor[a] == byte.MaxValue);\r\n        }\r\n\r\n        static Func<byte[], uint> AdditivePdbHeuristic(bool reflectState, params PatternDatabase[] pdbs)\r\n        {\r\n            return state =>\r\n            {\r\n                var s = state;\r\n                if (reflectState)\r\n                {\r\n                    s = new byte[state.Length];\r\n                    MirrorState(state, s);\r\n                }\r\n                uint score = 0;\r\n                for (int i = 0; i < pdbs.Length; i += 1)\r\n                {\r\n                    score += pdbs[i].Evaluate(s);\r\n                }\r\n                return score;\r\n            };\r\n        }\r\n\r\n        private static readonly byte[] SymmetryMap = new byte[] { 0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15 };\r\n        private static readonly byte[] PathMap = new byte[] { 0, 4, 8, 12, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15 };\r\n        static void MirrorState(byte[] state, byte[] symmetry)\r\n        {\r\n            for (int i = 0; i < symmetry.Length; i += 1)\r\n            {\r\n                symmetry[SymmetryMap[i]] = PathMap[state[i]];\r\n            }\r\n        }\r\n    }\r\n}\r\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"6624a91697ccb26f9e5b9053d8f3aca631f30765","subject":"Remove Resource.designer.cs","message":"Remove Resource.designer.cs\n","repos":"2yangk23\/osu,johnneijzen\/osu,EVAST9919\/osu,peppy\/osu-new,ZLima12\/osu,ppy\/osu,peppy\/osu,ZLima12\/osu,ppy\/osu,peppy\/osu,peppy\/osu,UselessToucan\/osu,smoogipoo\/osu,NeoAdonis\/osu,NeoAdonis\/osu,UselessToucan\/osu,ppy\/osu,smoogipoo\/osu,smoogipooo\/osu,johnneijzen\/osu,smoogipoo\/osu,NeoAdonis\/osu,EVAST9919\/osu,UselessToucan\/osu,2yangk23\/osu","old_file":"osu.Android\/Resources\/Resource.designer.cs","new_file":"osu.Android\/Resources\/Resource.designer.cs","new_contents":"","old_contents":"#pragma warning disable 1591\n\/\/------------------------------------------------------------------------------\n\/\/ <auto-generated>\n\/\/     This code was generated by a tool.\n\/\/     Runtime Version:4.0.30319.42000\n\/\/\n\/\/     Changes to this file may cause incorrect behavior and will be lost if\n\/\/     the code is regenerated.\n\/\/ <\/auto-generated>\n\/\/------------------------------------------------------------------------------\n\n[assembly: global::Android.Runtime.ResourceDesignerAttribute(\"osu.Android.Resource\", IsApplication=true)]\n\nnamespace osu.Android\n{\n\t\n\t\n\t[System.CodeDom.Compiler.GeneratedCodeAttribute(\"Xamarin.Android.Build.Tasks\", \"1.0.0.0\")]\n\tpublic partial class Resource\n\t{\n\t\t\n\t\tstatic Resource()\n\t\t{\n\t\t\tglobal::Android.Runtime.ResourceIdManager.UpdateIdValues();\n\t\t}\n\t\t\n\t\tpublic static void UpdateIdValues()\n\t\t{\n\t\t}\n\t\t\n\t\tpublic partial class Attribute\n\t\t{\n\t\t\t\n\t\t\tstatic Attribute()\n\t\t\t{\n\t\t\t\tglobal::Android.Runtime.ResourceIdManager.UpdateIdValues();\n\t\t\t}\n\t\t\t\n\t\t\tprivate Attribute()\n\t\t\t{\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic partial class Color\n\t\t{\n\t\t\t\n\t\t\t\/\/ aapt resource value: 0x7f030002\n\t\t\tpublic const int colorAccent = 2130903042;\n\t\t\t\n\t\t\t\/\/ aapt resource value: 0x7f030000\n\t\t\tpublic const int colorPrimary = 2130903040;\n\t\t\t\n\t\t\t\/\/ aapt resource value: 0x7f030001\n\t\t\tpublic const int colorPrimaryDark = 2130903041;\n\t\t\t\n\t\t\t\/\/ aapt resource value: 0x7f030003\n\t\t\tpublic const int ic_launcher_background = 2130903043;\n\t\t\t\n\t\t\tstatic Color()\n\t\t\t{\n\t\t\t\tglobal::Android.Runtime.ResourceIdManager.UpdateIdValues();\n\t\t\t}\n\t\t\t\n\t\t\tprivate Color()\n\t\t\t{\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic partial class Mipmap\n\t\t{\n\t\t\t\n\t\t\t\/\/ aapt resource value: 0x7f020000\n\t\t\tpublic const int ic_launcher = 2130837504;\n\t\t\t\n\t\t\t\/\/ aapt resource value: 0x7f020001\n\t\t\tpublic const int ic_launcher_foreground = 2130837505;\n\t\t\t\n\t\t\t\/\/ aapt resource value: 0x7f020002\n\t\t\tpublic const int ic_launcher_round = 2130837506;\n\t\t\t\n\t\t\tstatic Mipmap()\n\t\t\t{\n\t\t\t\tglobal::Android.Runtime.ResourceIdManager.UpdateIdValues();\n\t\t\t}\n\t\t\t\n\t\t\tprivate Mipmap()\n\t\t\t{\n\t\t\t}\n\t\t}\n\t}\n}\n#pragma warning restore 1591\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"a4c1b9a1a7195dca0f4b5f5f078774f306c0c916","subject":"Rename startTime to fadeStartTime","message":"Rename startTime to fadeStartTime\n","repos":"smoogipoo\/osu,NeoAdonis\/osu,ppy\/osu,smoogipoo\/osu,NeoAdonis\/osu,peppy\/osu,peppy\/osu-new,ppy\/osu,UselessToucan\/osu,ppy\/osu,peppy\/osu,smoogipoo\/osu,UselessToucan\/osu,smoogipooo\/osu,UselessToucan\/osu,NeoAdonis\/osu,peppy\/osu","old_file":"osu.Game.Rulesets.Osu\/Mods\/OsuModHidden.cs","new_file":"osu.Game.Rulesets.Osu\/Mods\/OsuModHidden.cs","new_contents":"\ufeff\/\/ Copyright (c) ppy Pty Ltd <contact@ppy.sh>. Licensed under the MIT Licence.\n\/\/ See the LICENCE file in the repository root for full licence text.\n\nusing System;\nusing System.Diagnostics;\nusing System.Linq;\nusing osu.Framework.Graphics;\nusing osu.Game.Beatmaps;\nusing osu.Game.Rulesets.Mods;\nusing osu.Game.Rulesets.Objects;\nusing osu.Game.Rulesets.Objects.Drawables;\nusing osu.Game.Rulesets.Osu.Objects.Drawables;\nusing osu.Game.Rulesets.Osu.Objects;\n\nnamespace osu.Game.Rulesets.Osu.Mods\n{\n    public class OsuModHidden : ModHidden\n    {\n        public override string Description => @\"Play with no approach circles and fading circles\/sliders.\";\n        public override double ScoreMultiplier => 1.06;\n\n        public override Type[] IncompatibleMods => new[] { typeof(OsuModTraceable), typeof(OsuModSpinIn) };\n\n        private const double fade_in_duration_multiplier = 0.4;\n        private const double fade_out_duration_multiplier = 0.3;\n\n        protected override bool IsFirstAdjustableObject(HitObject hitObject) => !(hitObject is Spinner || hitObject is SpinnerTick);\n\n        public override void ApplyToBeatmap(IBeatmap beatmap)\n        {\n            base.ApplyToBeatmap(beatmap);\n\n            foreach (var obj in beatmap.HitObjects.OfType<OsuHitObject>())\n                applyFadeInAdjustment(obj);\n\n            static void applyFadeInAdjustment(OsuHitObject osuObject)\n            {\n                osuObject.TimeFadeIn = osuObject.TimePreempt * fade_in_duration_multiplier;\n                foreach (var nested in osuObject.NestedHitObjects.OfType<OsuHitObject>())\n                    applyFadeInAdjustment(nested);\n            }\n        }\n\n        protected override void ApplyIncreasedVisibilityState(DrawableHitObject hitObject, ArmedState state)\n        {\n            applyState(hitObject, true);\n        }\n\n        protected override void ApplyNormalVisibilityState(DrawableHitObject hitObject, ArmedState state)\n        {\n            applyState(hitObject, false);\n        }\n\n        private void applyState(DrawableHitObject drawableObject, bool increaseVisibility)\n        {\n            if (!(drawableObject is DrawableOsuHitObject drawableOsuObject))\n                return;\n\n            OsuHitObject hitObject = drawableOsuObject.HitObject;\n\n            (double fadeStartTime, double fadeDuration) = getFadeOutParameters(drawableOsuObject);\n\n            switch (drawableObject)\n            {\n                case DrawableSliderTail _:\n                    using (drawableObject.BeginAbsoluteSequence(fadeStartTime))\n                        drawableObject.FadeOut(fadeDuration);\n\n                    break;\n\n                case DrawableSliderRepeat sliderRepeat:\n                    using (drawableObject.BeginAbsoluteSequence(fadeStartTime))\n                        \/\/ only apply to circle piece \u2013 reverse arrow is not affected by hidden.\n                        sliderRepeat.CirclePiece.FadeOut(fadeDuration);\n\n                    break;\n\n                case DrawableHitCircle circle:\n                    Drawable fadeTarget = circle;\n\n                    if (increaseVisibility)\n                    {\n                        \/\/ only fade the circle piece (not the approach circle) for the increased visibility object.\n                        fadeTarget = circle.CirclePiece;\n                    }\n                    else\n                    {\n                        \/\/ we don't want to see the approach circle\n                        using (circle.BeginAbsoluteSequence(hitObject.StartTime - hitObject.TimePreempt))\n                            circle.ApproachCircle.Hide();\n                    }\n\n                    using (drawableObject.BeginAbsoluteSequence(fadeStartTime))\n                        fadeTarget.FadeOut(fadeDuration);\n                    break;\n\n                case DrawableSlider slider:\n                    using (slider.BeginAbsoluteSequence(fadeStartTime))\n                        slider.Body.FadeOut(fadeDuration, Easing.Out);\n\n                    break;\n\n                case DrawableSliderTick sliderTick:\n                    using (sliderTick.BeginAbsoluteSequence(fadeStartTime))\n                        sliderTick.FadeOut(fadeDuration);\n\n                    break;\n\n                case DrawableSpinner spinner:\n                    \/\/ hide elements we don't care about.\n                    \/\/ todo: hide background\n\n                    using (spinner.BeginAbsoluteSequence(fadeStartTime))\n                        spinner.FadeOut(fadeDuration);\n\n                    break;\n            }\n        }\n\n        private (double startTime, double fadeDuration) getFadeOutParameters(DrawableOsuHitObject drawableObject)\n        {\n            switch (drawableObject)\n            {\n                case DrawableSliderTail tail:\n                    \/\/ Use the same fade sequence as the slider head.\n                    Debug.Assert(tail.Slider != null);\n                    return getParameters(tail.Slider.HeadCircle);\n\n                case DrawableSliderRepeat repeat:\n                    \/\/ Use the same fade sequence as the slider head.\n                    Debug.Assert(repeat.Slider != null);\n                    return getParameters(repeat.Slider.HeadCircle);\n\n                default:\n                    return getParameters(drawableObject.HitObject);\n            }\n\n            static (double startTime, double fadeDuration) getParameters(OsuHitObject hitObject)\n            {\n                var fadeOutStartTime = hitObject.StartTime - hitObject.TimePreempt + hitObject.TimeFadeIn;\n                var fadeOutDuration = hitObject.TimePreempt * fade_out_duration_multiplier;\n\n                \/\/ new duration from completed fade in to end (before fading out)\n                var longFadeDuration = hitObject.GetEndTime() - fadeOutStartTime;\n\n                switch (hitObject)\n                {\n                    case Slider _:\n                        return (fadeOutStartTime, longFadeDuration);\n\n                    case SliderTick _:\n                        var tickFadeOutDuration = Math.Min(hitObject.TimePreempt - DrawableSliderTick.ANIM_DURATION, 1000);\n                        return (hitObject.StartTime - tickFadeOutDuration, tickFadeOutDuration);\n\n                    case Spinner _:\n                        return (fadeOutStartTime + longFadeDuration, fadeOutDuration);\n\n                    default:\n                        return (fadeOutStartTime, fadeOutDuration);\n                }\n            }\n        }\n    }\n}\n","old_contents":"\ufeff\/\/ Copyright (c) ppy Pty Ltd <contact@ppy.sh>. Licensed under the MIT Licence.\n\/\/ See the LICENCE file in the repository root for full licence text.\n\nusing System;\nusing System.Diagnostics;\nusing System.Linq;\nusing osu.Framework.Graphics;\nusing osu.Game.Beatmaps;\nusing osu.Game.Rulesets.Mods;\nusing osu.Game.Rulesets.Objects;\nusing osu.Game.Rulesets.Objects.Drawables;\nusing osu.Game.Rulesets.Osu.Objects.Drawables;\nusing osu.Game.Rulesets.Osu.Objects;\n\nnamespace osu.Game.Rulesets.Osu.Mods\n{\n    public class OsuModHidden : ModHidden\n    {\n        public override string Description => @\"Play with no approach circles and fading circles\/sliders.\";\n        public override double ScoreMultiplier => 1.06;\n\n        public override Type[] IncompatibleMods => new[] { typeof(OsuModTraceable), typeof(OsuModSpinIn) };\n\n        private const double fade_in_duration_multiplier = 0.4;\n        private const double fade_out_duration_multiplier = 0.3;\n\n        protected override bool IsFirstAdjustableObject(HitObject hitObject) => !(hitObject is Spinner || hitObject is SpinnerTick);\n\n        public override void ApplyToBeatmap(IBeatmap beatmap)\n        {\n            base.ApplyToBeatmap(beatmap);\n\n            foreach (var obj in beatmap.HitObjects.OfType<OsuHitObject>())\n                applyFadeInAdjustment(obj);\n\n            static void applyFadeInAdjustment(OsuHitObject osuObject)\n            {\n                osuObject.TimeFadeIn = osuObject.TimePreempt * fade_in_duration_multiplier;\n                foreach (var nested in osuObject.NestedHitObjects.OfType<OsuHitObject>())\n                    applyFadeInAdjustment(nested);\n            }\n        }\n\n        protected override void ApplyIncreasedVisibilityState(DrawableHitObject hitObject, ArmedState state)\n        {\n            applyState(hitObject, true);\n        }\n\n        protected override void ApplyNormalVisibilityState(DrawableHitObject hitObject, ArmedState state)\n        {\n            applyState(hitObject, false);\n        }\n\n        private void applyState(DrawableHitObject drawableObject, bool increaseVisibility)\n        {\n            if (!(drawableObject is DrawableOsuHitObject drawableOsuObject))\n                return;\n\n            OsuHitObject hitObject = drawableOsuObject.HitObject;\n\n            (double startTime, double fadeDuration) = getFadeOutParameters(drawableOsuObject);\n\n            switch (drawableObject)\n            {\n                case DrawableSliderTail _:\n                    using (drawableObject.BeginAbsoluteSequence(startTime))\n                        drawableObject.FadeOut(fadeDuration);\n\n                    break;\n\n                case DrawableSliderRepeat sliderRepeat:\n                    using (drawableObject.BeginAbsoluteSequence(startTime))\n                        \/\/ only apply to circle piece \u2013 reverse arrow is not affected by hidden.\n                        sliderRepeat.CirclePiece.FadeOut(fadeDuration);\n\n                    break;\n\n                case DrawableHitCircle circle:\n                    Drawable fadeTarget = circle;\n\n                    if (increaseVisibility)\n                    {\n                        \/\/ only fade the circle piece (not the approach circle) for the increased visibility object.\n                        fadeTarget = circle.CirclePiece;\n                    }\n                    else\n                    {\n                        \/\/ we don't want to see the approach circle\n                        using (circle.BeginAbsoluteSequence(hitObject.StartTime - hitObject.TimePreempt))\n                            circle.ApproachCircle.Hide();\n                    }\n\n                    using (drawableObject.BeginAbsoluteSequence(startTime))\n                        fadeTarget.FadeOut(fadeDuration);\n                    break;\n\n                case DrawableSlider slider:\n                    using (slider.BeginAbsoluteSequence(startTime))\n                        slider.Body.FadeOut(fadeDuration, Easing.Out);\n\n                    break;\n\n                case DrawableSliderTick sliderTick:\n                    using (sliderTick.BeginAbsoluteSequence(startTime))\n                        sliderTick.FadeOut(fadeDuration);\n\n                    break;\n\n                case DrawableSpinner spinner:\n                    \/\/ hide elements we don't care about.\n                    \/\/ todo: hide background\n\n                    using (spinner.BeginAbsoluteSequence(startTime))\n                        spinner.FadeOut(fadeDuration);\n\n                    break;\n            }\n        }\n\n        private (double startTime, double fadeDuration) getFadeOutParameters(DrawableOsuHitObject drawableObject)\n        {\n            switch (drawableObject)\n            {\n                case DrawableSliderTail tail:\n                    \/\/ Use the same fade sequence as the slider head.\n                    Debug.Assert(tail.Slider != null);\n                    return getParameters(tail.Slider.HeadCircle);\n\n                case DrawableSliderRepeat repeat:\n                    \/\/ Use the same fade sequence as the slider head.\n                    Debug.Assert(repeat.Slider != null);\n                    return getParameters(repeat.Slider.HeadCircle);\n\n                default:\n                    return getParameters(drawableObject.HitObject);\n            }\n\n            static (double startTime, double fadeDuration) getParameters(OsuHitObject hitObject)\n            {\n                var fadeOutStartTime = hitObject.StartTime - hitObject.TimePreempt + hitObject.TimeFadeIn;\n                var fadeOutDuration = hitObject.TimePreempt * fade_out_duration_multiplier;\n\n                \/\/ new duration from completed fade in to end (before fading out)\n                var longFadeDuration = hitObject.GetEndTime() - fadeOutStartTime;\n\n                switch (hitObject)\n                {\n                    case Slider _:\n                        return (fadeOutStartTime, longFadeDuration);\n\n                    case SliderTick _:\n                        var tickFadeOutDuration = Math.Min(hitObject.TimePreempt - DrawableSliderTick.ANIM_DURATION, 1000);\n                        return (hitObject.StartTime - tickFadeOutDuration, tickFadeOutDuration);\n\n                    case Spinner _:\n                        return (fadeOutStartTime + longFadeDuration, fadeOutDuration);\n\n                    default:\n                        return (fadeOutStartTime, fadeOutDuration);\n                }\n            }\n        }\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"08821da954d3927d776534fa1550d23838b3855a","subject":"Change mod description","message":"Change mod description\n","repos":"ppy\/osu,peppy\/osu,NeoAdonis\/osu,peppy\/osu,smoogipooo\/osu,smoogipoo\/osu,UselessToucan\/osu,NeoAdonis\/osu,smoogipoo\/osu,ppy\/osu,smoogipoo\/osu,peppy\/osu,NeoAdonis\/osu,UselessToucan\/osu,peppy\/osu-new,ppy\/osu,UselessToucan\/osu","old_file":"osu.Game.Rulesets.Osu\/Mods\/OsuModRandom.cs","new_file":"osu.Game.Rulesets.Osu\/Mods\/OsuModRandom.cs","new_contents":"\/\/ Copyright (c) ppy Pty Ltd <contact@ppy.sh>. Licensed under the MIT Licence.\n\/\/ See the LICENCE file in the repository root for full licence text.\n\nusing System;\nusing System.Linq;\nusing osu.Framework.Bindables;\nusing osu.Game.Beatmaps;\nusing osu.Game.Configuration;\nusing osu.Game.Rulesets.Mods;\nusing osu.Game.Rulesets.Objects;\nusing osu.Game.Rulesets.Osu.Objects;\nusing osu.Game.Rulesets.Osu.UI;\nusing osuTK;\n\nnamespace osu.Game.Rulesets.Osu.Mods\n{\n    \/\/\/ <summary>\n    \/\/\/ Mod that randomises the positions of the <see cref=\"HitObject\"\/>s\n    \/\/\/ <\/summary>\n    public class OsuModRandom : ModRandom, IApplicableToBeatmap\n    {\n        public override string Description => \"It never gets boring!\";\n        public override bool Ranked => false;\n\n        [SettingSource(\"Circles\", \"Hit circles appear at random positions\")]\n        public Bindable<bool> RandomiseCirclePositions { get; } = new BindableBool\n        {\n            Default = true,\n            Value = true,\n        };\n\n        [SettingSource(\"Sliders\", \"Sliders appear at random positions\")]\n        public Bindable<bool> RandomiseSliderPositions { get; } = new BindableBool\n        {\n            Default = true,\n            Value = true,\n        };\n\n        [SettingSource(\"Spinners\", \"Spinners appear at random positions\")]\n        public Bindable<bool> RandomiseSpinnerPositions { get; } = new BindableBool\n        {\n            Default = true,\n            Value = true,\n        };\n\n        public void ApplyToBeatmap(IBeatmap beatmap)\n        {\n            var rng = new Random();\n\n            foreach (var hitObject in beatmap.HitObjects)\n            {\n                if (RandomiseCirclePositions.Value && hitObject is HitCircle circle)\n                {\n                    circle.Position = new Vector2(\n                        (float)rng.NextDouble() * OsuPlayfield.BASE_SIZE.X,\n                        (float)rng.NextDouble() * OsuPlayfield.BASE_SIZE.Y\n                    );\n                }\n                else if (RandomiseSpinnerPositions.Value && hitObject is Spinner spinner)\n                {\n                    spinner.Position = new Vector2(\n                        (float)rng.NextDouble() * OsuPlayfield.BASE_SIZE.X,\n                        (float)rng.NextDouble() * OsuPlayfield.BASE_SIZE.Y\n                    );\n                }\n                else if (RandomiseSliderPositions.Value && hitObject is Slider slider)\n                {\n                    \/\/ Min. distances from the slider's position to the border to prevent the slider from being partially out of the screen\n                    float minLeft = 0, minRight = 0, minTop = 0, minBottom = 0;\n\n                    var controlPointPositions = (from position\n                                                     in slider.Path.ControlPoints\n                                                 select position.Position.Value).ToList();\n\n                    controlPointPositions.Add(slider.EndPosition);\n                    controlPointPositions.RemoveAt(controlPointPositions.Count - 1);\n\n                    foreach (var position in controlPointPositions)\n                    {\n                        if (position.X > minRight)\n                        {\n                            minRight = position.X;\n                        }\n                        else if (-position.X > minLeft)\n                        {\n                            minLeft = -position.X;\n                        }\n\n                        if (position.Y > minBottom)\n                        {\n                            minBottom = position.Y;\n                        }\n                        else if (-position.Y > minTop)\n                        {\n                            minTop = -position.Y;\n                        }\n                    }\n\n                    slider.Position = new Vector2(\n                        (float)rng.NextDouble() * (OsuPlayfield.BASE_SIZE.X - minLeft - minRight) + minLeft,\n                        (float)rng.NextDouble() * (OsuPlayfield.BASE_SIZE.Y - minTop - minBottom) + minTop\n                    );\n                }\n            }\n        }\n    }\n}\n","old_contents":"\/\/ Copyright (c) ppy Pty Ltd <contact@ppy.sh>. Licensed under the MIT Licence.\n\/\/ See the LICENCE file in the repository root for full licence text.\n\nusing System;\nusing System.Linq;\nusing osu.Framework.Bindables;\nusing osu.Game.Beatmaps;\nusing osu.Game.Configuration;\nusing osu.Game.Rulesets.Mods;\nusing osu.Game.Rulesets.Objects;\nusing osu.Game.Rulesets.Osu.Objects;\nusing osu.Game.Rulesets.Osu.UI;\nusing osuTK;\n\nnamespace osu.Game.Rulesets.Osu.Mods\n{\n    \/\/\/ <summary>\n    \/\/\/ Mod that randomises the positions of the <see cref=\"HitObject\"\/>s\n    \/\/\/ <\/summary>\n    public class OsuModRandom : ModRandom, IApplicableToBeatmap\n    {\n        public override string Description => \"Practice your reaction time!\";\n        public override bool Ranked => false;\n\n        [SettingSource(\"Circles\", \"Hit circles appear at random positions\")]\n        public Bindable<bool> RandomiseCirclePositions { get; } = new BindableBool\n        {\n            Default = true,\n            Value = true,\n        };\n\n        [SettingSource(\"Sliders\", \"Sliders appear at random positions\")]\n        public Bindable<bool> RandomiseSliderPositions { get; } = new BindableBool\n        {\n            Default = true,\n            Value = true,\n        };\n\n        [SettingSource(\"Spinners\", \"Spinners appear at random positions\")]\n        public Bindable<bool> RandomiseSpinnerPositions { get; } = new BindableBool\n        {\n            Default = true,\n            Value = true,\n        };\n\n        public void ApplyToBeatmap(IBeatmap beatmap)\n        {\n            var rng = new Random();\n\n            foreach (var hitObject in beatmap.HitObjects)\n            {\n                if (RandomiseCirclePositions.Value && hitObject is HitCircle circle)\n                {\n                    circle.Position = new Vector2(\n                        (float)rng.NextDouble() * OsuPlayfield.BASE_SIZE.X,\n                        (float)rng.NextDouble() * OsuPlayfield.BASE_SIZE.Y\n                    );\n                }\n                else if (RandomiseSpinnerPositions.Value && hitObject is Spinner spinner)\n                {\n                    spinner.Position = new Vector2(\n                        (float)rng.NextDouble() * OsuPlayfield.BASE_SIZE.X,\n                        (float)rng.NextDouble() * OsuPlayfield.BASE_SIZE.Y\n                    );\n                }\n                else if (RandomiseSliderPositions.Value && hitObject is Slider slider)\n                {\n                    \/\/ Min. distances from the slider's position to the border to prevent the slider from being partially out of the screen\n                    float minLeft = 0, minRight = 0, minTop = 0, minBottom = 0;\n\n                    var controlPointPositions = (from position\n                                                     in slider.Path.ControlPoints\n                                                 select position.Position.Value).ToList();\n\n                    controlPointPositions.Add(slider.EndPosition);\n                    controlPointPositions.RemoveAt(controlPointPositions.Count - 1);\n\n                    foreach (var position in controlPointPositions)\n                    {\n                        if (position.X > minRight)\n                        {\n                            minRight = position.X;\n                        }\n                        else if (-position.X > minLeft)\n                        {\n                            minLeft = -position.X;\n                        }\n\n                        if (position.Y > minBottom)\n                        {\n                            minBottom = position.Y;\n                        }\n                        else if (-position.Y > minTop)\n                        {\n                            minTop = -position.Y;\n                        }\n                    }\n\n                    slider.Position = new Vector2(\n                        (float)rng.NextDouble() * (OsuPlayfield.BASE_SIZE.X - minLeft - minRight) + minLeft,\n                        (float)rng.NextDouble() * (OsuPlayfield.BASE_SIZE.Y - minTop - minBottom) + minTop\n                    );\n                }\n            }\n        }\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"024f136d820db7791324d988fc4e9d2a20e47676","subject":"Reduce buffer count by one","message":"Reduce buffer count by one\n\n","repos":"ppy\/osu,smoogipooo\/osu,smoogipoo\/osu,smoogipoo\/osu,NeoAdonis\/osu,ppy\/osu,UselessToucan\/osu,EVAST9919\/osu,ZLima12\/osu,UselessToucan\/osu,EVAST9919\/osu,peppy\/osu-new,UselessToucan\/osu,2yangk23\/osu,peppy\/osu,NeoAdonis\/osu,ZLima12\/osu,2yangk23\/osu,peppy\/osu,johnneijzen\/osu,johnneijzen\/osu,ppy\/osu,peppy\/osu,smoogipoo\/osu,NeoAdonis\/osu","old_file":"osu.Game\/Graphics\/Backgrounds\/Triangles.cs","new_file":"osu.Game\/Graphics\/Backgrounds\/Triangles.cs","new_contents":"\ufeff\/\/ Copyright (c) ppy Pty Ltd <contact@ppy.sh>. Licensed under the MIT Licence.\n\/\/ See the LICENCE file in the repository root for full licence text.\n\nusing osu.Framework.Graphics;\nusing osu.Framework.MathUtils;\nusing osuTK;\nusing osuTK.Graphics;\nusing System;\nusing osu.Framework.Graphics.Shaders;\nusing osu.Framework.Graphics.Textures;\nusing osuTK.Graphics.ES30;\nusing osu.Framework.Graphics.Colour;\nusing osu.Framework.Graphics.Primitives;\nusing osu.Framework.Allocation;\nusing System.Collections.Generic;\nusing osu.Framework.Graphics.Batches;\nusing osu.Framework.Graphics.OpenGL.Vertices;\nusing osu.Framework.Lists;\n\nnamespace osu.Game.Graphics.Backgrounds\n{\n    public class Triangles : Drawable\n    {\n        private const float triangle_size = 100;\n        private const float base_velocity = 50;\n\n        \/\/\/ <summary>\n        \/\/\/ How many screen-space pixels are smoothed over.\n        \/\/\/ Same behavior as Sprite's EdgeSmoothness.\n        \/\/\/ <\/summary>\n        private const float edge_smoothness = 1;\n\n        public Color4 ColourLight = Color4.White;\n        public Color4 ColourDark = Color4.Black;\n\n        \/\/\/ <summary>\n        \/\/\/ Whether we want to expire triangles as they exit our draw area completely.\n        \/\/\/ <\/summary>\n        protected virtual bool ExpireOffScreenTriangles => true;\n\n        \/\/\/ <summary>\n        \/\/\/ Whether we should create new triangles as others expire.\n        \/\/\/ <\/summary>\n        protected virtual bool CreateNewTriangles => true;\n\n        \/\/\/ <summary>\n        \/\/\/ The amount of triangles we want compared to the default distribution.\n        \/\/\/ <\/summary>\n        protected virtual float SpawnRatio => 1;\n\n        private float triangleScale = 1;\n\n        \/\/\/ <summary>\n        \/\/\/ Whether we should drop-off alpha values of triangles more quickly to improve\n        \/\/\/ the visual appearance of fading. This defaults to on as it is generally more\n        \/\/\/ aesthetically pleasing, but should be turned off in buffered containers.\n        \/\/\/ <\/summary>\n        public bool HideAlphaDiscrepancies = true;\n\n        \/\/\/ <summary>\n        \/\/\/ The relative velocity of the triangles. Default is 1.\n        \/\/\/ <\/summary>\n        public float Velocity = 1;\n\n        private readonly SortedList<TriangleParticle> parts = new SortedList<TriangleParticle>(Comparer<TriangleParticle>.Default);\n\n        private IShader shader;\n        private readonly Texture texture;\n\n        public Triangles()\n        {\n            texture = Texture.WhitePixel;\n        }\n\n        [BackgroundDependencyLoader]\n        private void load(ShaderManager shaders)\n        {\n            shader = shaders.Load(VertexShaderDescriptor.TEXTURE_2, FragmentShaderDescriptor.TEXTURE_ROUNDED);\n        }\n\n        protected override void LoadComplete()\n        {\n            base.LoadComplete();\n            addTriangles(true);\n        }\n\n        public float TriangleScale\n        {\n            get => triangleScale;\n            set\n            {\n                float change = value \/ triangleScale;\n                triangleScale = value;\n\n                for (int i = 0; i < parts.Count; i++)\n                {\n                    TriangleParticle newParticle = parts[i];\n                    newParticle.Scale *= change;\n                    parts[i] = newParticle;\n                }\n            }\n        }\n\n        protected override void Update()\n        {\n            base.Update();\n\n            Invalidate(Invalidation.DrawNode, shallPropagate: false);\n\n            if (CreateNewTriangles)\n                addTriangles(false);\n\n            float adjustedAlpha = HideAlphaDiscrepancies\n                \/\/ Cubically scale alpha to make it drop off more sharply.\n                ? (float)Math.Pow(DrawColourInfo.Colour.AverageColour.Linear.A, 3)\n                : 1;\n\n            float elapsedSeconds = (float)Time.Elapsed \/ 1000;\n            \/\/ Since position is relative, the velocity needs to scale inversely with DrawHeight.\n            \/\/ Since we will later multiply by the scale of individual triangles we normalize by\n            \/\/ dividing by triangleScale.\n            float movedDistance = -elapsedSeconds * Velocity * base_velocity \/ (DrawHeight * triangleScale);\n\n            for (int i = 0; i < parts.Count; i++)\n            {\n                TriangleParticle newParticle = parts[i];\n\n                \/\/ Scale moved distance by the size of the triangle. Smaller triangles should move more slowly.\n                newParticle.Position.Y += parts[i].Scale * movedDistance;\n                newParticle.Colour.A = adjustedAlpha;\n\n                parts[i] = newParticle;\n\n                float bottomPos = parts[i].Position.Y + triangle_size * parts[i].Scale * 0.866f \/ DrawHeight;\n                if (bottomPos < 0)\n                    parts.RemoveAt(i);\n            }\n        }\n\n        protected int AimCount;\n\n        private void addTriangles(bool randomY)\n        {\n            AimCount = (int)(DrawWidth * DrawHeight * 0.002f \/ (triangleScale * triangleScale) * SpawnRatio);\n\n            for (int i = 0; i < AimCount - parts.Count; i++)\n                parts.Add(createTriangle(randomY));\n        }\n\n        private TriangleParticle createTriangle(bool randomY)\n        {\n            TriangleParticle particle = CreateTriangle();\n\n            particle.Position = new Vector2(RNG.NextSingle(), randomY ? RNG.NextSingle() : 1);\n            particle.Colour = CreateTriangleShade();\n\n            return particle;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Creates a triangle particle with a random scale.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The triangle particle.<\/returns>\n        protected virtual TriangleParticle CreateTriangle()\n        {\n            const float std_dev = 0.16f;\n            const float mean = 0.5f;\n\n            float u1 = 1 - RNG.NextSingle(); \/\/uniform(0,1] random floats\n            float u2 = 1 - RNG.NextSingle();\n            float randStdNormal = (float)(Math.Sqrt(-2.0 * Math.Log(u1)) * Math.Sin(2.0 * Math.PI * u2)); \/\/random normal(0,1)\n            var scale = Math.Max(triangleScale * (mean + std_dev * randStdNormal), 0.1f); \/\/random normal(mean,stdDev^2)\n\n            return new TriangleParticle { Scale = scale };\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Creates a shade of colour for the triangles.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The colour.<\/returns>\n        protected virtual Color4 CreateTriangleShade() => Interpolation.ValueAt(RNG.NextSingle(), ColourDark, ColourLight, 0, 1);\n\n        protected override DrawNode CreateDrawNode() => new TrianglesDrawNode(this);\n\n        private class TrianglesDrawNode : DrawNode\n        {\n            protected new Triangles Source => (Triangles)base.Source;\n\n            private IShader shader;\n            private Texture texture;\n\n            private readonly List<TriangleParticle> parts = new List<TriangleParticle>();\n            private Vector2 size;\n\n            private LinearBatch<TexturedVertex2D> vertexBatch;\n\n            public TrianglesDrawNode(Triangles source)\n                : base(source)\n            {\n            }\n\n            public override void ApplyState()\n            {\n                base.ApplyState();\n\n                shader = Source.shader;\n                texture = Source.texture;\n                size = Source.DrawSize;\n\n                parts.Clear();\n                parts.AddRange(Source.parts);\n            }\n\n            public override void Draw(Action<TexturedVertex2D> vertexAction)\n            {\n                base.Draw(vertexAction);\n\n                if (vertexBatch == null || vertexBatch.Size != Source.AimCount * 6)\n                {\n                    vertexBatch?.Dispose();\n                    vertexBatch = new LinearBatch<TexturedVertex2D>(Source.AimCount * 6, 1, PrimitiveType.Triangles);\n                }\n\n                shader.Bind();\n\n                Vector2 localInflationAmount = edge_smoothness * DrawInfo.MatrixInverse.ExtractScale().Xy;\n\n                foreach (TriangleParticle particle in parts)\n                {\n                    var offset = triangle_size * new Vector2(particle.Scale * 0.5f, particle.Scale * 0.866f);\n\n                    var triangle = new Triangle(\n                        Vector2Extensions.Transform(particle.Position * size, DrawInfo.Matrix),\n                        Vector2Extensions.Transform(particle.Position * size + offset, DrawInfo.Matrix),\n                        Vector2Extensions.Transform(particle.Position * size + new Vector2(-offset.X, offset.Y), DrawInfo.Matrix)\n                    );\n\n                    ColourInfo colourInfo = DrawColourInfo.Colour;\n                    colourInfo.ApplyChild(particle.Colour);\n\n                    DrawTriangle(\n                        texture,\n                        triangle,\n                        colourInfo,\n                        null,\n                        vertexBatch.AddAction,\n                        Vector2.Divide(localInflationAmount, new Vector2(2 * offset.X, offset.Y)));\n                }\n\n                shader.Unbind();\n            }\n\n            protected override void Dispose(bool isDisposing)\n            {\n                base.Dispose(isDisposing);\n\n                vertexBatch?.Dispose();\n            }\n        }\n\n        protected struct TriangleParticle : IComparable<TriangleParticle>\n        {\n            \/\/\/ <summary>\n            \/\/\/ The position of the top vertex of the triangle.\n            \/\/\/ <\/summary>\n            public Vector2 Position;\n\n            \/\/\/ <summary>\n            \/\/\/ The colour of the triangle.\n            \/\/\/ <\/summary>\n            public Color4 Colour;\n\n            \/\/\/ <summary>\n            \/\/\/ The scale of the triangle.\n            \/\/\/ <\/summary>\n            public float Scale;\n\n            \/\/\/ <summary>\n            \/\/\/ Compares two <see cref=\"TriangleParticle\"\/>s. This is a reverse comparer because when the\n            \/\/\/ triangles are added to the particles list, they should be drawn from largest to smallest\n            \/\/\/ such that the smaller triangles appear on top.\n            \/\/\/ <\/summary>\n            \/\/\/ <param name=\"other\"><\/param>\n            \/\/\/ <returns><\/returns>\n            public int CompareTo(TriangleParticle other) => other.Scale.CompareTo(Scale);\n        }\n    }\n}\n","old_contents":"\ufeff\/\/ Copyright (c) ppy Pty Ltd <contact@ppy.sh>. Licensed under the MIT Licence.\n\/\/ See the LICENCE file in the repository root for full licence text.\n\nusing osu.Framework.Graphics;\nusing osu.Framework.MathUtils;\nusing osuTK;\nusing osuTK.Graphics;\nusing System;\nusing osu.Framework.Graphics.Shaders;\nusing osu.Framework.Graphics.Textures;\nusing osuTK.Graphics.ES30;\nusing osu.Framework.Graphics.Colour;\nusing osu.Framework.Graphics.Primitives;\nusing osu.Framework.Allocation;\nusing System.Collections.Generic;\nusing osu.Framework.Graphics.Batches;\nusing osu.Framework.Graphics.OpenGL.Vertices;\nusing osu.Framework.Lists;\n\nnamespace osu.Game.Graphics.Backgrounds\n{\n    public class Triangles : Drawable\n    {\n        private const float triangle_size = 100;\n        private const float base_velocity = 50;\n\n        \/\/\/ <summary>\n        \/\/\/ How many screen-space pixels are smoothed over.\n        \/\/\/ Same behavior as Sprite's EdgeSmoothness.\n        \/\/\/ <\/summary>\n        private const float edge_smoothness = 1;\n\n        public Color4 ColourLight = Color4.White;\n        public Color4 ColourDark = Color4.Black;\n\n        \/\/\/ <summary>\n        \/\/\/ Whether we want to expire triangles as they exit our draw area completely.\n        \/\/\/ <\/summary>\n        protected virtual bool ExpireOffScreenTriangles => true;\n\n        \/\/\/ <summary>\n        \/\/\/ Whether we should create new triangles as others expire.\n        \/\/\/ <\/summary>\n        protected virtual bool CreateNewTriangles => true;\n\n        \/\/\/ <summary>\n        \/\/\/ The amount of triangles we want compared to the default distribution.\n        \/\/\/ <\/summary>\n        protected virtual float SpawnRatio => 1;\n\n        private float triangleScale = 1;\n\n        \/\/\/ <summary>\n        \/\/\/ Whether we should drop-off alpha values of triangles more quickly to improve\n        \/\/\/ the visual appearance of fading. This defaults to on as it is generally more\n        \/\/\/ aesthetically pleasing, but should be turned off in buffered containers.\n        \/\/\/ <\/summary>\n        public bool HideAlphaDiscrepancies = true;\n\n        \/\/\/ <summary>\n        \/\/\/ The relative velocity of the triangles. Default is 1.\n        \/\/\/ <\/summary>\n        public float Velocity = 1;\n\n        private readonly SortedList<TriangleParticle> parts = new SortedList<TriangleParticle>(Comparer<TriangleParticle>.Default);\n\n        private IShader shader;\n        private readonly Texture texture;\n\n        public Triangles()\n        {\n            texture = Texture.WhitePixel;\n        }\n\n        [BackgroundDependencyLoader]\n        private void load(ShaderManager shaders)\n        {\n            shader = shaders.Load(VertexShaderDescriptor.TEXTURE_2, FragmentShaderDescriptor.TEXTURE_ROUNDED);\n        }\n\n        protected override void LoadComplete()\n        {\n            base.LoadComplete();\n            addTriangles(true);\n        }\n\n        public float TriangleScale\n        {\n            get => triangleScale;\n            set\n            {\n                float change = value \/ triangleScale;\n                triangleScale = value;\n\n                for (int i = 0; i < parts.Count; i++)\n                {\n                    TriangleParticle newParticle = parts[i];\n                    newParticle.Scale *= change;\n                    parts[i] = newParticle;\n                }\n            }\n        }\n\n        protected override void Update()\n        {\n            base.Update();\n\n            Invalidate(Invalidation.DrawNode, shallPropagate: false);\n\n            if (CreateNewTriangles)\n                addTriangles(false);\n\n            float adjustedAlpha = HideAlphaDiscrepancies\n                \/\/ Cubically scale alpha to make it drop off more sharply.\n                ? (float)Math.Pow(DrawColourInfo.Colour.AverageColour.Linear.A, 3)\n                : 1;\n\n            float elapsedSeconds = (float)Time.Elapsed \/ 1000;\n            \/\/ Since position is relative, the velocity needs to scale inversely with DrawHeight.\n            \/\/ Since we will later multiply by the scale of individual triangles we normalize by\n            \/\/ dividing by triangleScale.\n            float movedDistance = -elapsedSeconds * Velocity * base_velocity \/ (DrawHeight * triangleScale);\n\n            for (int i = 0; i < parts.Count; i++)\n            {\n                TriangleParticle newParticle = parts[i];\n\n                \/\/ Scale moved distance by the size of the triangle. Smaller triangles should move more slowly.\n                newParticle.Position.Y += parts[i].Scale * movedDistance;\n                newParticle.Colour.A = adjustedAlpha;\n\n                parts[i] = newParticle;\n\n                float bottomPos = parts[i].Position.Y + triangle_size * parts[i].Scale * 0.866f \/ DrawHeight;\n                if (bottomPos < 0)\n                    parts.RemoveAt(i);\n            }\n        }\n\n        protected int AimCount;\n\n        private void addTriangles(bool randomY)\n        {\n            AimCount = (int)(DrawWidth * DrawHeight * 0.002f \/ (triangleScale * triangleScale) * SpawnRatio);\n\n            for (int i = 0; i < AimCount - parts.Count; i++)\n                parts.Add(createTriangle(randomY));\n        }\n\n        private TriangleParticle createTriangle(bool randomY)\n        {\n            TriangleParticle particle = CreateTriangle();\n\n            particle.Position = new Vector2(RNG.NextSingle(), randomY ? RNG.NextSingle() : 1);\n            particle.Colour = CreateTriangleShade();\n\n            return particle;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Creates a triangle particle with a random scale.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The triangle particle.<\/returns>\n        protected virtual TriangleParticle CreateTriangle()\n        {\n            const float std_dev = 0.16f;\n            const float mean = 0.5f;\n\n            float u1 = 1 - RNG.NextSingle(); \/\/uniform(0,1] random floats\n            float u2 = 1 - RNG.NextSingle();\n            float randStdNormal = (float)(Math.Sqrt(-2.0 * Math.Log(u1)) * Math.Sin(2.0 * Math.PI * u2)); \/\/random normal(0,1)\n            var scale = Math.Max(triangleScale * (mean + std_dev * randStdNormal), 0.1f); \/\/random normal(mean,stdDev^2)\n\n            return new TriangleParticle { Scale = scale };\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Creates a shade of colour for the triangles.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The colour.<\/returns>\n        protected virtual Color4 CreateTriangleShade() => Interpolation.ValueAt(RNG.NextSingle(), ColourDark, ColourLight, 0, 1);\n\n        protected override DrawNode CreateDrawNode() => new TrianglesDrawNode(this);\n\n        private class TrianglesDrawNode : DrawNode\n        {\n            protected new Triangles Source => (Triangles)base.Source;\n\n            private IShader shader;\n            private Texture texture;\n\n            private readonly List<TriangleParticle> parts = new List<TriangleParticle>();\n            private Vector2 size;\n\n            private LinearBatch<TexturedVertex2D> vertexBatch;\n\n            public TrianglesDrawNode(Triangles source)\n                : base(source)\n            {\n            }\n\n            public override void ApplyState()\n            {\n                base.ApplyState();\n\n                shader = Source.shader;\n                texture = Source.texture;\n                size = Source.DrawSize;\n\n                parts.Clear();\n                parts.AddRange(Source.parts);\n            }\n\n            public override void Draw(Action<TexturedVertex2D> vertexAction)\n            {\n                if (vertexBatch == null && Source.AimCount > 0)\n                    vertexBatch = new LinearBatch<TexturedVertex2D>(Source.AimCount * 3, 2, PrimitiveType.Triangles);\n\n                base.Draw(vertexAction);\n\n                shader.Bind();\n\n                Vector2 localInflationAmount = edge_smoothness * DrawInfo.MatrixInverse.ExtractScale().Xy;\n\n                foreach (TriangleParticle particle in parts)\n                {\n                    var offset = triangle_size * new Vector2(particle.Scale * 0.5f, particle.Scale * 0.866f);\n\n                    var triangle = new Triangle(\n                        Vector2Extensions.Transform(particle.Position * size, DrawInfo.Matrix),\n                        Vector2Extensions.Transform(particle.Position * size + offset, DrawInfo.Matrix),\n                        Vector2Extensions.Transform(particle.Position * size + new Vector2(-offset.X, offset.Y), DrawInfo.Matrix)\n                    );\n\n                    ColourInfo colourInfo = DrawColourInfo.Colour;\n                    colourInfo.ApplyChild(particle.Colour);\n\n                    DrawTriangle(\n                        texture,\n                        triangle,\n                        colourInfo,\n                        null,\n                        vertexBatch.AddAction,\n                        Vector2.Divide(localInflationAmount, new Vector2(2 * offset.X, offset.Y)));\n                }\n\n                shader.Unbind();\n            }\n\n            protected override void Dispose(bool isDisposing)\n            {\n                base.Dispose(isDisposing);\n\n                vertexBatch?.Dispose();\n            }\n        }\n\n        protected struct TriangleParticle : IComparable<TriangleParticle>\n        {\n            \/\/\/ <summary>\n            \/\/\/ The position of the top vertex of the triangle.\n            \/\/\/ <\/summary>\n            public Vector2 Position;\n\n            \/\/\/ <summary>\n            \/\/\/ The colour of the triangle.\n            \/\/\/ <\/summary>\n            public Color4 Colour;\n\n            \/\/\/ <summary>\n            \/\/\/ The scale of the triangle.\n            \/\/\/ <\/summary>\n            public float Scale;\n\n            \/\/\/ <summary>\n            \/\/\/ Compares two <see cref=\"TriangleParticle\"\/>s. This is a reverse comparer because when the\n            \/\/\/ triangles are added to the particles list, they should be drawn from largest to smallest\n            \/\/\/ such that the smaller triangles appear on top.\n            \/\/\/ <\/summary>\n            \/\/\/ <param name=\"other\"><\/param>\n            \/\/\/ <returns><\/returns>\n            public int CompareTo(TriangleParticle other) => other.Scale.CompareTo(Scale);\n        }\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"61d7b63914c2c806f1ae6eab113f01a7193036d1","subject":"Readability Improvement","message":"Readability Improvement","repos":"UselessToucan\/osu,EVAST9919\/osu,smoogipoo\/osu,smoogipooo\/osu,smoogipoo\/osu,johnneijzen\/osu,peppy\/osu,ppy\/osu,peppy\/osu,NeoAdonis\/osu,peppy\/osu,UselessToucan\/osu,ppy\/osu,2yangk23\/osu,ppy\/osu,2yangk23\/osu,NeoAdonis\/osu,johnneijzen\/osu,peppy\/osu-new,smoogipoo\/osu,NeoAdonis\/osu,UselessToucan\/osu,EVAST9919\/osu","old_file":"osu.Game\/Overlays\/Mods\/ModSelectOverlay.cs","new_file":"osu.Game\/Overlays\/Mods\/ModSelectOverlay.cs","new_contents":"\ufeff\/\/ Copyright (c) ppy Pty Ltd <contact@ppy.sh>. Licensed under the MIT Licence.\n\/\/ See the LICENCE file in the repository root for full licence text.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing osu.Framework.Allocation;\nusing osu.Framework.Audio;\nusing osu.Framework.Audio.Sample;\nusing osu.Framework.Bindables;\nusing osu.Framework.Extensions.Color4Extensions;\nusing osu.Framework.Graphics;\nusing osu.Framework.Graphics.Containers;\nusing osu.Framework.Graphics.Shapes;\nusing osu.Framework.Input.Events;\nusing osu.Game.Configuration;\nusing osu.Game.Graphics;\nusing osu.Game.Graphics.Backgrounds;\nusing osu.Game.Graphics.Containers;\nusing osu.Game.Graphics.Sprites;\nusing osu.Game.Graphics.UserInterface;\nusing osu.Game.Overlays.Mods.Sections;\nusing osu.Game.Rulesets.Mods;\nusing osu.Game.Screens;\nusing osuTK;\nusing osuTK.Graphics;\nusing osuTK.Input;\n\nnamespace osu.Game.Overlays.Mods\n{\n    public class ModSelectOverlay : WaveOverlayContainer\n    {\n        protected readonly TriangleButton DeselectAllButton;\n        protected readonly TriangleButton CustomiseButton;\n        protected readonly TriangleButton CloseButton;\n\n        protected readonly OsuSpriteText MultiplierLabel;\n        protected readonly OsuSpriteText UnrankedLabel;\n\n        protected override bool BlockNonPositionalInput => false;\n\n        protected override bool DimMainContent => false;\n\n        protected readonly FillFlowContainer<ModSection> ModSectionsContainer;\n\n        protected readonly FillFlowContainer<ModControlSection> ModSettingsContent;\n\n        protected readonly Container ModSettingsContainer;\n\n        protected readonly Bindable<IReadOnlyList<Mod>> SelectedMods = new Bindable<IReadOnlyList<Mod>>(Array.Empty<Mod>());\n\n        private Bindable<Dictionary<ModType, IReadOnlyList<Mod>>> availableMods;\n\n        protected Color4 LowMultiplierColour;\n        protected Color4 HighMultiplierColour;\n\n        private const float content_width = 0.8f;\n        private readonly FillFlowContainer footerContainer;\n\n        private SampleChannel sampleOn, sampleOff;\n\n        public ModSelectOverlay()\n        {\n            Waves.FirstWaveColour = OsuColour.FromHex(@\"19b0e2\");\n            Waves.SecondWaveColour = OsuColour.FromHex(@\"2280a2\");\n            Waves.ThirdWaveColour = OsuColour.FromHex(@\"005774\");\n            Waves.FourthWaveColour = OsuColour.FromHex(@\"003a4e\");\n\n            Height = 510;\n            Padding = new MarginPadding { Horizontal = -OsuScreen.HORIZONTAL_OVERFLOW_PADDING };\n\n            Children = new Drawable[]\n            {\n                new Container\n                {\n                    RelativeSizeAxes = Axes.Both,\n                    Masking = true,\n                    Children = new Drawable[]\n                    {\n                        new Box\n                        {\n                            RelativeSizeAxes = Axes.Both,\n                            Colour = new Color4(36, 50, 68, 255)\n                        },\n                        new Triangles\n                        {\n                            TriangleScale = 5,\n                            RelativeSizeAxes = Axes.X,\n                            Height = Height, \/\/set the height from the start to ensure correct triangle density.\n                            ColourLight = new Color4(53, 66, 82, 255),\n                            ColourDark = new Color4(41, 54, 70, 255),\n                        },\n                    },\n                },\n                new GridContainer\n                {\n                    RelativeSizeAxes = Axes.Both,\n                    Anchor = Anchor.BottomCentre,\n                    Origin = Anchor.BottomCentre,\n                    RowDimensions = new[]\n                    {\n                        new Dimension(GridSizeMode.Absolute, 90),\n                        new Dimension(GridSizeMode.Distributed),\n                        new Dimension(GridSizeMode.Absolute, 70),\n                    },\n                    Content = new[]\n                    {\n                        new Drawable[]\n                        {\n                            new Container\n                            {\n                                RelativeSizeAxes = Axes.Both,\n                                Origin = Anchor.TopCentre,\n                                Anchor = Anchor.TopCentre,\n                                Children = new Drawable[]\n                                {\n                                    new Box\n                                    {\n                                        RelativeSizeAxes = Axes.Both,\n                                        Colour = OsuColour.Gray(10).Opacity(100),\n                                    },\n                                    new FillFlowContainer\n                                    {\n                                        Origin = Anchor.Centre,\n                                        Anchor = Anchor.Centre,\n                                        RelativeSizeAxes = Axes.X,\n                                        AutoSizeAxes = Axes.Y,\n                                        Direction = FillDirection.Vertical,\n                                        Width = content_width,\n                                        Padding = new MarginPadding { Horizontal = OsuScreen.HORIZONTAL_OVERFLOW_PADDING },\n                                        Children = new Drawable[]\n                                        {\n                                            new OsuSpriteText\n                                            {\n                                                Text = @\"Gameplay Mods\",\n                                                Font = OsuFont.GetFont(size: 22, weight: FontWeight.Bold),\n                                                Shadow = true,\n                                                Margin = new MarginPadding\n                                                {\n                                                    Bottom = 4,\n                                                },\n                                            },\n                                            new OsuTextFlowContainer(text =>\n                                            {\n                                                text.Font = text.Font.With(size: 18);\n                                                text.Shadow = true;\n                                            })\n                                            {\n                                                RelativeSizeAxes = Axes.X,\n                                                AutoSizeAxes = Axes.Y,\n                                                Text = \"Mods provide different ways to enjoy gameplay. Some have an effect on the score you can achieve during ranked play.\\nOthers are just for fun.\",\n                                            },\n                                        },\n                                    },\n                                },\n                            },\n                        },\n                        new Drawable[]\n                        {\n                            \/\/ Body\n                            new OsuScrollContainer\n                            {\n                                ScrollbarVisible = false,\n                                Origin = Anchor.TopCentre,\n                                Anchor = Anchor.TopCentre,\n                                RelativeSizeAxes = Axes.Both,\n                                Padding = new MarginPadding\n                                {\n                                    Vertical = 10,\n                                    Horizontal = OsuScreen.HORIZONTAL_OVERFLOW_PADDING\n                                },\n                                Child = ModSectionsContainer = new FillFlowContainer<ModSection>\n                                {\n                                    Origin = Anchor.TopCentre,\n                                    Anchor = Anchor.TopCentre,\n                                    RelativeSizeAxes = Axes.X,\n                                    AutoSizeAxes = Axes.Y,\n                                    Spacing = new Vector2(0f, 10f),\n                                    Width = content_width,\n                                    LayoutDuration = 200,\n                                    LayoutEasing = Easing.OutQuint,\n                                    Children = new ModSection[]\n                                    {\n                                        new DifficultyReductionSection { Action = modButtonPressed },\n                                        new DifficultyIncreaseSection { Action = modButtonPressed },\n                                        new AutomationSection { Action = modButtonPressed },\n                                        new ConversionSection { Action = modButtonPressed },\n                                        new FunSection { Action = modButtonPressed },\n                                    }\n                                },\n                            },\n                        },\n                        new Drawable[]\n                        {\n                            \/\/ Footer\n                            new Container\n                            {\n                                RelativeSizeAxes = Axes.Both,\n                                Origin = Anchor.TopCentre,\n                                Anchor = Anchor.TopCentre,\n                                Children = new Drawable[]\n                                {\n                                    new Box\n                                    {\n                                        RelativeSizeAxes = Axes.Both,\n                                        Colour = new Color4(172, 20, 116, 255),\n                                        Alpha = 0.5f,\n                                    },\n                                    footerContainer = new FillFlowContainer\n                                    {\n                                        Origin = Anchor.BottomCentre,\n                                        Anchor = Anchor.BottomCentre,\n                                        AutoSizeAxes = Axes.Y,\n                                        RelativeSizeAxes = Axes.X,\n                                        Width = content_width,\n                                        Direction = FillDirection.Horizontal,\n                                        Padding = new MarginPadding\n                                        {\n                                            Vertical = 15,\n                                            Horizontal = OsuScreen.HORIZONTAL_OVERFLOW_PADDING\n                                        },\n                                        Children = new Drawable[]\n                                        {\n                                            DeselectAllButton = new TriangleButton\n                                            {\n                                                Width = 180,\n                                                Text = \"Deselect All\",\n                                                Action = DeselectAll,\n                                                Margin = new MarginPadding\n                                                {\n                                                    Right = 20\n                                                }\n                                            },\n                                            CustomiseButton = new TriangleButton\n                                            {\n                                                Width = 180,\n                                                Text = \"Customisation\",\n                                                Action = () => ModSettingsContainer.Alpha = ModSettingsContainer.Alpha == 1 ? 0 : 1,\n                                                Enabled = { Value = false },\n                                                Margin = new MarginPadding\n                                                {\n                                                    Right = 20\n                                                }\n                                            },\n                                            CloseButton = new TriangleButton\n                                            {\n                                                Width = 180,\n                                                Text = \"Close\",\n                                                Action = Hide,\n                                                Margin = new MarginPadding\n                                                {\n                                                    Right = 20\n                                                }\n                                            },\n                                            new OsuSpriteText\n                                            {\n                                                Text = @\"Score Multiplier:\",\n                                                Font = OsuFont.GetFont(size: 30),\n                                                Margin = new MarginPadding\n                                                {\n                                                    Top = 5,\n                                                    Right = 10\n                                                }\n                                            },\n                                            MultiplierLabel = new OsuSpriteText\n                                            {\n                                                Font = OsuFont.GetFont(size: 30, weight: FontWeight.Bold),\n                                                Margin = new MarginPadding\n                                                {\n                                                    Top = 5\n                                                }\n                                            },\n                                            UnrankedLabel = new OsuSpriteText\n                                            {\n                                                Text = @\"(Unranked)\",\n                                                Font = OsuFont.GetFont(size: 30, weight: FontWeight.Bold),\n                                                Margin = new MarginPadding\n                                                {\n                                                    Top = 5,\n                                                    Left = 10\n                                                }\n                                            }\n                                        }\n                                    }\n                                },\n                            }\n                        },\n                    },\n                },\n                ModSettingsContainer = new Container\n                {\n                    RelativeSizeAxes = Axes.Both,\n                    Anchor = Anchor.BottomRight,\n                    Origin = Anchor.BottomRight,\n                    Width = 0.25f,\n                    Alpha = 0,\n                    X = -100,\n                    Children = new Drawable[]\n                    {\n                        new Box\n                        {\n                            RelativeSizeAxes = Axes.Both,\n                            Colour = new Color4(0, 0, 0, 192)\n                        },\n                        new OsuScrollContainer\n                        {\n                            RelativeSizeAxes = Axes.Both,\n                            Child = ModSettingsContent = new FillFlowContainer<ModControlSection>\n                            {\n                                Anchor = Anchor.TopCentre,\n                                Origin = Anchor.TopCentre,\n                                RelativeSizeAxes = Axes.X,\n                                AutoSizeAxes = Axes.Y,\n                                Spacing = new Vector2(0f, 10f),\n                                Padding = new MarginPadding(20),\n                            }\n                        }\n                    }\n                }\n            };\n        }\n\n        [BackgroundDependencyLoader(true)]\n        private void load(OsuColour colours, AudioManager audio, Bindable<IReadOnlyList<Mod>> selectedMods, OsuGameBase osu)\n        {\n            LowMultiplierColour = colours.Red;\n            HighMultiplierColour = colours.Green;\n            UnrankedLabel.Colour = colours.Blue;\n\n            availableMods = osu.AvailableMods.GetBoundCopy();\n            SelectedMods.BindTo(selectedMods);\n\n            sampleOn = audio.Samples.Get(@\"UI\/check-on\");\n            sampleOff = audio.Samples.Get(@\"UI\/check-off\");\n        }\n\n        public void DeselectAll()\n        {\n            foreach (var section in ModSectionsContainer.Children)\n                section.DeselectAll();\n\n            refreshSelectedMods();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Deselect one or more mods.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"modTypes\">The types of <see cref=\"Mod\"\/>s which should be deselected.<\/param>\n        \/\/\/ <param name=\"immediate\">Set to true to bypass animations and update selections immediately.<\/param>\n        public void DeselectTypes(Type[] modTypes, bool immediate = false)\n        {\n            if (modTypes.Length == 0) return;\n\n            foreach (var section in ModSectionsContainer.Children)\n                section.DeselectTypes(modTypes, immediate);\n        }\n\n        protected override void LoadComplete()\n        {\n            base.LoadComplete();\n\n            availableMods.BindValueChanged(availableModsChanged, true);\n            SelectedMods.BindValueChanged(selectedModsChanged, true);\n        }\n\n        protected override void PopOut()\n        {\n            base.PopOut();\n\n            footerContainer.MoveToX(footerContainer.DrawSize.X, WaveContainer.DISAPPEAR_DURATION, Easing.InSine);\n            footerContainer.FadeOut(WaveContainer.DISAPPEAR_DURATION, Easing.InSine);\n\n            foreach (var section in ModSectionsContainer.Children)\n            {\n                section.ButtonsContainer.TransformSpacingTo(new Vector2(100f, 0f), WaveContainer.DISAPPEAR_DURATION, Easing.InSine);\n                section.ButtonsContainer.MoveToX(100f, WaveContainer.DISAPPEAR_DURATION, Easing.InSine);\n                section.ButtonsContainer.FadeOut(WaveContainer.DISAPPEAR_DURATION, Easing.InSine);\n            }\n        }\n\n        protected override void PopIn()\n        {\n            base.PopIn();\n\n            footerContainer.MoveToX(0, WaveContainer.APPEAR_DURATION, Easing.OutQuint);\n            footerContainer.FadeIn(WaveContainer.APPEAR_DURATION, Easing.OutQuint);\n\n            foreach (var section in ModSectionsContainer.Children)\n            {\n                section.ButtonsContainer.TransformSpacingTo(new Vector2(50f, 0f), WaveContainer.APPEAR_DURATION, Easing.OutQuint);\n                section.ButtonsContainer.MoveToX(0, WaveContainer.APPEAR_DURATION, Easing.OutQuint);\n                section.ButtonsContainer.FadeIn(WaveContainer.APPEAR_DURATION, Easing.OutQuint);\n            }\n        }\n\n        protected override bool OnKeyDown(KeyDownEvent e)\n        {\n            switch (e.Key)\n            {\n                case Key.Number1:\n                    DeselectAllButton.Click();\n                    return true;\n\n                case Key.Number2:\n                    CloseButton.Click();\n                    return true;\n            }\n\n            return base.OnKeyDown(e);\n        }\n\n        private void availableModsChanged(ValueChangedEvent<Dictionary<ModType, IReadOnlyList<Mod>>> mods)\n        {\n            if (mods.NewValue == null) return;\n\n            foreach (var section in ModSectionsContainer.Children)\n                section.Mods = mods.NewValue[section.ModType];\n        }\n\n        private void selectedModsChanged(ValueChangedEvent<IReadOnlyList<Mod>> mods)\n        {\n            foreach (var section in ModSectionsContainer.Children)\n                section.SelectTypes(mods.NewValue.Select(m => m.GetType()).ToList());\n\n            updateMods();\n\n            updateModSettings(mods);\n        }\n\n        private void updateMods()\n        {\n            var multiplier = 1.0;\n            var ranked = true;\n\n            foreach (var mod in SelectedMods.Value)\n            {\n                multiplier *= mod.ScoreMultiplier;\n                ranked &= mod.Ranked;\n            }\n\n            MultiplierLabel.Text = $\"{multiplier:N2}x\";\n            if (multiplier > 1.0)\n                MultiplierLabel.FadeColour(HighMultiplierColour, 200);\n            else if (multiplier < 1.0)\n                MultiplierLabel.FadeColour(LowMultiplierColour, 200);\n            else\n                MultiplierLabel.FadeColour(Color4.White, 200);\n\n            UnrankedLabel.FadeTo(ranked ? 0 : 1, 200);\n        }\n\n        private void updateModSettings(ValueChangedEvent<IReadOnlyList<Mod>> selectedMods)\n        {\n            ModSettingsContent.Clear();\n\n            foreach (var mod in selectedMods.NewValue)\n            {\n                var settings = mod.CreateSettingsControls().ToList();\n                if (settings.Count > 0)\n                    ModSettingsContent.Add(new ModControlSection(mod, settings));\n            }\n\n            bool hasSettings = ModSettingsContent.Count > 0;\n\n            CustomiseButton.Enabled.Value = hasSettings;\n\n            if (!hasSettings)\n                ModSettingsContainer.Hide();\n        }\n\n        private void modButtonPressed(Mod selectedMod)\n        {\n            if (selectedMod != null)\n            {\n                if (State.Value == Visibility.Visible) sampleOn?.Play();\n\n                DeselectTypes(selectedMod.IncompatibleMods, true);\n\n                if (selectedMod.RequiresConfiguration) ModSettingsContainer.Alpha = 1;\n            }\n            else\n            {\n                if (State.Value == Visibility.Visible) sampleOff?.Play();\n            }\n\n            refreshSelectedMods();\n        }\n\n        private void refreshSelectedMods() => SelectedMods.Value = ModSectionsContainer.Children.SelectMany(s => s.SelectedMods).ToArray();\n\n        #region Disposal\n\n        protected override void Dispose(bool isDisposing)\n        {\n            base.Dispose(isDisposing);\n\n            availableMods?.UnbindAll();\n            SelectedMods?.UnbindAll();\n        }\n\n        #endregion\n    }\n}\n","old_contents":"\ufeff\/\/ Copyright (c) ppy Pty Ltd <contact@ppy.sh>. Licensed under the MIT Licence.\n\/\/ See the LICENCE file in the repository root for full licence text.\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing osu.Framework.Allocation;\nusing osu.Framework.Audio;\nusing osu.Framework.Audio.Sample;\nusing osu.Framework.Bindables;\nusing osu.Framework.Extensions.Color4Extensions;\nusing osu.Framework.Graphics;\nusing osu.Framework.Graphics.Containers;\nusing osu.Framework.Graphics.Shapes;\nusing osu.Framework.Input.Events;\nusing osu.Game.Configuration;\nusing osu.Game.Graphics;\nusing osu.Game.Graphics.Backgrounds;\nusing osu.Game.Graphics.Containers;\nusing osu.Game.Graphics.Sprites;\nusing osu.Game.Graphics.UserInterface;\nusing osu.Game.Overlays.Mods.Sections;\nusing osu.Game.Rulesets.Mods;\nusing osu.Game.Screens;\nusing osuTK;\nusing osuTK.Graphics;\nusing osuTK.Input;\n\nnamespace osu.Game.Overlays.Mods\n{\n    public class ModSelectOverlay : WaveOverlayContainer\n    {\n        protected readonly TriangleButton DeselectAllButton;\n        protected readonly TriangleButton CustomiseButton;\n        protected readonly TriangleButton CloseButton;\n\n        protected readonly OsuSpriteText MultiplierLabel;\n        protected readonly OsuSpriteText UnrankedLabel;\n\n        protected override bool BlockNonPositionalInput => false;\n\n        protected override bool DimMainContent => false;\n\n        protected readonly FillFlowContainer<ModSection> ModSectionsContainer;\n\n        protected readonly FillFlowContainer<ModControlSection> ModSettingsContent;\n\n        protected readonly Container ModSettingsContainer;\n\n        protected readonly Bindable<IReadOnlyList<Mod>> SelectedMods = new Bindable<IReadOnlyList<Mod>>(Array.Empty<Mod>());\n\n        private Bindable<Dictionary<ModType, IReadOnlyList<Mod>>> availableMods;\n\n        protected Color4 LowMultiplierColour;\n        protected Color4 HighMultiplierColour;\n\n        private const float content_width = 0.8f;\n        private readonly FillFlowContainer footerContainer;\n\n        private SampleChannel sampleOn, sampleOff;\n\n        public ModSelectOverlay()\n        {\n            Waves.FirstWaveColour = OsuColour.FromHex(@\"19b0e2\");\n            Waves.SecondWaveColour = OsuColour.FromHex(@\"2280a2\");\n            Waves.ThirdWaveColour = OsuColour.FromHex(@\"005774\");\n            Waves.FourthWaveColour = OsuColour.FromHex(@\"003a4e\");\n\n            Height = 510;\n            Padding = new MarginPadding { Horizontal = -OsuScreen.HORIZONTAL_OVERFLOW_PADDING };\n\n            Children = new Drawable[]\n            {\n                new Container\n                {\n                    RelativeSizeAxes = Axes.Both,\n                    Masking = true,\n                    Children = new Drawable[]\n                    {\n                        new Box\n                        {\n                            RelativeSizeAxes = Axes.Both,\n                            Colour = new Color4(36, 50, 68, 255)\n                        },\n                        new Triangles\n                        {\n                            TriangleScale = 5,\n                            RelativeSizeAxes = Axes.X,\n                            Height = Height, \/\/set the height from the start to ensure correct triangle density.\n                            ColourLight = new Color4(53, 66, 82, 255),\n                            ColourDark = new Color4(41, 54, 70, 255),\n                        },\n                    },\n                },\n                new GridContainer\n                {\n                    RelativeSizeAxes = Axes.Both,\n                    Anchor = Anchor.BottomCentre,\n                    Origin = Anchor.BottomCentre,\n                    RowDimensions = new[]\n                    {\n                        new Dimension(GridSizeMode.Absolute, 90),\n                        new Dimension(GridSizeMode.Distributed),\n                        new Dimension(GridSizeMode.Absolute, 70),\n                    },\n                    Content = new[]\n                    {\n                        new Drawable[]\n                        {\n                            new Container\n                            {\n                                RelativeSizeAxes = Axes.Both,\n                                Origin = Anchor.TopCentre,\n                                Anchor = Anchor.TopCentre,\n                                Children = new Drawable[]\n                                {\n                                    new Box\n                                    {\n                                        RelativeSizeAxes = Axes.Both,\n                                        Colour = OsuColour.Gray(10).Opacity(100),\n                                    },\n                                    new FillFlowContainer\n                                    {\n                                        Origin = Anchor.Centre,\n                                        Anchor = Anchor.Centre,\n                                        RelativeSizeAxes = Axes.X,\n                                        AutoSizeAxes = Axes.Y,\n                                        Direction = FillDirection.Vertical,\n                                        Width = content_width,\n                                        Padding = new MarginPadding { Horizontal = OsuScreen.HORIZONTAL_OVERFLOW_PADDING },\n                                        Children = new Drawable[]\n                                        {\n                                            new OsuSpriteText\n                                            {\n                                                Text = @\"Gameplay Mods\",\n                                                Font = OsuFont.GetFont(size: 22, weight: FontWeight.Bold),\n                                                Shadow = true,\n                                                Margin = new MarginPadding\n                                                {\n                                                    Bottom = 4,\n                                                },\n                                            },\n                                            new OsuTextFlowContainer(text =>\n                                            {\n                                                text.Font = text.Font.With(size: 18);\n                                                text.Shadow = true;\n                                            })\n                                            {\n                                                RelativeSizeAxes = Axes.X,\n                                                AutoSizeAxes = Axes.Y,\n                                                Text = \"Mods provide different ways to enjoy gameplay. Some have an effect on the score you can achieve during ranked play.\\nOthers are just for fun.\",\n                                            },\n                                        },\n                                    },\n                                },\n                            },\n                        },\n                        new Drawable[]\n                        {\n                            \/\/ Body\n                            new OsuScrollContainer\n                            {\n                                ScrollbarVisible = false,\n                                Origin = Anchor.TopCentre,\n                                Anchor = Anchor.TopCentre,\n                                RelativeSizeAxes = Axes.Both,\n                                Padding = new MarginPadding\n                                {\n                                    Vertical = 10,\n                                    Horizontal = OsuScreen.HORIZONTAL_OVERFLOW_PADDING\n                                },\n                                Child = ModSectionsContainer = new FillFlowContainer<ModSection>\n                                {\n                                    Origin = Anchor.TopCentre,\n                                    Anchor = Anchor.TopCentre,\n                                    RelativeSizeAxes = Axes.X,\n                                    AutoSizeAxes = Axes.Y,\n                                    Spacing = new Vector2(0f, 10f),\n                                    Width = content_width,\n                                    LayoutDuration = 200,\n                                    LayoutEasing = Easing.OutQuint,\n                                    Children = new ModSection[]\n                                    {\n                                        new DifficultyReductionSection { Action = modButtonPressed },\n                                        new DifficultyIncreaseSection { Action = modButtonPressed },\n                                        new AutomationSection { Action = modButtonPressed },\n                                        new ConversionSection { Action = modButtonPressed },\n                                        new FunSection { Action = modButtonPressed },\n                                    }\n                                },\n                            },\n                        },\n                        new Drawable[]\n                        {\n                            \/\/ Footer\n                            new Container\n                            {\n                                RelativeSizeAxes = Axes.Both,\n                                Origin = Anchor.TopCentre,\n                                Anchor = Anchor.TopCentre,\n                                Children = new Drawable[]\n                                {\n                                    new Box\n                                    {\n                                        RelativeSizeAxes = Axes.Both,\n                                        Colour = new Color4(172, 20, 116, 255),\n                                        Alpha = 0.5f,\n                                    },\n                                    footerContainer = new FillFlowContainer\n                                    {\n                                        Origin = Anchor.BottomCentre,\n                                        Anchor = Anchor.BottomCentre,\n                                        AutoSizeAxes = Axes.Y,\n                                        RelativeSizeAxes = Axes.X,\n                                        Width = content_width,\n                                        Direction = FillDirection.Horizontal,\n                                        Padding = new MarginPadding\n                                        {\n                                            Vertical = 15,\n                                            Horizontal = OsuScreen.HORIZONTAL_OVERFLOW_PADDING\n                                        },\n                                        Children = new Drawable[]\n                                        {\n                                            DeselectAllButton = new TriangleButton\n                                            {\n                                                Width = 180,\n                                                Text = \"Deselect All\",\n                                                Action = DeselectAll,\n                                                Margin = new MarginPadding\n                                                {\n                                                    Right = 20\n                                                }\n                                            },\n                                            CustomiseButton = new TriangleButton\n                                            {\n                                                Width = 180,\n                                                Text = \"Customisation\",\n                                                Action = () => ModSettingsContainer.Alpha = ModSettingsContainer.Alpha == 1 ? 0 : 1,\n                                                Enabled = { Value = false },\n                                                Margin = new MarginPadding\n                                                {\n                                                    Right = 20\n                                                }\n                                            },\n                                            CloseButton = new TriangleButton\n                                            {\n                                                Width = 180,\n                                                Text = \"Close\",\n                                                Action = Hide,\n                                                Margin = new MarginPadding\n                                                {\n                                                    Right = 20\n                                                }\n                                            },\n                                            new OsuSpriteText\n                                            {\n                                                Text = @\"Score Multiplier:\",\n                                                Font = OsuFont.GetFont(size: 30),\n                                                Margin = new MarginPadding\n                                                {\n                                                    Top = 5,\n                                                    Right = 10\n                                                }\n                                            },\n                                            MultiplierLabel = new OsuSpriteText\n                                            {\n                                                Font = OsuFont.GetFont(size: 30, weight: FontWeight.Bold),\n                                                Margin = new MarginPadding\n                                                {\n                                                    Top = 5\n                                                }\n                                            },\n                                            UnrankedLabel = new OsuSpriteText\n                                            {\n                                                Text = @\"(Unranked)\",\n                                                Font = OsuFont.GetFont(size: 30, weight: FontWeight.Bold),\n                                                Margin = new MarginPadding\n                                                {\n                                                    Top = 5,\n                                                    Left = 10\n                                                }\n                                            }\n                                        }\n                                    }\n                                },\n                            }\n                        },\n                    },\n                },\n                ModSettingsContainer = new Container\n                {\n                    RelativeSizeAxes = Axes.Both,\n                    Anchor = Anchor.BottomRight,\n                    Origin = Anchor.BottomRight,\n                    Width = 0.25f,\n                    Alpha = 0,\n                    X = -100,\n                    Children = new Drawable[]\n                    {\n                        new Box\n                        {\n                            RelativeSizeAxes = Axes.Both,\n                            Colour = new Color4(0, 0, 0, 192)\n                        },\n                        new OsuScrollContainer\n                        {\n                            RelativeSizeAxes = Axes.Both,\n                            Child = ModSettingsContent = new FillFlowContainer<ModControlSection>\n                            {\n                                Anchor = Anchor.TopCentre,\n                                Origin = Anchor.TopCentre,\n                                RelativeSizeAxes = Axes.X,\n                                AutoSizeAxes = Axes.Y,\n                                Spacing = new Vector2(0f, 10f),\n                                Padding = new MarginPadding(20),\n                            }\n                        }\n                    }\n                }\n            };\n        }\n\n        [BackgroundDependencyLoader(true)]\n        private void load(OsuColour colours, AudioManager audio, Bindable<IReadOnlyList<Mod>> selectedMods, OsuGameBase osu)\n        {\n            LowMultiplierColour = colours.Red;\n            HighMultiplierColour = colours.Green;\n            UnrankedLabel.Colour = colours.Blue;\n\n            availableMods = osu.AvailableMods.GetBoundCopy();\n            SelectedMods.BindTo(selectedMods);\n\n            sampleOn = audio.Samples.Get(@\"UI\/check-on\");\n            sampleOff = audio.Samples.Get(@\"UI\/check-off\");\n        }\n\n        public void DeselectAll()\n        {\n            foreach (var section in ModSectionsContainer.Children)\n                section.DeselectAll();\n\n            refreshSelectedMods();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Deselect one or more mods.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"modTypes\">The types of <see cref=\"Mod\"\/>s which should be deselected.<\/param>\n        \/\/\/ <param name=\"immediate\">Set to true to bypass animations and update selections immediately.<\/param>\n        public void DeselectTypes(Type[] modTypes, bool immediate = false)\n        {\n            if (modTypes.Length == 0) return;\n\n            foreach (var section in ModSectionsContainer.Children)\n                section.DeselectTypes(modTypes, immediate);\n        }\n\n        protected override void LoadComplete()\n        {\n            base.LoadComplete();\n\n            availableMods.BindValueChanged(availableModsChanged, true);\n            SelectedMods.BindValueChanged(selectedModsChanged, true);\n        }\n\n        protected override void PopOut()\n        {\n            base.PopOut();\n\n            footerContainer.MoveToX(footerContainer.DrawSize.X, WaveContainer.DISAPPEAR_DURATION, Easing.InSine);\n            footerContainer.FadeOut(WaveContainer.DISAPPEAR_DURATION, Easing.InSine);\n\n            foreach (var section in ModSectionsContainer.Children)\n            {\n                section.ButtonsContainer.TransformSpacingTo(new Vector2(100f, 0f), WaveContainer.DISAPPEAR_DURATION, Easing.InSine);\n                section.ButtonsContainer.MoveToX(100f, WaveContainer.DISAPPEAR_DURATION, Easing.InSine);\n                section.ButtonsContainer.FadeOut(WaveContainer.DISAPPEAR_DURATION, Easing.InSine);\n            }\n        }\n\n        protected override void PopIn()\n        {\n            base.PopIn();\n\n            footerContainer.MoveToX(0, WaveContainer.APPEAR_DURATION, Easing.OutQuint);\n            footerContainer.FadeIn(WaveContainer.APPEAR_DURATION, Easing.OutQuint);\n\n            foreach (var section in ModSectionsContainer.Children)\n            {\n                section.ButtonsContainer.TransformSpacingTo(new Vector2(50f, 0f), WaveContainer.APPEAR_DURATION, Easing.OutQuint);\n                section.ButtonsContainer.MoveToX(0, WaveContainer.APPEAR_DURATION, Easing.OutQuint);\n                section.ButtonsContainer.FadeIn(WaveContainer.APPEAR_DURATION, Easing.OutQuint);\n            }\n        }\n\n        protected override bool OnKeyDown(KeyDownEvent e)\n        {\n            switch (e.Key)\n            {\n                case Key.Number1:\n                    DeselectAllButton.Click();\n                    return true;\n\n                case Key.Number2:\n                    CloseButton.Click();\n                    return true;\n            }\n\n            return base.OnKeyDown(e);\n        }\n\n        private void availableModsChanged(ValueChangedEvent<Dictionary<ModType, IReadOnlyList<Mod>>> mods)\n        {\n            if (mods.NewValue == null) return;\n\n            foreach (var section in ModSectionsContainer.Children)\n                section.Mods = mods.NewValue[section.ModType];\n        }\n\n        private void selectedModsChanged(ValueChangedEvent<IReadOnlyList<Mod>> mods)\n        {\n            foreach (var section in ModSectionsContainer.Children)\n                section.SelectTypes(mods.NewValue.Select(m => m.GetType()).ToList());\n\n            updateMods();\n\n            updateModSettings(mods);\n        }\n\n        private void updateMods()\n        {\n            var multiplier = 1.0;\n            var ranked = true;\n\n            foreach (var mod in SelectedMods.Value)\n            {\n                multiplier *= mod.ScoreMultiplier;\n                ranked &= mod.Ranked;\n            }\n\n            MultiplierLabel.Text = $\"{multiplier:N2}x\";\n            if (multiplier > 1.0)\n                MultiplierLabel.FadeColour(HighMultiplierColour, 200);\n            else if (multiplier < 1.0)\n                MultiplierLabel.FadeColour(LowMultiplierColour, 200);\n            else\n                MultiplierLabel.FadeColour(Color4.White, 200);\n\n            UnrankedLabel.FadeTo(ranked ? 0 : 1, 200);\n        }\n\n        private void updateModSettings(ValueChangedEvent<IReadOnlyList<Mod>> selectedMods)\n        {\n            ModSettingsContent.Clear();\n\n            foreach (var mod in selectedMods.NewValue)\n            {\n                var settings = mod.CreateSettingsControls().ToList();\n                if (settings.Count > 0)\n                    ModSettingsContent.Add(new ModControlSection(mod, settings));\n            }\n\n            bool hasSettings = ModSettingsContent.Count > 0;\n\n            CustomiseButton.Enabled.Value = hasSettings;\n\n            if (!hasSettings)\n                ModSettingsContainer.Hide();\n        }\n\n        private void modButtonPressed(Mod selectedMod)\n        {\n            if (selectedMod != null)\n            {\n                if (State.Value == Visibility.Visible) sampleOn?.Play();\n                DeselectTypes(selectedMod.IncompatibleMods, true);\n                if (selectedMod.RequiresConfiguration) ModSettingsContainer.Alpha = 1;\n            }\n            else\n            {\n                if (State.Value == Visibility.Visible) sampleOff?.Play();\n            }\n\n            refreshSelectedMods();\n        }\n\n        private void refreshSelectedMods() => SelectedMods.Value = ModSectionsContainer.Children.SelectMany(s => s.SelectedMods).ToArray();\n\n        #region Disposal\n\n        protected override void Dispose(bool isDisposing)\n        {\n            base.Dispose(isDisposing);\n\n            availableMods?.UnbindAll();\n            SelectedMods?.UnbindAll();\n        }\n\n        #endregion\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"ad959ce5238dbd8ca4465305d703efac065a3dab","subject":"Make toolbar button abstract","message":"Make toolbar button abstract\n","repos":"NeoAdonis\/osu,ppy\/osu,smoogipooo\/osu,smoogipoo\/osu,ppy\/osu,peppy\/osu,peppy\/osu,UselessToucan\/osu,smoogipoo\/osu,peppy\/osu-new,UselessToucan\/osu,peppy\/osu,NeoAdonis\/osu,smoogipoo\/osu,NeoAdonis\/osu,UselessToucan\/osu,ppy\/osu","old_file":"osu.Game\/Overlays\/Toolbar\/ToolbarButton.cs","new_file":"osu.Game\/Overlays\/Toolbar\/ToolbarButton.cs","new_contents":"\ufeff\/\/ Copyright (c) ppy Pty Ltd <contact@ppy.sh>. Licensed under the MIT Licence.\n\/\/ See the LICENCE file in the repository root for full licence text.\n\nusing osu.Framework.Extensions.Color4Extensions;\nusing osu.Framework.Graphics;\nusing osu.Framework.Graphics.Containers;\nusing osu.Framework.Graphics.Effects;\nusing osu.Framework.Graphics.Sprites;\nusing osu.Game.Graphics;\nusing osu.Game.Graphics.Backgrounds;\nusing osu.Game.Graphics.Sprites;\nusing osuTK;\nusing osuTK.Graphics;\nusing osu.Framework.Graphics.Shapes;\nusing osu.Framework.Input.Events;\nusing osu.Game.Graphics.Containers;\nusing osu.Game.Graphics.UserInterface;\n\nnamespace osu.Game.Overlays.Toolbar\n{\n    public abstract class ToolbarButton : OsuClickableContainer\n    {\n        public const float WIDTH = Toolbar.HEIGHT * 1.4f;\n\n        public void SetIcon(Drawable icon)\n        {\n            IconContainer.Icon = icon;\n            IconContainer.Show();\n        }\n\n        public void SetIcon(IconUsage icon) => SetIcon(new SpriteIcon\n        {\n            Size = new Vector2(20),\n            Icon = icon\n        });\n\n        public IconUsage Icon\n        {\n            set => SetIcon(value);\n        }\n\n        public string Text\n        {\n            get => DrawableText.Text;\n            set => DrawableText.Text = value;\n        }\n\n        public string TooltipMain\n        {\n            get => tooltip1.Text;\n            set => tooltip1.Text = value;\n        }\n\n        public string TooltipSub\n        {\n            get => tooltip2.Text;\n            set => tooltip2.Text = value;\n        }\n\n        protected virtual Anchor TooltipAnchor => Anchor.TopLeft;\n\n        protected ConstrainedIconContainer IconContainer;\n        protected SpriteText DrawableText;\n        protected Box HoverBackground;\n        private readonly Box flashBackground;\n        private readonly FillFlowContainer tooltipContainer;\n        private readonly SpriteText tooltip1;\n        private readonly SpriteText tooltip2;\n        protected FillFlowContainer Flow;\n\n        protected ToolbarButton()\n            : base(HoverSampleSet.Loud)\n        {\n            Width = WIDTH;\n            RelativeSizeAxes = Axes.Y;\n\n            Children = new Drawable[]\n            {\n                HoverBackground = new Box\n                {\n                    RelativeSizeAxes = Axes.Both,\n                    Colour = OsuColour.Gray(80).Opacity(180),\n                    Blending = BlendingParameters.Additive,\n                    Alpha = 0,\n                },\n                flashBackground = new Box\n                {\n                    RelativeSizeAxes = Axes.Both,\n                    Alpha = 0,\n                    Colour = Color4.White.Opacity(100),\n                    Blending = BlendingParameters.Additive,\n                },\n                Flow = new FillFlowContainer\n                {\n                    Direction = FillDirection.Horizontal,\n                    Spacing = new Vector2(5),\n                    Anchor = Anchor.TopCentre,\n                    Origin = Anchor.TopCentre,\n                    Padding = new MarginPadding { Left = Toolbar.HEIGHT \/ 2, Right = Toolbar.HEIGHT \/ 2 },\n                    RelativeSizeAxes = Axes.Y,\n                    AutoSizeAxes = Axes.X,\n                    Children = new Drawable[]\n                    {\n                        IconContainer = new ConstrainedIconContainer\n                        {\n                            Anchor = Anchor.CentreLeft,\n                            Origin = Anchor.CentreLeft,\n                            Size = new Vector2(20),\n                            Alpha = 0,\n                        },\n                        DrawableText = new OsuSpriteText\n                        {\n                            Anchor = Anchor.CentreLeft,\n                            Origin = Anchor.CentreLeft,\n                        },\n                    },\n                },\n                tooltipContainer = new FillFlowContainer\n                {\n                    Direction = FillDirection.Vertical,\n                    RelativeSizeAxes = Axes.Both, \/\/ stops us being considered in parent's autosize\n                    Anchor = TooltipAnchor.HasFlag(Anchor.x0) ? Anchor.BottomLeft : Anchor.BottomRight,\n                    Origin = TooltipAnchor,\n                    Position = new Vector2(TooltipAnchor.HasFlag(Anchor.x0) ? 5 : -5, 5),\n                    Alpha = 0,\n                    Children = new[]\n                    {\n                        tooltip1 = new OsuSpriteText\n                        {\n                            Anchor = TooltipAnchor,\n                            Origin = TooltipAnchor,\n                            Shadow = true,\n                            Font = OsuFont.GetFont(size: 22, weight: FontWeight.Bold),\n                        },\n                        tooltip2 = new OsuSpriteText\n                        {\n                            Anchor = TooltipAnchor,\n                            Origin = TooltipAnchor,\n                            Shadow = true,\n                        }\n                    }\n                }\n            };\n        }\n\n        protected override bool OnMouseDown(MouseDownEvent e) => true;\n\n        protected override bool OnClick(ClickEvent e)\n        {\n            flashBackground.FadeOutFromOne(800, Easing.OutQuint);\n            tooltipContainer.FadeOut(100);\n            return base.OnClick(e);\n        }\n\n        protected override bool OnHover(HoverEvent e)\n        {\n            HoverBackground.FadeIn(200);\n            tooltipContainer.FadeIn(100);\n            return base.OnHover(e);\n        }\n\n        protected override void OnHoverLost(HoverLostEvent e)\n        {\n            HoverBackground.FadeOut(200);\n            tooltipContainer.FadeOut(100);\n        }\n    }\n\n    public class OpaqueBackground : Container\n    {\n        public OpaqueBackground()\n        {\n            RelativeSizeAxes = Axes.Both;\n            Masking = true;\n            MaskingSmoothness = 0;\n            EdgeEffect = new EdgeEffectParameters\n            {\n                Type = EdgeEffectType.Shadow,\n                Colour = Color4.Black.Opacity(40),\n                Radius = 5,\n            };\n\n            Children = new Drawable[]\n            {\n                new Box\n                {\n                    RelativeSizeAxes = Axes.Both,\n                    Colour = OsuColour.Gray(30)\n                },\n                new Triangles\n                {\n                    RelativeSizeAxes = Axes.Both,\n                    ColourLight = OsuColour.Gray(40),\n                    ColourDark = OsuColour.Gray(20),\n                },\n            };\n        }\n    }\n}\n","old_contents":"\ufeff\/\/ Copyright (c) ppy Pty Ltd <contact@ppy.sh>. Licensed under the MIT Licence.\n\/\/ See the LICENCE file in the repository root for full licence text.\n\nusing osu.Framework.Extensions.Color4Extensions;\nusing osu.Framework.Graphics;\nusing osu.Framework.Graphics.Containers;\nusing osu.Framework.Graphics.Effects;\nusing osu.Framework.Graphics.Sprites;\nusing osu.Game.Graphics;\nusing osu.Game.Graphics.Backgrounds;\nusing osu.Game.Graphics.Sprites;\nusing osuTK;\nusing osuTK.Graphics;\nusing osu.Framework.Graphics.Shapes;\nusing osu.Framework.Input.Events;\nusing osu.Game.Graphics.Containers;\nusing osu.Game.Graphics.UserInterface;\n\nnamespace osu.Game.Overlays.Toolbar\n{\n    public class ToolbarButton : OsuClickableContainer\n    {\n        public const float WIDTH = Toolbar.HEIGHT * 1.4f;\n\n        public void SetIcon(Drawable icon)\n        {\n            IconContainer.Icon = icon;\n            IconContainer.Show();\n        }\n\n        public void SetIcon(IconUsage icon) => SetIcon(new SpriteIcon\n        {\n            Size = new Vector2(20),\n            Icon = icon\n        });\n\n        public IconUsage Icon\n        {\n            set => SetIcon(value);\n        }\n\n        public string Text\n        {\n            get => DrawableText.Text;\n            set => DrawableText.Text = value;\n        }\n\n        public string TooltipMain\n        {\n            get => tooltip1.Text;\n            set => tooltip1.Text = value;\n        }\n\n        public string TooltipSub\n        {\n            get => tooltip2.Text;\n            set => tooltip2.Text = value;\n        }\n\n        protected virtual Anchor TooltipAnchor => Anchor.TopLeft;\n\n        protected ConstrainedIconContainer IconContainer;\n        protected SpriteText DrawableText;\n        protected Box HoverBackground;\n        private readonly Box flashBackground;\n        private readonly FillFlowContainer tooltipContainer;\n        private readonly SpriteText tooltip1;\n        private readonly SpriteText tooltip2;\n        protected FillFlowContainer Flow;\n\n        public ToolbarButton()\n            : base(HoverSampleSet.Loud)\n        {\n            Width = WIDTH;\n            RelativeSizeAxes = Axes.Y;\n\n            Children = new Drawable[]\n            {\n                HoverBackground = new Box\n                {\n                    RelativeSizeAxes = Axes.Both,\n                    Colour = OsuColour.Gray(80).Opacity(180),\n                    Blending = BlendingParameters.Additive,\n                    Alpha = 0,\n                },\n                flashBackground = new Box\n                {\n                    RelativeSizeAxes = Axes.Both,\n                    Alpha = 0,\n                    Colour = Color4.White.Opacity(100),\n                    Blending = BlendingParameters.Additive,\n                },\n                Flow = new FillFlowContainer\n                {\n                    Direction = FillDirection.Horizontal,\n                    Spacing = new Vector2(5),\n                    Anchor = Anchor.TopCentre,\n                    Origin = Anchor.TopCentre,\n                    Padding = new MarginPadding { Left = Toolbar.HEIGHT \/ 2, Right = Toolbar.HEIGHT \/ 2 },\n                    RelativeSizeAxes = Axes.Y,\n                    AutoSizeAxes = Axes.X,\n                    Children = new Drawable[]\n                    {\n                        IconContainer = new ConstrainedIconContainer\n                        {\n                            Anchor = Anchor.CentreLeft,\n                            Origin = Anchor.CentreLeft,\n                            Size = new Vector2(20),\n                            Alpha = 0,\n                        },\n                        DrawableText = new OsuSpriteText\n                        {\n                            Anchor = Anchor.CentreLeft,\n                            Origin = Anchor.CentreLeft,\n                        },\n                    },\n                },\n                tooltipContainer = new FillFlowContainer\n                {\n                    Direction = FillDirection.Vertical,\n                    RelativeSizeAxes = Axes.Both, \/\/ stops us being considered in parent's autosize\n                    Anchor = TooltipAnchor.HasFlag(Anchor.x0) ? Anchor.BottomLeft : Anchor.BottomRight,\n                    Origin = TooltipAnchor,\n                    Position = new Vector2(TooltipAnchor.HasFlag(Anchor.x0) ? 5 : -5, 5),\n                    Alpha = 0,\n                    Children = new[]\n                    {\n                        tooltip1 = new OsuSpriteText\n                        {\n                            Anchor = TooltipAnchor,\n                            Origin = TooltipAnchor,\n                            Shadow = true,\n                            Font = OsuFont.GetFont(size: 22, weight: FontWeight.Bold),\n                        },\n                        tooltip2 = new OsuSpriteText\n                        {\n                            Anchor = TooltipAnchor,\n                            Origin = TooltipAnchor,\n                            Shadow = true,\n                        }\n                    }\n                }\n            };\n        }\n\n        protected override bool OnMouseDown(MouseDownEvent e) => true;\n\n        protected override bool OnClick(ClickEvent e)\n        {\n            flashBackground.FadeOutFromOne(800, Easing.OutQuint);\n            tooltipContainer.FadeOut(100);\n            return base.OnClick(e);\n        }\n\n        protected override bool OnHover(HoverEvent e)\n        {\n            HoverBackground.FadeIn(200);\n            tooltipContainer.FadeIn(100);\n            return base.OnHover(e);\n        }\n\n        protected override void OnHoverLost(HoverLostEvent e)\n        {\n            HoverBackground.FadeOut(200);\n            tooltipContainer.FadeOut(100);\n        }\n    }\n\n    public class OpaqueBackground : Container\n    {\n        public OpaqueBackground()\n        {\n            RelativeSizeAxes = Axes.Both;\n            Masking = true;\n            MaskingSmoothness = 0;\n            EdgeEffect = new EdgeEffectParameters\n            {\n                Type = EdgeEffectType.Shadow,\n                Colour = Color4.Black.Opacity(40),\n                Radius = 5,\n            };\n\n            Children = new Drawable[]\n            {\n                new Box\n                {\n                    RelativeSizeAxes = Axes.Both,\n                    Colour = OsuColour.Gray(30)\n                },\n                new Triangles\n                {\n                    RelativeSizeAxes = Axes.Both,\n                    ColourLight = OsuColour.Gray(40),\n                    ColourDark = OsuColour.Gray(20),\n                },\n            };\n        }\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"4fc77be62498ae4ae2d998cf38cc8b991a4d11b0","subject":"Fix incorrect sorting of hit objects into SpeedAdjustmentContainers","message":"Fix incorrect sorting of hit objects into SpeedAdjustmentContainers\n","repos":"smoogipoo\/osu,peppy\/osu,Drezi126\/osu,smoogipooo\/osu,naoey\/osu,UselessToucan\/osu,johnneijzen\/osu,peppy\/osu,ZLima12\/osu,2yangk23\/osu,ZLima12\/osu,NeoAdonis\/osu,DrabWeb\/osu,ppy\/osu,NeoAdonis\/osu,NeoAdonis\/osu,Damnae\/osu,UselessToucan\/osu,smoogipoo\/osu,Frontear\/osuKyzer,DrabWeb\/osu,EVAST9919\/osu,smoogipoo\/osu,Nabile-Rahmani\/osu,2yangk23\/osu,UselessToucan\/osu,johnneijzen\/osu,ppy\/osu,peppy\/osu,DrabWeb\/osu,ppy\/osu,EVAST9919\/osu,naoey\/osu,naoey\/osu,peppy\/osu-new","old_file":"osu.Game\/Rulesets\/UI\/ScrollingPlayfield.cs","new_file":"osu.Game\/Rulesets\/UI\/ScrollingPlayfield.cs","new_contents":"\/\/ Copyright (c) 2007-2017 ppy Pty Ltd <contact@ppy.sh>.\r\n\/\/ Licensed under the MIT Licence - https:\/\/raw.githubusercontent.com\/ppy\/osu\/master\/LICENCE\r\n\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing OpenTK.Input;\r\nusing osu.Framework.Configuration;\r\nusing osu.Framework.Graphics;\r\nusing osu.Framework.Graphics.Containers;\r\nusing osu.Framework.Graphics.Transforms;\r\nusing osu.Framework.Input;\r\nusing osu.Framework.MathUtils;\r\nusing osu.Game.Rulesets.Judgements;\r\nusing osu.Game.Rulesets.Objects;\r\nusing osu.Game.Rulesets.Objects.Drawables;\r\nusing osu.Game.Rulesets.Timing;\r\n\r\nnamespace osu.Game.Rulesets.UI\r\n{\r\n    \/\/\/ <summary>\r\n    \/\/\/ A type of <see cref=\"Playfield{TObject, TJudgement}\"\/> specialized towards scrolling <see cref=\"DrawableHitObject\"\/>s.\r\n    \/\/\/ <\/summary>\r\n    public class ScrollingPlayfield<TObject, TJudgement> : Playfield<TObject, TJudgement>\r\n        where TObject : HitObject\r\n        where TJudgement : Judgement\r\n    {\r\n        \/\/\/ <summary>\r\n        \/\/\/ The default span of time visible by the length of the scrolling axes.\r\n        \/\/\/ This is clamped between <see cref=\"time_span_min\"\/> and <see cref=\"time_span_max\"\/>.\r\n        \/\/\/ <\/summary>\r\n        private const double time_span_default = 1500;\r\n        \/\/\/ <summary>\r\n        \/\/\/ The minimum span of time that may be visible by the length of the scrolling axes.\r\n        \/\/\/ <\/summary>\r\n        private const double time_span_min = 50;\r\n        \/\/\/ <summary>\r\n        \/\/\/ The maximum span of time that may be visible by the length of the scrolling axes.\r\n        \/\/\/ <\/summary>\r\n        private const double time_span_max = 10000;\r\n        \/\/\/ <summary>\r\n        \/\/\/ The step increase\/decrease of the span of time visible by the length of the scrolling axes.\r\n        \/\/\/ <\/summary>\r\n        private const double time_span_step = 50;\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ The span of time that is visible by the length of the scrolling axes.\r\n        \/\/\/ For example, only hit objects with start time less than or equal to 1000 will be visible with <see cref=\"VisibleTimeRange\"\/> = 1000.\r\n        \/\/\/ <\/summary>\r\n        public readonly BindableDouble VisibleTimeRange = new BindableDouble(time_span_default)\r\n        {\r\n            Default = time_span_default,\r\n            MinValue = time_span_min,\r\n            MaxValue = time_span_max\r\n        };\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Whether to reverse the scrolling direction is reversed.\r\n        \/\/\/ <\/summary>\r\n        public readonly BindableBool Reversed = new BindableBool();\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ The container that contains the <see cref=\"SpeedAdjustmentContainer\"\/>s and <see cref=\"DrawableHitObject\"\/>s.\r\n        \/\/\/ <\/summary>\r\n        internal new readonly ScrollingHitObjectContainer HitObjects;\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Creates a new <see cref=\"ScrollingPlayfield{TObject, TJudgement}\"\/>.\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <param name=\"scrollingAxes\">The axes on which <see cref=\"DrawableHitObject\"\/>s in this container should scroll.<\/param>\r\n        \/\/\/ <param name=\"customWidth\">Whether we want our internal coordinate system to be scaled to a specified width<\/param>\r\n        protected ScrollingPlayfield(Axes scrollingAxes, float? customWidth = null)\r\n            : base(customWidth)\r\n        {\r\n            base.HitObjects = HitObjects = new ScrollingHitObjectContainer(scrollingAxes) { RelativeSizeAxes = Axes.Both };\r\n            HitObjects.VisibleTimeRange.BindTo(VisibleTimeRange);\r\n            HitObjects.Reversed.BindTo(Reversed);\r\n        }\r\n\r\n        private List<ScrollingPlayfield<TObject, TJudgement>> nestedPlayfields;\r\n        \/\/\/ <summary>\r\n        \/\/\/ All the <see cref=\"ScrollingPlayfield{TObject, TJudgement}\"\/>s nested inside this playfield.\r\n        \/\/\/ <\/summary>\r\n        public IEnumerable<ScrollingPlayfield<TObject, TJudgement>> NestedPlayfields => nestedPlayfields;\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Adds a <see cref=\"ScrollingPlayfield{TObject, TJudgement}\"\/> to this playfield. The nested <see cref=\"ScrollingPlayfield{TObject, TJudgement}\"\/>\r\n        \/\/\/ will be given all of the same speed adjustments as this playfield.\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <param name=\"otherPlayfield\">The <see cref=\"ScrollingPlayfield{TObject, TJudgement}\"\/> to add.<\/param>\r\n        protected void AddNested(ScrollingPlayfield<TObject, TJudgement> otherPlayfield)\r\n        {\r\n            if (nestedPlayfields == null)\r\n                nestedPlayfields = new List<ScrollingPlayfield<TObject, TJudgement>>();\r\n\r\n            nestedPlayfields.Add(otherPlayfield);\r\n        }\r\n\r\n        protected override bool OnKeyDown(InputState state, KeyDownEventArgs args)\r\n        {\r\n            if (state.Keyboard.ControlPressed)\r\n            {\r\n                switch (args.Key)\r\n                {\r\n                    case Key.Minus:\r\n                        transformVisibleTimeRangeTo(VisibleTimeRange + time_span_step, 200, Easing.OutQuint);\r\n                        break;\r\n                    case Key.Plus:\r\n                        transformVisibleTimeRangeTo(VisibleTimeRange - time_span_step, 200, Easing.OutQuint);\r\n                        break;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        private void transformVisibleTimeRangeTo(double newTimeRange, double duration = 0, Easing easing = Easing.None)\r\n        {\r\n            this.TransformTo(this.PopulateTransform(new TransformVisibleTimeRange(), newTimeRange, duration, easing));\r\n        }\r\n\r\n        private class TransformVisibleTimeRange : Transform<double, ScrollingPlayfield<TObject, TJudgement>>\r\n        {\r\n            private double valueAt(double time)\r\n            {\r\n                if (time < StartTime) return StartValue;\r\n                if (time >= EndTime) return EndValue;\r\n\r\n                return Interpolation.ValueAt(time, StartValue, EndValue, StartTime, EndTime, Easing);\r\n            }\r\n\r\n            public override string TargetMember => \"VisibleTimeRange.Value\";\r\n\r\n            protected override void Apply(ScrollingPlayfield<TObject, TJudgement> d, double time) => d.VisibleTimeRange.Value = valueAt(time);\r\n            protected override void ReadIntoStartValue(ScrollingPlayfield<TObject, TJudgement> d) => StartValue = d.VisibleTimeRange.Value;\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ A container that provides the foundation for sorting <see cref=\"DrawableHitObject\"\/>s into <see cref=\"SpeedAdjustmentContainer\"\/>s.\r\n        \/\/\/ <\/summary>\r\n        internal class ScrollingHitObjectContainer : HitObjectContainer\r\n        {\r\n            \/\/\/ <summary>\r\n            \/\/\/ Gets or sets the range of time that is visible by the length of the scrolling axes.\r\n            \/\/\/ For example, only hit objects with start time less than or equal to 1000 will be visible with <see cref=\"VisibleTimeRange\"\/> = 1000.\r\n            \/\/\/ <\/summary>\r\n            public readonly BindableDouble VisibleTimeRange = new BindableDouble { Default = 1000 };\r\n\r\n            \/\/\/ <summary>\r\n            \/\/\/ Whether to reverse the scrolling direction is reversed.\r\n            \/\/\/ <\/summary>\r\n            public readonly BindableBool Reversed = new BindableBool();\r\n\r\n            private readonly Container<SpeedAdjustmentContainer> speedAdjustments;\r\n\r\n            private readonly Axes scrollingAxes;\r\n\r\n            \/\/\/ <summary>\r\n            \/\/\/ Creates a new <see cref=\"ScrollingHitObjectContainer\"\/>.\r\n            \/\/\/ <\/summary>\r\n            \/\/\/ <param name=\"scrollingAxes\">The axes upon which hit objects should appear to scroll inside this container.<\/param>\r\n            public ScrollingHitObjectContainer(Axes scrollingAxes)\r\n            {\r\n                this.scrollingAxes = scrollingAxes;\r\n\r\n                AddInternal(speedAdjustments = new Container<SpeedAdjustmentContainer> { RelativeSizeAxes = Axes.Both });\r\n\r\n                \/\/ Default speed adjustment\r\n                AddSpeedAdjustment(new SpeedAdjustmentContainer(new MultiplierControlPoint(0)));\r\n            }\r\n\r\n            \/\/\/ <summary>\r\n            \/\/\/ Adds a <see cref=\"SpeedAdjustmentContainer\"\/> to this container.\r\n            \/\/\/ <\/summary>\r\n            \/\/\/ <param name=\"speedAdjustment\">The <see cref=\"SpeedAdjustmentContainer\"\/>.<\/param>\r\n            public void AddSpeedAdjustment(SpeedAdjustmentContainer speedAdjustment)\r\n            {\r\n                speedAdjustment.ScrollingAxes = scrollingAxes;\r\n                speedAdjustment.VisibleTimeRange.BindTo(VisibleTimeRange);\r\n                speedAdjustment.Reversed.BindTo(Reversed);\r\n                speedAdjustments.Add(speedAdjustment);\r\n\r\n                \/\/ We now need to re-sort the hit objects in the last speed adjustment prior to this one, to see if they need a new parent\r\n                var previousSpeedAdjustment = speedAdjustments.LastOrDefault(s => s.ControlPoint.StartTime <= speedAdjustment.ControlPoint.StartTime);\r\n                if (previousSpeedAdjustment == null)\r\n                    return;\r\n\r\n                for (int i = 0; i < previousSpeedAdjustment.Children.Count; i++)\r\n                {\r\n                    DrawableHitObject hitObject = previousSpeedAdjustment[i];\r\n\r\n                    var newSpeedAdjustment = adjustmentContainerFor(hitObject);\r\n                    if (newSpeedAdjustment == previousSpeedAdjustment)\r\n                        continue;\r\n\r\n                    previousSpeedAdjustment.Remove(hitObject);\r\n                    newSpeedAdjustment.Add(hitObject);\r\n\r\n                    i--;\r\n                }\r\n            }\r\n\r\n            public override IEnumerable<DrawableHitObject> Objects => speedAdjustments.SelectMany(s => s.Children);\r\n\r\n            \/\/\/ <summary>\r\n            \/\/\/ Adds a hit object to this <see cref=\"ScrollingHitObjectContainer\"\/>. The hit objects will be queued to be processed\r\n            \/\/\/ new <see cref=\"SpeedAdjustmentContainer\"\/>s are added to this <see cref=\"ScrollingHitObjectContainer\"\/>.\r\n            \/\/\/ <\/summary>\r\n            \/\/\/ <param name=\"hitObject\">The hit object to add.<\/param>\r\n            public override void Add(DrawableHitObject hitObject)\r\n            {\r\n                if (!(hitObject is IScrollingHitObject))\r\n                    throw new InvalidOperationException($\"Hit objects added to a {nameof(ScrollingHitObjectContainer)} must implement {nameof(IScrollingHitObject)}.\");\r\n\r\n                var target = adjustmentContainerFor(hitObject);\r\n                if (target == null)\r\n                    throw new InvalidOperationException($\"A {nameof(SpeedAdjustmentContainer)} to container {hitObject} could not be found.\");\r\n\r\n                target.Add(hitObject);\r\n            }\r\n\r\n            public override bool Remove(DrawableHitObject hitObject) => speedAdjustments.Any(s => s.Remove(hitObject));\r\n\r\n            \/\/\/ <summary>\r\n            \/\/\/ Finds the <see cref=\"SpeedAdjustmentContainer\"\/> which provides the speed adjustment active at the start time\r\n            \/\/\/ of a hit object. If there is no <see cref=\"SpeedAdjustmentContainer\"\/> active at the start time of the hit object,\r\n            \/\/\/ then the first (time-wise) speed adjustment is returned.\r\n            \/\/\/ <\/summary>\r\n            \/\/\/ <param name=\"hitObject\">The hit object to find the active <see cref=\"SpeedAdjustmentContainer\"\/> for.<\/param>\r\n            \/\/\/ <returns>The <see cref=\"SpeedAdjustmentContainer\"\/> active at <paramref name=\"hitObject\"\/>'s start time. Null if there are no speed adjustments.<\/returns>\r\n            private SpeedAdjustmentContainer adjustmentContainerFor(DrawableHitObject hitObject) => speedAdjustments.LastOrDefault(c => c.CanContain(hitObject)) ?? speedAdjustments.FirstOrDefault();\r\n\r\n            \/\/\/ <summary>\r\n            \/\/\/ Finds the <see cref=\"SpeedAdjustmentContainer\"\/> which provides the speed adjustment active at a time.\r\n            \/\/\/ If there is no <see cref=\"SpeedAdjustmentContainer\"\/> active at the time, then the first (time-wise) speed adjustment is returned.\r\n            \/\/\/ <\/summary>\r\n            \/\/\/ <param name=\"time\">The time to find the active <see cref=\"SpeedAdjustmentContainer\"\/> at.<\/param>\r\n            \/\/\/ <returns>The <see cref=\"SpeedAdjustmentContainer\"\/> active at <paramref name=\"time\"\/>. Null if there are no speed adjustments.<\/returns>\r\n            private SpeedAdjustmentContainer adjustmentContainerAt(double time) => speedAdjustments.LastOrDefault(c => c.CanContain(time)) ?? speedAdjustments.FirstOrDefault();\r\n        }\r\n    }\r\n}\r\n","old_contents":"\/\/ Copyright (c) 2007-2017 ppy Pty Ltd <contact@ppy.sh>.\r\n\/\/ Licensed under the MIT Licence - https:\/\/raw.githubusercontent.com\/ppy\/osu\/master\/LICENCE\r\n\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing OpenTK.Input;\r\nusing osu.Framework.Configuration;\r\nusing osu.Framework.Graphics;\r\nusing osu.Framework.Graphics.Containers;\r\nusing osu.Framework.Graphics.Transforms;\r\nusing osu.Framework.Input;\r\nusing osu.Framework.MathUtils;\r\nusing osu.Game.Rulesets.Judgements;\r\nusing osu.Game.Rulesets.Objects;\r\nusing osu.Game.Rulesets.Objects.Drawables;\r\nusing osu.Game.Rulesets.Timing;\r\n\r\nnamespace osu.Game.Rulesets.UI\r\n{\r\n    \/\/\/ <summary>\r\n    \/\/\/ A type of <see cref=\"Playfield{TObject, TJudgement}\"\/> specialized towards scrolling <see cref=\"DrawableHitObject\"\/>s.\r\n    \/\/\/ <\/summary>\r\n    public class ScrollingPlayfield<TObject, TJudgement> : Playfield<TObject, TJudgement>\r\n        where TObject : HitObject\r\n        where TJudgement : Judgement\r\n    {\r\n        \/\/\/ <summary>\r\n        \/\/\/ The default span of time visible by the length of the scrolling axes.\r\n        \/\/\/ This is clamped between <see cref=\"time_span_min\"\/> and <see cref=\"time_span_max\"\/>.\r\n        \/\/\/ <\/summary>\r\n        private const double time_span_default = 1500;\r\n        \/\/\/ <summary>\r\n        \/\/\/ The minimum span of time that may be visible by the length of the scrolling axes.\r\n        \/\/\/ <\/summary>\r\n        private const double time_span_min = 50;\r\n        \/\/\/ <summary>\r\n        \/\/\/ The maximum span of time that may be visible by the length of the scrolling axes.\r\n        \/\/\/ <\/summary>\r\n        private const double time_span_max = 10000;\r\n        \/\/\/ <summary>\r\n        \/\/\/ The step increase\/decrease of the span of time visible by the length of the scrolling axes.\r\n        \/\/\/ <\/summary>\r\n        private const double time_span_step = 50;\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ The span of time that is visible by the length of the scrolling axes.\r\n        \/\/\/ For example, only hit objects with start time less than or equal to 1000 will be visible with <see cref=\"VisibleTimeRange\"\/> = 1000.\r\n        \/\/\/ <\/summary>\r\n        public readonly BindableDouble VisibleTimeRange = new BindableDouble(time_span_default)\r\n        {\r\n            Default = time_span_default,\r\n            MinValue = time_span_min,\r\n            MaxValue = time_span_max\r\n        };\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Whether to reverse the scrolling direction is reversed.\r\n        \/\/\/ <\/summary>\r\n        public readonly BindableBool Reversed = new BindableBool();\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ The container that contains the <see cref=\"SpeedAdjustmentContainer\"\/>s and <see cref=\"DrawableHitObject\"\/>s.\r\n        \/\/\/ <\/summary>\r\n        internal new readonly ScrollingHitObjectContainer HitObjects;\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Creates a new <see cref=\"ScrollingPlayfield{TObject, TJudgement}\"\/>.\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <param name=\"scrollingAxes\">The axes on which <see cref=\"DrawableHitObject\"\/>s in this container should scroll.<\/param>\r\n        \/\/\/ <param name=\"customWidth\">Whether we want our internal coordinate system to be scaled to a specified width<\/param>\r\n        protected ScrollingPlayfield(Axes scrollingAxes, float? customWidth = null)\r\n            : base(customWidth)\r\n        {\r\n            base.HitObjects = HitObjects = new ScrollingHitObjectContainer(scrollingAxes) { RelativeSizeAxes = Axes.Both };\r\n            HitObjects.VisibleTimeRange.BindTo(VisibleTimeRange);\r\n            HitObjects.Reversed.BindTo(Reversed);\r\n        }\r\n\r\n        private List<ScrollingPlayfield<TObject, TJudgement>> nestedPlayfields;\r\n        \/\/\/ <summary>\r\n        \/\/\/ All the <see cref=\"ScrollingPlayfield{TObject, TJudgement}\"\/>s nested inside this playfield.\r\n        \/\/\/ <\/summary>\r\n        public IEnumerable<ScrollingPlayfield<TObject, TJudgement>> NestedPlayfields => nestedPlayfields;\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Adds a <see cref=\"ScrollingPlayfield{TObject, TJudgement}\"\/> to this playfield. The nested <see cref=\"ScrollingPlayfield{TObject, TJudgement}\"\/>\r\n        \/\/\/ will be given all of the same speed adjustments as this playfield.\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <param name=\"otherPlayfield\">The <see cref=\"ScrollingPlayfield{TObject, TJudgement}\"\/> to add.<\/param>\r\n        protected void AddNested(ScrollingPlayfield<TObject, TJudgement> otherPlayfield)\r\n        {\r\n            if (nestedPlayfields == null)\r\n                nestedPlayfields = new List<ScrollingPlayfield<TObject, TJudgement>>();\r\n\r\n            nestedPlayfields.Add(otherPlayfield);\r\n        }\r\n\r\n        protected override bool OnKeyDown(InputState state, KeyDownEventArgs args)\r\n        {\r\n            if (state.Keyboard.ControlPressed)\r\n            {\r\n                switch (args.Key)\r\n                {\r\n                    case Key.Minus:\r\n                        transformVisibleTimeRangeTo(VisibleTimeRange + time_span_step, 200, Easing.OutQuint);\r\n                        break;\r\n                    case Key.Plus:\r\n                        transformVisibleTimeRangeTo(VisibleTimeRange - time_span_step, 200, Easing.OutQuint);\r\n                        break;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        private void transformVisibleTimeRangeTo(double newTimeRange, double duration = 0, Easing easing = Easing.None)\r\n        {\r\n            this.TransformTo(this.PopulateTransform(new TransformVisibleTimeRange(), newTimeRange, duration, easing));\r\n        }\r\n\r\n        private class TransformVisibleTimeRange : Transform<double, ScrollingPlayfield<TObject, TJudgement>>\r\n        {\r\n            private double valueAt(double time)\r\n            {\r\n                if (time < StartTime) return StartValue;\r\n                if (time >= EndTime) return EndValue;\r\n\r\n                return Interpolation.ValueAt(time, StartValue, EndValue, StartTime, EndTime, Easing);\r\n            }\r\n\r\n            public override string TargetMember => \"VisibleTimeRange.Value\";\r\n\r\n            protected override void Apply(ScrollingPlayfield<TObject, TJudgement> d, double time) => d.VisibleTimeRange.Value = valueAt(time);\r\n            protected override void ReadIntoStartValue(ScrollingPlayfield<TObject, TJudgement> d) => StartValue = d.VisibleTimeRange.Value;\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ A container that provides the foundation for sorting <see cref=\"DrawableHitObject\"\/>s into <see cref=\"SpeedAdjustmentContainer\"\/>s.\r\n        \/\/\/ <\/summary>\r\n        internal class ScrollingHitObjectContainer : HitObjectContainer\r\n        {\r\n            \/\/\/ <summary>\r\n            \/\/\/ Gets or sets the range of time that is visible by the length of the scrolling axes.\r\n            \/\/\/ For example, only hit objects with start time less than or equal to 1000 will be visible with <see cref=\"VisibleTimeRange\"\/> = 1000.\r\n            \/\/\/ <\/summary>\r\n            public readonly BindableDouble VisibleTimeRange = new BindableDouble { Default = 1000 };\r\n\r\n            \/\/\/ <summary>\r\n            \/\/\/ Whether to reverse the scrolling direction is reversed.\r\n            \/\/\/ <\/summary>\r\n            public readonly BindableBool Reversed = new BindableBool();\r\n\r\n            private readonly Container<SpeedAdjustmentContainer> speedAdjustments;\r\n\r\n            private readonly Axes scrollingAxes;\r\n\r\n            \/\/\/ <summary>\r\n            \/\/\/ Creates a new <see cref=\"ScrollingHitObjectContainer\"\/>.\r\n            \/\/\/ <\/summary>\r\n            \/\/\/ <param name=\"scrollingAxes\">The axes upon which hit objects should appear to scroll inside this container.<\/param>\r\n            public ScrollingHitObjectContainer(Axes scrollingAxes)\r\n            {\r\n                this.scrollingAxes = scrollingAxes;\r\n\r\n                AddInternal(speedAdjustments = new Container<SpeedAdjustmentContainer> { RelativeSizeAxes = Axes.Both });\r\n\r\n                \/\/ Default speed adjustment\r\n                AddSpeedAdjustment(new SpeedAdjustmentContainer(new MultiplierControlPoint(0)));\r\n            }\r\n\r\n            \/\/\/ <summary>\r\n            \/\/\/ Adds a <see cref=\"SpeedAdjustmentContainer\"\/> to this container.\r\n            \/\/\/ <\/summary>\r\n            \/\/\/ <param name=\"speedAdjustment\">The <see cref=\"SpeedAdjustmentContainer\"\/>.<\/param>\r\n            public void AddSpeedAdjustment(SpeedAdjustmentContainer speedAdjustment)\r\n            {\r\n                speedAdjustment.ScrollingAxes = scrollingAxes;\r\n                speedAdjustment.VisibleTimeRange.BindTo(VisibleTimeRange);\r\n                speedAdjustment.Reversed.BindTo(Reversed);\r\n                speedAdjustments.Add(speedAdjustment);\r\n\r\n                \/\/ We now need to re-sort the hit objects in the last speed adjustment prior to this one, to see if they need a new parent\r\n                var previousSpeedAdjustment = speedAdjustments.LastOrDefault(s => s.ControlPoint.StartTime <= speedAdjustment.ControlPoint.StartTime);\r\n                if (previousSpeedAdjustment == null)\r\n                    return;\r\n\r\n                for (int i = 0; i < previousSpeedAdjustment.Children.Count; i++)\r\n                {\r\n                    DrawableHitObject hitObject = previousSpeedAdjustment[i];\r\n\r\n                    var newSpeedAdjustment = adjustmentContainerFor(hitObject);\r\n                    if (newSpeedAdjustment == previousSpeedAdjustment)\r\n                        continue;\r\n\r\n                    previousSpeedAdjustment.Remove(hitObject);\r\n                    newSpeedAdjustment.Add(hitObject);\r\n\r\n                    i--;\r\n                }\r\n            }\r\n\r\n            public override IEnumerable<DrawableHitObject> Objects => speedAdjustments.SelectMany(s => s.Children);\r\n\r\n            \/\/\/ <summary>\r\n            \/\/\/ Adds a hit object to this <see cref=\"ScrollingHitObjectContainer\"\/>. The hit objects will be queued to be processed\r\n            \/\/\/ new <see cref=\"SpeedAdjustmentContainer\"\/>s are added to this <see cref=\"ScrollingHitObjectContainer\"\/>.\r\n            \/\/\/ <\/summary>\r\n            \/\/\/ <param name=\"hitObject\">The hit object to add.<\/param>\r\n            public override void Add(DrawableHitObject hitObject)\r\n            {\r\n                if (!(hitObject is IScrollingHitObject))\r\n                    throw new InvalidOperationException($\"Hit objects added to a {nameof(ScrollingHitObjectContainer)} must implement {nameof(IScrollingHitObject)}.\");\r\n\r\n                var target = adjustmentContainerFor(hitObject);\r\n                if (target == null)\r\n                    throw new InvalidOperationException($\"A {nameof(SpeedAdjustmentContainer)} to container {hitObject} could not be found.\");\r\n\r\n                target.Add(hitObject);\r\n            }\r\n\r\n            public override bool Remove(DrawableHitObject hitObject) => speedAdjustments.Any(s => s.Remove(hitObject));\r\n\r\n            \/\/\/ <summary>\r\n            \/\/\/ Finds the <see cref=\"SpeedAdjustmentContainer\"\/> which provides the speed adjustment active at the start time\r\n            \/\/\/ of a hit object. If there is no <see cref=\"SpeedAdjustmentContainer\"\/> active at the start time of the hit object,\r\n            \/\/\/ then the first (time-wise) speed adjustment is returned.\r\n            \/\/\/ <\/summary>\r\n            \/\/\/ <param name=\"hitObject\">The hit object to find the active <see cref=\"SpeedAdjustmentContainer\"\/> for.<\/param>\r\n            \/\/\/ <returns>The <see cref=\"SpeedAdjustmentContainer\"\/> active at <paramref name=\"hitObject\"\/>'s start time. Null if there are no speed adjustments.<\/returns>\r\n            private SpeedAdjustmentContainer adjustmentContainerFor(DrawableHitObject hitObject) => speedAdjustments.FirstOrDefault(c => c.CanContain(hitObject)) ?? speedAdjustments.LastOrDefault();\r\n\r\n            \/\/\/ <summary>\r\n            \/\/\/ Finds the <see cref=\"SpeedAdjustmentContainer\"\/> which provides the speed adjustment active at a time.\r\n            \/\/\/ If there is no <see cref=\"SpeedAdjustmentContainer\"\/> active at the time, then the first (time-wise) speed adjustment is returned.\r\n            \/\/\/ <\/summary>\r\n            \/\/\/ <param name=\"time\">The time to find the active <see cref=\"SpeedAdjustmentContainer\"\/> at.<\/param>\r\n            \/\/\/ <returns>The <see cref=\"SpeedAdjustmentContainer\"\/> active at <paramref name=\"time\"\/>. Null if there are no speed adjustments.<\/returns>\r\n            private SpeedAdjustmentContainer adjustmentContainerAt(double time) => speedAdjustments.FirstOrDefault(c => c.CanContain(time)) ?? speedAdjustments.LastOrDefault();\r\n        }\r\n    }\r\n}\r\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"d7742766d054ca1d036985b6ca6c62ab946851c4","subject":"Add key\/press repeat support to carousel","message":"Add key\/press repeat support to carousel\n","repos":"peppy\/osu,smoogipoo\/osu,NeoAdonis\/osu,smoogipooo\/osu,peppy\/osu-new,UselessToucan\/osu,NeoAdonis\/osu,peppy\/osu,peppy\/osu,smoogipoo\/osu,ppy\/osu,ppy\/osu,ppy\/osu,NeoAdonis\/osu,UselessToucan\/osu,smoogipoo\/osu,UselessToucan\/osu","old_file":"osu.Game\/Screens\/Select\/BeatmapCarousel.cs","new_file":"osu.Game\/Screens\/Select\/BeatmapCarousel.cs","new_contents":"\ufeff\/\/ Copyright (c) ppy Pty Ltd <contact@ppy.sh>. Licensed under the MIT Licence.\n\/\/ See the LICENCE file in the repository root for full licence text.\n\nusing osuTK;\nusing osu.Framework.Graphics;\nusing osu.Framework.Graphics.Containers;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing osu.Game.Configuration;\nusing osuTK.Input;\nusing osu.Framework.Utils;\nusing System.Diagnostics;\nusing osu.Framework.Allocation;\nusing osu.Framework.Bindables;\nusing osu.Framework.Caching;\nusing osu.Framework.Threading;\nusing osu.Framework.Extensions.IEnumerableExtensions;\nusing osu.Framework.Input.Bindings;\nusing osu.Framework.Input.Events;\nusing osu.Game.Beatmaps;\nusing osu.Game.Graphics.Containers;\nusing osu.Game.Graphics.Cursor;\nusing osu.Game.Input.Bindings;\nusing osu.Game.Screens.Select.Carousel;\n\nnamespace osu.Game.Screens.Select\n{\n    public class BeatmapCarousel : CompositeDrawable, IKeyBindingHandler<GlobalAction>\n    {\n        \/\/\/ <summary>\n        \/\/\/ Height of the area above the carousel that should be treated as visible due to transparency of elements in front of it.\n        \/\/\/ <\/summary>\n        public float BleedTop { get; set; }\n\n        \/\/\/ <summary>\n        \/\/\/ Height of the area below the carousel that should be treated as visible due to transparency of elements in front of it.\n        \/\/\/ <\/summary>\n        public float BleedBottom { get; set; }\n\n        \/\/\/ <summary>\n        \/\/\/ Triggered when the <see cref=\"BeatmapSets\"\/> loaded change and are completely loaded.\n        \/\/\/ <\/summary>\n        public Action BeatmapSetsChanged;\n\n        \/\/\/ <summary>\n        \/\/\/ The currently selected beatmap.\n        \/\/\/ <\/summary>\n        public BeatmapInfo SelectedBeatmap => selectedBeatmap?.Beatmap;\n\n        private CarouselBeatmap selectedBeatmap => selectedBeatmapSet?.Beatmaps.FirstOrDefault(s => s.State.Value == CarouselItemState.Selected);\n\n        \/\/\/ <summary>\n        \/\/\/ The currently selected beatmap set.\n        \/\/\/ <\/summary>\n        public BeatmapSetInfo SelectedBeatmapSet => selectedBeatmapSet?.BeatmapSet;\n\n        \/\/\/ <summary>\n        \/\/\/ A function to optionally decide on a recommended difficulty from a beatmap set.\n        \/\/\/ <\/summary>\n        public Func<IEnumerable<BeatmapInfo>, BeatmapInfo> GetRecommendedBeatmap;\n\n        private CarouselBeatmapSet selectedBeatmapSet;\n\n        \/\/\/ <summary>\n        \/\/\/ Raised when the <see cref=\"SelectedBeatmap\"\/> is changed.\n        \/\/\/ <\/summary>\n        public Action<BeatmapInfo> SelectionChanged;\n\n        public override bool HandleNonPositionalInput => AllowSelection;\n        public override bool HandlePositionalInput => AllowSelection;\n\n        public override bool PropagatePositionalInputSubTree => AllowSelection;\n        public override bool PropagateNonPositionalInputSubTree => AllowSelection;\n\n        \/\/\/ <summary>\n        \/\/\/ Whether carousel items have completed asynchronously loaded.\n        \/\/\/ <\/summary>\n        public bool BeatmapSetsLoaded { get; private set; }\n\n        private readonly CarouselScrollContainer scroll;\n\n        private IEnumerable<CarouselBeatmapSet> beatmapSets => root.Children.OfType<CarouselBeatmapSet>();\n\n        \/\/ todo: only used for testing, maybe remove.\n        public IEnumerable<BeatmapSetInfo> BeatmapSets\n        {\n            get => beatmapSets.Select(g => g.BeatmapSet);\n            set => loadBeatmapSets(value);\n        }\n\n        private void loadBeatmapSets(IEnumerable<BeatmapSetInfo> beatmapSets)\n        {\n            CarouselRoot newRoot = new CarouselRoot(this);\n\n            beatmapSets.Select(createCarouselSet).Where(g => g != null).ForEach(newRoot.AddChild);\n            newRoot.Filter(activeCriteria);\n\n            \/\/ preload drawables as the ctor overhead is quite high currently.\n            _ = newRoot.Drawables;\n\n            root = newRoot;\n            if (selectedBeatmapSet != null && !beatmapSets.Contains(selectedBeatmapSet.BeatmapSet))\n                selectedBeatmapSet = null;\n\n            scrollableContent.Clear(false);\n            itemsCache.Invalidate();\n            scrollPositionCache.Invalidate();\n\n            \/\/ Run on late scheduler want to ensure this runs after all pending UpdateBeatmapSet \/ RemoveBeatmapSet operations are run.\n            SchedulerAfterChildren.Add(() =>\n            {\n                BeatmapSetsChanged?.Invoke();\n                BeatmapSetsLoaded = true;\n            });\n        }\n\n        private readonly List<float> yPositions = new List<float>();\n        private readonly Cached itemsCache = new Cached();\n        private readonly Cached scrollPositionCache = new Cached();\n\n        private readonly Container<DrawableCarouselItem> scrollableContent;\n\n        public Bindable<bool> RightClickScrollingEnabled = new Bindable<bool>();\n\n        public Bindable<RandomSelectAlgorithm> RandomAlgorithm = new Bindable<RandomSelectAlgorithm>();\n        private readonly List<CarouselBeatmapSet> previouslyVisitedRandomSets = new List<CarouselBeatmapSet>();\n        private readonly Stack<CarouselBeatmap> randomSelectedBeatmaps = new Stack<CarouselBeatmap>();\n\n        protected List<DrawableCarouselItem> Items = new List<DrawableCarouselItem>();\n\n        private CarouselRoot root;\n\n        private IBindable<WeakReference<BeatmapSetInfo>> itemUpdated;\n        private IBindable<WeakReference<BeatmapSetInfo>> itemRemoved;\n        private IBindable<WeakReference<BeatmapInfo>> itemHidden;\n        private IBindable<WeakReference<BeatmapInfo>> itemRestored;\n\n        public BeatmapCarousel()\n        {\n            root = new CarouselRoot(this);\n            InternalChild = new OsuContextMenuContainer\n            {\n                RelativeSizeAxes = Axes.Both,\n                Child = scroll = new CarouselScrollContainer\n                {\n                    Masking = false,\n                    RelativeSizeAxes = Axes.Both,\n                    Child = scrollableContent = new Container<DrawableCarouselItem>\n                    {\n                        RelativeSizeAxes = Axes.X,\n                    }\n                }\n            };\n        }\n\n        [Resolved]\n        private BeatmapManager beatmaps { get; set; }\n\n        [BackgroundDependencyLoader(permitNulls: true)]\n        private void load(OsuConfigManager config)\n        {\n            config.BindWith(OsuSetting.RandomSelectAlgorithm, RandomAlgorithm);\n            config.BindWith(OsuSetting.SongSelectRightMouseScroll, RightClickScrollingEnabled);\n\n            RightClickScrollingEnabled.ValueChanged += enabled => scroll.RightMouseScrollbar = enabled.NewValue;\n            RightClickScrollingEnabled.TriggerChange();\n\n            itemUpdated = beatmaps.ItemUpdated.GetBoundCopy();\n            itemUpdated.BindValueChanged(beatmapUpdated);\n            itemRemoved = beatmaps.ItemRemoved.GetBoundCopy();\n            itemRemoved.BindValueChanged(beatmapRemoved);\n            itemHidden = beatmaps.BeatmapHidden.GetBoundCopy();\n            itemHidden.BindValueChanged(beatmapHidden);\n            itemRestored = beatmaps.BeatmapRestored.GetBoundCopy();\n            itemRestored.BindValueChanged(beatmapRestored);\n\n            loadBeatmapSets(GetLoadableBeatmaps());\n        }\n\n        protected virtual IEnumerable<BeatmapSetInfo> GetLoadableBeatmaps() => beatmaps.GetAllUsableBeatmapSetsEnumerable(IncludedDetails.AllButFiles);\n\n        public void RemoveBeatmapSet(BeatmapSetInfo beatmapSet) => Schedule(() =>\n        {\n            var existingSet = beatmapSets.FirstOrDefault(b => b.BeatmapSet.ID == beatmapSet.ID);\n\n            if (existingSet == null)\n                return;\n\n            root.RemoveChild(existingSet);\n            itemsCache.Invalidate();\n        });\n\n        public void UpdateBeatmapSet(BeatmapSetInfo beatmapSet) => Schedule(() =>\n        {\n            int? previouslySelectedID = null;\n            CarouselBeatmapSet existingSet = beatmapSets.FirstOrDefault(b => b.BeatmapSet.ID == beatmapSet.ID);\n\n            \/\/ If the selected beatmap is about to be removed, store its ID so it can be re-selected if required\n            if (existingSet?.State?.Value == CarouselItemState.Selected)\n                previouslySelectedID = selectedBeatmap?.Beatmap.ID;\n\n            var newSet = createCarouselSet(beatmapSet);\n\n            if (existingSet != null)\n                root.RemoveChild(existingSet);\n\n            if (newSet == null)\n            {\n                itemsCache.Invalidate();\n                return;\n            }\n\n            root.AddChild(newSet);\n\n            \/\/ only reset scroll position if already near the scroll target.\n            \/\/ without this, during a large beatmap import it is impossible to navigate the carousel.\n            applyActiveCriteria(false, alwaysResetScrollPosition: false);\n\n            \/\/ check if we can\/need to maintain our current selection.\n            if (previouslySelectedID != null)\n                select((CarouselItem)newSet.Beatmaps.FirstOrDefault(b => b.Beatmap.ID == previouslySelectedID) ?? newSet);\n\n            itemsCache.Invalidate();\n            Schedule(() => BeatmapSetsChanged?.Invoke());\n        });\n\n        \/\/\/ <summary>\n        \/\/\/ Selects a given beatmap on the carousel.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"beatmap\">The beatmap to select.<\/param>\n        \/\/\/ <param name=\"bypassFilters\">Whether to select the beatmap even if it is filtered (i.e., not visible on carousel).<\/param>\n        \/\/\/ <returns>True if a selection was made, False if it wasn't.<\/returns>\n        public bool SelectBeatmap(BeatmapInfo beatmap, bool bypassFilters = true)\n        {\n            \/\/ ensure that any pending events from BeatmapManager have been run before attempting a selection.\n            Scheduler.Update();\n\n            if (beatmap?.Hidden != false)\n                return false;\n\n            foreach (CarouselBeatmapSet set in beatmapSets)\n            {\n                if (!bypassFilters && set.Filtered.Value)\n                    continue;\n\n                var item = set.Beatmaps.FirstOrDefault(p => p.Beatmap.Equals(beatmap));\n\n                if (item == null)\n                    \/\/ The beatmap that needs to be selected doesn't exist in this set\n                    continue;\n\n                if (!bypassFilters && item.Filtered.Value)\n                    return false;\n\n                select(item);\n\n                \/\/ if we got here and the set is filtered, it means we were bypassing filters.\n                \/\/ in this case, reapplying the filter is necessary to ensure the panel is in the correct place\n                \/\/ (since it is forcefully being included in the carousel).\n                if (set.Filtered.Value)\n                {\n                    Debug.Assert(bypassFilters);\n\n                    applyActiveCriteria(false);\n                }\n\n                return true;\n            }\n\n            return false;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Increment selection in the carousel in a chosen direction.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"direction\">The direction to increment. Negative is backwards.<\/param>\n        \/\/\/ <param name=\"skipDifficulties\">Whether to skip individual difficulties and only increment over full groups.<\/param>\n        public void SelectNext(int direction = 1, bool skipDifficulties = true)\n        {\n            if (beatmapSets.All(s => s.Filtered.Value))\n                return;\n\n            if (skipDifficulties)\n                selectNextSet(direction, true);\n            else\n                selectNextDifficulty(direction);\n        }\n\n        private void selectNextSet(int direction, bool skipDifficulties)\n        {\n            var unfilteredSets = beatmapSets.Where(s => !s.Filtered.Value).ToList();\n\n            var nextSet = unfilteredSets[(unfilteredSets.IndexOf(selectedBeatmapSet) + direction + unfilteredSets.Count) % unfilteredSets.Count];\n\n            if (skipDifficulties)\n                select(nextSet);\n            else\n                select(direction > 0 ? nextSet.Beatmaps.First(b => !b.Filtered.Value) : nextSet.Beatmaps.Last(b => !b.Filtered.Value));\n        }\n\n        private void selectNextDifficulty(int direction)\n        {\n            var unfilteredDifficulties = selectedBeatmapSet.Children.Where(s => !s.Filtered.Value).ToList();\n\n            int index = unfilteredDifficulties.IndexOf(selectedBeatmap);\n\n            if (index + direction < 0 || index + direction >= unfilteredDifficulties.Count)\n                selectNextSet(direction, false);\n            else\n                select(unfilteredDifficulties[index + direction]);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Select the next beatmap in the random sequence.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>True if a selection could be made, else False.<\/returns>\n        public bool SelectNextRandom()\n        {\n            var visibleSets = beatmapSets.Where(s => !s.Filtered.Value).ToList();\n            if (!visibleSets.Any())\n                return false;\n\n            if (selectedBeatmap != null)\n            {\n                randomSelectedBeatmaps.Push(selectedBeatmap);\n\n                \/\/ when performing a random, we want to add the current set to the previously visited list\n                \/\/ else the user may be \"randomised\" to the existing selection.\n                if (previouslyVisitedRandomSets.LastOrDefault() != selectedBeatmapSet)\n                    previouslyVisitedRandomSets.Add(selectedBeatmapSet);\n            }\n\n            CarouselBeatmapSet set;\n\n            if (RandomAlgorithm.Value == RandomSelectAlgorithm.RandomPermutation)\n            {\n                var notYetVisitedSets = visibleSets.Except(previouslyVisitedRandomSets).ToList();\n\n                if (!notYetVisitedSets.Any())\n                {\n                    previouslyVisitedRandomSets.RemoveAll(s => visibleSets.Contains(s));\n                    notYetVisitedSets = visibleSets;\n                }\n\n                set = notYetVisitedSets.ElementAt(RNG.Next(notYetVisitedSets.Count));\n                previouslyVisitedRandomSets.Add(set);\n            }\n            else\n                set = visibleSets.ElementAt(RNG.Next(visibleSets.Count));\n\n            select(set);\n            return true;\n        }\n\n        public void SelectPreviousRandom()\n        {\n            while (randomSelectedBeatmaps.Any())\n            {\n                var beatmap = randomSelectedBeatmaps.Pop();\n\n                if (!beatmap.Filtered.Value)\n                {\n                    if (RandomAlgorithm.Value == RandomSelectAlgorithm.RandomPermutation)\n                        previouslyVisitedRandomSets.Remove(selectedBeatmapSet);\n                    select(beatmap);\n                    break;\n                }\n            }\n        }\n\n        private void select(CarouselItem item)\n        {\n            if (!AllowSelection)\n                return;\n\n            if (item == null) return;\n\n            item.State.Value = CarouselItemState.Selected;\n        }\n\n        private FilterCriteria activeCriteria = new FilterCriteria();\n\n        protected ScheduledDelegate PendingFilter;\n\n        public bool AllowSelection = true;\n\n        \/\/\/ <summary>\n        \/\/\/ Half the height of the visible content.\n        \/\/\/ <remarks>\n        \/\/\/ This is different from the height of <see cref=\"ScrollContainer{T}\"\/>.displayableContent, since\n        \/\/\/ the beatmap carousel bleeds into the <see cref=\"FilterControl\"\/> and the <see cref=\"Footer\"\/>\n        \/\/\/ <\/remarks>\n        \/\/\/ <\/summary>\n        private float visibleHalfHeight => (DrawHeight + BleedBottom + BleedTop) \/ 2;\n\n        \/\/\/ <summary>\n        \/\/\/ The position of the lower visible bound with respect to the current scroll position.\n        \/\/\/ <\/summary>\n        private float visibleBottomBound => scroll.Current + DrawHeight + BleedBottom;\n\n        \/\/\/ <summary>\n        \/\/\/ The position of the upper visible bound with respect to the current scroll position.\n        \/\/\/ <\/summary>\n        private float visibleUpperBound => scroll.Current - BleedTop;\n\n        public void FlushPendingFilterOperations()\n        {\n            if (PendingFilter?.Completed == false)\n            {\n                applyActiveCriteria(false);\n                Update();\n            }\n        }\n\n        public void Filter(FilterCriteria newCriteria, bool debounce = true)\n        {\n            if (newCriteria != null)\n                activeCriteria = newCriteria;\n\n            applyActiveCriteria(debounce);\n        }\n\n        private void applyActiveCriteria(bool debounce, bool alwaysResetScrollPosition = true)\n        {\n            if (root.Children.Any() != true) return;\n\n            void perform()\n            {\n                PendingFilter = null;\n\n                root.Filter(activeCriteria);\n                itemsCache.Invalidate();\n\n                if (alwaysResetScrollPosition || !scroll.UserScrolling)\n                    ScrollToSelected();\n            }\n\n            PendingFilter?.Cancel();\n            PendingFilter = null;\n\n            if (debounce)\n                PendingFilter = Scheduler.AddDelayed(perform, 250);\n            else\n                perform();\n        }\n\n        private float? scrollTarget;\n\n        \/\/\/ <summary>\n        \/\/\/ Scroll to the current <see cref=\"SelectedBeatmap\"\/>.\n        \/\/\/ <\/summary>\n        public void ScrollToSelected() => scrollPositionCache.Invalidate();\n\n        #region Key \/ button selection logic\n\n        protected override bool OnKeyDown(KeyDownEvent e)\n        {\n            switch (e.Key)\n            {\n                case Key.Left:\n                    if (!e.Repeat)\n                        beginRepeatSelection(() => SelectNext(-1, true), e.Key);\n                    return true;\n\n                case Key.Right:\n                    if (!e.Repeat)\n                        beginRepeatSelection(() => SelectNext(1, true), e.Key);\n                    return true;\n            }\n\n            return false;\n        }\n\n        protected override void OnKeyUp(KeyUpEvent e)\n        {\n            switch (e.Key)\n            {\n                case Key.Left:\n                case Key.Right:\n                    endRepeatSelection(e.Key);\n                    break;\n            }\n\n            base.OnKeyUp(e);\n        }\n\n        public bool OnPressed(GlobalAction action)\n        {\n            switch (action)\n            {\n                case GlobalAction.SelectNext:\n                    beginRepeatSelection(() => SelectNext(1, false), action);\n                    return true;\n\n                case GlobalAction.SelectPrevious:\n                    beginRepeatSelection(() => SelectNext(-1, false), action);\n                    return true;\n            }\n\n            return false;\n        }\n\n        public void OnReleased(GlobalAction action)\n        {\n            switch (action)\n            {\n                case GlobalAction.SelectNext:\n                case GlobalAction.SelectPrevious:\n                    endRepeatSelection(action);\n                    break;\n            }\n        }\n\n        private const double repeat_interval = 120;\n\n        private ScheduledDelegate repeatDelegate;\n        private object lastRepeatSource;\n\n        \/\/\/ <summary>\n        \/\/\/ Begin repeating the specified selection action.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"action\">The action to perform.<\/param>\n        \/\/\/ <param name=\"source\">The source of the action. Used in conjunction with <see cref=\"endRepeatSelection\"\/> to only cancel the correct action (most recently pressed key).<\/param>\n        private void beginRepeatSelection(Action action, object source)\n        {\n            endRepeatSelection();\n\n            lastRepeatSource = source;\n            Scheduler.Add(repeatDelegate = new ScheduledDelegate(action, Time.Current, repeat_interval));\n        }\n\n        private void endRepeatSelection(object source = null)\n        {\n            \/\/ only the most recent source should be able to cancel the current action.\n            if (source != null && !EqualityComparer<object>.Default.Equals(lastRepeatSource, source))\n                return;\n\n            repeatDelegate?.Cancel();\n            repeatDelegate = null;\n            lastRepeatSource = null;\n        }\n\n        #endregion\n\n        protected override void Update()\n        {\n            base.Update();\n\n            if (!itemsCache.IsValid)\n                updateItems();\n\n            \/\/ Remove all items that should no longer be on-screen\n            scrollableContent.RemoveAll(p => p.Y < visibleUpperBound - p.DrawHeight || p.Y > visibleBottomBound || !p.IsPresent);\n\n            \/\/ Find index range of all items that should be on-screen\n            Trace.Assert(Items.Count == yPositions.Count);\n\n            int firstIndex = yPositions.BinarySearch(visibleUpperBound - DrawableCarouselItem.MAX_HEIGHT);\n            if (firstIndex < 0) firstIndex = ~firstIndex;\n            int lastIndex = yPositions.BinarySearch(visibleBottomBound);\n            if (lastIndex < 0) lastIndex = ~lastIndex;\n\n            int notVisibleCount = 0;\n\n            \/\/ Add those items within the previously found index range that should be displayed.\n            for (int i = firstIndex; i < lastIndex; ++i)\n            {\n                DrawableCarouselItem item = Items[i];\n\n                if (!item.Item.Visible)\n                {\n                    if (!item.IsPresent)\n                        notVisibleCount++;\n                    continue;\n                }\n\n                float depth = i + (item is DrawableCarouselBeatmapSet ? -Items.Count : 0);\n\n                \/\/ Only add if we're not already part of the content.\n                if (!scrollableContent.Contains(item))\n                {\n                    \/\/ Makes sure headers are always _below_ items,\n                    \/\/ and depth flows downward.\n                    item.Depth = depth;\n\n                    switch (item.LoadState)\n                    {\n                        case LoadState.NotLoaded:\n                            LoadComponentAsync(item);\n                            break;\n\n                        case LoadState.Loading:\n                            break;\n\n                        default:\n                            scrollableContent.Add(item);\n                            break;\n                    }\n                }\n                else\n                {\n                    scrollableContent.ChangeChildDepth(item, depth);\n                }\n            }\n\n            \/\/ this is not actually useful right now, but once we have groups may well be.\n            if (notVisibleCount > 50)\n                itemsCache.Invalidate();\n\n            \/\/ Update externally controlled state of currently visible items\n            \/\/ (e.g. x-offset and opacity).\n            foreach (DrawableCarouselItem p in scrollableContent.Children)\n                updateItem(p);\n        }\n\n        protected override void UpdateAfterChildren()\n        {\n            base.UpdateAfterChildren();\n\n            if (!scrollPositionCache.IsValid)\n                updateScrollPosition();\n        }\n\n        protected override void Dispose(bool isDisposing)\n        {\n            base.Dispose(isDisposing);\n\n            \/\/ aggressively dispose \"off-screen\" items to reduce GC pressure.\n            foreach (var i in Items)\n                i.Dispose();\n        }\n\n        private void beatmapRemoved(ValueChangedEvent<WeakReference<BeatmapSetInfo>> weakItem)\n        {\n            if (weakItem.NewValue.TryGetTarget(out var item))\n                RemoveBeatmapSet(item);\n        }\n\n        private void beatmapUpdated(ValueChangedEvent<WeakReference<BeatmapSetInfo>> weakItem)\n        {\n            if (weakItem.NewValue.TryGetTarget(out var item))\n                UpdateBeatmapSet(item);\n        }\n\n        private void beatmapRestored(ValueChangedEvent<WeakReference<BeatmapInfo>> weakItem)\n        {\n            if (weakItem.NewValue.TryGetTarget(out var b))\n                UpdateBeatmapSet(beatmaps.QueryBeatmapSet(s => s.ID == b.BeatmapSetInfoID));\n        }\n\n        private void beatmapHidden(ValueChangedEvent<WeakReference<BeatmapInfo>> weakItem)\n        {\n            if (weakItem.NewValue.TryGetTarget(out var b))\n                UpdateBeatmapSet(beatmaps.QueryBeatmapSet(s => s.ID == b.BeatmapSetInfoID));\n        }\n\n        private CarouselBeatmapSet createCarouselSet(BeatmapSetInfo beatmapSet)\n        {\n            if (beatmapSet.Beatmaps.All(b => b.Hidden))\n                return null;\n\n            \/\/ todo: remove the need for this.\n            foreach (var b in beatmapSet.Beatmaps)\n                b.Metadata ??= beatmapSet.Metadata;\n\n            var set = new CarouselBeatmapSet(beatmapSet)\n            {\n                GetRecommendedBeatmap = beatmaps => GetRecommendedBeatmap?.Invoke(beatmaps)\n            };\n\n            foreach (var c in set.Beatmaps)\n            {\n                c.State.ValueChanged += state =>\n                {\n                    if (state.NewValue == CarouselItemState.Selected)\n                    {\n                        selectedBeatmapSet = set;\n                        SelectionChanged?.Invoke(c.Beatmap);\n\n                        itemsCache.Invalidate();\n                        ScrollToSelected();\n                    }\n                };\n            }\n\n            return set;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Computes the target Y positions for every item in the carousel.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The Y position of the currently selected item.<\/returns>\n        private void updateItems()\n        {\n            Items = root.Drawables.ToList();\n\n            yPositions.Clear();\n\n            float currentY = visibleHalfHeight;\n            DrawableCarouselBeatmapSet lastSet = null;\n\n            scrollTarget = null;\n\n            foreach (DrawableCarouselItem d in Items)\n            {\n                if (d.IsPresent)\n                {\n                    switch (d)\n                    {\n                        case DrawableCarouselBeatmapSet set:\n                        {\n                            lastSet = set;\n\n                            set.MoveToX(set.Item.State.Value == CarouselItemState.Selected ? -100 : 0, 500, Easing.OutExpo);\n                            set.MoveToY(currentY, 750, Easing.OutExpo);\n                            break;\n                        }\n\n                        case DrawableCarouselBeatmap beatmap:\n                        {\n                            if (beatmap.Item.State.Value == CarouselItemState.Selected)\n                                \/\/ scroll position at currentY makes the set panel appear at the very top of the carousel's screen space\n                                \/\/ move down by half of visible height (height of the carousel's visible extent, including semi-transparent areas)\n                                \/\/ then reapply the top semi-transparent area (because carousel's screen space starts below it)\n                                \/\/ and finally add half of the panel's own height to achieve vertical centering of the panel itself\n                                scrollTarget = currentY - visibleHalfHeight + BleedTop + beatmap.DrawHeight \/ 2;\n\n                            void performMove(float y, float? startY = null)\n                            {\n                                if (startY != null) beatmap.MoveTo(new Vector2(0, startY.Value));\n                                beatmap.MoveToX(beatmap.Item.State.Value == CarouselItemState.Selected ? -50 : 0, 500, Easing.OutExpo);\n                                beatmap.MoveToY(y, 750, Easing.OutExpo);\n                            }\n\n                            Debug.Assert(lastSet != null);\n\n                            float? setY = null;\n                            if (!d.IsLoaded || beatmap.Alpha == 0) \/\/ can't use IsPresent due to DrawableCarouselItem override.\n                                setY = lastSet.Y + lastSet.DrawHeight + 5;\n\n                            if (d.IsLoaded)\n                                performMove(currentY, setY);\n                            else\n                            {\n                                float y = currentY;\n                                d.OnLoadComplete += _ => performMove(y, setY);\n                            }\n\n                            break;\n                        }\n                    }\n                }\n\n                yPositions.Add(currentY);\n\n                if (d.Item.Visible)\n                    currentY += d.DrawHeight + 5;\n            }\n\n            currentY += visibleHalfHeight;\n            scrollableContent.Height = currentY;\n\n            if (BeatmapSetsLoaded && (selectedBeatmapSet == null || selectedBeatmap == null || selectedBeatmapSet.State.Value != CarouselItemState.Selected))\n            {\n                selectedBeatmapSet = null;\n                SelectionChanged?.Invoke(null);\n            }\n\n            itemsCache.Validate();\n        }\n\n        private bool firstScroll = true;\n\n        private void updateScrollPosition()\n        {\n            if (scrollTarget != null)\n            {\n                if (firstScroll)\n                {\n                    \/\/ reduce movement when first displaying the carousel.\n                    scroll.ScrollTo(scrollTarget.Value - 200, false);\n                    firstScroll = false;\n                }\n\n                scroll.ScrollTo(scrollTarget.Value);\n                scrollPositionCache.Validate();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Computes the x-offset of currently visible items. Makes the carousel appear round.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"dist\">\n        \/\/\/ Vertical distance from the center of the carousel container\n        \/\/\/ ranging from -1 to 1.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"halfHeight\">Half the height of the carousel container.<\/param>\n        private static float offsetX(float dist, float halfHeight)\n        {\n            \/\/ The radius of the circle the carousel moves on.\n            const float circle_radius = 3;\n            float discriminant = MathF.Max(0, circle_radius * circle_radius - dist * dist);\n            float x = (circle_radius - MathF.Sqrt(discriminant)) * halfHeight;\n\n            return 125 + x;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Update a item's x position and multiplicative alpha based on its y position and\n        \/\/\/ the current scroll position.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"p\">The item to be updated.<\/param>\n        private void updateItem(DrawableCarouselItem p)\n        {\n            float itemDrawY = p.Position.Y - visibleUpperBound + p.DrawHeight \/ 2;\n            float dist = Math.Abs(1f - itemDrawY \/ visibleHalfHeight);\n\n            \/\/ Setting the origin position serves as an additive position on top of potential\n            \/\/ local transformation we may want to apply (e.g. when a item gets selected, we\n            \/\/ may want to smoothly transform it leftwards.)\n            p.OriginPosition = new Vector2(-offsetX(dist, visibleHalfHeight), 0);\n\n            \/\/ We are applying a multiplicative alpha (which is internally done by nesting an\n            \/\/ additional container and setting that container's alpha) such that we can\n            \/\/ layer transformations on top, with a similar reasoning to the previous comment.\n            p.SetMultiplicativeAlpha(Math.Clamp(1.75f - 1.5f * dist, 0, 1));\n        }\n\n        private class CarouselRoot : CarouselGroupEagerSelect\n        {\n            private readonly BeatmapCarousel carousel;\n\n            public CarouselRoot(BeatmapCarousel carousel)\n            {\n                \/\/ root should always remain selected. if not, PerformSelection will not be called.\n                State.Value = CarouselItemState.Selected;\n                State.ValueChanged += state => State.Value = CarouselItemState.Selected;\n\n                this.carousel = carousel;\n            }\n\n            protected override void PerformSelection()\n            {\n                if (LastSelected == null || LastSelected.Filtered.Value)\n                    carousel?.SelectNextRandom();\n                else\n                    base.PerformSelection();\n            }\n        }\n\n        private class CarouselScrollContainer : OsuScrollContainer\n        {\n            private bool rightMouseScrollBlocked;\n\n            \/\/\/ <summary>\n            \/\/\/ Whether the last scroll event was user triggered, directly on the scroll container.\n            \/\/\/ <\/summary>\n            public bool UserScrolling { get; private set; }\n\n            protected override void OnUserScroll(float value, bool animated = true, double? distanceDecay = default)\n            {\n                UserScrolling = true;\n                base.OnUserScroll(value, animated, distanceDecay);\n            }\n\n            public new void ScrollTo(float value, bool animated = true, double? distanceDecay = null)\n            {\n                UserScrolling = false;\n                base.ScrollTo(value, animated, distanceDecay);\n            }\n\n            protected override bool OnMouseDown(MouseDownEvent e)\n            {\n                if (e.Button == MouseButton.Right)\n                {\n                    \/\/ we need to block right click absolute scrolling when hovering a carousel item so context menus can display.\n                    \/\/ this can be reconsidered when we have an alternative to right click scrolling.\n                    if (GetContainingInputManager().HoveredDrawables.OfType<DrawableCarouselItem>().Any())\n                    {\n                        rightMouseScrollBlocked = true;\n                        return false;\n                    }\n                }\n\n                rightMouseScrollBlocked = false;\n                return base.OnMouseDown(e);\n            }\n\n            protected override bool OnDragStart(DragStartEvent e)\n            {\n                if (rightMouseScrollBlocked)\n                    return false;\n\n                return base.OnDragStart(e);\n            }\n        }\n    }\n}\n","old_contents":"\ufeff\/\/ Copyright (c) ppy Pty Ltd <contact@ppy.sh>. Licensed under the MIT Licence.\n\/\/ See the LICENCE file in the repository root for full licence text.\n\nusing osuTK;\nusing osu.Framework.Graphics;\nusing osu.Framework.Graphics.Containers;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing osu.Game.Configuration;\nusing osuTK.Input;\nusing osu.Framework.Utils;\nusing System.Diagnostics;\nusing osu.Framework.Allocation;\nusing osu.Framework.Bindables;\nusing osu.Framework.Caching;\nusing osu.Framework.Threading;\nusing osu.Framework.Extensions.IEnumerableExtensions;\nusing osu.Framework.Input.Bindings;\nusing osu.Framework.Input.Events;\nusing osu.Game.Beatmaps;\nusing osu.Game.Graphics.Containers;\nusing osu.Game.Graphics.Cursor;\nusing osu.Game.Input.Bindings;\nusing osu.Game.Screens.Select.Carousel;\n\nnamespace osu.Game.Screens.Select\n{\n    public class BeatmapCarousel : CompositeDrawable, IKeyBindingHandler<GlobalAction>\n    {\n        \/\/\/ <summary>\n        \/\/\/ Height of the area above the carousel that should be treated as visible due to transparency of elements in front of it.\n        \/\/\/ <\/summary>\n        public float BleedTop { get; set; }\n\n        \/\/\/ <summary>\n        \/\/\/ Height of the area below the carousel that should be treated as visible due to transparency of elements in front of it.\n        \/\/\/ <\/summary>\n        public float BleedBottom { get; set; }\n\n        \/\/\/ <summary>\n        \/\/\/ Triggered when the <see cref=\"BeatmapSets\"\/> loaded change and are completely loaded.\n        \/\/\/ <\/summary>\n        public Action BeatmapSetsChanged;\n\n        \/\/\/ <summary>\n        \/\/\/ The currently selected beatmap.\n        \/\/\/ <\/summary>\n        public BeatmapInfo SelectedBeatmap => selectedBeatmap?.Beatmap;\n\n        private CarouselBeatmap selectedBeatmap => selectedBeatmapSet?.Beatmaps.FirstOrDefault(s => s.State.Value == CarouselItemState.Selected);\n\n        \/\/\/ <summary>\n        \/\/\/ The currently selected beatmap set.\n        \/\/\/ <\/summary>\n        public BeatmapSetInfo SelectedBeatmapSet => selectedBeatmapSet?.BeatmapSet;\n\n        \/\/\/ <summary>\n        \/\/\/ A function to optionally decide on a recommended difficulty from a beatmap set.\n        \/\/\/ <\/summary>\n        public Func<IEnumerable<BeatmapInfo>, BeatmapInfo> GetRecommendedBeatmap;\n\n        private CarouselBeatmapSet selectedBeatmapSet;\n\n        \/\/\/ <summary>\n        \/\/\/ Raised when the <see cref=\"SelectedBeatmap\"\/> is changed.\n        \/\/\/ <\/summary>\n        public Action<BeatmapInfo> SelectionChanged;\n\n        public override bool HandleNonPositionalInput => AllowSelection;\n        public override bool HandlePositionalInput => AllowSelection;\n\n        public override bool PropagatePositionalInputSubTree => AllowSelection;\n        public override bool PropagateNonPositionalInputSubTree => AllowSelection;\n\n        \/\/\/ <summary>\n        \/\/\/ Whether carousel items have completed asynchronously loaded.\n        \/\/\/ <\/summary>\n        public bool BeatmapSetsLoaded { get; private set; }\n\n        private readonly CarouselScrollContainer scroll;\n\n        private IEnumerable<CarouselBeatmapSet> beatmapSets => root.Children.OfType<CarouselBeatmapSet>();\n\n        \/\/ todo: only used for testing, maybe remove.\n        public IEnumerable<BeatmapSetInfo> BeatmapSets\n        {\n            get => beatmapSets.Select(g => g.BeatmapSet);\n            set => loadBeatmapSets(value);\n        }\n\n        private void loadBeatmapSets(IEnumerable<BeatmapSetInfo> beatmapSets)\n        {\n            CarouselRoot newRoot = new CarouselRoot(this);\n\n            beatmapSets.Select(createCarouselSet).Where(g => g != null).ForEach(newRoot.AddChild);\n            newRoot.Filter(activeCriteria);\n\n            \/\/ preload drawables as the ctor overhead is quite high currently.\n            _ = newRoot.Drawables;\n\n            root = newRoot;\n            if (selectedBeatmapSet != null && !beatmapSets.Contains(selectedBeatmapSet.BeatmapSet))\n                selectedBeatmapSet = null;\n\n            scrollableContent.Clear(false);\n            itemsCache.Invalidate();\n            scrollPositionCache.Invalidate();\n\n            \/\/ Run on late scheduler want to ensure this runs after all pending UpdateBeatmapSet \/ RemoveBeatmapSet operations are run.\n            SchedulerAfterChildren.Add(() =>\n            {\n                BeatmapSetsChanged?.Invoke();\n                BeatmapSetsLoaded = true;\n            });\n        }\n\n        private readonly List<float> yPositions = new List<float>();\n        private readonly Cached itemsCache = new Cached();\n        private readonly Cached scrollPositionCache = new Cached();\n\n        private readonly Container<DrawableCarouselItem> scrollableContent;\n\n        public Bindable<bool> RightClickScrollingEnabled = new Bindable<bool>();\n\n        public Bindable<RandomSelectAlgorithm> RandomAlgorithm = new Bindable<RandomSelectAlgorithm>();\n        private readonly List<CarouselBeatmapSet> previouslyVisitedRandomSets = new List<CarouselBeatmapSet>();\n        private readonly Stack<CarouselBeatmap> randomSelectedBeatmaps = new Stack<CarouselBeatmap>();\n\n        protected List<DrawableCarouselItem> Items = new List<DrawableCarouselItem>();\n\n        private CarouselRoot root;\n\n        private IBindable<WeakReference<BeatmapSetInfo>> itemUpdated;\n        private IBindable<WeakReference<BeatmapSetInfo>> itemRemoved;\n        private IBindable<WeakReference<BeatmapInfo>> itemHidden;\n        private IBindable<WeakReference<BeatmapInfo>> itemRestored;\n\n        public BeatmapCarousel()\n        {\n            root = new CarouselRoot(this);\n            InternalChild = new OsuContextMenuContainer\n            {\n                RelativeSizeAxes = Axes.Both,\n                Child = scroll = new CarouselScrollContainer\n                {\n                    Masking = false,\n                    RelativeSizeAxes = Axes.Both,\n                    Child = scrollableContent = new Container<DrawableCarouselItem>\n                    {\n                        RelativeSizeAxes = Axes.X,\n                    }\n                }\n            };\n        }\n\n        [Resolved]\n        private BeatmapManager beatmaps { get; set; }\n\n        [BackgroundDependencyLoader(permitNulls: true)]\n        private void load(OsuConfigManager config)\n        {\n            config.BindWith(OsuSetting.RandomSelectAlgorithm, RandomAlgorithm);\n            config.BindWith(OsuSetting.SongSelectRightMouseScroll, RightClickScrollingEnabled);\n\n            RightClickScrollingEnabled.ValueChanged += enabled => scroll.RightMouseScrollbar = enabled.NewValue;\n            RightClickScrollingEnabled.TriggerChange();\n\n            itemUpdated = beatmaps.ItemUpdated.GetBoundCopy();\n            itemUpdated.BindValueChanged(beatmapUpdated);\n            itemRemoved = beatmaps.ItemRemoved.GetBoundCopy();\n            itemRemoved.BindValueChanged(beatmapRemoved);\n            itemHidden = beatmaps.BeatmapHidden.GetBoundCopy();\n            itemHidden.BindValueChanged(beatmapHidden);\n            itemRestored = beatmaps.BeatmapRestored.GetBoundCopy();\n            itemRestored.BindValueChanged(beatmapRestored);\n\n            loadBeatmapSets(GetLoadableBeatmaps());\n        }\n\n        protected virtual IEnumerable<BeatmapSetInfo> GetLoadableBeatmaps() => beatmaps.GetAllUsableBeatmapSetsEnumerable(IncludedDetails.AllButFiles);\n\n        public void RemoveBeatmapSet(BeatmapSetInfo beatmapSet) => Schedule(() =>\n        {\n            var existingSet = beatmapSets.FirstOrDefault(b => b.BeatmapSet.ID == beatmapSet.ID);\n\n            if (existingSet == null)\n                return;\n\n            root.RemoveChild(existingSet);\n            itemsCache.Invalidate();\n        });\n\n        public void UpdateBeatmapSet(BeatmapSetInfo beatmapSet) => Schedule(() =>\n        {\n            int? previouslySelectedID = null;\n            CarouselBeatmapSet existingSet = beatmapSets.FirstOrDefault(b => b.BeatmapSet.ID == beatmapSet.ID);\n\n            \/\/ If the selected beatmap is about to be removed, store its ID so it can be re-selected if required\n            if (existingSet?.State?.Value == CarouselItemState.Selected)\n                previouslySelectedID = selectedBeatmap?.Beatmap.ID;\n\n            var newSet = createCarouselSet(beatmapSet);\n\n            if (existingSet != null)\n                root.RemoveChild(existingSet);\n\n            if (newSet == null)\n            {\n                itemsCache.Invalidate();\n                return;\n            }\n\n            root.AddChild(newSet);\n\n            \/\/ only reset scroll position if already near the scroll target.\n            \/\/ without this, during a large beatmap import it is impossible to navigate the carousel.\n            applyActiveCriteria(false, alwaysResetScrollPosition: false);\n\n            \/\/ check if we can\/need to maintain our current selection.\n            if (previouslySelectedID != null)\n                select((CarouselItem)newSet.Beatmaps.FirstOrDefault(b => b.Beatmap.ID == previouslySelectedID) ?? newSet);\n\n            itemsCache.Invalidate();\n            Schedule(() => BeatmapSetsChanged?.Invoke());\n        });\n\n        \/\/\/ <summary>\n        \/\/\/ Selects a given beatmap on the carousel.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"beatmap\">The beatmap to select.<\/param>\n        \/\/\/ <param name=\"bypassFilters\">Whether to select the beatmap even if it is filtered (i.e., not visible on carousel).<\/param>\n        \/\/\/ <returns>True if a selection was made, False if it wasn't.<\/returns>\n        public bool SelectBeatmap(BeatmapInfo beatmap, bool bypassFilters = true)\n        {\n            \/\/ ensure that any pending events from BeatmapManager have been run before attempting a selection.\n            Scheduler.Update();\n\n            if (beatmap?.Hidden != false)\n                return false;\n\n            foreach (CarouselBeatmapSet set in beatmapSets)\n            {\n                if (!bypassFilters && set.Filtered.Value)\n                    continue;\n\n                var item = set.Beatmaps.FirstOrDefault(p => p.Beatmap.Equals(beatmap));\n\n                if (item == null)\n                    \/\/ The beatmap that needs to be selected doesn't exist in this set\n                    continue;\n\n                if (!bypassFilters && item.Filtered.Value)\n                    return false;\n\n                select(item);\n\n                \/\/ if we got here and the set is filtered, it means we were bypassing filters.\n                \/\/ in this case, reapplying the filter is necessary to ensure the panel is in the correct place\n                \/\/ (since it is forcefully being included in the carousel).\n                if (set.Filtered.Value)\n                {\n                    Debug.Assert(bypassFilters);\n\n                    applyActiveCriteria(false);\n                }\n\n                return true;\n            }\n\n            return false;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Increment selection in the carousel in a chosen direction.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"direction\">The direction to increment. Negative is backwards.<\/param>\n        \/\/\/ <param name=\"skipDifficulties\">Whether to skip individual difficulties and only increment over full groups.<\/param>\n        public void SelectNext(int direction = 1, bool skipDifficulties = true)\n        {\n            if (beatmapSets.All(s => s.Filtered.Value))\n                return;\n\n            if (skipDifficulties)\n                selectNextSet(direction, true);\n            else\n                selectNextDifficulty(direction);\n        }\n\n        private void selectNextSet(int direction, bool skipDifficulties)\n        {\n            var unfilteredSets = beatmapSets.Where(s => !s.Filtered.Value).ToList();\n\n            var nextSet = unfilteredSets[(unfilteredSets.IndexOf(selectedBeatmapSet) + direction + unfilteredSets.Count) % unfilteredSets.Count];\n\n            if (skipDifficulties)\n                select(nextSet);\n            else\n                select(direction > 0 ? nextSet.Beatmaps.First(b => !b.Filtered.Value) : nextSet.Beatmaps.Last(b => !b.Filtered.Value));\n        }\n\n        private void selectNextDifficulty(int direction)\n        {\n            var unfilteredDifficulties = selectedBeatmapSet.Children.Where(s => !s.Filtered.Value).ToList();\n\n            int index = unfilteredDifficulties.IndexOf(selectedBeatmap);\n\n            if (index + direction < 0 || index + direction >= unfilteredDifficulties.Count)\n                selectNextSet(direction, false);\n            else\n                select(unfilteredDifficulties[index + direction]);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Select the next beatmap in the random sequence.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>True if a selection could be made, else False.<\/returns>\n        public bool SelectNextRandom()\n        {\n            var visibleSets = beatmapSets.Where(s => !s.Filtered.Value).ToList();\n            if (!visibleSets.Any())\n                return false;\n\n            if (selectedBeatmap != null)\n            {\n                randomSelectedBeatmaps.Push(selectedBeatmap);\n\n                \/\/ when performing a random, we want to add the current set to the previously visited list\n                \/\/ else the user may be \"randomised\" to the existing selection.\n                if (previouslyVisitedRandomSets.LastOrDefault() != selectedBeatmapSet)\n                    previouslyVisitedRandomSets.Add(selectedBeatmapSet);\n            }\n\n            CarouselBeatmapSet set;\n\n            if (RandomAlgorithm.Value == RandomSelectAlgorithm.RandomPermutation)\n            {\n                var notYetVisitedSets = visibleSets.Except(previouslyVisitedRandomSets).ToList();\n\n                if (!notYetVisitedSets.Any())\n                {\n                    previouslyVisitedRandomSets.RemoveAll(s => visibleSets.Contains(s));\n                    notYetVisitedSets = visibleSets;\n                }\n\n                set = notYetVisitedSets.ElementAt(RNG.Next(notYetVisitedSets.Count));\n                previouslyVisitedRandomSets.Add(set);\n            }\n            else\n                set = visibleSets.ElementAt(RNG.Next(visibleSets.Count));\n\n            select(set);\n            return true;\n        }\n\n        public void SelectPreviousRandom()\n        {\n            while (randomSelectedBeatmaps.Any())\n            {\n                var beatmap = randomSelectedBeatmaps.Pop();\n\n                if (!beatmap.Filtered.Value)\n                {\n                    if (RandomAlgorithm.Value == RandomSelectAlgorithm.RandomPermutation)\n                        previouslyVisitedRandomSets.Remove(selectedBeatmapSet);\n                    select(beatmap);\n                    break;\n                }\n            }\n        }\n\n        private void select(CarouselItem item)\n        {\n            if (!AllowSelection)\n                return;\n\n            if (item == null) return;\n\n            item.State.Value = CarouselItemState.Selected;\n        }\n\n        private FilterCriteria activeCriteria = new FilterCriteria();\n\n        protected ScheduledDelegate PendingFilter;\n\n        public bool AllowSelection = true;\n\n        \/\/\/ <summary>\n        \/\/\/ Half the height of the visible content.\n        \/\/\/ <remarks>\n        \/\/\/ This is different from the height of <see cref=\"ScrollContainer{T}\"\/>.displayableContent, since\n        \/\/\/ the beatmap carousel bleeds into the <see cref=\"FilterControl\"\/> and the <see cref=\"Footer\"\/>\n        \/\/\/ <\/remarks>\n        \/\/\/ <\/summary>\n        private float visibleHalfHeight => (DrawHeight + BleedBottom + BleedTop) \/ 2;\n\n        \/\/\/ <summary>\n        \/\/\/ The position of the lower visible bound with respect to the current scroll position.\n        \/\/\/ <\/summary>\n        private float visibleBottomBound => scroll.Current + DrawHeight + BleedBottom;\n\n        \/\/\/ <summary>\n        \/\/\/ The position of the upper visible bound with respect to the current scroll position.\n        \/\/\/ <\/summary>\n        private float visibleUpperBound => scroll.Current - BleedTop;\n\n        public void FlushPendingFilterOperations()\n        {\n            if (PendingFilter?.Completed == false)\n            {\n                applyActiveCriteria(false);\n                Update();\n            }\n        }\n\n        public void Filter(FilterCriteria newCriteria, bool debounce = true)\n        {\n            if (newCriteria != null)\n                activeCriteria = newCriteria;\n\n            applyActiveCriteria(debounce);\n        }\n\n        private void applyActiveCriteria(bool debounce, bool alwaysResetScrollPosition = true)\n        {\n            if (root.Children.Any() != true) return;\n\n            void perform()\n            {\n                PendingFilter = null;\n\n                root.Filter(activeCriteria);\n                itemsCache.Invalidate();\n\n                if (alwaysResetScrollPosition || !scroll.UserScrolling)\n                    ScrollToSelected();\n            }\n\n            PendingFilter?.Cancel();\n            PendingFilter = null;\n\n            if (debounce)\n                PendingFilter = Scheduler.AddDelayed(perform, 250);\n            else\n                perform();\n        }\n\n        private float? scrollTarget;\n\n        \/\/\/ <summary>\n        \/\/\/ Scroll to the current <see cref=\"SelectedBeatmap\"\/>.\n        \/\/\/ <\/summary>\n        public void ScrollToSelected() => scrollPositionCache.Invalidate();\n\n        protected override bool OnKeyDown(KeyDownEvent e)\n        {\n            switch (e.Key)\n            {\n                case Key.Left:\n                    SelectNext(-1, true);\n                    return true;\n\n                case Key.Right:\n                    SelectNext(1, true);\n                    return true;\n            }\n\n            return false;\n        }\n\n        public bool OnPressed(GlobalAction action)\n        {\n            switch (action)\n            {\n                case GlobalAction.SelectNext:\n                    SelectNext(1, false);\n                    return true;\n\n                case GlobalAction.SelectPrevious:\n                    SelectNext(-1, false);\n                    return true;\n            }\n\n            return false;\n        }\n\n        public void OnReleased(GlobalAction action)\n        {\n        }\n\n        protected override void Update()\n        {\n            base.Update();\n\n            if (!itemsCache.IsValid)\n                updateItems();\n\n            \/\/ Remove all items that should no longer be on-screen\n            scrollableContent.RemoveAll(p => p.Y < visibleUpperBound - p.DrawHeight || p.Y > visibleBottomBound || !p.IsPresent);\n\n            \/\/ Find index range of all items that should be on-screen\n            Trace.Assert(Items.Count == yPositions.Count);\n\n            int firstIndex = yPositions.BinarySearch(visibleUpperBound - DrawableCarouselItem.MAX_HEIGHT);\n            if (firstIndex < 0) firstIndex = ~firstIndex;\n            int lastIndex = yPositions.BinarySearch(visibleBottomBound);\n            if (lastIndex < 0) lastIndex = ~lastIndex;\n\n            int notVisibleCount = 0;\n\n            \/\/ Add those items within the previously found index range that should be displayed.\n            for (int i = firstIndex; i < lastIndex; ++i)\n            {\n                DrawableCarouselItem item = Items[i];\n\n                if (!item.Item.Visible)\n                {\n                    if (!item.IsPresent)\n                        notVisibleCount++;\n                    continue;\n                }\n\n                float depth = i + (item is DrawableCarouselBeatmapSet ? -Items.Count : 0);\n\n                \/\/ Only add if we're not already part of the content.\n                if (!scrollableContent.Contains(item))\n                {\n                    \/\/ Makes sure headers are always _below_ items,\n                    \/\/ and depth flows downward.\n                    item.Depth = depth;\n\n                    switch (item.LoadState)\n                    {\n                        case LoadState.NotLoaded:\n                            LoadComponentAsync(item);\n                            break;\n\n                        case LoadState.Loading:\n                            break;\n\n                        default:\n                            scrollableContent.Add(item);\n                            break;\n                    }\n                }\n                else\n                {\n                    scrollableContent.ChangeChildDepth(item, depth);\n                }\n            }\n\n            \/\/ this is not actually useful right now, but once we have groups may well be.\n            if (notVisibleCount > 50)\n                itemsCache.Invalidate();\n\n            \/\/ Update externally controlled state of currently visible items\n            \/\/ (e.g. x-offset and opacity).\n            foreach (DrawableCarouselItem p in scrollableContent.Children)\n                updateItem(p);\n        }\n\n        protected override void UpdateAfterChildren()\n        {\n            base.UpdateAfterChildren();\n\n            if (!scrollPositionCache.IsValid)\n                updateScrollPosition();\n        }\n\n        protected override void Dispose(bool isDisposing)\n        {\n            base.Dispose(isDisposing);\n\n            \/\/ aggressively dispose \"off-screen\" items to reduce GC pressure.\n            foreach (var i in Items)\n                i.Dispose();\n        }\n\n        private void beatmapRemoved(ValueChangedEvent<WeakReference<BeatmapSetInfo>> weakItem)\n        {\n            if (weakItem.NewValue.TryGetTarget(out var item))\n                RemoveBeatmapSet(item);\n        }\n\n        private void beatmapUpdated(ValueChangedEvent<WeakReference<BeatmapSetInfo>> weakItem)\n        {\n            if (weakItem.NewValue.TryGetTarget(out var item))\n                UpdateBeatmapSet(item);\n        }\n\n        private void beatmapRestored(ValueChangedEvent<WeakReference<BeatmapInfo>> weakItem)\n        {\n            if (weakItem.NewValue.TryGetTarget(out var b))\n                UpdateBeatmapSet(beatmaps.QueryBeatmapSet(s => s.ID == b.BeatmapSetInfoID));\n        }\n\n        private void beatmapHidden(ValueChangedEvent<WeakReference<BeatmapInfo>> weakItem)\n        {\n            if (weakItem.NewValue.TryGetTarget(out var b))\n                UpdateBeatmapSet(beatmaps.QueryBeatmapSet(s => s.ID == b.BeatmapSetInfoID));\n        }\n\n        private CarouselBeatmapSet createCarouselSet(BeatmapSetInfo beatmapSet)\n        {\n            if (beatmapSet.Beatmaps.All(b => b.Hidden))\n                return null;\n\n            \/\/ todo: remove the need for this.\n            foreach (var b in beatmapSet.Beatmaps)\n                b.Metadata ??= beatmapSet.Metadata;\n\n            var set = new CarouselBeatmapSet(beatmapSet)\n            {\n                GetRecommendedBeatmap = beatmaps => GetRecommendedBeatmap?.Invoke(beatmaps)\n            };\n\n            foreach (var c in set.Beatmaps)\n            {\n                c.State.ValueChanged += state =>\n                {\n                    if (state.NewValue == CarouselItemState.Selected)\n                    {\n                        selectedBeatmapSet = set;\n                        SelectionChanged?.Invoke(c.Beatmap);\n\n                        itemsCache.Invalidate();\n                        ScrollToSelected();\n                    }\n                };\n            }\n\n            return set;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Computes the target Y positions for every item in the carousel.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>The Y position of the currently selected item.<\/returns>\n        private void updateItems()\n        {\n            Items = root.Drawables.ToList();\n\n            yPositions.Clear();\n\n            float currentY = visibleHalfHeight;\n            DrawableCarouselBeatmapSet lastSet = null;\n\n            scrollTarget = null;\n\n            foreach (DrawableCarouselItem d in Items)\n            {\n                if (d.IsPresent)\n                {\n                    switch (d)\n                    {\n                        case DrawableCarouselBeatmapSet set:\n                        {\n                            lastSet = set;\n\n                            set.MoveToX(set.Item.State.Value == CarouselItemState.Selected ? -100 : 0, 500, Easing.OutExpo);\n                            set.MoveToY(currentY, 750, Easing.OutExpo);\n                            break;\n                        }\n\n                        case DrawableCarouselBeatmap beatmap:\n                        {\n                            if (beatmap.Item.State.Value == CarouselItemState.Selected)\n                                \/\/ scroll position at currentY makes the set panel appear at the very top of the carousel's screen space\n                                \/\/ move down by half of visible height (height of the carousel's visible extent, including semi-transparent areas)\n                                \/\/ then reapply the top semi-transparent area (because carousel's screen space starts below it)\n                                \/\/ and finally add half of the panel's own height to achieve vertical centering of the panel itself\n                                scrollTarget = currentY - visibleHalfHeight + BleedTop + beatmap.DrawHeight \/ 2;\n\n                            void performMove(float y, float? startY = null)\n                            {\n                                if (startY != null) beatmap.MoveTo(new Vector2(0, startY.Value));\n                                beatmap.MoveToX(beatmap.Item.State.Value == CarouselItemState.Selected ? -50 : 0, 500, Easing.OutExpo);\n                                beatmap.MoveToY(y, 750, Easing.OutExpo);\n                            }\n\n                            Debug.Assert(lastSet != null);\n\n                            float? setY = null;\n                            if (!d.IsLoaded || beatmap.Alpha == 0) \/\/ can't use IsPresent due to DrawableCarouselItem override.\n                                setY = lastSet.Y + lastSet.DrawHeight + 5;\n\n                            if (d.IsLoaded)\n                                performMove(currentY, setY);\n                            else\n                            {\n                                float y = currentY;\n                                d.OnLoadComplete += _ => performMove(y, setY);\n                            }\n\n                            break;\n                        }\n                    }\n                }\n\n                yPositions.Add(currentY);\n\n                if (d.Item.Visible)\n                    currentY += d.DrawHeight + 5;\n            }\n\n            currentY += visibleHalfHeight;\n            scrollableContent.Height = currentY;\n\n            if (BeatmapSetsLoaded && (selectedBeatmapSet == null || selectedBeatmap == null || selectedBeatmapSet.State.Value != CarouselItemState.Selected))\n            {\n                selectedBeatmapSet = null;\n                SelectionChanged?.Invoke(null);\n            }\n\n            itemsCache.Validate();\n        }\n\n        private bool firstScroll = true;\n\n        private void updateScrollPosition()\n        {\n            if (scrollTarget != null)\n            {\n                if (firstScroll)\n                {\n                    \/\/ reduce movement when first displaying the carousel.\n                    scroll.ScrollTo(scrollTarget.Value - 200, false);\n                    firstScroll = false;\n                }\n\n                scroll.ScrollTo(scrollTarget.Value);\n                scrollPositionCache.Validate();\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Computes the x-offset of currently visible items. Makes the carousel appear round.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"dist\">\n        \/\/\/ Vertical distance from the center of the carousel container\n        \/\/\/ ranging from -1 to 1.\n        \/\/\/ <\/param>\n        \/\/\/ <param name=\"halfHeight\">Half the height of the carousel container.<\/param>\n        private static float offsetX(float dist, float halfHeight)\n        {\n            \/\/ The radius of the circle the carousel moves on.\n            const float circle_radius = 3;\n            float discriminant = MathF.Max(0, circle_radius * circle_radius - dist * dist);\n            float x = (circle_radius - MathF.Sqrt(discriminant)) * halfHeight;\n\n            return 125 + x;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Update a item's x position and multiplicative alpha based on its y position and\n        \/\/\/ the current scroll position.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"p\">The item to be updated.<\/param>\n        private void updateItem(DrawableCarouselItem p)\n        {\n            float itemDrawY = p.Position.Y - visibleUpperBound + p.DrawHeight \/ 2;\n            float dist = Math.Abs(1f - itemDrawY \/ visibleHalfHeight);\n\n            \/\/ Setting the origin position serves as an additive position on top of potential\n            \/\/ local transformation we may want to apply (e.g. when a item gets selected, we\n            \/\/ may want to smoothly transform it leftwards.)\n            p.OriginPosition = new Vector2(-offsetX(dist, visibleHalfHeight), 0);\n\n            \/\/ We are applying a multiplicative alpha (which is internally done by nesting an\n            \/\/ additional container and setting that container's alpha) such that we can\n            \/\/ layer transformations on top, with a similar reasoning to the previous comment.\n            p.SetMultiplicativeAlpha(Math.Clamp(1.75f - 1.5f * dist, 0, 1));\n        }\n\n        private class CarouselRoot : CarouselGroupEagerSelect\n        {\n            private readonly BeatmapCarousel carousel;\n\n            public CarouselRoot(BeatmapCarousel carousel)\n            {\n                \/\/ root should always remain selected. if not, PerformSelection will not be called.\n                State.Value = CarouselItemState.Selected;\n                State.ValueChanged += state => State.Value = CarouselItemState.Selected;\n\n                this.carousel = carousel;\n            }\n\n            protected override void PerformSelection()\n            {\n                if (LastSelected == null || LastSelected.Filtered.Value)\n                    carousel?.SelectNextRandom();\n                else\n                    base.PerformSelection();\n            }\n        }\n\n        private class CarouselScrollContainer : OsuScrollContainer\n        {\n            private bool rightMouseScrollBlocked;\n\n            \/\/\/ <summary>\n            \/\/\/ Whether the last scroll event was user triggered, directly on the scroll container.\n            \/\/\/ <\/summary>\n            public bool UserScrolling { get; private set; }\n\n            protected override void OnUserScroll(float value, bool animated = true, double? distanceDecay = default)\n            {\n                UserScrolling = true;\n                base.OnUserScroll(value, animated, distanceDecay);\n            }\n\n            public new void ScrollTo(float value, bool animated = true, double? distanceDecay = null)\n            {\n                UserScrolling = false;\n                base.ScrollTo(value, animated, distanceDecay);\n            }\n\n            protected override bool OnMouseDown(MouseDownEvent e)\n            {\n                if (e.Button == MouseButton.Right)\n                {\n                    \/\/ we need to block right click absolute scrolling when hovering a carousel item so context menus can display.\n                    \/\/ this can be reconsidered when we have an alternative to right click scrolling.\n                    if (GetContainingInputManager().HoveredDrawables.OfType<DrawableCarouselItem>().Any())\n                    {\n                        rightMouseScrollBlocked = true;\n                        return false;\n                    }\n                }\n\n                rightMouseScrollBlocked = false;\n                return base.OnMouseDown(e);\n            }\n\n            protected override bool OnDragStart(DragStartEvent e)\n            {\n                if (rightMouseScrollBlocked)\n                    return false;\n\n                return base.OnDragStart(e);\n            }\n        }\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"e29007562f9f684bd301f8bb8090f70058df0112","subject":"Fix BuildTransactionValidationsTestAsync","message":"Fix BuildTransactionValidationsTestAsync\n","repos":"nopara73\/HiddenWallet,nopara73\/HiddenWallet,nopara73\/HiddenWallet,nopara73\/HiddenWallet","old_file":"WalletWasabi.Tests\/IntegrationTests\/RegTests.cs","new_file":"WalletWasabi.Tests\/IntegrationTests\/RegTests.cs","new_contents":"using NBitcoin;\nusing NBitcoin.BouncyCastle.Math;\nusing NBitcoin.Crypto;\nusing NBitcoin.Protocol;\nusing NBitcoin.RPC;\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Runtime.CompilerServices;\nusing System.Runtime.InteropServices;\nusing System.Security;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing WalletWasabi.Backend;\nusing WalletWasabi.Backend.Models;\nusing WalletWasabi.Backend.Models.Responses;\nusing WalletWasabi.Blockchain.Analysis.Clustering;\nusing WalletWasabi.Blockchain.BlockFilters;\nusing WalletWasabi.Blockchain.Blocks;\nusing WalletWasabi.Blockchain.Keys;\nusing WalletWasabi.Blockchain.TransactionBroadcasting;\nusing WalletWasabi.Blockchain.TransactionBuilding;\nusing WalletWasabi.Blockchain.TransactionOutputs;\nusing WalletWasabi.Blockchain.TransactionProcessing;\nusing WalletWasabi.Blockchain.Transactions;\nusing WalletWasabi.CoinJoin.Client.Clients;\nusing WalletWasabi.CoinJoin.Client.Clients.Queuing;\nusing WalletWasabi.CoinJoin.Client.Rounds;\nusing WalletWasabi.CoinJoin.Common.Models;\nusing WalletWasabi.CoinJoin.Coordinator;\nusing WalletWasabi.CoinJoin.Coordinator.Rounds;\nusing WalletWasabi.Crypto;\nusing WalletWasabi.Exceptions;\nusing WalletWasabi.Helpers;\nusing WalletWasabi.Logging;\nusing WalletWasabi.Models;\nusing WalletWasabi.Services;\nusing WalletWasabi.Stores;\nusing WalletWasabi.Tests.XunitConfiguration;\nusing WalletWasabi.TorSocks5;\nusing WalletWasabi.WebClients.Wasabi;\nusing Xunit;\nusing static NBitcoin.Crypto.SchnorrBlinding;\n\nnamespace WalletWasabi.Tests.IntegrationTests\n{\n\t[Collection(\"RegTest collection\")]\n\tpublic class RegTests\n\t{\n#pragma warning disable IDE0059 \/\/ Value assigned to symbol is never used\n\t\tprivate RegTestFixture RegTestFixture { get; }\n\n\t\tpublic RegTests(RegTestFixture regTestFixture)\n\t\t{\n\t\t\tRegTestFixture = regTestFixture;\n\t\t}\n\n\t\tpublic static string GetWorkDir([CallerFilePath]string callerFilePath = null, [CallerMemberName]string callerMemberName = null)\n\t\t{\n\t\t\treturn Path.Combine(Global.Instance.DataDir, EnvironmentHelpers.ExtractFileName(callerFilePath), callerMemberName);\n\t\t}\n\n\t\tprivate async Task AssertFiltersInitializedAsync(Backend.Global global)\n\t\t{\n\t\t\tvar firstHash = await global.RpcClient.GetBlockHashAsync(0);\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tusing var client = new WasabiClient(new Uri(RegTestFixture.BackendEndPoint), null);\n\t\t\t\tFiltersResponse filtersResponse = await client.GetFiltersAsync(firstHash, 1000);\n\t\t\t\tAssert.NotNull(filtersResponse);\n\n\t\t\t\tvar filterCount = filtersResponse.Filters.Count();\n\t\t\t\tif (filterCount >= 101)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tawait Task.Delay(100);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate async Task<(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global)> InitializeTestEnvironmentAsync(int numberOfBlocksToGenerate, [CallerFilePath]string callerFilePath = null, [CallerMemberName] string callerMemberName = null)\n\t\t{\n\t\t\tvar global = RegTestFixture.Global;\n\t\t\tawait AssertFiltersInitializedAsync(global); \/\/ Make sure fitlers are created on the server side.\n\t\t\tif (numberOfBlocksToGenerate != 0)\n\t\t\t{\n\t\t\t\tawait global.RpcClient.GenerateAsync(numberOfBlocksToGenerate); \/\/ Make sure everything is confirmed.\n\t\t\t}\n\t\t\tglobal.Coordinator.UtxoReferee.Clear();\n\n\t\t\tvar network = global.RpcClient.Network;\n\t\t\tvar serviceConfiguration = new ServiceConfiguration(2, 2, 21, 50, RegTestFixture.BackendRegTestNode.P2pEndPoint, Money.Coins(Constants.DefaultDustThreshold));\n\t\t\tvar bitcoinStore = new BitcoinStore();\n\t\t\tvar dir = GetWorkDir(callerFilePath, callerMemberName);\n\t\t\tawait bitcoinStore.InitializeAsync(dir, network);\n\t\t\treturn (\"password\", global.RpcClient, network, global.Coordinator, serviceConfiguration, bitcoinStore, global);\n\t\t}\n\n\t\t#region BackendTests\n\n\t\t[Fact]\n\t\tpublic async Task GetExchangeRatesAsync()\n\t\t{\n\t\t\tusing var client = new TorHttpClient(new Uri(RegTestFixture.BackendEndPoint), null);\n\t\t\tusing var response = await client.SendAsync(HttpMethod.Get, $\"\/api\/v{Constants.BackendMajorVersion}\/btc\/offchain\/exchange-rates\");\n\t\t\tAssert.True(response.StatusCode == HttpStatusCode.OK);\n\n\t\t\tvar exchangeRates = await response.Content.ReadAsJsonAsync<List<ExchangeRate>>();\n\t\t\tAssert.Single(exchangeRates);\n\n\t\t\tvar rate = exchangeRates[0];\n\t\t\tAssert.Equal(\"USD\", rate.Ticker);\n\t\t\tAssert.True(rate.Rate > 0);\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task GetClientVersionAsync()\n\t\t{\n\t\t\tusing var client = new WasabiClient(new Uri(RegTestFixture.BackendEndPoint), null);\n\t\t\tvar uptodate = await client.CheckUpdatesAsync(CancellationToken.None);\n\t\t\tAssert.True(uptodate.BackendCompatible);\n\t\t\tAssert.True(uptodate.ClientUpToDate);\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task BroadcastReplayTxAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\tvar utxos = await rpc.ListUnspentAsync();\n\t\t\tvar utxo = utxos[0];\n\t\t\tvar tx = await rpc.GetRawTransactionAsync(utxo.OutPoint.Hash);\n\t\t\tvar content = new StringContent($\"'{tx.ToHex()}'\", Encoding.UTF8, \"application\/json\");\n\n\t\t\tLogger.TurnOff();\n\t\t\tusing (var client = new TorHttpClient(new Uri(RegTestFixture.BackendEndPoint), null))\n\t\t\tusing (var response = await client.SendAsync(HttpMethod.Post, $\"\/api\/v{Constants.BackendMajorVersion}\/btc\/blockchain\/broadcast\", content))\n\t\t\t{\n\t\t\t\tAssert.Equal(HttpStatusCode.OK, response.StatusCode);\n\t\t\t\tAssert.Equal(\"Transaction is already in the blockchain.\", await response.Content.ReadAsJsonAsync<string>());\n\t\t\t}\n\t\t\tLogger.TurnOn();\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task BroadcastInvalidTxAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\tvar content = new StringContent($\"''\", Encoding.UTF8, \"application\/json\");\n\n\t\t\tLogger.TurnOff();\n\t\t\tusing (var client = new TorHttpClient(new Uri(RegTestFixture.BackendEndPoint), null))\n\t\t\tusing (var response = await client.SendAsync(HttpMethod.Post, $\"\/api\/v{Constants.BackendMajorVersion}\/btc\/blockchain\/broadcast\", content))\n\t\t\t{\n\t\t\t\tAssert.NotEqual(HttpStatusCode.OK, response.StatusCode);\n\t\t\t\tAssert.Equal(HttpStatusCode.BadRequest, response.StatusCode);\n\t\t\t\tAssert.Equal(\"Invalid hex.\", await response.Content.ReadAsJsonAsync<string>());\n\t\t\t}\n\t\t\tLogger.TurnOn();\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task FilterBuilderTestAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\tvar indexBuilderServiceDir = GetWorkDir();\n\t\t\tvar indexFilePath = Path.Combine(indexBuilderServiceDir, $\"Index{rpc.Network}.dat\");\n\t\t\tvar utxoSetFilePath = Path.Combine(indexBuilderServiceDir, $\"UtxoSet{rpc.Network}.dat\");\n\n\t\t\tvar indexBuilderService = new IndexBuilderService(rpc, global.HostedServices.FirstOrDefault<BlockNotifier>(), indexFilePath, utxoSetFilePath);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tindexBuilderService.Synchronize();\n\n\t\t\t\t\/\/ Test initial synchronization.\n\t\t\t\tvar times = 0;\n\t\t\t\tuint256 firstHash = await rpc.GetBlockHashAsync(0);\n\t\t\t\twhile (indexBuilderService.GetFilterLinesExcluding(firstHash, 101, out _).filters.Count() != 101)\n\t\t\t\t{\n\t\t\t\t\tif (times > 500) \/\/ 30 sec\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new TimeoutException($\"{nameof(IndexBuilderService)} test timed out.\");\n\t\t\t\t\t}\n\t\t\t\t\tawait Task.Delay(100);\n\t\t\t\t\ttimes++;\n\t\t\t\t}\n\n\t\t\t\t\/\/ Test later synchronization.\n\t\t\t\tawait rpc.GenerateAsync(10);\n\t\t\t\ttimes = 0;\n\t\t\t\twhile (indexBuilderService.GetFilterLinesExcluding(firstHash, 111, out bool found5).filters.Count() != 111)\n\t\t\t\t{\n\t\t\t\t\tAssert.True(found5);\n\t\t\t\t\tif (times > 500) \/\/ 30 sec\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new TimeoutException($\"{nameof(IndexBuilderService)} test timed out.\");\n\t\t\t\t\t}\n\t\t\t\t\tawait Task.Delay(100);\n\t\t\t\t\ttimes++;\n\t\t\t\t}\n\n\t\t\t\t\/\/ Test correct number of filters is received.\n\t\t\t\tvar hundredthHash = await rpc.GetBlockHashAsync(100);\n\t\t\t\tAssert.Equal(11, indexBuilderService.GetFilterLinesExcluding(hundredthHash, 11, out bool found).filters.Count());\n\t\t\t\tAssert.True(found);\n\t\t\t\tvar bestHash = await rpc.GetBestBlockHashAsync();\n\t\t\t\tAssert.Empty(indexBuilderService.GetFilterLinesExcluding(bestHash, 1, out bool found2).filters);\n\t\t\t\tAssert.Empty(indexBuilderService.GetFilterLinesExcluding(uint256.Zero, 1, out bool found3).filters);\n\t\t\t\tAssert.False(found3);\n\n\t\t\t\t\/\/ Test filter block hashes are correct.\n\t\t\t\tvar filters = indexBuilderService.GetFilterLinesExcluding(firstHash, 111, out bool found4).filters.ToArray();\n\t\t\t\tAssert.True(found4);\n\t\t\t\tfor (int i = 0; i < 111; i++)\n\t\t\t\t{\n\t\t\t\t\tvar expectedHash = await rpc.GetBlockHashAsync(i + 1);\n\t\t\t\t\tvar filterModel = filters[i];\n\t\t\t\t\tAssert.Equal(expectedHash, filterModel.Header.BlockHash);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tif (indexBuilderService != null)\n\t\t\t\t{\n\t\t\t\t\tawait indexBuilderService.StopAsync();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t#endregion BackendTests\n\n\t\t#region ServicesTests\n\n\t\t[Fact]\n\t\tpublic async Task FilterDownloaderTestAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\tvar synchronizer = new WasabiSynchronizer(rpc.Network, bitcoinStore, new Uri(RegTestFixture.BackendEndPoint), null);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tsynchronizer.Start(requestInterval: TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), 1000);\n\n\t\t\t\tvar blockCount = await rpc.GetBlockCountAsync() + 1; \/\/ Plus one because of the zeroth.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \/\/ Test initial synchronization.\n\t\t\t\tvar times = 0;\n\t\t\t\tint filterCount;\n\t\t\t\twhile ((filterCount = bitcoinStore.SmartHeaderChain.HashCount) < blockCount)\n\t\t\t\t{\n\t\t\t\t\tif (times > 500) \/\/ 30 sec\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new TimeoutException($\"{nameof(WasabiSynchronizer)} test timed out. Needed filters: {blockCount}, got only: {filterCount}.\");\n\t\t\t\t\t}\n\t\t\t\t\tawait Task.Delay(100);\n\t\t\t\t\ttimes++;\n\t\t\t\t}\n\n\t\t\t\tAssert.Equal(blockCount, bitcoinStore.SmartHeaderChain.HashCount);\n\n\t\t\t\t\/\/ Test later synchronization.\n\t\t\t\tawait RegTestFixture.BackendRegTestNode.GenerateAsync(10);\n\t\t\t\ttimes = 0;\n\t\t\t\twhile ((filterCount = bitcoinStore.SmartHeaderChain.HashCount) < blockCount + 10)\n\t\t\t\t{\n\t\t\t\t\tif (times > 500) \/\/ 30 sec\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new TimeoutException($\"{nameof(WasabiSynchronizer)} test timed out. Needed filters: {blockCount + 10}, got only: {filterCount}.\");\n\t\t\t\t\t}\n\t\t\t\t\tawait Task.Delay(100);\n\t\t\t\t\ttimes++;\n\t\t\t\t}\n\n\t\t\t\t\/\/ Test correct number of filters is received.\n\t\t\t\tAssert.Equal(blockCount + 10, bitcoinStore.SmartHeaderChain.HashCount);\n\n\t\t\t\t\/\/ Test filter block hashes are correct.\n\t\t\t\tvar filterList = new List<FilterModel>();\n\t\t\t\tawait bitcoinStore.IndexStore.ForeachFiltersAsync(async x =>\n\t\t\t\t{\n\t\t\t\t\tfilterList.Add(x);\n\t\t\t\t\tawait Task.CompletedTask;\n\t\t\t\t},\n\t\t\t\tnew Height(0));\n\t\t\t\tFilterModel[] filters = filterList.ToArray();\n\t\t\t\tfor (int i = 0; i < 101; i++)\n\t\t\t\t{\n\t\t\t\t\tvar expectedHash = await rpc.GetBlockHashAsync(i);\n\t\t\t\t\tvar filter = filters[i];\n\t\t\t\t\tAssert.Equal(i, (int)filter.Header.Height);\n\t\t\t\t\tAssert.Equal(expectedHash, filter.Header.BlockHash);\n\t\t\t\t\tAssert.Equal(IndexBuilderService.CreateDummyEmptyFilter(expectedHash).ToString(), filter.Filter.ToString());\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tawait synchronizer?.StopAsync();\n\t\t\t}\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task ReorgTestAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\tvar keyManager = KeyManager.CreateNew(out _, password);\n\n\t\t\t\/\/ Mine some coins, make a few bech32 transactions then make it confirm.\n\t\t\tawait rpc.GenerateAsync(1);\n\t\t\tvar key = keyManager.GenerateNewKey(SmartLabel.Empty, KeyState.Clean, isInternal: false);\n\t\t\tvar tx2 = await rpc.SendToAddressAsync(key.GetP2wpkhAddress(network), Money.Coins(0.1m));\n\t\t\tkey = keyManager.GenerateNewKey(SmartLabel.Empty, KeyState.Clean, isInternal: false);\n\t\t\tvar tx3 = await rpc.SendToAddressAsync(key.GetP2wpkhAddress(network), Money.Coins(0.1m));\n\t\t\tvar tx4 = await rpc.SendToAddressAsync(key.GetP2pkhAddress(network), Money.Coins(0.1m));\n\t\t\tvar tx5 = await rpc.SendToAddressAsync(key.GetP2shOverP2wpkhAddress(network), Money.Coins(0.1m));\n\t\t\tvar tx1 = await rpc.SendToAddressAsync(key.GetP2wpkhAddress(network), Money.Coins(0.1m), replaceable: true);\n\n\t\t\tawait rpc.GenerateAsync(2); \/\/ Generate two, so we can test for two reorg\n\n\t\t\tvar node = RegTestFixture.BackendRegTestNode;\n\n\t\t\tvar synchronizer = new WasabiSynchronizer(rpc.Network, bitcoinStore, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tsynchronizer.Start(requestInterval: TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(5), 1000);\n\n\t\t\t\tvar reorgAwaiter = new EventsAwaiter<FilterModel>(\n\t\t\t\t\th => bitcoinStore.IndexStore.Reorged += h,\n\t\t\t\t\th => bitcoinStore.IndexStore.Reorged -= h,\n\t\t\t\t\t2);\n\n\t\t\t\t\/\/ Test initial synchronization.\n\t\t\t\tawait WaitForIndexesToSyncAsync(global, TimeSpan.FromSeconds(90), bitcoinStore);\n\n\t\t\t\tvar tip = await rpc.GetBestBlockHashAsync();\n\t\t\t\tAssert.Equal(tip, bitcoinStore.SmartHeaderChain.TipHash);\n\t\t\t\tvar tipBlock = await rpc.GetBlockHeaderAsync(tip);\n\t\t\t\tAssert.Equal(tipBlock.HashPrevBlock, bitcoinStore.SmartHeaderChain.GetChain().Select(x => x.header.BlockHash).ToArray()[bitcoinStore.SmartHeaderChain.HashCount - 2]);\n\n\t\t\t\tvar utxoPath = global.IndexBuilderService.Bech32UtxoSetFilePath;\n\t\t\t\tvar utxoLines = await File.ReadAllTextAsync(utxoPath);\n\t\t\t\tAssert.Contains(tx1.ToString(), utxoLines);\n\t\t\t\tAssert.Contains(tx2.ToString(), utxoLines);\n\t\t\t\tAssert.Contains(tx3.ToString(), utxoLines);\n\t\t\t\tAssert.DoesNotContain(tx4.ToString(), utxoLines); \/\/ make sure only bech is recorded\n\t\t\t\tAssert.DoesNotContain(tx5.ToString(), utxoLines); \/\/ make sure only bech is recorded\n\n\t\t\t\t\/\/ Test synchronization after fork.\n\t\t\t\tawait rpc.InvalidateBlockAsync(tip); \/\/ Reorg 1\n\t\t\t\ttip = await rpc.GetBestBlockHashAsync();\n\t\t\t\tawait rpc.InvalidateBlockAsync(tip); \/\/ Reorg 2\n\t\t\t\tvar tx1bumpRes = await rpc.BumpFeeAsync(tx1); \/\/ RBF it\n\n\t\t\t\tawait rpc.GenerateAsync(5);\n\t\t\t\tawait WaitForIndexesToSyncAsync(global, TimeSpan.FromSeconds(90), bitcoinStore);\n\n\t\t\t\tutxoLines = await File.ReadAllTextAsync(utxoPath);\n\t\t\t\tAssert.Contains(tx1bumpRes.TransactionId.ToString(), utxoLines); \/\/ assert the tx1bump is the correct tx\n\t\t\t\tAssert.DoesNotContain(tx1.ToString(), utxoLines); \/\/ assert tx1 is abandoned (despite it confirmed previously)\n\t\t\t\tAssert.Contains(tx2.ToString(), utxoLines);\n\t\t\t\tAssert.Contains(tx3.ToString(), utxoLines);\n\t\t\t\tAssert.DoesNotContain(tx4.ToString(), utxoLines);\n\t\t\t\tAssert.DoesNotContain(tx5.ToString(), utxoLines);\n\n\t\t\t\tvar hashes = bitcoinStore.SmartHeaderChain.GetChain().Select(x => x.header.BlockHash).ToArray();\n\t\t\t\tAssert.DoesNotContain(tip, hashes);\n\t\t\t\tAssert.DoesNotContain(tipBlock.HashPrevBlock, hashes);\n\n\t\t\t\ttip = await rpc.GetBestBlockHashAsync();\n\t\t\t\tAssert.Equal(tip, bitcoinStore.SmartHeaderChain.TipHash);\n\n\t\t\t\tvar filterList = new List<FilterModel>();\n\t\t\t\tawait bitcoinStore.IndexStore.ForeachFiltersAsync(async x =>\n\t\t\t\t{\n\t\t\t\t\tfilterList.Add(x);\n\t\t\t\t\tawait Task.CompletedTask;\n\t\t\t\t},\n\t\t\t\tnew Height(0));\n\t\t\t\tvar filterTip = filterList.Last();\n\t\t\t\tAssert.Equal(tip, filterTip.Header.BlockHash);\n\n\t\t\t\t\/\/ Test filter block hashes are correct after fork.\n\t\t\t\tvar blockCountIncludingGenesis = await rpc.GetBlockCountAsync() + 1;\n\n\t\t\t\tfilterList.Clear();\n\t\t\t\tawait bitcoinStore.IndexStore.ForeachFiltersAsync(async x =>\n\t\t\t\t{\n\t\t\t\t\tfilterList.Add(x);\n\t\t\t\t\tawait Task.CompletedTask;\n\t\t\t\t},\n\t\t\t\tnew Height(0));\n\t\t\t\tFilterModel[] filters = filterList.ToArray();\n\t\t\t\tfor (int i = 0; i < blockCountIncludingGenesis; i++)\n\t\t\t\t{\n\t\t\t\t\tvar expectedHash = await rpc.GetBlockHashAsync(i);\n\t\t\t\t\tvar filter = filters[i];\n\t\t\t\t\tAssert.Equal(i, (int)filter.Header.Height);\n\t\t\t\t\tAssert.Equal(expectedHash, filter.Header.BlockHash);\n\t\t\t\t\tif (i < 101) \/\/ Later other tests may fill the filter.\n\t\t\t\t\t{\n\t\t\t\t\t\tAssert.Equal(IndexBuilderService.CreateDummyEmptyFilter(expectedHash).ToString(), filter.Filter.ToString());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t\/\/ Test the serialization, too.\n\t\t\t\ttip = await rpc.GetBestBlockHashAsync();\n\t\t\t\tvar blockHash = tip;\n\t\t\t\tfor (var i = 0; i < hashes.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar block = await rpc.GetBlockHeaderAsync(blockHash);\n\t\t\t\t\tAssert.Equal(blockHash, hashes[hashes.Length - i - 1]);\n\t\t\t\t\tblockHash = block.HashPrevBlock;\n\t\t\t\t}\n\n\t\t\t\t\/\/ Assert reorg happened exactly as many times as we reorged.\n\t\t\t\tawait reorgAwaiter.WaitAsync(TimeSpan.FromSeconds(10));\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tawait synchronizer?.StopAsync();\n\t\t\t}\n\t\t}\n\n\t\tprivate async Task WaitForIndexesToSyncAsync(Backend.Global global, TimeSpan timeout, BitcoinStore bitcoinStore)\n\t\t{\n\t\t\tvar bestHash = await global.RpcClient.GetBestBlockHashAsync();\n\n\t\t\tvar times = 0;\n\t\t\twhile (bitcoinStore.SmartHeaderChain.TipHash != bestHash)\n\t\t\t{\n\t\t\t\tif (times > timeout.TotalSeconds)\n\t\t\t\t{\n\t\t\t\t\tthrow new TimeoutException($\"{nameof(WasabiSynchronizer)} test timed out. Filter was not downloaded.\");\n\t\t\t\t}\n\t\t\t\tawait Task.Delay(TimeSpan.FromSeconds(1));\n\t\t\t\ttimes++;\n\t\t\t}\n\t\t}\n\n\t\t#endregion ServicesTests\n\n\t\t#region ClientTests\n\n\t\t[Fact]\n\t\tpublic async Task WalletTestsAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\t\/\/ Create the services.\n\t\t\t\/\/ 1. Create connection service.\n\t\t\tvar nodes = new NodesGroup(global.Config.Network, requirements: Constants.NodeRequirements);\n\t\t\tnodes.ConnectedNodes.Add(await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync());\n\n\t\t\tNode node = await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync();\n\t\t\tnode.Behaviors.Add(bitcoinStore.CreateUntrustedP2pBehavior());\n\n\t\t\t\/\/ 3. Create wasabi synchronizer service.\n\t\t\tvar synchronizer = new WasabiSynchronizer(rpc.Network, bitcoinStore, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\t\/\/ 4. Create key manager service.\n\t\t\tvar keyManager = KeyManager.CreateNew(out _, password);\n\n\t\t\t\/\/ 5. Create chaumian coinjoin client.\n\t\t\tvar chaumianClient = new CoinJoinClient(synchronizer, rpc.Network, keyManager, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\t\/\/ 5. Create wallet service.\n\t\t\tvar workDir = GetWorkDir();\n\t\t\tvar wallet = new WalletService(bitcoinStore, keyManager, synchronizer, chaumianClient, nodes, workDir, serviceConfiguration, synchronizer);\n\t\t\twallet.NewFilterProcessed += Wallet_NewFilterProcessed;\n\n\t\t\t\/\/ Get some money, make it confirm.\n\t\t\tvar key = keyManager.GetNextReceiveKey(\"foo label\", out _);\n\t\t\tvar txId = await rpc.SendToAddressAsync(key.GetP2wpkhAddress(network), Money.Coins(0.1m));\n\t\t\tawait rpc.GenerateAsync(1);\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tInterlocked.Exchange(ref _filtersProcessedByWalletCount, 0);\n\t\t\t\tnodes.Connect(); \/\/ Start connection service.\n\t\t\t\tnode.VersionHandshake(); \/\/ Start mempool service.\n\t\t\t\tsynchronizer.Start(requestInterval: TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(5), 1000); \/\/ Start wasabi synchronizer service.\n\t\t\t\tchaumianClient.Start(); \/\/ Start chaumian coinjoin client.\n\n\t\t\t\t\/\/ Wait until the filter our previous transaction is present.\n\t\t\t\tvar blockCount = await rpc.GetBlockCountAsync();\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), blockCount);\n\n\t\t\t\tusing (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30)))\n\t\t\t\t{\n\t\t\t\t\tawait wallet.InitializeAsync(cts.Token); \/\/ Initialize wallet service.\n\t\t\t\t}\n\t\t\t\tAssert.Equal(1, await wallet.CountBlocksAsync());\n\n\t\t\t\tAssert.Single(wallet.Coins);\n\t\t\t\tvar firstCoin = wallet.Coins.Single();\n\t\t\t\tAssert.Equal(Money.Coins(0.1m), firstCoin.Amount);\n\t\t\t\tAssert.Equal(new Height((int)bitcoinStore.SmartHeaderChain.TipHeight), firstCoin.Height);\n\t\t\t\tAssert.InRange(firstCoin.Index, 0U, 1U);\n\t\t\t\tAssert.False(firstCoin.Unavailable);\n\t\t\t\tAssert.Equal(\"foo label\", firstCoin.Label);\n\t\t\t\tAssert.Equal(key.P2wpkhScript, firstCoin.ScriptPubKey);\n\t\t\t\tAssert.Null(firstCoin.SpenderTransactionId);\n\t\t\t\tAssert.NotNull(firstCoin.SpentOutputs);\n\t\t\t\tAssert.NotEmpty(firstCoin.SpentOutputs);\n\t\t\t\tAssert.Equal(txId, firstCoin.TransactionId);\n\t\t\t\tAssert.Single(keyManager.GetKeys(KeyState.Used, false));\n\t\t\t\tAssert.Equal(\"foo label\", keyManager.GetKeys(KeyState.Used, false).Single().Label);\n\n\t\t\t\t\/\/ Get some money, make it confirm.\n\t\t\t\tvar key2 = keyManager.GetNextReceiveKey(\"bar label\", out _);\n\t\t\t\tvar txId2 = await rpc.SendToAddressAsync(key2.GetP2wpkhAddress(network), Money.Coins(0.01m));\n\t\t\t\tInterlocked.Exchange(ref _filtersProcessedByWalletCount, 0);\n\t\t\t\tawait rpc.GenerateAsync(1);\n\t\t\t\tvar txId3 = await rpc.SendToAddressAsync(key2.GetP2wpkhAddress(network), Money.Coins(0.02m));\n\t\t\t\tawait rpc.GenerateAsync(1);\n\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), 2);\n\t\t\t\tAssert.Equal(3, await wallet.CountBlocksAsync());\n\n\t\t\t\tAssert.Equal(3, wallet.Coins.Count());\n\t\t\t\tfirstCoin = wallet.Coins.OrderBy(x => x.Height).First();\n\t\t\t\tvar secondCoin = wallet.Coins.OrderBy(x => x.Height).Take(2).Last();\n\t\t\t\tvar thirdCoin = wallet.Coins.OrderBy(x => x.Height).Last();\n\t\t\t\tAssert.Equal(Money.Coins(0.01m), secondCoin.Amount);\n\t\t\t\tAssert.Equal(Money.Coins(0.02m), thirdCoin.Amount);\n\t\t\t\tAssert.Equal(new Height(bitcoinStore.SmartHeaderChain.TipHeight).Value - 2, firstCoin.Height.Value);\n\t\t\t\tAssert.Equal(new Height(bitcoinStore.SmartHeaderChain.TipHeight).Value - 1, secondCoin.Height.Value);\n\t\t\t\tAssert.Equal(new Height(bitcoinStore.SmartHeaderChain.TipHeight), thirdCoin.Height);\n\t\t\t\tAssert.False(thirdCoin.Unavailable);\n\t\t\t\tAssert.Equal(\"foo label\", firstCoin.Label);\n\t\t\t\tAssert.Equal(\"bar label\", secondCoin.Label);\n\t\t\t\tAssert.Equal(\"bar label\", thirdCoin.Label);\n\t\t\t\tAssert.Equal(key.P2wpkhScript, firstCoin.ScriptPubKey);\n\t\t\t\tAssert.Equal(key2.P2wpkhScript, secondCoin.ScriptPubKey);\n\t\t\t\tAssert.Equal(key2.P2wpkhScript, thirdCoin.ScriptPubKey);\n\t\t\t\tAssert.Null(thirdCoin.SpenderTransactionId);\n\t\t\t\tAssert.NotNull(firstCoin.SpentOutputs);\n\t\t\t\tAssert.NotNull(secondCoin.SpentOutputs);\n\t\t\t\tAssert.NotNull(thirdCoin.SpentOutputs);\n\t\t\t\tAssert.NotEmpty(firstCoin.SpentOutputs);\n\t\t\t\tAssert.NotEmpty(secondCoin.SpentOutputs);\n\t\t\t\tAssert.NotEmpty(thirdCoin.SpentOutputs);\n\t\t\t\tAssert.Equal(txId, firstCoin.TransactionId);\n\t\t\t\tAssert.Equal(txId2, secondCoin.TransactionId);\n\t\t\t\tAssert.Equal(txId3, thirdCoin.TransactionId);\n\n\t\t\t\tAssert.Equal(2, keyManager.GetKeys(KeyState.Used, false).Count());\n\t\t\t\tAssert.Empty(keyManager.GetKeys(KeyState.Used, true));\n\t\t\t\tAssert.Equal(2, keyManager.GetKeys(KeyState.Used).Count());\n\t\t\t\tAssert.Empty(keyManager.GetKeys(KeyState.Locked, false));\n\t\t\t\tAssert.Equal(14, keyManager.GetKeys(KeyState.Locked, true).Count());\n\t\t\t\tAssert.Equal(14, keyManager.GetKeys(KeyState.Locked).Count());\n\t\t\t\tAssert.Equal(21, keyManager.GetKeys(KeyState.Clean, true).Count());\n\t\t\t\tAssert.Equal(21, keyManager.GetKeys(KeyState.Clean, false).Count());\n\t\t\t\tAssert.Equal(42, keyManager.GetKeys(KeyState.Clean).Count());\n\t\t\t\tAssert.Equal(58, keyManager.GetKeys().Count());\n\n\t\t\t\tAssert.Single(keyManager.GetKeys(x => x.Label == \"foo label\" && x.KeyState == KeyState.Used && !x.IsInternal));\n\t\t\t\tAssert.Single(keyManager.GetKeys(x => x.Label == \"bar label\" && x.KeyState == KeyState.Used && !x.IsInternal));\n\n\t\t\t\t\/\/ REORG TESTS\n\t\t\t\tvar txId4 = await rpc.SendToAddressAsync(key2.GetP2wpkhAddress(network), Money.Coins(0.03m), replaceable: true);\n\t\t\t\tInterlocked.Exchange(ref _filtersProcessedByWalletCount, 0);\n\t\t\t\tawait rpc.GenerateAsync(2);\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), 2);\n\n\t\t\t\tAssert.NotEmpty(wallet.Coins.Where(x => x.TransactionId == txId4));\n\t\t\t\tvar tip = await rpc.GetBestBlockHashAsync();\n\t\t\t\tawait rpc.InvalidateBlockAsync(tip); \/\/ Reorg 1\n\t\t\t\ttip = await rpc.GetBestBlockHashAsync();\n\t\t\t\tawait rpc.InvalidateBlockAsync(tip); \/\/ Reorg 2\n\t\t\t\tvar tx4bumpRes = await rpc.BumpFeeAsync(txId4); \/\/ RBF it\n\t\t\t\tInterlocked.Exchange(ref _filtersProcessedByWalletCount, 0);\n\t\t\t\tawait rpc.GenerateAsync(3);\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), 3);\n\t\t\t\tAssert.Equal(4, await wallet.CountBlocksAsync());\n\n\t\t\t\tAssert.Equal(4, wallet.Coins.Count());\n\t\t\t\tAssert.Empty(wallet.Coins.Where(x => x.TransactionId == txId4));\n\t\t\t\tAssert.NotEmpty(wallet.Coins.Where(x => x.TransactionId == tx4bumpRes.TransactionId));\n\t\t\t\tvar rbfCoin = wallet.Coins.Single(x => x.TransactionId == tx4bumpRes.TransactionId);\n\n\t\t\t\tAssert.Equal(Money.Coins(0.03m), rbfCoin.Amount);\n\t\t\t\tAssert.Equal(new Height(bitcoinStore.SmartHeaderChain.TipHeight).Value - 2, rbfCoin.Height.Value);\n\t\t\t\tAssert.False(rbfCoin.Unavailable);\n\t\t\t\tAssert.Equal(\"bar label\", rbfCoin.Label);\n\t\t\t\tAssert.Equal(key2.P2wpkhScript, rbfCoin.ScriptPubKey);\n\t\t\t\tAssert.Null(rbfCoin.SpenderTransactionId);\n\t\t\t\tAssert.NotNull(rbfCoin.SpentOutputs);\n\t\t\t\tAssert.NotEmpty(rbfCoin.SpentOutputs);\n\t\t\t\tAssert.Equal(tx4bumpRes.TransactionId, rbfCoin.TransactionId);\n\n\t\t\t\tAssert.Equal(2, keyManager.GetKeys(KeyState.Used, false).Count());\n\t\t\t\tAssert.Empty(keyManager.GetKeys(KeyState.Used, true));\n\t\t\t\tAssert.Equal(2, keyManager.GetKeys(KeyState.Used).Count());\n\t\t\t\tAssert.Empty(keyManager.GetKeys(KeyState.Locked, false));\n\t\t\t\tAssert.Equal(14, keyManager.GetKeys(KeyState.Locked, true).Count());\n\t\t\t\tAssert.Equal(14, keyManager.GetKeys(KeyState.Locked).Count());\n\t\t\t\tAssert.Equal(21, keyManager.GetKeys(KeyState.Clean, true).Count());\n\t\t\t\tAssert.Equal(21, keyManager.GetKeys(KeyState.Clean, false).Count());\n\t\t\t\tAssert.Equal(42, keyManager.GetKeys(KeyState.Clean).Count());\n\t\t\t\tAssert.Equal(58, keyManager.GetKeys().Count());\n\n\t\t\t\tAssert.Single(keyManager.GetKeys(KeyState.Used, false).Where(x => x.Label == \"foo label\"));\n\t\t\t\tAssert.Single(keyManager.GetKeys(KeyState.Used, false).Where(x => x.Label == \"bar label\"));\n\n\t\t\t\t\/\/ TEST MEMPOOL\n\t\t\t\tvar txId5 = await rpc.SendToAddressAsync(key.GetP2wpkhAddress(network), Money.Coins(0.1m));\n\t\t\t\tawait Task.Delay(1000); \/\/ Wait tx to arrive and get processed.\n\t\t\t\tAssert.NotEmpty(wallet.Coins.Where(x => x.TransactionId == txId5));\n\t\t\t\tvar mempoolCoin = wallet.Coins.Single(x => x.TransactionId == txId5);\n\t\t\t\tAssert.Equal(Height.Mempool, mempoolCoin.Height);\n\n\t\t\t\tInterlocked.Exchange(ref _filtersProcessedByWalletCount, 0);\n\t\t\t\tawait rpc.GenerateAsync(1);\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), 1);\n\t\t\t\tvar res = await rpc.GetTxOutAsync(mempoolCoin.TransactionId, (int)mempoolCoin.Index, true);\n\t\t\t\tAssert.Equal(new Height(bitcoinStore.SmartHeaderChain.TipHeight), mempoolCoin.Height);\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\twallet.NewFilterProcessed -= Wallet_NewFilterProcessed;\n\t\t\t\twallet?.Dispose();\n\t\t\t\t\/\/ Dispose wasabi synchronizer service.\n\t\t\t\tawait synchronizer?.StopAsync();\n\n\t\t\t\t\/\/ Dispose connection service.\n\t\t\t\tnodes?.Dispose();\n\n\t\t\t\t\/\/ Dispose mempool serving node.\n\t\t\t\tnode?.Disconnect();\n\n\t\t\t\t\/\/ Dispose chaumian coinjoin client.\n\t\t\t\tif (chaumianClient != null)\n\t\t\t\t{\n\t\t\t\t\tawait chaumianClient.StopAsync();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate async Task WaitForFiltersToBeProcessedAsync(TimeSpan timeout, int numberOfFiltersToWaitFor)\n\t\t{\n\t\t\tvar times = 0;\n\t\t\twhile (Interlocked.Read(ref _filtersProcessedByWalletCount) < numberOfFiltersToWaitFor)\n\t\t\t{\n\t\t\t\tif (times > timeout.TotalSeconds)\n\t\t\t\t{\n\t\t\t\t\tthrow new TimeoutException($\"{nameof(WalletService)} test timed out. Filter was not processed. Needed: {numberOfFiltersToWaitFor}, got only: {Interlocked.Read(ref _filtersProcessedByWalletCount)}.\");\n\t\t\t\t}\n\t\t\t\tawait Task.Delay(TimeSpan.FromSeconds(1));\n\t\t\t\ttimes++;\n\t\t\t}\n\t\t}\n\n\t\tprivate long _filtersProcessedByWalletCount;\n\n\t\tprivate void Wallet_NewFilterProcessed(object sender, FilterModel e)\n\t\t{\n\t\t\tInterlocked.Increment(ref _filtersProcessedByWalletCount);\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task SendTestsAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\t\/\/ Create the services.\n\t\t\t\/\/ 1. Create connection service.\n\t\t\tvar nodes = new NodesGroup(global.Config.Network, requirements: Constants.NodeRequirements);\n\t\t\tnodes.ConnectedNodes.Add(await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync());\n\n\t\t\t\/\/ 2. Create mempool service.\n\n\t\t\tNode node = await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync();\n\t\t\tnode.Behaviors.Add(bitcoinStore.CreateUntrustedP2pBehavior());\n\n\t\t\t\/\/ 3. Create wasabi synchronizer service.\n\t\t\tvar synchronizer = new WasabiSynchronizer(rpc.Network, bitcoinStore, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\t\/\/ 4. Create key manager service.\n\t\t\tvar keyManager = KeyManager.CreateNew(out _, password);\n\n\t\t\t\/\/ 5. Create chaumian coinjoin client.\n\t\t\tvar chaumianClient = new CoinJoinClient(synchronizer, rpc.Network, keyManager, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\t\/\/ 6. Create wallet service.\n\t\t\tvar workDir = GetWorkDir();\n\t\t\tvar wallet = new WalletService(bitcoinStore, keyManager, synchronizer, chaumianClient, nodes, workDir, serviceConfiguration, synchronizer);\n\t\t\twallet.NewFilterProcessed += Wallet_NewFilterProcessed;\n\n\t\t\t\/\/ Get some money, make it confirm.\n\t\t\tvar key = keyManager.GetNextReceiveKey(\"foo label\", out _);\n\t\t\tvar key2 = keyManager.GetNextReceiveKey(\"foo label\", out _);\n\t\t\tvar txId = await rpc.SendToAddressAsync(key.GetP2wpkhAddress(network), Money.Coins(1m));\n\t\t\tAssert.NotNull(txId);\n\t\t\tawait rpc.GenerateAsync(1);\n\t\t\tvar txId2 = await rpc.SendToAddressAsync(key2.GetP2wpkhAddress(network), Money.Coins(1m));\n\t\t\tAssert.NotNull(txId2);\n\t\t\tawait rpc.GenerateAsync(1);\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tInterlocked.Exchange(ref _filtersProcessedByWalletCount, 0);\n\t\t\t\tnodes.Connect(); \/\/ Start connection service.\n\t\t\t\tnode.VersionHandshake(); \/\/ Start mempool service.\n\t\t\t\tsynchronizer.Start(requestInterval: TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(5), 10000); \/\/ Start wasabi synchronizer service.\n\t\t\t\tchaumianClient.Start(); \/\/ Start chaumian coinjoin client.\n\n\t\t\t\t\/\/ Wait until the filter our previous transaction is present.\n\t\t\t\tvar blockCount = await rpc.GetBlockCountAsync();\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), blockCount);\n\n\t\t\t\tusing (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30)))\n\t\t\t\t{\n\t\t\t\t\tawait wallet.InitializeAsync(cts.Token); \/\/ Initialize wallet service.\n\t\t\t\t}\n\t\t\t\tvar broadcaster = new TransactionBroadcaster(network, bitcoinStore, synchronizer, nodes, rpc);\n\t\t\t\tbroadcaster.AddWalletService(wallet);\n\n\t\t\t\tvar waitCount = 0;\n\t\t\t\twhile (wallet.Coins.Sum(x => x.Amount) == Money.Zero)\n\t\t\t\t{\n\t\t\t\t\tawait Task.Delay(1000);\n\t\t\t\t\twaitCount++;\n\t\t\t\t\tif (waitCount >= 21)\n\t\t\t\t\t{\n\t\t\t\t\t\tLogger.LogInfo(\"Funding transaction to the wallet did not arrive.\");\n\t\t\t\t\t\treturn; \/\/ Very rarely this test fails. I have no clue why. Probably because all these RegTests are interconnected, anyway let's not bother the CI with it.\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar scp = new Key().ScriptPubKey;\n\t\t\t\tvar res2 = wallet.BuildTransaction(password, new PaymentIntent(scp, Money.Coins(0.05m), label: \"foo\"), FeeStrategy.CreateFromConfirmationTarget(5), allowUnconfirmed: false);\n\n\t\t\t\tAssert.NotNull(res2.Transaction);\n\t\t\t\tAssert.Single(res2.OuterWalletOutputs);\n\t\t\t\tAssert.Equal(scp, res2.OuterWalletOutputs.Single().ScriptPubKey);\n\t\t\t\tAssert.Single(res2.InnerWalletOutputs);\n\t\t\t\tAssert.True(res2.Fee > Money.Satoshis(2 * 100)); \/\/ since there is a sanity check of 2sat\/vb in the server\n\t\t\t\tAssert.InRange(res2.FeePercentOfSent, 0, 1);\n\t\t\t\tAssert.Single(res2.SpentCoins);\n\t\t\t\tvar spentCoin = Assert.Single(res2.SpentCoins);\n\t\t\t\tAssert.Contains(new[] { key.P2wpkhScript, key2.P2wpkhScript }, x => x == spentCoin.ScriptPubKey);\n\t\t\t\tAssert.Equal(Money.Coins(1m), res2.SpentCoins.Single().Amount);\n\t\t\t\tAssert.False(res2.SpendsUnconfirmed);\n\n\t\t\t\tawait broadcaster.SendTransactionAsync(res2.Transaction);\n\n\t\t\t\tAssert.Contains(res2.InnerWalletOutputs.Single(), wallet.Coins);\n\n\t\t\t\t#region Basic\n\n\t\t\t\tScript receive = keyManager.GetNextReceiveKey(\"Basic\", out _).P2wpkhScript;\n\t\t\t\tMoney amountToSend = wallet.Coins.Where(x => !x.Unavailable).Sum(x => x.Amount) \/ 2;\n\t\t\t\tvar res = wallet.BuildTransaction(password, new PaymentIntent(receive, amountToSend, label: \"foo\"), FeeStrategy.SevenDaysConfirmationTargetStrategy, allowUnconfirmed: true);\n\n\t\t\t\tforeach (SmartCoin coin in res.SpentCoins)\n\t\t\t\t{\n\t\t\t\t\tAssert.False(coin.CoinJoinInProgress);\n\t\t\t\t\tAssert.True(coin.Confirmed);\n\t\t\t\t\tAssert.Null(coin.SpenderTransactionId);\n\t\t\t\t\tAssert.True(coin.Unspent);\n\t\t\t\t}\n\n\t\t\t\tAssert.Equal(2, res.InnerWalletOutputs.Count());\n\t\t\t\tAssert.Empty(res.OuterWalletOutputs);\n\t\t\t\tvar activeOutput = res.InnerWalletOutputs.Single(x => x.ScriptPubKey == receive);\n\t\t\t\tvar changeOutput = res.InnerWalletOutputs.Single(x => x.ScriptPubKey != receive);\n\n\t\t\t\tAssert.Equal(receive, activeOutput.ScriptPubKey);\n\t\t\t\tAssert.Equal(amountToSend, activeOutput.Amount);\n\t\t\t\tif (res.SpentCoins.Sum(x => x.Amount) - activeOutput.Amount == res.Fee) \/\/ this happens when change is too small\n\t\t\t\t{\n\t\t\t\t\tAssert.Contains(res.Transaction.Transaction.Outputs, x => x.Value == activeOutput.Amount);\n\t\t\t\t\tLogger.LogInfo($\"Change Output: {changeOutput.Amount.ToString(false, true)} {changeOutput.ScriptPubKey.GetDestinationAddress(network)}\");\n\t\t\t\t}\n\t\t\t\tLogger.LogInfo($\"{nameof(res.Fee)}: {res.Fee}\");\n\t\t\t\tLogger.LogInfo($\"{nameof(res.FeePercentOfSent)}: {res.FeePercentOfSent} %\");\n\t\t\t\tLogger.LogInfo($\"{nameof(res.SpendsUnconfirmed)}: {res.SpendsUnconfirmed}\");\n\t\t\t\tLogger.LogInfo($\"Active Output: {activeOutput.Amount.ToString(false, true)} {activeOutput.ScriptPubKey.GetDestinationAddress(network)}\");\n\t\t\t\tLogger.LogInfo($\"TxId: {res.Transaction.GetHash()}\");\n\n\t\t\t\tvar foundReceive = false;\n\t\t\t\tAssert.InRange(res.Transaction.Transaction.Outputs.Count, 1, 2);\n\t\t\t\tforeach (var output in res.Transaction.Transaction.Outputs)\n\t\t\t\t{\n\t\t\t\t\tif (output.ScriptPubKey == receive)\n\t\t\t\t\t{\n\t\t\t\t\t\tfoundReceive = true;\n\t\t\t\t\t\tAssert.Equal(amountToSend, output.Value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tAssert.True(foundReceive);\n\n\t\t\t\tawait broadcaster.SendTransactionAsync(res.Transaction);\n\n\t\t\t\t#endregion Basic\n\n\t\t\t\t#region SubtractFeeFromAmount\n\n\t\t\t\treceive = keyManager.GetNextReceiveKey(\"SubtractFeeFromAmount\", out _).P2wpkhScript;\n\t\t\t\tamountToSend = wallet.Coins.Where(x => !x.Unavailable).Sum(x => x.Amount) \/ 3;\n\t\t\t\tres = wallet.BuildTransaction(password, new PaymentIntent(receive, amountToSend, subtractFee: true, label: \"foo\"), FeeStrategy.SevenDaysConfirmationTargetStrategy, allowUnconfirmed: true);\n\n\t\t\t\tAssert.Equal(2, res.InnerWalletOutputs.Count());\n\t\t\t\tAssert.Empty(res.OuterWalletOutputs);\n\t\t\t\tactiveOutput = res.InnerWalletOutputs.Single(x => x.ScriptPubKey == receive);\n\t\t\t\tchangeOutput = res.InnerWalletOutputs.Single(x => x.ScriptPubKey != receive);\n\n\t\t\t\tAssert.Equal(receive, activeOutput.ScriptPubKey);\n\t\t\t\tAssert.Equal(amountToSend - res.Fee, activeOutput.Amount);\n\t\t\t\tAssert.Contains(res.Transaction.Transaction.Outputs, x => x.Value == changeOutput.Amount);\n\t\t\t\tLogger.LogInfo($\"{nameof(res.Fee)}: {res.Fee}\");\n\t\t\t\tLogger.LogInfo($\"{nameof(res.FeePercentOfSent)}: {res.FeePercentOfSent} %\");\n\t\t\t\tLogger.LogInfo($\"{nameof(res.SpendsUnconfirmed)}: {res.SpendsUnconfirmed}\");\n\t\t\t\tLogger.LogInfo($\"Active Output: {activeOutput.Amount.ToString(false, true)} {activeOutput.ScriptPubKey.GetDestinationAddress(network)}\");\n\t\t\t\tLogger.LogInfo($\"Change Output: {changeOutput.Amount.ToString(false, true)} {changeOutput.ScriptPubKey.GetDestinationAddress(network)}\");\n\t\t\t\tLogger.LogInfo($\"TxId: {res.Transaction.GetHash()}\");\n\n\t\t\t\tfoundReceive = false;\n\t\t\t\tAssert.InRange(res.Transaction.Transaction.Outputs.Count, 1, 2);\n\t\t\t\tforeach (var output in res.Transaction.Transaction.Outputs)\n\t\t\t\t{\n\t\t\t\t\tif (output.ScriptPubKey == receive)\n\t\t\t\t\t{\n\t\t\t\t\t\tfoundReceive = true;\n\t\t\t\t\t\tAssert.Equal(amountToSend - res.Fee, output.Value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tAssert.True(foundReceive);\n\n\t\t\t\t#endregion SubtractFeeFromAmount\n\n\t\t\t\t#region LowFee\n\n\t\t\t\tres = wallet.BuildTransaction(password, new PaymentIntent(receive, amountToSend, label: \"foo\"), FeeStrategy.SevenDaysConfirmationTargetStrategy, allowUnconfirmed: true);\n\n\t\t\t\tAssert.Equal(2, res.InnerWalletOutputs.Count());\n\t\t\t\tAssert.Empty(res.OuterWalletOutputs);\n\t\t\t\tactiveOutput = res.InnerWalletOutputs.Single(x => x.ScriptPubKey == receive);\n\t\t\t\tchangeOutput = res.InnerWalletOutputs.Single(x => x.ScriptPubKey != receive);\n\n\t\t\t\tAssert.Equal(receive, activeOutput.ScriptPubKey);\n\t\t\t\tAssert.Equal(amountToSend, activeOutput.Amount);\n\t\t\t\tAssert.Contains(res.Transaction.Transaction.Outputs, x => x.Value == changeOutput.Amount);\n\t\t\t\tLogger.LogInfo($\"{nameof(res.Fee)}: {res.Fee}\");\n\t\t\t\tLogger.LogInfo($\"{nameof(res.FeePercentOfSent)}: {res.FeePercentOfSent} %\");\n\t\t\t\tLogger.LogInfo($\"{nameof(res.SpendsUnconfirmed)}: {res.SpendsUnconfirmed}\");\n\t\t\t\tLogger.LogInfo($\"Active Output: {activeOutput.Amount.ToString(false, true)} {activeOutput.ScriptPubKey.GetDestinationAddress(network)}\");\n\t\t\t\tLogger.LogInfo($\"Change Output: {changeOutput.Amount.ToString(false, true)} {changeOutput.ScriptPubKey.GetDestinationAddress(network)}\");\n\t\t\t\tLogger.LogInfo($\"TxId: {res.Transaction.GetHash()}\");\n\n\t\t\t\tfoundReceive = false;\n\t\t\t\tAssert.InRange(res.Transaction.Transaction.Outputs.Count, 1, 2);\n\t\t\t\tforeach (var output in res.Transaction.Transaction.Outputs)\n\t\t\t\t{\n\t\t\t\t\tif (output.ScriptPubKey == receive)\n\t\t\t\t\t{\n\t\t\t\t\t\tfoundReceive = true;\n\t\t\t\t\t\tAssert.Equal(amountToSend, output.Value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tAssert.True(foundReceive);\n\n\t\t\t\t#endregion LowFee\n\n\t\t\t\t#region MediumFee\n\n\t\t\t\tres = wallet.BuildTransaction(password, new PaymentIntent(receive, amountToSend, label: \"foo\"), FeeStrategy.OneDayConfirmationTargetStrategy, allowUnconfirmed: true);\n\n\t\t\t\tAssert.Equal(2, res.InnerWalletOutputs.Count());\n\t\t\t\tAssert.Empty(res.OuterWalletOutputs);\n\t\t\t\tactiveOutput = res.InnerWalletOutputs.Single(x => x.ScriptPubKey == receive);\n\t\t\t\tchangeOutput = res.InnerWalletOutputs.Single(x => x.ScriptPubKey != receive);\n\n\t\t\t\tAssert.Equal(receive, activeOutput.ScriptPubKey);\n\t\t\t\tAssert.Equal(amountToSend, activeOutput.Amount);\n\t\t\t\tAssert.Contains(res.Transaction.Transaction.Outputs, x => x.Value == changeOutput.Amount);\n\t\t\t\tLogger.LogInfo($\"{nameof(res.Fee)}: {res.Fee}\");\n\t\t\t\tLogger.LogInfo($\"{nameof(res.FeePercentOfSent)}: {res.FeePercentOfSent} %\");\n\t\t\t\tLogger.LogInfo($\"{nameof(res.SpendsUnconfirmed)}: {res.SpendsUnconfirmed}\");\n\t\t\t\tLogger.LogInfo($\"Active Output: {activeOutput.Amount.ToString(false, true)} {activeOutput.ScriptPubKey.GetDestinationAddress(network)}\");\n\t\t\t\tLogger.LogInfo($\"Change Output: {changeOutput.Amount.ToString(false, true)} {changeOutput.ScriptPubKey.GetDestinationAddress(network)}\");\n\t\t\t\tLogger.LogInfo($\"TxId: {res.Transaction.GetHash()}\");\n\n\t\t\t\tfoundReceive = false;\n\t\t\t\tAssert.InRange(res.Transaction.Transaction.Outputs.Count, 1, 2);\n\t\t\t\tforeach (var output in res.Transaction.Transaction.Outputs)\n\t\t\t\t{\n\t\t\t\t\tif (output.ScriptPubKey == receive)\n\t\t\t\t\t{\n\t\t\t\t\t\tfoundReceive = true;\n\t\t\t\t\t\tAssert.Equal(amountToSend, output.Value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tAssert.True(foundReceive);\n\n\t\t\t\t#endregion MediumFee\n\n\t\t\t\t#region HighFee\n\n\t\t\t\tres = wallet.BuildTransaction(password, new PaymentIntent(receive, amountToSend, label: \"foo\"), FeeStrategy.TwentyMinutesConfirmationTargetStrategy, allowUnconfirmed: true);\n\n\t\t\t\tAssert.Equal(2, res.InnerWalletOutputs.Count());\n\t\t\t\tAssert.Empty(res.OuterWalletOutputs);\n\t\t\t\tactiveOutput = res.InnerWalletOutputs.Single(x => x.ScriptPubKey == receive);\n\t\t\t\tchangeOutput = res.InnerWalletOutputs.Single(x => x.ScriptPubKey != receive);\n\n\t\t\t\tAssert.Equal(receive, activeOutput.ScriptPubKey);\n\t\t\t\tAssert.Equal(amountToSend, activeOutput.Amount);\n\t\t\t\tAssert.Contains(res.Transaction.Transaction.Outputs, x => x.Value == changeOutput.Amount);\n\t\t\t\tLogger.LogInfo($\"{nameof(res.Fee)}: {res.Fee}\");\n\t\t\t\tLogger.LogInfo($\"{nameof(res.FeePercentOfSent)}: {res.FeePercentOfSent} %\");\n\t\t\t\tLogger.LogInfo($\"{nameof(res.SpendsUnconfirmed)}: {res.SpendsUnconfirmed}\");\n\t\t\t\tLogger.LogInfo($\"Active Output: {activeOutput.Amount.ToString(false, true)} {activeOutput.ScriptPubKey.GetDestinationAddress(network)}\");\n\t\t\t\tLogger.LogInfo($\"Change Output: {changeOutput.Amount.ToString(false, true)} {changeOutput.ScriptPubKey.GetDestinationAddress(network)}\");\n\t\t\t\tLogger.LogInfo($\"TxId: {res.Transaction.GetHash()}\");\n\n\t\t\t\tfoundReceive = false;\n\t\t\t\tAssert.InRange(res.Transaction.Transaction.Outputs.Count, 1, 2);\n\t\t\t\tforeach (var output in res.Transaction.Transaction.Outputs)\n\t\t\t\t{\n\t\t\t\t\tif (output.ScriptPubKey == receive)\n\t\t\t\t\t{\n\t\t\t\t\t\tfoundReceive = true;\n\t\t\t\t\t\tAssert.Equal(amountToSend, output.Value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tAssert.True(foundReceive);\n\n\t\t\t\tAssert.InRange(res.Fee, Money.Zero, res.Fee);\n\t\t\t\tAssert.InRange(res.Fee, res.Fee, res.Fee);\n\n\t\t\t\tawait broadcaster.SendTransactionAsync(res.Transaction);\n\n\t\t\t\t#endregion HighFee\n\n\t\t\t\t#region MaxAmount\n\n\t\t\t\treceive = keyManager.GetNextReceiveKey(\"MaxAmount\", out _).P2wpkhScript;\n\n\t\t\t\tres = wallet.BuildTransaction(password, new PaymentIntent(receive, MoneyRequest.CreateAllRemaining(), \"foo\"), FeeStrategy.SevenDaysConfirmationTargetStrategy, allowUnconfirmed: true);\n\n\t\t\t\tAssert.Single(res.InnerWalletOutputs);\n\t\t\t\tAssert.Empty(res.OuterWalletOutputs);\n\t\t\t\tactiveOutput = res.InnerWalletOutputs.Single();\n\n\t\t\t\tAssert.Equal(receive, activeOutput.ScriptPubKey);\n\n\t\t\t\tAssert.Single(res.Transaction.Transaction.Outputs);\n\t\t\t\tvar maxBuiltTxOutput = res.Transaction.Transaction.Outputs.Single();\n\t\t\t\tAssert.Equal(receive, maxBuiltTxOutput.ScriptPubKey);\n\t\t\t\tAssert.Equal(wallet.Coins.Where(x => !x.Unavailable).Sum(x => x.Amount) - res.Fee, maxBuiltTxOutput.Value);\n\n\t\t\t\tawait broadcaster.SendTransactionAsync(res.Transaction);\n\n\t\t\t\t#endregion MaxAmount\n\n\t\t\t\t#region InputSelection\n\n\t\t\t\treceive = keyManager.GetNextReceiveKey(\"InputSelection\", out _).P2wpkhScript;\n\n\t\t\t\tvar inputCountBefore = res.SpentCoins.Count();\n\n\t\t\t\tres = wallet.BuildTransaction(password, new PaymentIntent(receive, MoneyRequest.CreateAllRemaining(), \"foo\"), FeeStrategy.SevenDaysConfirmationTargetStrategy,\n\t\t\t\t\tallowUnconfirmed: true,\n\t\t\t\t\tallowedInputs: wallet.Coins.Where(x => !x.Unavailable).Select(x => new TxoRef(x.TransactionId, x.Index)).Take(1));\n\n\t\t\t\tAssert.Single(res.InnerWalletOutputs);\n\t\t\t\tAssert.Empty(res.OuterWalletOutputs);\n\t\t\t\tactiveOutput = res.InnerWalletOutputs.Single(x => x.ScriptPubKey == receive);\n\n\t\t\t\tAssert.True(inputCountBefore >= res.SpentCoins.Count());\n\t\t\t\tAssert.Equal(res.SpentCoins.Count(), res.Transaction.Transaction.Inputs.Count);\n\n\t\t\t\tAssert.Equal(receive, activeOutput.ScriptPubKey);\n\t\t\t\tLogger.LogInfo($\"{nameof(res.Fee)}: {res.Fee}\");\n\t\t\t\tLogger.LogInfo($\"{nameof(res.FeePercentOfSent)}: {res.FeePercentOfSent} %\");\n\t\t\t\tLogger.LogInfo($\"{nameof(res.SpendsUnconfirmed)}: {res.SpendsUnconfirmed}\");\n\t\t\t\tLogger.LogInfo($\"Active Output: {activeOutput.Amount.ToString(false, true)} {activeOutput.ScriptPubKey.GetDestinationAddress(network)}\");\n\t\t\t\tLogger.LogInfo($\"TxId: {res.Transaction.GetHash()}\");\n\n\t\t\t\tAssert.Single(res.Transaction.Transaction.Outputs);\n\n\t\t\t\tres = wallet.BuildTransaction(password, new PaymentIntent(receive, MoneyRequest.CreateAllRemaining(), \"foo\"), FeeStrategy.SevenDaysConfirmationTargetStrategy,\n\t\t\t\t\tallowUnconfirmed: true,\n\t\t\t\t\tallowedInputs: new[] { res.SpentCoins.Select(x => new TxoRef(x.TransactionId, x.Index)).First() });\n\n\t\t\t\tAssert.Single(res.InnerWalletOutputs);\n\t\t\t\tAssert.Empty(res.OuterWalletOutputs);\n\t\t\t\tactiveOutput = res.InnerWalletOutputs.Single(x => x.ScriptPubKey == receive);\n\n\t\t\t\tAssert.Single(res.Transaction.Transaction.Inputs);\n\t\t\t\tAssert.Single(res.Transaction.Transaction.Outputs);\n\t\t\t\tAssert.Single(res.SpentCoins);\n\n\t\t\t\t#endregion InputSelection\n\n\t\t\t\t#region Labeling\n\n\t\t\t\tScript receive2 = keyManager.GetNextReceiveKey(\"foo\", out _).P2wpkhScript;\n\t\t\t\tres = wallet.BuildTransaction(password, new PaymentIntent(receive2, MoneyRequest.CreateAllRemaining(), \"my label\"), FeeStrategy.SevenDaysConfirmationTargetStrategy, allowUnconfirmed: true);\n\n\t\t\t\tAssert.Single(res.InnerWalletOutputs);\n\t\t\t\tAssert.Equal(\"foo, my label\", res.InnerWalletOutputs.Single().Label);\n\n\t\t\t\tamountToSend = wallet.Coins.Where(x => !x.Unavailable).Sum(x => x.Amount) \/ 3;\n\t\t\t\tres = wallet.BuildTransaction(\n\t\t\t\t\tpassword,\n\t\t\t\t\tnew PaymentIntent(\n\t\t\t\t\t\tnew DestinationRequest(new Key(), amountToSend, label: \"outgoing\"),\n\t\t\t\t\t\tnew DestinationRequest(new Key(), amountToSend, label: \"outgoing2\")),\n\t\t\t\t\tFeeStrategy.SevenDaysConfirmationTargetStrategy,\n\t\t\t\t\tallowUnconfirmed: true);\n\n\t\t\t\tAssert.Single(res.InnerWalletOutputs);\n\t\t\t\tAssert.Equal(2, res.OuterWalletOutputs.Count());\n\t\t\t\tIEnumerable<string> change = res.InnerWalletOutputs.Single().Label.Labels;\n\t\t\t\tAssert.Contains(\"outgoing\", change);\n\t\t\t\tAssert.Contains(\"outgoing2\", change);\n\n\t\t\t\tawait broadcaster.SendTransactionAsync(res.Transaction);\n\n\t\t\t\tIEnumerable<SmartCoin> unconfirmedCoins = wallet.Coins.Where(x => x.Height == Height.Mempool).ToArray();\n\t\t\t\tIEnumerable<string> unconfirmedCoinLabels = unconfirmedCoins.SelectMany(x => x.Label.Labels).ToArray();\n\t\t\t\tAssert.Contains(\"outgoing\", unconfirmedCoinLabels);\n\t\t\t\tAssert.Contains(\"outgoing2\", unconfirmedCoinLabels);\n\t\t\t\tIEnumerable<string> allKeyLabels = keyManager.GetKeys().SelectMany(x => x.Label.Labels);\n\t\t\t\tAssert.Contains(\"outgoing\", allKeyLabels);\n\t\t\t\tAssert.Contains(\"outgoing2\", allKeyLabels);\n\n\t\t\t\tInterlocked.Exchange(ref _filtersProcessedByWalletCount, 0);\n\t\t\t\tawait rpc.GenerateAsync(1);\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), 1);\n\n\t\t\t\tvar bestHeight = new Height(bitcoinStore.SmartHeaderChain.TipHeight);\n\t\t\t\tIEnumerable<string> confirmedCoinLabels = wallet.Coins.Where(x => x.Height == bestHeight).SelectMany(x => x.Label.Labels);\n\t\t\t\tAssert.Contains(\"outgoing\", confirmedCoinLabels);\n\t\t\t\tAssert.Contains(\"outgoing2\", confirmedCoinLabels);\n\t\t\t\tallKeyLabels = keyManager.GetKeys().SelectMany(x => x.Label.Labels);\n\t\t\t\tAssert.Contains(\"outgoing\", allKeyLabels);\n\t\t\t\tAssert.Contains(\"outgoing2\", allKeyLabels);\n\n\t\t\t\t#endregion Labeling\n\n\t\t\t\t#region AllowedInputsDisallowUnconfirmed\n\n\t\t\t\tinputCountBefore = res.SpentCoins.Count();\n\n\t\t\t\treceive = keyManager.GetNextReceiveKey(\"AllowedInputsDisallowUnconfirmed\", out _).P2wpkhScript;\n\n\t\t\t\tvar allowedInputs = wallet.Coins.Where(x => !x.Unavailable).Select(x => new TxoRef(x.TransactionId, x.Index)).Take(1);\n\t\t\t\tvar toSend = new PaymentIntent(receive, MoneyRequest.CreateAllRemaining(), \"fizz\");\n\n\t\t\t\t\/\/ covers:\n\t\t\t\t\/\/ disallow unconfirmed with allowed inputs\n\t\t\t\tres = wallet.BuildTransaction(password, toSend, FeeStrategy.TwentyMinutesConfirmationTargetStrategy, false, allowedInputs: allowedInputs);\n\n\t\t\t\tactiveOutput = res.InnerWalletOutputs.Single(x => x.ScriptPubKey == receive);\n\t\t\t\tAssert.Single(res.InnerWalletOutputs);\n\t\t\t\tAssert.Empty(res.OuterWalletOutputs);\n\n\t\t\t\tAssert.Equal(receive, activeOutput.ScriptPubKey);\n\t\t\t\tLogger.LogDebug($\"{nameof(res.Fee)}: {res.Fee}\");\n\t\t\t\tLogger.LogDebug($\"{nameof(res.FeePercentOfSent)}: {res.FeePercentOfSent} %\");\n\t\t\t\tLogger.LogDebug($\"{nameof(res.SpendsUnconfirmed)}: {res.SpendsUnconfirmed}\");\n\t\t\t\tLogger.LogDebug($\"Active Output: {activeOutput.Amount.ToString(false, true)} {activeOutput.ScriptPubKey.GetDestinationAddress(network)}\");\n\t\t\t\tLogger.LogDebug($\"TxId: {res.Transaction.GetHash()}\");\n\n\t\t\t\tAssert.True(inputCountBefore >= res.SpentCoins.Count());\n\t\t\t\tAssert.False(res.SpendsUnconfirmed);\n\n\t\t\t\tAssert.Single(res.Transaction.Transaction.Inputs);\n\t\t\t\tAssert.Single(res.Transaction.Transaction.Outputs);\n\t\t\t\tAssert.Single(res.SpentCoins);\n\n\t\t\t\tAssert.True(inputCountBefore >= res.SpentCoins.Count());\n\t\t\t\tAssert.Equal(res.SpentCoins.Count(), res.Transaction.Transaction.Inputs.Count);\n\n\t\t\t\t#endregion AllowedInputsDisallowUnconfirmed\n\n\t\t\t\t#region CustomChange\n\n\t\t\t\t\/\/ covers:\n\t\t\t\t\/\/ customchange\n\t\t\t\t\/\/ feePc > 1\n\t\t\t\tvar k1 = new Key();\n\t\t\t\tvar k2 = new Key();\n\t\t\t\tres = wallet.BuildTransaction(\n\t\t\t\t\tpassword,\n\t\t\t\t\tnew PaymentIntent(\n\t\t\t\t\t\tnew DestinationRequest(k1, MoneyRequest.CreateChange()),\n\t\t\t\t\t\tnew DestinationRequest(k2, Money.Coins(0.0003m), label: \"outgoing\")),\n\t\t\t\t\tFeeStrategy.TwentyMinutesConfirmationTargetStrategy);\n\n\t\t\t\tAssert.Contains(k1.ScriptPubKey, res.OuterWalletOutputs.Select(x => x.ScriptPubKey));\n\t\t\t\tAssert.Contains(k2.ScriptPubKey, res.OuterWalletOutputs.Select(x => x.ScriptPubKey));\n\n\t\t\t\t#endregion CustomChange\n\n\t\t\t\t#region FeePcHigh\n\n\t\t\t\tres = wallet.BuildTransaction(\n\t\t\t\t\tpassword,\n\t\t\t\t\tnew PaymentIntent(new Key(), Money.Coins(0.0003m), label: \"outgoing\"),\n\t\t\t\t\tFeeStrategy.TwentyMinutesConfirmationTargetStrategy);\n\n\t\t\t\tAssert.True(res.FeePercentOfSent > 1);\n\n\t\t\t\tvar newChangeK = keyManager.GenerateNewKey(\"foo\", KeyState.Clean, isInternal: true);\n\t\t\t\tres = wallet.BuildTransaction(\n\t\t\t\t\tpassword,\n\t\t\t\t\tnew PaymentIntent(\n\t\t\t\t\t\tnew DestinationRequest(newChangeK.P2wpkhScript, MoneyRequest.CreateChange(), \"boo\"),\n\t\t\t\t\t\tnew DestinationRequest(new Key(), Money.Coins(0.0003m), label: \"outgoing\")),\n\t\t\t\t\tFeeStrategy.TwentyMinutesConfirmationTargetStrategy);\n\n\t\t\t\tAssert.True(res.FeePercentOfSent > 1);\n\t\t\t\tAssert.Single(res.OuterWalletOutputs);\n\t\t\t\tAssert.Single(res.InnerWalletOutputs);\n\t\t\t\tSmartCoin changeRes = res.InnerWalletOutputs.Single();\n\t\t\t\tAssert.Equal(newChangeK.P2wpkhScript, changeRes.ScriptPubKey);\n\t\t\t\tAssert.Equal(newChangeK.Label, changeRes.Label);\n\t\t\t\tAssert.Equal(KeyState.Clean, newChangeK.KeyState); \/\/ Still clean, because the tx wasn't yet propagated.\n\n\t\t\t\t#endregion FeePcHigh\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\twallet.NewFilterProcessed -= Wallet_NewFilterProcessed;\n\t\t\t\twallet?.Dispose();\n\t\t\t\t\/\/ Dispose wasabi synchronizer service.\n\t\t\t\tawait synchronizer?.StopAsync();\n\t\t\t\t\/\/ Dispose connection service.\n\t\t\t\tnodes?.Dispose();\n\t\t\t\t\/\/ Dispose mempool serving node.\n\t\t\t\tnode?.Disconnect();\n\t\t\t\t\/\/ Dispose chaumian coinjoin client.\n\t\t\t\tif (chaumianClient != null)\n\t\t\t\t{\n\t\t\t\t\tawait chaumianClient.StopAsync();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task BuildTransactionValidationsTestAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\t\/\/ Create the services.\n\t\t\t\/\/ 1. Create connection service.\n\t\t\tvar nodes = new NodesGroup(global.Config.Network, requirements: Constants.NodeRequirements);\n\t\t\tnodes.ConnectedNodes.Add(await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync());\n\n\t\t\t\/\/ 2. Create mempool service.\n\n\t\t\tNode node = await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync();\n\t\t\tnode.Behaviors.Add(bitcoinStore.CreateUntrustedP2pBehavior());\n\n\t\t\t\/\/ 3. Create wasabi synchronizer service.\n\t\t\tvar synchronizer = new WasabiSynchronizer(rpc.Network, bitcoinStore, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\t\/\/ 4. Create key manager service.\n\t\t\tvar keyManager = KeyManager.CreateNew(out _, password);\n\n\t\t\t\/\/ 5. Create chaumian coinjoin client.\n\t\t\tvar chaumianClient = new CoinJoinClient(synchronizer, rpc.Network, keyManager, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\t\/\/ 6. Create wallet service.\n\t\t\tvar workDir = GetWorkDir();\n\t\t\tvar wallet = new WalletService(bitcoinStore, keyManager, synchronizer, chaumianClient, nodes, workDir, serviceConfiguration, synchronizer);\n\t\t\twallet.NewFilterProcessed += Wallet_NewFilterProcessed;\n\n\t\t\tvar scp = new Key().ScriptPubKey;\n\n\t\t\tvar validIntent = new PaymentIntent(scp, Money.Coins(1));\n\t\t\tvar invalidIntent = new PaymentIntent(\n\t\t\t\tnew DestinationRequest(scp, Money.Coins(10 * 1000 * 1000)),\n\t\t\t\tnew DestinationRequest(scp, Money.Coins(12 * 1000 * 1000)));\n\n\t\t\tAssert.Throws<OverflowException>(() => new PaymentIntent(\n\t\t\t\tnew DestinationRequest(scp, Money.Satoshis(long.MaxValue)),\n\t\t\t\tnew DestinationRequest(scp, Money.Satoshis(long.MaxValue)),\n\t\t\t\tnew DestinationRequest(scp, Money.Satoshis(5))));\n\n\t\t\tLogger.TurnOff();\n\t\t\tAssert.Throws<ArgumentNullException>(() => wallet.BuildTransaction(null, null, FeeStrategy.CreateFromConfirmationTarget(4)));\n\n\t\t\t\/\/ toSend cannot have a null element\n\t\t\tAssert.Throws<ArgumentNullException>(() => wallet.BuildTransaction(null, new PaymentIntent(new[] { (DestinationRequest)null }), FeeStrategy.CreateFromConfirmationTarget(0)));\n\n\t\t\t\/\/ toSend cannot have a zero element\n\t\t\tAssert.Throws<ArgumentException>(() => wallet.BuildTransaction(null, new PaymentIntent(Array.Empty<DestinationRequest>()), FeeStrategy.SevenDaysConfirmationTargetStrategy));\n\n\t\t\t\/\/ feeTarget has to be in the range 0 to 1008\n\t\t\tAssert.Throws<ArgumentOutOfRangeException>(() => wallet.BuildTransaction(null, validIntent, FeeStrategy.CreateFromConfirmationTarget(-10)));\n\t\t\tAssert.Throws<ArgumentOutOfRangeException>(() => wallet.BuildTransaction(null, validIntent, FeeStrategy.CreateFromConfirmationTarget(2000)));\n\n\t\t\t\/\/ toSend amount sum has to be in range 0 to 2099999997690000\n\t\t\tAssert.Throws<ArgumentOutOfRangeException>(() => wallet.BuildTransaction(null, invalidIntent, FeeStrategy.TwentyMinutesConfirmationTargetStrategy));\n\n\t\t\t\/\/ toSend negative sum amount\n\t\t\tAssert.Throws<ArgumentOutOfRangeException>(() => wallet.BuildTransaction(null, new PaymentIntent(scp, Money.Satoshis(-10000)), FeeStrategy.TwentyMinutesConfirmationTargetStrategy));\n\n\t\t\t\/\/ toSend negative operation amount\n\t\t\tAssert.Throws<ArgumentOutOfRangeException>(() => wallet.BuildTransaction(\n\t\t\t\tnull,\n\t\t\t\tnew PaymentIntent(\n\t\t\t\t\tnew DestinationRequest(scp, Money.Satoshis(20000)),\n\t\t\t\t\tnew DestinationRequest(scp, Money.Satoshis(-10000))),\n\t\t\t\tFeeStrategy.TwentyMinutesConfirmationTargetStrategy));\n\n\t\t\t\/\/ allowedInputs cannot be empty\n\t\t\tAssert.Throws<ArgumentException>(() => wallet.BuildTransaction(null, validIntent, FeeStrategy.TwentyMinutesConfirmationTargetStrategy, allowedInputs: Array.Empty<TxoRef>()));\n\n\t\t\t\/\/ \"Only one element can contain the AllRemaining flag.\n\t\t\tAssert.Throws<ArgumentException>(() => wallet.BuildTransaction(\n\t\t\t\tpassword,\n\t\t\t\tnew PaymentIntent(\n\t\t\t\t\tnew DestinationRequest(scp, MoneyRequest.CreateAllRemaining(), \"zero\"),\n\t\t\t\t\tnew DestinationRequest(scp, MoneyRequest.CreateAllRemaining(), \"zero\")),\n\t\t\t\tFeeStrategy.SevenDaysConfirmationTargetStrategy,\n\t\t\t\tfalse));\n\n\t\t\t\/\/ Get some money, make it confirm.\n\t\t\tvar txId = await rpc.SendToAddressAsync(keyManager.GetNextReceiveKey(\"foo\", out _).GetP2wpkhAddress(network), Money.Coins(1m));\n\n\t\t\t\/\/ Generate some coins\n\t\t\tawait rpc.GenerateAsync(2);\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tnodes.Connect(); \/\/ Start connection service.\n\t\t\t\tnode.VersionHandshake(); \/\/ Start mempool service.\n\t\t\t\tsynchronizer.Start(requestInterval: TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(5), 10000); \/\/ Start wasabi synchronizer service.\n\t\t\t\tchaumianClient.Start(); \/\/ Start chaumian coinjoin client.\n\n\t\t\t\t\/\/ Wait until the filter our previous transaction is present.\n\t\t\t\tvar blockCount = await rpc.GetBlockCountAsync();\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), blockCount);\n\n\t\t\t\tusing (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30)))\n\t\t\t\t{\n\t\t\t\t\tawait wallet.InitializeAsync(cts.Token); \/\/ Initialize wallet service.\n\t\t\t\t}\n\n\t\t\t\t\/\/ subtract Fee from amount index with no enough money\n\t\t\t\tvar operations = new PaymentIntent(\n\t\t\t\t\tnew DestinationRequest(scp, Money.Coins(1m), subtractFee: true),\n\t\t\t\t\tnew DestinationRequest(scp, Money.Coins(0.5m)));\n\t\t\t\tAssert.Throws<InsufficientBalanceException>(() => wallet.BuildTransaction(password, operations, FeeStrategy.TwentyMinutesConfirmationTargetStrategy, false));\n\n\t\t\t\t\/\/ No enough money (only one confirmed coin, no unconfirmed allowed)\n\t\t\t\toperations = new PaymentIntent(scp, Money.Coins(1.5m));\n\t\t\t\tAssert.Throws<InsufficientBalanceException>(() => wallet.BuildTransaction(null, operations, FeeStrategy.TwentyMinutesConfirmationTargetStrategy));\n\n\t\t\t\t\/\/ No enough money (only one confirmed coin, unconfirmed allowed)\n\t\t\t\tAssert.Throws<InsufficientBalanceException>(() => wallet.BuildTransaction(null, operations, FeeStrategy.TwentyMinutesConfirmationTargetStrategy, true));\n\n\t\t\t\t\/\/ Add new money with no confirmation\n\t\t\t\tvar txId2 = await rpc.SendToAddressAsync(keyManager.GetNextReceiveKey(\"bar\", out _).GetP2wpkhAddress(network), Money.Coins(2m));\n\t\t\t\tawait Task.Delay(1000); \/\/ Wait tx to arrive and get processed.\n\n\t\t\t\t\/\/ Enough money (one confirmed coin and one unconfirmed coin, unconfirmed are NOT allowed)\n\t\t\t\tAssert.Throws<InsufficientBalanceException>(() => wallet.BuildTransaction(null, operations, FeeStrategy.TwentyMinutesConfirmationTargetStrategy, false));\n\n\t\t\t\t\/\/ Enough money (one unconfirmed coin, unconfirmed are allowed)\n\t\t\t\tvar btx = wallet.BuildTransaction(password, operations, FeeStrategy.TwentyMinutesConfirmationTargetStrategy, true);\n\t\t\t\tvar spentCoin = Assert.Single(btx.SpentCoins);\n\t\t\t\tAssert.False(spentCoin.Confirmed);\n\n\t\t\t\t\/\/ Enough money (one confirmed coin and one unconfirmed coin, unconfirmed are allowed)\n\t\t\t\toperations = new PaymentIntent(scp, Money.Coins(2.5m));\n\t\t\t\tbtx = wallet.BuildTransaction(password, operations, FeeStrategy.TwentyMinutesConfirmationTargetStrategy, true);\n\t\t\t\tAssert.Equal(2, btx.SpentCoins.Count());\n\t\t\t\tAssert.Equal(1, btx.SpentCoins.Count(c => c.Confirmed));\n\t\t\t\tAssert.Equal(1, btx.SpentCoins.Count(c => !c.Confirmed));\n\n\t\t\t\t\/\/ Only one operation with AllRemainingFlag\n\n\t\t\t\tAssert.Throws<ArgumentException>(() => wallet.BuildTransaction(\n\t\t\t\t\tnull,\n\t\t\t\t\tnew PaymentIntent(\n\t\t\t\t\t\tnew DestinationRequest(scp, MoneyRequest.CreateAllRemaining()),\n\t\t\t\t\t\tnew DestinationRequest(scp, MoneyRequest.CreateAllRemaining())),\n\t\t\t\t\tFeeStrategy.TwentyMinutesConfirmationTargetStrategy));\n\n\t\t\t\tLogger.TurnOn();\n\n\t\t\t\toperations = new PaymentIntent(scp, Money.Coins(0.5m));\n\t\t\t\tbtx = wallet.BuildTransaction(password, operations, FeeStrategy.TwentyMinutesConfirmationTargetStrategy);\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\twallet?.Dispose();\n\t\t\t\t\/\/ Dispose wasabi synchronizer service.\n\t\t\t\tawait synchronizer?.StopAsync();\n\t\t\t\t\/\/ Dispose connection service.\n\t\t\t\tnodes?.Dispose();\n\t\t\t\t\/\/ Dispose mempool serving node.\n\t\t\t\tnode?.Disconnect();\n\t\t\t\t\/\/ Dispose chaumian coinjoin client.\n\t\t\t\tif (chaumianClient != null)\n\t\t\t\t{\n\t\t\t\t\tawait chaumianClient.StopAsync();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task BuildTransactionReorgsTestAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\t\/\/ Create the services.\n\t\t\t\/\/ 1. Create connection service.\n\t\t\tvar nodes = new NodesGroup(global.Config.Network, requirements: Constants.NodeRequirements);\n\t\t\tnodes.ConnectedNodes.Add(await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync());\n\n\t\t\t\/\/ 2. Create mempool service.\n\n\t\t\tNode node = await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync();\n\t\t\tnode.Behaviors.Add(bitcoinStore.CreateUntrustedP2pBehavior());\n\n\t\t\t\/\/ 3. Create wasabi synchronizer service.\n\t\t\tvar synchronizer = new WasabiSynchronizer(rpc.Network, bitcoinStore, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\t\/\/ 4. Create key manager service.\n\t\t\tvar keyManager = KeyManager.CreateNew(out _, password);\n\n\t\t\t\/\/ 5. Create chaumian coinjoin client.\n\t\t\tvar chaumianClient = new CoinJoinClient(synchronizer, rpc.Network, keyManager, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\t\/\/ 6. Create wallet service.\n\t\t\tvar workDir = GetWorkDir();\n\t\t\tvar wallet = new WalletService(bitcoinStore, keyManager, synchronizer, chaumianClient, nodes, workDir, serviceConfiguration, synchronizer);\n\t\t\twallet.NewFilterProcessed += Wallet_NewFilterProcessed;\n\n\t\t\tAssert.Empty(wallet.Coins);\n\t\t\tvar baseTip = await rpc.GetBestBlockHashAsync();\n\n\t\t\t\/\/ Generate script\n\t\t\tvar scp = new Key().ScriptPubKey;\n\n\t\t\t\/\/ Get some money, make it confirm.\n\t\t\tvar key = keyManager.GetNextReceiveKey(\"foo label\", out _);\n\t\t\tvar fundingTxId = await rpc.SendToAddressAsync(key.GetP2wpkhAddress(network), Money.Coins(0.1m));\n\n\t\t\t\/\/ Generate some coins\n\t\t\tawait rpc.GenerateAsync(2);\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tnodes.Connect(); \/\/ Start connection service.\n\t\t\t\tnode.VersionHandshake(); \/\/ Start mempool service.\n\t\t\t\tsynchronizer.Start(requestInterval: TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(5), 10000); \/\/ Start wasabi synchronizer service.\n\t\t\t\tchaumianClient.Start(); \/\/ Start chaumian coinjoin client.\n\n\t\t\t\t\/\/ Wait until the filter our previous transaction is present.\n\t\t\t\tvar blockCount = await rpc.GetBlockCountAsync();\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), blockCount);\n\n\t\t\t\tusing (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30)))\n\t\t\t\t{\n\t\t\t\t\tawait wallet.InitializeAsync(cts.Token); \/\/ Initialize wallet service.\n\t\t\t\t}\n\t\t\t\tvar coin = Assert.Single(wallet.Coins);\n\t\t\t\tAssert.True(coin.Confirmed);\n\t\t\t\tvar broadcaster = new TransactionBroadcaster(network, bitcoinStore, synchronizer, nodes, rpc);\n\t\t\t\tbroadcaster.AddWalletService(wallet);\n\n\t\t\t\t\/\/ Send money before reorg.\n\t\t\t\tvar operations = new PaymentIntent(scp, Money.Coins(0.011m));\n\t\t\t\tvar btx1 = wallet.BuildTransaction(password, operations, FeeStrategy.TwentyMinutesConfirmationTargetStrategy);\n\t\t\t\tawait broadcaster.SendTransactionAsync(btx1.Transaction);\n\t\t\t\tvar coin2 = Assert.Single(wallet.Coins);\n\t\t\t\tAssert.NotEqual(coin, coin2);\n\t\t\t\tAssert.False(coin2.Confirmed);\n\n\t\t\t\toperations = new PaymentIntent(scp, Money.Coins(0.012m));\n\t\t\t\tvar btx2 = wallet.BuildTransaction(password, operations, FeeStrategy.TwentyMinutesConfirmationTargetStrategy, allowUnconfirmed: true);\n\t\t\t\tawait broadcaster.SendTransactionAsync(btx2.Transaction);\n\t\t\t\tvar coin3 = Assert.Single(wallet.Coins);\n\t\t\t\tAssert.NotEqual(coin2, coin3);\n\t\t\t\tAssert.False(coin3.Confirmed);\n\n\t\t\t\t\/\/ Test synchronization after fork.\n\t\t\t\t\/\/ Invalidate the blocks containing the funding transaction\n\t\t\t\tvar tip = await rpc.GetBestBlockHashAsync();\n\t\t\t\tawait rpc.InvalidateBlockAsync(tip); \/\/ Reorg 1\n\t\t\t\ttip = await rpc.GetBestBlockHashAsync();\n\t\t\t\tawait rpc.InvalidateBlockAsync(tip); \/\/ Reorg 2\n\n\t\t\t\t\/\/ Generate three new blocks (replace the previous invalidated ones)\n\t\t\t\tInterlocked.Exchange(ref _filtersProcessedByWalletCount, 0);\n\t\t\t\tawait rpc.GenerateAsync(3);\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), 3);\n\n\t\t\t\tvar coin4 = Assert.Single(wallet.Coins);\n\t\t\t\tAssert.Equal(coin3, coin4);\n\t\t\t\tAssert.True(coin.Confirmed);\n\t\t\t\tAssert.True(coin2.Confirmed);\n\t\t\t\tAssert.True(coin3.Confirmed);\n\t\t\t\tAssert.True(coin4.Confirmed);\n\n\t\t\t\t\/\/ Send money after reorg.\n\t\t\t\t\/\/ When we invalidate a block, the transactions set in the invalidated block\n\t\t\t\t\/\/ are reintroduced when we generate a new block through the rpc call\n\t\t\t\toperations = new PaymentIntent(scp, Money.Coins(0.013m));\n\t\t\t\tvar btx3 = wallet.BuildTransaction(password, operations, FeeStrategy.TwentyMinutesConfirmationTargetStrategy);\n\t\t\t\tawait broadcaster.SendTransactionAsync(btx3.Transaction);\n\t\t\t\tvar coin5 = Assert.Single(wallet.Coins);\n\t\t\t\tAssert.NotEqual(coin4, coin5);\n\t\t\t\tAssert.False(coin5.Confirmed);\n\n\t\t\t\toperations = new PaymentIntent(scp, Money.Coins(0.014m));\n\t\t\t\tvar btx4 = wallet.BuildTransaction(password, operations, FeeStrategy.TwentyMinutesConfirmationTargetStrategy, allowUnconfirmed: true);\n\t\t\t\tawait broadcaster.SendTransactionAsync(btx4.Transaction);\n\t\t\t\tvar coin6 = Assert.Single(wallet.Coins);\n\t\t\t\tAssert.NotEqual(coin5, coin6);\n\t\t\t\tAssert.False(coin6.Confirmed);\n\n\t\t\t\t\/\/ Test synchronization after fork with different transactions.\n\t\t\t\t\/\/ Create a fork that invalidates the blocks containing the funding transaction\n\t\t\t\tInterlocked.Exchange(ref _filtersProcessedByWalletCount, 0);\n\t\t\t\tawait rpc.InvalidateBlockAsync(baseTip);\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tawait rpc.AbandonTransactionAsync(fundingTxId);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\tif (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t\treturn; \/\/ Occassionally this fails on Linux or OSX, I have no idea why.\n\t\t\t\t}\n\t\t\t\t\/\/ Spend the inputs of the tx so we know\n\t\t\t\tvar success = bitcoinStore.TransactionStore.TryGetTransaction(fundingTxId, out SmartTransaction invalidSmartTransaction);\n\t\t\t\tAssert.True(success);\n\t\t\t\tvar invalidCoin = Assert.Single(((CoinsRegistry)wallet.Coins).AsAllCoinsView().CreatedBy(invalidSmartTransaction.GetHash()));\n\t\t\t\tAssert.True(invalidCoin.SpenderTransactionId != null);\n\t\t\t\tAssert.True(invalidCoin.Confirmed);\n\n\t\t\t\tvar overwriteTx = Transaction.Create(network);\n\t\t\t\toverwriteTx.Inputs.AddRange(invalidSmartTransaction.Transaction.Inputs);\n\t\t\t\tvar walletAddress = keyManager.GetNextReceiveKey(\"foo\", out _).GetP2wpkhAddress(network);\n\t\t\t\tbool onAddress = false;\n\t\t\t\tforeach (var invalidOutput in invalidSmartTransaction.Transaction.Outputs)\n\t\t\t\t{\n\t\t\t\t\tif (onAddress)\n\t\t\t\t\t{\n\t\t\t\t\t\toverwriteTx.Outputs.Add(new TxOut(invalidOutput.Value, new Key().PubKey.GetAddress(ScriptPubKeyType.Segwit, network)));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\toverwriteTx.Outputs.Add(new TxOut(invalidOutput.Value, walletAddress));\n\t\t\t\t\t\tonAddress = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar srtxwwreq = new SignRawTransactionRequest();\n\t\t\t\tsrtxwwreq.Transaction = overwriteTx;\n\t\t\t\tvar srtxwwres = await rpc.SignRawTransactionWithWalletAsync(srtxwwreq);\n\n\t\t\t\tvar eventAwaiter = new EventAwaiter<ProcessedResult>(\n\t\t\t\t\th => wallet.TransactionProcessor.WalletRelevantTransactionProcessed += h,\n\t\t\t\t\th => wallet.TransactionProcessor.WalletRelevantTransactionProcessed -= h);\n\t\t\t\tawait rpc.SendRawTransactionAsync(srtxwwres.SignedTransaction);\n\t\t\t\tawait rpc.GenerateAsync(10);\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), 10);\n\t\t\t\tvar eventArgs = await eventAwaiter.WaitAsync(TimeSpan.FromSeconds(21));\n\t\t\t\tvar doubleSpend = Assert.Single(eventArgs.SuccessfullyDoubleSpentCoins);\n\t\t\t\tAssert.Equal(invalidCoin.TransactionId, doubleSpend.TransactionId);\n\n\t\t\t\tvar curBlockHash = await rpc.GetBestBlockHashAsync();\n\t\t\t\tblockCount = await rpc.GetBlockCountAsync();\n\t\t\t\tAssert.Equal(bitcoinStore.SmartHeaderChain.TipHash, curBlockHash);\n\t\t\t\tAssert.Equal((int)bitcoinStore.SmartHeaderChain.TipHeight, blockCount);\n\n\t\t\t\t\/\/ Make sure the funding transaction is not in any block of the chain\n\t\t\t\twhile (curBlockHash != rpc.Network.GenesisHash)\n\t\t\t\t{\n\t\t\t\t\tvar block = await rpc.GetBlockAsync(curBlockHash);\n\n\t\t\t\t\tif (block.Transactions.Any(tx => tx.GetHash() == fundingTxId))\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new Exception($\"Transaction found in block at height {blockCount} hash: {block.GetHash()}\");\n\t\t\t\t\t}\n\t\t\t\t\tcurBlockHash = block.Header.HashPrevBlock;\n\t\t\t\t\tblockCount--;\n\t\t\t\t}\n\n\t\t\t\t\/\/ Get some money, make it confirm.\n\t\t\t\t\/\/ this is necesary because we are in a fork now.\n\t\t\t\teventAwaiter = new EventAwaiter<ProcessedResult>(\n\t\t\t\t\t\t\t\th => wallet.TransactionProcessor.WalletRelevantTransactionProcessed += h,\n\t\t\t\t\t\t\t\th => wallet.TransactionProcessor.WalletRelevantTransactionProcessed -= h);\n\t\t\t\tfundingTxId = await rpc.SendToAddressAsync(key.GetP2wpkhAddress(network), Money.Coins(1m), replaceable: true);\n\t\t\t\teventArgs = await eventAwaiter.WaitAsync(TimeSpan.FromSeconds(21));\n\t\t\t\tAssert.Equal(fundingTxId, eventArgs.NewlyReceivedCoins.Single().TransactionId);\n\t\t\t\tAssert.Contains(fundingTxId, wallet.Coins.Select(x => x.TransactionId));\n\n\t\t\t\tvar fundingBumpTxId = await rpc.BumpFeeAsync(fundingTxId);\n\t\t\t\tawait Task.Delay(2000); \/\/ Waits for the funding transaction get to the mempool.\n\t\t\t\tAssert.Contains(fundingBumpTxId.TransactionId, wallet.Coins.Select(x => x.TransactionId));\n\t\t\t\tAssert.DoesNotContain(fundingTxId, wallet.Coins.Select(x => x.TransactionId));\n\t\t\t\tAssert.Single(wallet.Coins.Where(x => x.TransactionId == fundingBumpTxId.TransactionId));\n\n\t\t\t\t\/\/ Confirm the coin\n\t\t\t\tInterlocked.Exchange(ref _filtersProcessedByWalletCount, 0);\n\t\t\t\tawait rpc.GenerateAsync(1);\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), 1);\n\n\t\t\t\tAssert.Single(wallet.Coins.Where(x => x.Confirmed && x.TransactionId == fundingBumpTxId.TransactionId));\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\twallet?.Dispose();\n\t\t\t\t\/\/ Dispose wasabi synchronizer service.\n\t\t\t\tawait synchronizer?.StopAsync();\n\t\t\t\t\/\/ Dispose connection service.\n\t\t\t\tnodes?.Dispose();\n\t\t\t\t\/\/ Dispose mempool serving node.\n\t\t\t\tnode?.Disconnect();\n\t\t\t\t\/\/ Dispose chaumian coinjoin client.\n\t\t\t\tif (chaumianClient != null)\n\t\t\t\t{\n\t\t\t\t\tawait chaumianClient.StopAsync();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task SpendUnconfirmedTxTestAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\t\/\/ Create the services.\n\t\t\t\/\/ 1. Create connection service.\n\t\t\tvar nodes = new NodesGroup(global.Config.Network, requirements: Constants.NodeRequirements);\n\t\t\tnodes.ConnectedNodes.Add(await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync());\n\n\t\t\t\/\/ 2. Create mempool service.\n\n\t\t\tNode node = await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync();\n\t\t\tnode.Behaviors.Add(bitcoinStore.CreateUntrustedP2pBehavior());\n\n\t\t\t\/\/ 3. Create wasabi synchronizer service.\n\t\t\tvar synchronizer = new WasabiSynchronizer(rpc.Network, bitcoinStore, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\t\/\/ 4. Create key manager service.\n\t\t\tvar keyManager = KeyManager.CreateNew(out _, password);\n\n\t\t\t\/\/ 5. Create chaumian coinjoin client.\n\t\t\tvar chaumianClient = new CoinJoinClient(synchronizer, rpc.Network, keyManager, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\t\/\/ 6. Create wallet service.\n\t\t\tvar workDir = GetWorkDir();\n\t\t\tvar wallet = new WalletService(bitcoinStore, keyManager, synchronizer, chaumianClient, nodes, workDir, serviceConfiguration, synchronizer);\n\t\t\twallet.NewFilterProcessed += Wallet_NewFilterProcessed;\n\n\t\t\tAssert.Empty(wallet.Coins);\n\n\t\t\t\/\/ Get some money, make it confirm.\n\t\t\tvar key = keyManager.GetNextReceiveKey(\"foo label\", out _);\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tnodes.Connect(); \/\/ Start connection service.\n\t\t\t\tnode.VersionHandshake(); \/\/ Start mempool service.\n\t\t\t\tsynchronizer.Start(requestInterval: TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(5), 10000); \/\/ Start wasabi synchronizer service.\n\t\t\t\tchaumianClient.Start(); \/\/ Start chaumian coinjoin client.\n\n\t\t\t\t\/\/ Wait until the filter our previous transaction is present.\n\t\t\t\tvar blockCount = await rpc.GetBlockCountAsync();\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), blockCount);\n\n\t\t\t\tusing (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30)))\n\t\t\t\t{\n\t\t\t\t\tawait wallet.InitializeAsync(cts.Token); \/\/ Initialize wallet service.\n\t\t\t\t}\n\n\t\t\t\tAssert.Empty(wallet.Coins);\n\n\t\t\t\t\/\/ Get some money, make it confirm.\n\t\t\t\t\/\/ this is necesary because we are in a fork now.\n\t\t\t\tvar eventAwaiter = new EventAwaiter<ProcessedResult>(\n\t\t\t\t\th => wallet.TransactionProcessor.WalletRelevantTransactionProcessed += h,\n\t\t\t\t\th => wallet.TransactionProcessor.WalletRelevantTransactionProcessed -= h);\n\t\t\t\tvar tx0Id = await rpc.SendToAddressAsync(\n\t\t\t\t\tkey.GetP2wpkhAddress(network),\n\t\t\t\t\tMoney.Coins(1m),\n\t\t\t\t\treplaceable: true);\n\t\t\t\tvar eventArgs = await eventAwaiter.WaitAsync(TimeSpan.FromSeconds(21));\n\t\t\t\tAssert.Equal(tx0Id, eventArgs.NewlyReceivedCoins.Single().TransactionId);\n\t\t\t\tAssert.Single(wallet.Coins);\n\n\t\t\t\tvar broadcaster = new TransactionBroadcaster(network, bitcoinStore, synchronizer, nodes, rpc);\n\t\t\t\tbroadcaster.AddWalletService(wallet);\n\n\t\t\t\tvar operations = new PaymentIntent(\n\t\t\t\t\tnew DestinationRequest(key.P2wpkhScript, Money.Coins(0.01m)),\n\t\t\t\t\tnew DestinationRequest(new Key().ScriptPubKey, Money.Coins(0.01m)),\n\t\t\t\t\tnew DestinationRequest(new Key().ScriptPubKey, Money.Coins(0.01m)));\n\t\t\t\tvar tx1Res = wallet.BuildTransaction(password, operations, FeeStrategy.TwentyMinutesConfirmationTargetStrategy, allowUnconfirmed: true);\n\t\t\t\tAssert.Equal(2, tx1Res.InnerWalletOutputs.Count());\n\t\t\t\tAssert.Equal(2, tx1Res.OuterWalletOutputs.Count());\n\n\t\t\t\t\/\/ Spend the unconfirmed coin (send it to ourself)\n\t\t\t\toperations = new PaymentIntent(key.PubKey.WitHash.ScriptPubKey, Money.Coins(0.5m));\n\t\t\t\ttx1Res = wallet.BuildTransaction(password, operations, FeeStrategy.TwentyMinutesConfirmationTargetStrategy, allowUnconfirmed: true);\n\t\t\t\teventAwaiter = new EventAwaiter<ProcessedResult>(\n\t\t\t\t\th => wallet.TransactionProcessor.WalletRelevantTransactionProcessed += h,\n\t\t\t\t\th => wallet.TransactionProcessor.WalletRelevantTransactionProcessed -= h);\n\t\t\t\tawait broadcaster.SendTransactionAsync(tx1Res.Transaction);\n\t\t\t\teventArgs = await eventAwaiter.WaitAsync(TimeSpan.FromSeconds(21));\n\t\t\t\tAssert.Equal(tx0Id, eventArgs.NewlySpentCoins.Single().TransactionId);\n\t\t\t\tAssert.Equal(tx1Res.Transaction.GetHash(), eventArgs.NewlyReceivedCoins.First().TransactionId);\n\n\t\t\t\t\/\/ There is a coin created by the latest spending transaction\n\t\t\t\tAssert.Contains(wallet.Coins, x => x.TransactionId == tx1Res.Transaction.GetHash());\n\n\t\t\t\t\/\/ There is a coin destroyed\n\t\t\t\tvar allCoins = wallet.TransactionProcessor.Coins.AsAllCoinsView();\n\t\t\t\tAssert.Equal(1, allCoins.Count(x => x.Unavailable && x.SpenderTransactionId == tx1Res.Transaction.GetHash()));\n\n\t\t\t\t\/\/ There is at least one coin created from the destruction of the first coin\n\t\t\t\tAssert.Contains(wallet.Coins, x => x.SpentOutputs.Any(o => o.TransactionId == tx0Id));\n\n\t\t\t\tvar totalWallet = wallet.Coins.Where(c => !c.Unavailable).Sum(c => c.Amount);\n\t\t\t\tAssert.Equal((1 * Money.COIN) - tx1Res.Fee.Satoshi, totalWallet);\n\n\t\t\t\t\/\/ Spend the unconfirmed and unspent coin (send it to ourself)\n\t\t\t\toperations = new PaymentIntent(key.PubKey.WitHash.ScriptPubKey, Money.Coins(0.6m), subtractFee: true);\n\t\t\t\tvar tx2Res = wallet.BuildTransaction(password, operations, FeeStrategy.TwentyMinutesConfirmationTargetStrategy, allowUnconfirmed: true);\n\n\t\t\t\teventAwaiter = new EventAwaiter<ProcessedResult>(\n\t\t\t\t\t\t\t\th => wallet.TransactionProcessor.WalletRelevantTransactionProcessed += h,\n\t\t\t\t\t\t\t\th => wallet.TransactionProcessor.WalletRelevantTransactionProcessed -= h);\n\t\t\t\tawait broadcaster.SendTransactionAsync(tx2Res.Transaction);\n\t\t\t\teventArgs = await eventAwaiter.WaitAsync(TimeSpan.FromSeconds(21));\n\t\t\t\tvar spentCoins = eventArgs.NewlySpentCoins.ToArray();\n\t\t\t\tAssert.Equal(tx1Res.Transaction.GetHash(), spentCoins.First().TransactionId);\n\t\t\t\tuint256 tx2Hash = tx2Res.Transaction.GetHash();\n\t\t\t\tvar receivedCoins = eventArgs.NewlyReceivedCoins.ToArray();\n\t\t\t\tAssert.Equal(tx2Hash, receivedCoins[0].TransactionId);\n\t\t\t\tAssert.Equal(tx2Hash, receivedCoins[1].TransactionId);\n\n\t\t\t\t\/\/ There is a coin created by the latest spending transaction\n\t\t\t\tAssert.Contains(wallet.Coins, x => x.TransactionId == tx2Res.Transaction.GetHash());\n\n\t\t\t\t\/\/ There is a coin destroyed\n\t\t\t\tallCoins = wallet.TransactionProcessor.Coins.AsAllCoinsView();\n\t\t\t\tAssert.Equal(2, allCoins.Count(x => x.Unavailable && x.SpenderTransactionId == tx2Hash));\n\n\t\t\t\t\/\/ There is at least one coin created from the destruction of the first coin\n\t\t\t\tAssert.Contains(wallet.Coins, x => x.SpentOutputs.Any(o => o.TransactionId == tx1Res.Transaction.GetHash()));\n\n\t\t\t\ttotalWallet = wallet.Coins.Where(c => !c.Unavailable).Sum(c => c.Amount);\n\t\t\t\tAssert.Equal((1 * Money.COIN) - tx1Res.Fee.Satoshi - tx2Res.Fee.Satoshi, totalWallet);\n\n\t\t\t\tInterlocked.Exchange(ref _filtersProcessedByWalletCount, 0);\n\t\t\t\tvar blockId = (await rpc.GenerateAsync(1)).Single();\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), 1);\n\t\t\t\t}\n\t\t\t\tcatch (TimeoutException)\n\t\t\t\t{\n\t\t\t\t\tLogger.LogInfo(\"Index was not processed.\");\n\t\t\t\t\treturn; \/\/ Very rarely this test fails. I have no clue why. Probably because all these RegTests are interconnected, anyway let's not bother the CI with it.\n\t\t\t\t}\n\n\t\t\t\t\/\/ Verify transactions are confirmed in the blockchain\n\t\t\t\tvar block = await rpc.GetBlockAsync(blockId);\n\t\t\t\tAssert.Contains(block.Transactions, x => x.GetHash() == tx2Res.Transaction.GetHash());\n\t\t\t\tAssert.Contains(block.Transactions, x => x.GetHash() == tx1Res.Transaction.GetHash());\n\t\t\t\tAssert.Contains(block.Transactions, x => x.GetHash() == tx0Id);\n\n\t\t\t\tAssert.True(wallet.Coins.All(x => x.Confirmed));\n\n\t\t\t\t\/\/ Test coin basic count.\n\t\t\t\tICoinsView GetAllCoins() => wallet.TransactionProcessor.Coins.AsAllCoinsView();\n\t\t\t\tvar coinCount = GetAllCoins().Count();\n\t\t\t\tvar to = keyManager.GetNextReceiveKey(\"foo\", out _);\n\t\t\t\tvar res = wallet.BuildTransaction(password, new PaymentIntent(to.P2wpkhScript, Money.Coins(0.2345m), label: \"bar\"), FeeStrategy.TwentyMinutesConfirmationTargetStrategy, allowUnconfirmed: true);\n\t\t\t\tawait broadcaster.SendTransactionAsync(res.Transaction);\n\t\t\t\tAssert.Equal(coinCount + 2, GetAllCoins().Count());\n\t\t\t\tAssert.Equal(2, GetAllCoins().Count(x => !x.Confirmed));\n\t\t\t\tInterlocked.Exchange(ref _filtersProcessedByWalletCount, 0);\n\t\t\t\tawait rpc.GenerateAsync(1);\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), 1);\n\t\t\t\tAssert.Equal(coinCount + 2, GetAllCoins().Count());\n\t\t\t\tAssert.Equal(0, GetAllCoins().Count(x => !x.Confirmed));\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\twallet?.Dispose();\n\t\t\t\t\/\/ Dispose wasabi synchronizer service.\n\t\t\t\tawait synchronizer?.StopAsync();\n\t\t\t\t\/\/ Dispose connection service.\n\t\t\t\tnodes?.Dispose();\n\t\t\t\t\/\/ Dispose mempool serving node.\n\t\t\t\tnode?.Disconnect();\n\t\t\t\t\/\/ Dispose chaumian coinjoin client.\n\t\t\t\tif (chaumianClient != null)\n\t\t\t\t{\n\t\t\t\t\tawait chaumianClient.StopAsync();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task ReplaceByFeeTxTestAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\t\/\/ Create the services.\n\t\t\t\/\/ 1. Create connection service.\n\t\t\tvar nodes = new NodesGroup(global.Config.Network, requirements: Constants.NodeRequirements);\n\t\t\tnodes.ConnectedNodes.Add(await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync());\n\n\t\t\t\/\/ 2. Create mempool service.\n\n\t\t\tNode node = await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync();\n\t\t\tnode.Behaviors.Add(bitcoinStore.CreateUntrustedP2pBehavior());\n\n\t\t\t\/\/ 3. Create wasabi synchronizer service.\n\t\t\tvar synchronizer = new WasabiSynchronizer(rpc.Network, bitcoinStore, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\t\/\/ 4. Create key manager service.\n\t\t\tvar keyManager = KeyManager.CreateNew(out _, password);\n\n\t\t\t\/\/ 5. Create chaumian coinjoin client.\n\t\t\tvar chaumianClient = new CoinJoinClient(synchronizer, rpc.Network, keyManager, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\t\/\/ 6. Create wallet service.\n\t\t\tvar workDir = GetWorkDir();\n\t\t\tvar wallet = new WalletService(bitcoinStore, keyManager, synchronizer, chaumianClient, nodes, workDir, serviceConfiguration, synchronizer);\n\t\t\twallet.NewFilterProcessed += Wallet_NewFilterProcessed;\n\n\t\t\tAssert.Empty(wallet.Coins);\n\n\t\t\t\/\/ Get some money, make it confirm.\n\t\t\tvar key = keyManager.GetNextReceiveKey(\"foo label\", out _);\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tnodes.Connect(); \/\/ Start connection service.\n\t\t\t\tnode.VersionHandshake(); \/\/ Start mempool service.\n\t\t\t\tsynchronizer.Start(requestInterval: TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(5), 10000); \/\/ Start wasabi synchronizer service.\n\t\t\t\tchaumianClient.Start(); \/\/ Start chaumian coinjoin client.\n\n\t\t\t\t\/\/ Wait until the filter our previous transaction is present.\n\t\t\t\tvar blockCount = await rpc.GetBlockCountAsync();\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), blockCount);\n\n\t\t\t\tusing (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30)))\n\t\t\t\t{\n\t\t\t\t\tawait wallet.InitializeAsync(cts.Token); \/\/ Initialize wallet service.\n\t\t\t\t}\n\n\t\t\t\tAssert.Empty(wallet.Coins);\n\n\t\t\t\tvar tx0Id = await rpc.SendToAddressAsync(key.GetP2wpkhAddress(network), Money.Coins(1m), replaceable: true);\n\t\t\t\twhile (wallet.Coins.Count() == 0)\n\t\t\t\t{\n\t\t\t\t\tawait Task.Delay(500); \/\/ Waits for the funding transaction get to the mempool.\n\t\t\t\t}\n\n\t\t\t\tAssert.Single(wallet.Coins);\n\t\t\t\tAssert.True(wallet.Coins.First().IsReplaceable);\n\n\t\t\t\tvar bfr = await rpc.BumpFeeAsync(tx0Id);\n\t\t\t\tvar tx1Id = bfr.TransactionId;\n\t\t\t\tawait Task.Delay(2000); \/\/ Waits for the replacement transaction get to the mempool.\n\t\t\t\tAssert.Single(wallet.Coins);\n\t\t\t\tAssert.True(wallet.Coins.First().IsReplaceable);\n\t\t\t\tAssert.Equal(tx1Id, wallet.Coins.First().TransactionId);\n\n\t\t\t\tbfr = await rpc.BumpFeeAsync(tx1Id);\n\t\t\t\tvar tx2Id = bfr.TransactionId;\n\t\t\t\tawait Task.Delay(2000); \/\/ Waits for the replacement transaction get to the mempool.\n\t\t\t\tAssert.Single(wallet.Coins);\n\t\t\t\tAssert.True(wallet.Coins.First().IsReplaceable);\n\t\t\t\tAssert.Equal(tx2Id, wallet.Coins.First().TransactionId);\n\n\t\t\t\tInterlocked.Exchange(ref _filtersProcessedByWalletCount, 0);\n\t\t\t\tawait rpc.GenerateAsync(1);\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), 1);\n\t\t\t\tusing (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30)))\n\t\t\t\t{\n\t\t\t\t\tawait wallet.InitializeAsync(cts.Token); \/\/ Initialize wallet service.\n\t\t\t\t}\n\n\t\t\t\tvar coin = wallet.Coins.First();\n\t\t\t\tAssert.Single(wallet.Coins);\n\t\t\t\tAssert.True(coin.Confirmed);\n\t\t\t\tAssert.False(coin.IsReplaceable);\n\t\t\t\tAssert.Equal(tx2Id, coin.TransactionId);\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\twallet?.Dispose();\n\t\t\t\t\/\/ Dispose wasabi synchronizer service.\n\t\t\t\tawait synchronizer?.StopAsync();\n\t\t\t\t\/\/ Dispose connection service.\n\t\t\t\tnodes?.Dispose();\n\t\t\t\t\/\/ Dispose mempool serving node.\n\t\t\t\tnode?.Disconnect();\n\t\t\t\t\/\/ Dispose chaumian coinjoin client.\n\t\t\t\tif (chaumianClient != null)\n\t\t\t\t{\n\t\t\t\t\tawait chaumianClient.StopAsync();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task CoordinatorCtorTestsAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\tLogger.TurnOff(); \/\/ turn off at the end, otherwise, the tests logs would have of warnings\n\n\t\t\tvar bestBlockHash = await rpc.GetBestBlockHashAsync();\n\t\t\tvar bestBlock = await rpc.GetBlockAsync(bestBlockHash);\n\t\t\tvar coinbaseTxId = bestBlock.Transactions[0].GetHash();\n\t\t\tvar offchainTxId = network.Consensus.ConsensusFactory.CreateTransaction().GetHash();\n\t\t\tvar mempoolTxId = rpc.SendToAddress(new Key().PubKey.GetSegwitAddress(network), Money.Coins(1));\n\n\t\t\tvar folder = GetWorkDir();\n\t\t\tawait IoHelpers.DeleteRecursivelyWithMagicDustAsync(folder);\n\t\t\tDirectory.CreateDirectory(folder);\n\t\t\tvar cjfile = Path.Combine(folder, $\"CoinJoins{network}.txt\");\n\t\t\tFile.WriteAllLines(cjfile, new[] { coinbaseTxId.ToString(), offchainTxId.ToString(), mempoolTxId.ToString() });\n\n\t\t\tusing (var coordinatorToTest = new Coordinator(network, global.HostedServices.FirstOrDefault<BlockNotifier>(), folder, rpc, coordinator.RoundConfig))\n\t\t\t{\n\t\t\t\tvar txIds = await File.ReadAllLinesAsync(cjfile);\n\n\t\t\t\tAssert.Contains(coinbaseTxId.ToString(), txIds);\n\t\t\t\tAssert.Contains(mempoolTxId.ToString(), txIds);\n\t\t\t\tAssert.DoesNotContain(offchainTxId.ToString(), txIds);\n\n\t\t\t\tawait IoHelpers.DeleteRecursivelyWithMagicDustAsync(folder);\n\t\t\t\tDirectory.CreateDirectory(folder);\n\t\t\t\tFile.WriteAllLines(cjfile, new[] { coinbaseTxId.ToString(), \"This line is invalid (the file is corrupted)\", offchainTxId.ToString() });\n\n\t\t\t\tvar coordinatorToTest2 = new Coordinator(network, global.HostedServices.FirstOrDefault<BlockNotifier>(), folder, rpc, coordinatorToTest.RoundConfig);\n\t\t\t\tcoordinatorToTest2?.Dispose();\n\t\t\t\ttxIds = await File.ReadAllLinesAsync(cjfile);\n\t\t\t\tAssert.Single(txIds);\n\t\t\t\tAssert.Contains(coinbaseTxId.ToString(), txIds);\n\t\t\t\tAssert.DoesNotContain(offchainTxId.ToString(), txIds);\n\t\t\t\tAssert.DoesNotContain(\"This line is invalid (the file is corrupted)\", txIds);\n\t\t\t}\n\n\t\t\tLogger.TurnOn();\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task CcjTestsAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\tMoney denomination = Money.Coins(0.2m);\n\t\t\tdecimal coordinatorFeePercent = 0.2m;\n\t\t\tint anonymitySet = 2;\n\t\t\tint connectionConfirmationTimeout = 50;\n\t\t\tvar roundConfig = RegTestFixture.CreateRoundConfig(denomination, 2, 0.7, coordinatorFeePercent, anonymitySet, 100, connectionConfirmationTimeout, 50, 50, 2, 24, false, 11);\n\t\t\tawait coordinator.RoundConfig.UpdateOrDefaultAsync(roundConfig, toFile: true);\n\t\t\tcoordinator.AbortAllRoundsInInputRegistration(\"\");\n\n\t\t\tUri baseUri = new Uri(RegTestFixture.BackendEndPoint);\n\t\t\tusing var torClient = new TorHttpClient(baseUri, Global.Instance.TorSocks5Endpoint);\n\t\t\tusing var satoshiClient = new SatoshiClient(baseUri, null);\n\n\t\t\t#region PostInputsGetStates\n\n\t\t\t\/\/ <-------------------------->\n\t\t\t\/\/ POST INPUTS and GET STATES tests\n\t\t\t\/\/ <-------------------------->\n\n\t\t\tIEnumerable<RoundStateResponse> states = await satoshiClient.GetAllRoundStatesAsync();\n\t\t\tAssert.Equal(2, states.Count());\n\t\t\tforeach (RoundStateResponse rs in states)\n\t\t\t{\n\t\t\t\t\/\/ Never changes.\n\t\t\t\tAssert.True(0 < rs.RoundId);\n\t\t\t\tAssert.Equal(Money.Coins(0.00009648m), rs.FeePerInputs);\n\t\t\t\tAssert.Equal(Money.Coins(0.00004752m), rs.FeePerOutputs);\n\t\t\t\tAssert.Equal(7, rs.MaximumInputCountPerPeer);\n\t\t\t\t\/\/ Changes per rounds.\n\t\t\t\tAssert.Equal(denomination, rs.Denomination);\n\t\t\t\tAssert.Equal(coordinatorFeePercent, rs.CoordinatorFeePercent);\n\t\t\t\tAssert.Equal(anonymitySet, rs.RequiredPeerCount);\n\t\t\t\tAssert.Equal(connectionConfirmationTimeout, rs.RegistrationTimeout);\n\t\t\t\t\/\/ Changes per phases.\n\t\t\t\tAssert.Equal(RoundPhase.InputRegistration, rs.Phase);\n\t\t\t\tAssert.Equal(0, rs.RegisteredPeerCount);\n\t\t\t}\n\n\t\t\t\/\/ Inputs request tests\n\t\t\tvar inputsRequest = new InputsRequest\n\t\t\t{\n\t\t\t\tBlindedOutputScripts = null,\n\t\t\t\tChangeOutputAddress = null,\n\t\t\t\tInputs = null,\n\t\t\t};\n\n\t\t\tvar round = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\t\t\tvar roundId = round.RoundId;\n\t\t\tinputsRequest.RoundId = roundId;\n\t\t\tvar registeredAddresses = Array.Empty<BitcoinAddress>();\n\t\t\tvar schnorrPubKeys = round.MixingLevels.SchnorrPubKeys;\n\t\t\tvar requesters = Array.Empty<Requester>();\n\n\t\t\tHttpRequestException httpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.Equal($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nInvalid request.\", httpRequestException.Message);\n\n\t\t\tbyte[] dummySignature = new byte[65];\n\n\t\t\tinputsRequest.BlindedOutputScripts = Enumerable.Range(0, round.MixingLevels.Count() + 1).Select(x => uint256.One);\n\t\t\tinputsRequest.ChangeOutputAddress = new Key().PubKey.GetAddress(ScriptPubKeyType.Segwit, network);\n\t\t\tinputsRequest.Inputs = new List<InputProofModel> { new InputProofModel { Input = new TxoRef(uint256.One, 0), Proof = dummySignature } };\n\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.StartsWith($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nToo many blinded output was provided\", httpRequestException.Message);\n\n\t\t\tinputsRequest.BlindedOutputScripts = Enumerable.Range(0, round.MixingLevels.Count() - 2).Select(x => uint256.One);\n\t\t\tinputsRequest.ChangeOutputAddress = new Key().PubKey.GetAddress(ScriptPubKeyType.Segwit, network);\n\t\t\tinputsRequest.Inputs = new List<InputProofModel> { new InputProofModel { Input = new TxoRef(uint256.One, 0), Proof = dummySignature } };\n\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.StartsWith($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nDuplicate blinded output found\", httpRequestException.Message);\n\n\t\t\tinputsRequest.BlindedOutputScripts = new[] { uint256.Zero };\n\t\t\tinputsRequest.ChangeOutputAddress = new Key().PubKey.GetAddress(ScriptPubKeyType.Segwit, network);\n\t\t\tinputsRequest.Inputs = new List<InputProofModel> { new InputProofModel { Input = new TxoRef(uint256.One, 0), Proof = dummySignature } };\n\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.StartsWith($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nProvided input is not unspent\", httpRequestException.Message);\n\n\t\t\tvar addr = await rpc.GetNewAddressAsync();\n\t\t\tvar hash = await rpc.SendToAddressAsync(addr, Money.Coins(0.01m));\n\t\t\tvar tx = await rpc.GetRawTransactionAsync(hash);\n\t\t\tvar coin = tx.Outputs.GetCoins(addr.ScriptPubKey).Single();\n\n\t\t\tinputsRequest.Inputs = new List<InputProofModel> { new InputProofModel { Input = coin.Outpoint.ToTxoRef(), Proof = dummySignature } };\n\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.Equal($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nProvided input is neither confirmed, nor is from an unconfirmed coinjoin.\", httpRequestException.Message);\n\n\t\t\tvar blocks = await rpc.GenerateAsync(1);\n\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.Equal($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nProvided input must be witness_v0_keyhash.\", httpRequestException.Message);\n\n\t\t\tvar blockHash = blocks.Single();\n\t\t\tvar block = await rpc.GetBlockAsync(blockHash);\n\t\t\tvar coinbase = block.Transactions.First();\n\t\t\tinputsRequest.Inputs = new List<InputProofModel> { new InputProofModel { Input = new TxoRef(coinbase.GetHash(), 0), Proof = dummySignature } };\n\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.Equal($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nProvided input is immature.\", httpRequestException.Message);\n\n\t\t\tvar key = new Key();\n\t\t\tvar witnessAddress = key.PubKey.GetSegwitAddress(network);\n\t\t\thash = await rpc.SendToAddressAsync(witnessAddress, Money.Coins(0.01m));\n\t\t\tawait rpc.GenerateAsync(1);\n\t\t\ttx = await rpc.GetRawTransactionAsync(hash);\n\t\t\tcoin = tx.Outputs.GetCoins(witnessAddress.ScriptPubKey).Single();\n\t\t\tinputsRequest.Inputs = new List<InputProofModel> { new InputProofModel { Input = coin.Outpoint.ToTxoRef(), Proof = dummySignature } };\n\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.StartsWith($\"{HttpStatusCode.BadRequest.ToReasonString()}\", httpRequestException.Message);\n\n\t\t\tvar proof = key.SignCompact(uint256.One);\n\t\t\tinputsRequest.Inputs.First().Proof = proof;\n\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.Equal($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nProvided proof is invalid.\", httpRequestException.Message);\n\n\t\t\tround = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\t\t\tvar requester = new Requester();\n\t\t\tuint256 msg = new uint256(Hashes.SHA256(network.Consensus.ConsensusFactory.CreateTransaction().ToBytes()));\n\t\t\tuint256 blindedData = requester.BlindMessage(msg, round.MixingLevels.GetBaseLevel().SchnorrKey.SchnorrPubKey);\n\t\t\tinputsRequest.BlindedOutputScripts = new[] { blindedData };\n\t\t\tuint256 blindedOutputScriptsHash = new uint256(Hashes.SHA256(blindedData.ToBytes()));\n\n\t\t\tproof = key.SignCompact(blindedOutputScriptsHash);\n\t\t\tinputsRequest.Inputs.First().Proof = proof;\n\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.StartsWith($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nNot enough inputs are provided. Fee to pay:\", httpRequestException.Message);\n\n\t\t\troundConfig.Denomination = Money.Coins(0.01m); \/\/ exactly the same as our output\n\t\t\tawait coordinator.RoundConfig.UpdateOrDefaultAsync(roundConfig, toFile: true);\n\t\t\tcoordinator.AbortAllRoundsInInputRegistration(\"\");\n\t\t\tround = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\t\t\troundId = round.RoundId;\n\t\t\tinputsRequest.RoundId = roundId;\n\t\t\tschnorrPubKeys = round.MixingLevels.SchnorrPubKeys;\n\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.StartsWith($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nNot enough inputs are provided. Fee to pay:\", httpRequestException.Message);\n\n\t\t\troundConfig.Denomination = Money.Coins(0.00999999m); \/\/ one satoshi less than our output\n\t\t\tawait coordinator.RoundConfig.UpdateOrDefaultAsync(roundConfig, toFile: true);\n\t\t\tcoordinator.AbortAllRoundsInInputRegistration(\"\");\n\t\t\tround = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\t\t\troundId = round.RoundId;\n\t\t\tinputsRequest.RoundId = roundId;\n\t\t\tschnorrPubKeys = round.MixingLevels.SchnorrPubKeys;\n\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.StartsWith($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nNot enough inputs are provided. Fee to pay:\", httpRequestException.Message);\n\n\t\t\troundConfig.Denomination = Money.Coins(0.008m); \/\/ one satoshi less than our output\n\t\t\troundConfig.ConnectionConfirmationTimeout = 7;\n\t\t\tawait coordinator.RoundConfig.UpdateOrDefaultAsync(roundConfig, toFile: true);\n\t\t\tcoordinator.AbortAllRoundsInInputRegistration(\"\");\n\t\t\tround = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\t\t\troundId = round.RoundId;\n\t\t\tinputsRequest.RoundId = roundId;\n\t\t\tschnorrPubKeys = round.MixingLevels.SchnorrPubKeys;\n\t\t\trequester = new Requester();\n\t\t\trequesters = new[] { requester };\n\t\t\tmsg = network.Consensus.ConsensusFactory.CreateTransaction().GetHash();\n\t\t\tblindedData = requester.BlindMessage(msg, round.MixingLevels.GetBaseLevel().SchnorrKey.SchnorrPubKey);\n\t\t\tinputsRequest.BlindedOutputScripts = new[] { blindedData };\n\t\t\tblindedOutputScriptsHash = new uint256(Hashes.SHA256(blindedData.ToBytes()));\n\t\t\tproof = key.SignCompact(blindedOutputScriptsHash);\n\t\t\tinputsRequest.Inputs.First().Proof = proof;\n\t\t\tusing (var aliceClient = await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null))\n\t\t\t{\n\t\t\t\t\/\/ Test DelayedClientRoundRegistration logic.\n\t\t\t\tClientRoundRegistration first = null;\n\t\t\t\tvar second = new ClientRoundRegistration(aliceClient,\n\t\t\t\t\tnew[] { new SmartCoin(uint256.One, 1, Script.Empty, Money.Zero, new[] { new TxoRef(uint256.One, 1) }, Height.Unknown, true, 2, isLikelyCoinJoinOutput: false) },\n\t\t\t\t\tBitcoinAddress.Create(\"12Rty3c8j3QiZSwLVaBtch6XUMZaja3RC7\", Network.Main));\n\t\t\t\tfirst = second;\n\t\t\t\tsecond = null;\n\t\t\t\tAssert.NotNull(first);\n\t\t\t\tAssert.Null(second);\n\n\t\t\t\tAssert.NotEqual(Guid.Empty, aliceClient.UniqueId);\n\t\t\t\tAssert.True(aliceClient.RoundId > 0);\n\n\t\t\t\tRoundStateResponse roundState = await satoshiClient.GetRoundStateAsync(aliceClient.RoundId);\n\t\t\t\tAssert.Equal(RoundPhase.InputRegistration, roundState.Phase);\n\t\t\t\tAssert.Equal(1, roundState.RegisteredPeerCount);\n\n\t\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\t\tAssert.Equal($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nBlinded output has already been registered.\", httpRequestException.Message);\n\n\t\t\t\troundState = await satoshiClient.GetRoundStateAsync(aliceClient.RoundId);\n\t\t\t\tAssert.Equal(RoundPhase.InputRegistration, roundState.Phase);\n\t\t\t\tAssert.Equal(1, roundState.RegisteredPeerCount);\n\n\t\t\t\troundState = await satoshiClient.GetRoundStateAsync(aliceClient.RoundId);\n\t\t\t\tAssert.Equal(RoundPhase.InputRegistration, roundState.Phase);\n\t\t\t\tAssert.Equal(1, roundState.RegisteredPeerCount);\n\t\t\t\tawait aliceClient.PostUnConfirmationAsync();\n\t\t\t}\n\n\t\t\tround = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\t\t\trequester = new Requester();\n\t\t\tblindedData = requester.BlindScript(round.MixingLevels.GetBaseLevel().SchnorrKey.SchnorrPubKey.SignerPubKey, round.MixingLevels.GetBaseLevel().SchnorrKey.SchnorrPubKey.RpubKey, key.ScriptPubKey);\n\t\t\tinputsRequest.BlindedOutputScripts = new[] { blindedData };\n\t\t\tblindedOutputScriptsHash = new uint256(Hashes.SHA256(blindedData.ToBytes()));\n\t\t\tproof = key.SignCompact(blindedOutputScriptsHash);\n\t\t\tinputsRequest.Inputs.First().Proof = proof;\n\n\t\t\tvar currentRound = coordinator.TryGetRound(roundId);\n\t\t\tAssert.NotNull(currentRound);\n\t\t\tAssert.Equal(RoundPhase.InputRegistration, currentRound.Phase);\n\t\t\tAssert.Equal(2, currentRound.AnonymitySet);\n\t\t\tAssert.Equal(0, currentRound.CountAlices());\n\n\t\t\tusing (var aliceClient = await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null))\n\t\t\t{\n\t\t\t\tAssert.NotEqual(Guid.Empty, aliceClient.UniqueId);\n\t\t\t\tAssert.True(aliceClient.RoundId > 0);\n\n\t\t\t\tAssert.Equal(2, currentRound.AnonymitySet);\n\t\t\t\tAssert.Equal(1, currentRound.CountAlices());\n\n\t\t\t\tvar roundState = await satoshiClient.GetRoundStateAsync(aliceClient.RoundId);\n\t\t\t\tAssert.Equal(RoundPhase.InputRegistration, roundState.Phase);\n\t\t\t\tAssert.Equal(1, roundState.RegisteredPeerCount);\n\t\t\t}\n\n\t\t\tinputsRequest.BlindedOutputScripts = new[] { uint256.One };\n\t\t\tblindedOutputScriptsHash = new uint256(Hashes.SHA256(uint256.One.ToBytes()));\n\t\t\tproof = key.SignCompact(blindedOutputScriptsHash);\n\t\t\tinputsRequest.Inputs.First().Proof = proof;\n\t\t\tinputsRequest.Inputs = new List<InputProofModel> { inputsRequest.Inputs.First(), inputsRequest.Inputs.First() };\n\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.Equal($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nCannot register an input twice.\", httpRequestException.Message);\n\n\t\t\tvar inputProofs = new List<InputProofModel>();\n\t\t\tfor (int j = 0; j < 8; j++)\n\t\t\t{\n\t\t\t\tkey = new Key();\n\t\t\t\twitnessAddress = key.PubKey.GetSegwitAddress(network);\n\t\t\t\thash = await rpc.SendToAddressAsync(witnessAddress, Money.Coins(0.01m));\n\t\t\t\tawait rpc.GenerateAsync(1);\n\t\t\t\ttx = await rpc.GetRawTransactionAsync(hash);\n\t\t\t\tcoin = tx.Outputs.GetCoins(witnessAddress.ScriptPubKey).Single();\n\t\t\t\tproof = key.SignCompact(blindedOutputScriptsHash);\n\t\t\t\tinputProofs.Add(new InputProofModel { Input = coin.Outpoint.ToTxoRef(), Proof = proof });\n\t\t\t}\n\t\t\tvar blockHashed = await rpc.GenerateAsync(1);\n\n\t\t\tinputsRequest.Inputs = inputProofs;\n\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.Equal($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nMaximum 7 inputs can be registered.\", httpRequestException.Message);\n\t\t\tinputProofs.RemoveLast();\n\t\t\tinputsRequest.Inputs = inputProofs;\n\n\t\t\tAssert.NotNull(currentRound);\n\t\t\tAssert.Equal(RoundPhase.InputRegistration, currentRound.Phase);\n\t\t\tAssert.Equal(2, currentRound.AnonymitySet);\n\t\t\tAssert.Equal(1, currentRound.CountAlices());\n\n\t\t\tvar awaiter = new EventAwaiter<RoundPhase>(\n\t\t\t\th => currentRound.PhaseChanged += h,\n\t\t\t\th => currentRound.PhaseChanged -= h);\n\n\t\t\tusing (var aliceClient = await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null))\n\t\t\t{\n\t\t\t\tAssert.Equal(2, currentRound.AnonymitySet);\n\t\t\t\tAssert.Equal(2, currentRound.CountAlices());\n\t\t\t\tAssert.NotEqual(Guid.Empty, aliceClient.UniqueId);\n\t\t\t\tAssert.True(aliceClient.RoundId > 0);\n\n\t\t\t\tawait awaiter.WaitAsync(TimeSpan.FromSeconds(7));\n\n\t\t\t\tvar roundState = await satoshiClient.GetRoundStateAsync(aliceClient.RoundId);\n\t\t\t\tAssert.Equal(RoundPhase.ConnectionConfirmation, roundState.Phase);\n\t\t\t\tAssert.Equal(2, roundState.RegisteredPeerCount);\n\t\t\t\tvar inputRegistrableRoundState = await satoshiClient.GetRegistrableRoundStateAsync();\n\t\t\t\tAssert.Equal(0, inputRegistrableRoundState.RegisteredPeerCount);\n\n\t\t\t\troundConfig.ConnectionConfirmationTimeout = 1; \/\/ One second.\n\t\t\t\tawait coordinator.RoundConfig.UpdateOrDefaultAsync(roundConfig, toFile: true);\n\t\t\t\tcoordinator.AbortAllRoundsInInputRegistration(\"\");\n\t\t\t\tround = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\t\t\t\troundId = round.RoundId;\n\t\t\t\tinputsRequest.RoundId = roundId;\n\t\t\t\tschnorrPubKeys = round.MixingLevels.SchnorrPubKeys;\n\n\t\t\t\troundState = await satoshiClient.GetRoundStateAsync(aliceClient.RoundId);\n\t\t\t\tAssert.Equal(RoundPhase.ConnectionConfirmation, roundState.Phase);\n\t\t\t\tAssert.Equal(2, roundState.RegisteredPeerCount);\n\t\t\t}\n\n\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.Equal($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nInput is already registered in another round.\", httpRequestException.Message);\n\n\t\t\t\/\/ Wait until input registration times out.\n\t\t\tawait Task.Delay(TimeSpan.FromSeconds(8));\n\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.StartsWith($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nInput is banned from participation for\", httpRequestException.Message);\n\n\t\t\tvar spendingTx = network.Consensus.ConsensusFactory.CreateTransaction();\n\t\t\tvar bannedCoin = inputsRequest.Inputs.First().Input;\n\t\t\tvar utxos = coordinator.UtxoReferee;\n\t\t\tAssert.NotNull(await utxos.TryGetBannedAsync(bannedCoin.ToOutPoint(), false));\n\t\t\tspendingTx.Inputs.Add(new TxIn(bannedCoin.ToOutPoint()));\n\t\t\tspendingTx.Outputs.Add(new TxOut(Money.Coins(1), new Key().PubKey.GetSegwitAddress(network)));\n\t\t\tawait coordinator.ProcessConfirmedTransactionAsync(spendingTx);\n\n\t\t\tAssert.NotNull(await utxos.TryGetBannedAsync(new OutPoint(spendingTx.GetHash(), 0), false));\n\t\t\tAssert.Null(await utxos.TryGetBannedAsync(bannedCoin.ToOutPoint(), false));\n\n\t\t\tstates = await satoshiClient.GetAllRoundStatesAsync();\n\t\t\tforeach (var rs in states.Where(x => x.Phase == RoundPhase.InputRegistration))\n\t\t\t{\n\t\t\t\tAssert.Equal(0, rs.RegisteredPeerCount);\n\t\t\t}\n\n\t\t\t#endregion PostInputsGetStates\n\n\t\t\t#region PostConfirmationPostUnconfirmation\n\n\t\t\t\/\/ <-------------------------->\n\t\t\t\/\/ POST CONFIRMATION and POST UNCONFIRMATION tests\n\t\t\t\/\/ <-------------------------->\n\n\t\t\tkey = new Key();\n\t\t\twitnessAddress = key.PubKey.GetSegwitAddress(network);\n\t\t\thash = await rpc.SendToAddressAsync(witnessAddress, Money.Coins(0.01m));\n\t\t\tawait rpc.GenerateAsync(1);\n\t\t\ttx = await rpc.GetRawTransactionAsync(hash);\n\t\t\tcoin = tx.Outputs.GetCoins(witnessAddress.ScriptPubKey).Single();\n\t\t\tround = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\t\t\trequester = new Requester();\n\t\t\trequesters = new[] { requester };\n\t\t\tBitcoinWitPubKeyAddress bitcoinWitPubKeyAddress = new Key().PubKey.GetSegwitAddress(network);\n\t\t\tregisteredAddresses = new[] { bitcoinWitPubKeyAddress };\n\t\t\tScript script = bitcoinWitPubKeyAddress.ScriptPubKey;\n\t\t\tblindedData = requester.BlindScript(round.MixingLevels.GetBaseLevel().Signer.Key.PubKey, round.MixingLevels.GetBaseLevel().Signer.R.PubKey, script);\n\t\t\tblindedOutputScriptsHash = new uint256(Hashes.SHA256(blindedData.ToBytes()));\n\n\t\t\tusing (var aliceClient = await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, new Key().PubKey.GetAddress(ScriptPubKeyType.Segwit, network), new[] { blindedData }, new InputProofModel[] { new InputProofModel { Input = coin.Outpoint.ToTxoRef(), Proof = key.SignCompact(blindedOutputScriptsHash) } }, baseUri, null))\n\t\t\t{\n\t\t\t\tAssert.NotEqual(Guid.Empty, aliceClient.UniqueId);\n\t\t\t\tAssert.True(aliceClient.RoundId > 0);\n\t\t\t\t\/\/ Double the request.\n\t\t\t\t\/\/ badrequests\n\t\t\t\tusing (var response = await torClient.SendAsync(HttpMethod.Post, $\"\/api\/v{Constants.BackendMajorVersion}\/btc\/chaumiancoinjoin\/confirmation\"))\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(HttpStatusCode.BadRequest, response.StatusCode);\n\t\t\t\t}\n\t\t\t\tusing (var response = await torClient.SendAsync(HttpMethod.Post, $\"\/api\/v{Constants.BackendMajorVersion}\/btc\/chaumiancoinjoin\/confirmation?uniqueId={aliceClient.UniqueId}\"))\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(HttpStatusCode.BadRequest, response.StatusCode);\n\t\t\t\t}\n\t\t\t\tusing (var response = await torClient.SendAsync(HttpMethod.Post, $\"\/api\/v{Constants.BackendMajorVersion}\/btc\/chaumiancoinjoin\/confirmation?roundId={aliceClient.RoundId}\"))\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(HttpStatusCode.BadRequest, response.StatusCode);\n\t\t\t\t}\n\t\t\t\tusing (var response = await torClient.SendAsync(HttpMethod.Post, $\"\/api\/v{Constants.BackendMajorVersion}\/btc\/chaumiancoinjoin\/confirmation?uniqueId=foo&roundId={aliceClient.RoundId}\"))\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(HttpStatusCode.BadRequest, response.StatusCode);\n\t\t\t\t\tAssert.Equal(\"Invalid uniqueId provided.\", await response.Content.ReadAsJsonAsync<string>());\n\t\t\t\t}\n\t\t\t\tusing (var response = await torClient.SendAsync(HttpMethod.Post, $\"\/api\/v{Constants.BackendMajorVersion}\/btc\/chaumiancoinjoin\/confirmation?uniqueId={aliceClient.UniqueId}&roundId=bar\"))\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(HttpStatusCode.BadRequest, response.StatusCode);\n\t\t\t\t\tAssert.Null(await response.Content.ReadAsJsonAsync<string>());\n\t\t\t\t}\n\n\t\t\t\troundConfig.ConnectionConfirmationTimeout = 60;\n\t\t\t\tawait coordinator.RoundConfig.UpdateOrDefaultAsync(roundConfig, toFile: true);\n\t\t\t\tcoordinator.AbortAllRoundsInInputRegistration(\"\");\n\t\t\t\tround = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\t\t\t\troundId = round.RoundId;\n\t\t\t\tinputsRequest.RoundId = roundId;\n\t\t\t\tschnorrPubKeys = round.MixingLevels.SchnorrPubKeys;\n\t\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await aliceClient.PostConfirmationAsync());\n\t\t\t\tAssert.Equal($\"{HttpStatusCode.Gone.ToReasonString()}\\nRound is not running.\", httpRequestException.Message);\n\t\t\t}\n\n\t\t\tusing (var aliceClient = await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, new Key().PubKey.GetAddress(ScriptPubKeyType.Segwit, network), new[] { blindedData }, new InputProofModel[] { new InputProofModel { Input = coin.Outpoint.ToTxoRef(), Proof = key.SignCompact(blindedOutputScriptsHash) } }, baseUri, null))\n\t\t\t{\n\t\t\t\tAssert.NotEqual(Guid.Empty, aliceClient.UniqueId);\n\t\t\t\tAssert.True(aliceClient.RoundId > 0);\n\t\t\t\tawait aliceClient.PostUnConfirmationAsync();\n\t\t\t\tusing HttpResponseMessage response = await torClient.SendAsync(HttpMethod.Post, $\"\/api\/v{Constants.BackendMajorVersion}\/btc\/chaumiancoinjoin\/unconfirmation?uniqueId={aliceClient.UniqueId}&roundId={aliceClient.RoundId}\");\n\t\t\t\tAssert.True(response.IsSuccessStatusCode);\n\t\t\t\tAssert.Equal(HttpStatusCode.OK, response.StatusCode);\n\t\t\t\tAssert.Equal(\"Alice not found.\", await response.Content.ReadAsJsonAsync<string>());\n\t\t\t}\n\n\t\t\t#endregion PostConfirmationPostUnconfirmation\n\n\t\t\t#region PostOutput\n\n\t\t\t\/\/ <-------------------------->\n\t\t\t\/\/ POST OUTPUT tests\n\t\t\t\/\/ <-------------------------->\n\n\t\t\tvar key1 = new Key();\n\t\t\tvar key2 = new Key();\n\t\t\tvar outputAddress1 = key1.PubKey.GetSegwitAddress(network);\n\t\t\tvar outputAddress2 = key2.PubKey.GetSegwitAddress(network);\n\t\t\tvar hash1 = await rpc.SendToAddressAsync(outputAddress1, Money.Coins(0.01m));\n\t\t\tvar hash2 = await rpc.SendToAddressAsync(outputAddress2, Money.Coins(0.01m));\n\t\t\tawait rpc.GenerateAsync(1);\n\t\t\tvar tx1 = await rpc.GetRawTransactionAsync(hash1);\n\t\t\tvar tx2 = await rpc.GetRawTransactionAsync(hash2);\n\t\t\tvar index1 = 0;\n\t\t\tfor (int i = 0; i < tx1.Outputs.Count; i++)\n\t\t\t{\n\t\t\t\tvar output = tx1.Outputs[i];\n\t\t\t\tif (output.ScriptPubKey == outputAddress1.ScriptPubKey)\n\t\t\t\t{\n\t\t\t\t\tindex1 = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar index2 = 0;\n\t\t\tfor (int i = 0; i < tx2.Outputs.Count; i++)\n\t\t\t{\n\t\t\t\tvar output = tx2.Outputs[i];\n\t\t\t\tif (output.ScriptPubKey == outputAddress2.ScriptPubKey)\n\t\t\t\t{\n\t\t\t\t\tindex2 = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tround = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\t\t\tschnorrPubKeys = round.MixingLevels.SchnorrPubKeys;\n\t\t\troundId = round.RoundId;\n\n\t\t\tvar requester1 = new Requester();\n\t\t\tvar requester2 = new Requester();\n\n\t\t\tuint256 blinded1 = requester1.BlindScript(round.MixingLevels.GetBaseLevel().Signer.Key.PubKey, round.MixingLevels.GetBaseLevel().Signer.R.PubKey, outputAddress1.ScriptPubKey);\n\t\t\tuint256 blindedOutputScriptsHash1 = new uint256(Hashes.SHA256(blinded1.ToBytes()));\n\t\t\tuint256 blinded2 = requester2.BlindScript(round.MixingLevels.GetBaseLevel().Signer.Key.PubKey, round.MixingLevels.GetBaseLevel().Signer.R.PubKey, outputAddress2.ScriptPubKey);\n\t\t\tuint256 blindedOutputScriptsHash2 = new uint256(Hashes.SHA256(blinded2.ToBytes()));\n\n\t\t\tvar input1 = new OutPoint(hash1, index1);\n\t\t\tvar input2 = new OutPoint(hash2, index2);\n\n\t\t\tusing (var aliceClient1 = await AliceClient.CreateNewAsync(roundId, new[] { outputAddress1 }, schnorrPubKeys, new[] { requester1 }, network, new Key().PubKey.GetAddress(ScriptPubKeyType.Segwit, network), new[] { blinded1 }, new InputProofModel[] { new InputProofModel { Input = input1.ToTxoRef(), Proof = key1.SignCompact(blindedOutputScriptsHash1) } }, baseUri, null))\n\t\t\tusing (var aliceClient2 = await AliceClient.CreateNewAsync(roundId, new[] { outputAddress2 }, schnorrPubKeys, new[] { requester2 }, network, new Key().PubKey.GetAddress(ScriptPubKeyType.Segwit, network), new[] { blinded2 }, new InputProofModel[] { new InputProofModel { Input = input2.ToTxoRef(), Proof = key2.SignCompact(blindedOutputScriptsHash2) } }, baseUri, null))\n\t\t\t{\n\t\t\t\tAssert.Equal(aliceClient2.RoundId, aliceClient1.RoundId);\n\t\t\t\tAssert.NotEqual(aliceClient2.UniqueId, aliceClient1.UniqueId);\n\n\t\t\t\tvar connConfResp = await aliceClient1.PostConfirmationAsync();\n\t\t\t\tAssert.Equal(connConfResp.currentPhase, (await aliceClient1.PostConfirmationAsync()).currentPhase); \/\/ Make sure it won't throw error for double confirming.\n\t\t\t\tvar connConfResp2 = await aliceClient2.PostConfirmationAsync();\n\n\t\t\t\tAssert.Equal(connConfResp.currentPhase, connConfResp2.currentPhase);\n\t\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await aliceClient2.PostConfirmationAsync());\n\t\t\t\tAssert.Equal($\"{HttpStatusCode.Gone.ToReasonString()}\\nParticipation can be only confirmed from InputRegistration or ConnectionConfirmation phase. Current phase: OutputRegistration.\", httpRequestException.Message);\n\n\t\t\t\tvar roundState = await satoshiClient.GetRoundStateAsync(aliceClient1.RoundId);\n\t\t\t\tAssert.Equal(RoundPhase.OutputRegistration, roundState.Phase);\n\n\t\t\t\tif (!round.MixingLevels.GetBaseLevel().Signer.VerifyUnblindedSignature(connConfResp2.activeOutputs.First().Signature, outputAddress2.ScriptPubKey.ToBytes()))\n\t\t\t\t{\n\t\t\t\t\tthrow new NotSupportedException(\"Coordinator did not sign the blinded output properly.\");\n\t\t\t\t}\n\n\t\t\t\tusing (var bobClient1 = new BobClient(baseUri, null))\n\t\t\t\tusing (var bobClient2 = new BobClient(baseUri, null))\n\t\t\t\t{\n\t\t\t\t\tawait bobClient1.PostOutputAsync(aliceClient1.RoundId, new ActiveOutput(outputAddress1, connConfResp.activeOutputs.First().Signature, 0));\n\t\t\t\t\tawait bobClient2.PostOutputAsync(aliceClient2.RoundId, new ActiveOutput(outputAddress2, connConfResp2.activeOutputs.First().Signature, 0));\n\t\t\t\t}\n\n\t\t\t\troundState = await satoshiClient.GetRoundStateAsync(aliceClient1.RoundId);\n\t\t\t\tAssert.Equal(RoundPhase.Signing, roundState.Phase);\n\t\t\t\tAssert.Equal(2, roundState.RegisteredPeerCount);\n\t\t\t\tAssert.Equal(2, roundState.RequiredPeerCount);\n\n\t\t\t\t#endregion PostOutput\n\n\t\t\t\t#region GetCoinjoin\n\n\t\t\t\t\/\/ <-------------------------->\n\t\t\t\t\/\/ GET COINJOIN tests\n\t\t\t\t\/\/ <-------------------------->\n\n\t\t\t\tTransaction unsignedCoinJoin = await aliceClient1.GetUnsignedCoinJoinAsync();\n\t\t\t\tAssert.Equal(unsignedCoinJoin.ToHex(), (await aliceClient1.GetUnsignedCoinJoinAsync()).ToHex());\n\t\t\t\tAssert.Equal(unsignedCoinJoin.ToHex(), (await aliceClient2.GetUnsignedCoinJoinAsync()).ToHex());\n\n\t\t\t\tAssert.Contains(outputAddress1.ScriptPubKey, unsignedCoinJoin.Outputs.Select(x => x.ScriptPubKey));\n\t\t\t\tAssert.Contains(outputAddress2.ScriptPubKey, unsignedCoinJoin.Outputs.Select(x => x.ScriptPubKey));\n\t\t\t\tAssert.True(2 == unsignedCoinJoin.Outputs.Count); \/\/ Because the two input is equal, so change addresses won't be used, nor coordinator fee will be taken.\n\t\t\t\tAssert.Contains(input1, unsignedCoinJoin.Inputs.Select(x => x.PrevOut));\n\t\t\t\tAssert.Contains(input2, unsignedCoinJoin.Inputs.Select(x => x.PrevOut));\n\t\t\t\tAssert.True(2 == unsignedCoinJoin.Inputs.Count);\n\n\t\t\t\t#endregion GetCoinjoin\n\n\t\t\t\t#region PostSignatures\n\n\t\t\t\t\/\/ <-------------------------->\n\t\t\t\t\/\/ POST SIGNATURES tests\n\t\t\t\t\/\/ <-------------------------->\n\n\t\t\t\tvar partSignedCj1 = Transaction.Parse(unsignedCoinJoin.ToHex(), network);\n\t\t\t\tvar partSignedCj2 = Transaction.Parse(unsignedCoinJoin.ToHex(), network);\n\n\t\t\t\tvar builder = Network.RegTest.CreateTransactionBuilder();\n\t\t\t\tpartSignedCj1 = builder\n\t\t\t\t\t.ContinueToBuild(partSignedCj1)\n\t\t\t\t\t.AddKeys(key1)\n\t\t\t\t\t.AddCoins(new Coin(tx1, input1.N))\n\t\t\t\t\t.BuildTransaction(true);\n\n\t\t\t\tbuilder = Network.RegTest.CreateTransactionBuilder();\n\t\t\t\tpartSignedCj2 = builder\n\t\t\t\t\t.ContinueToBuild(partSignedCj2)\n\t\t\t\t\t.AddKeys(key2)\n\t\t\t\t\t.AddCoins(new Coin(tx2, input2.N))\n\t\t\t\t\t.BuildTransaction(true);\n\n\t\t\t\tvar myDic1 = new Dictionary<int, WitScript>();\n\t\t\t\tvar myDic2 = new Dictionary<int, WitScript>();\n\n\t\t\t\tfor (int i = 0; i < unsignedCoinJoin.Inputs.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tvar input = unsignedCoinJoin.Inputs[i];\n\t\t\t\t\tif (input.PrevOut == input1)\n\t\t\t\t\t{\n\t\t\t\t\t\tmyDic1.Add(i, partSignedCj1.Inputs[i].WitScript);\n\t\t\t\t\t}\n\t\t\t\t\tif (input.PrevOut == input2)\n\t\t\t\t\t{\n\t\t\t\t\t\tmyDic2.Add(i, partSignedCj2.Inputs[i].WitScript);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tawait aliceClient1.PostSignaturesAsync(myDic1);\n\t\t\t\tawait aliceClient2.PostSignaturesAsync(myDic2);\n\n\t\t\t\tuint256[] mempooltxs = await rpc.GetRawMempoolAsync();\n\t\t\t\tAssert.Contains(unsignedCoinJoin.GetHash(), mempooltxs);\n\n\t\t\t\tvar wasabiClient = new WasabiClient(baseUri, null);\n\t\t\t\tvar syncInfo = await wasabiClient.GetSynchronizeAsync(blockHashed[0], 1);\n\t\t\t\tAssert.Contains(unsignedCoinJoin.GetHash(), syncInfo.UnconfirmedCoinJoins);\n\t\t\t\tvar txs = await wasabiClient.GetTransactionsAsync(network, new[] { unsignedCoinJoin.GetHash() }, CancellationToken.None);\n\t\t\t\tAssert.NotEmpty(txs);\n\n\t\t\t\t#endregion PostSignatures\n\t\t\t}\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task CcjEqualInputTestsAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\tMoney denomination = Money.Coins(0.1m);\n\t\t\tdecimal coordinatorFeePercent = 0.0002m;\n\t\t\tint anonymitySet = 4;\n\t\t\tint connectionConfirmationTimeout = 50;\n\t\t\tvar roundConfig = RegTestFixture.CreateRoundConfig(denomination, 2, 0.7, coordinatorFeePercent, anonymitySet, 100, connectionConfirmationTimeout, 50, 50, 2, 24, false, 11);\n\t\t\tawait coordinator.RoundConfig.UpdateOrDefaultAsync(roundConfig, toFile: true);\n\t\t\tcoordinator.AbortAllRoundsInInputRegistration(\"\");\n\n\t\t\tUri baseUri = new Uri(RegTestFixture.BackendEndPoint);\n\t\t\tusing var torClient = new TorHttpClient(baseUri, Global.Instance.TorSocks5Endpoint);\n\t\t\tusing var satoshiClient = new SatoshiClient(baseUri, null);\n\t\t\tvar round = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\t\t\tvar roundId = round.RoundId;\n\n\t\t\t\/\/ We have to 4 participant so, this data structure is for keeping track of\n\t\t\t\/\/ important data for each of the participants in the coinjoin session.\n\t\t\tvar participants = new List<(AliceClient aliceClient,\n\t\t\t\t\t\t\t\t\t\t List<(Requester requester, BitcoinWitPubKeyAddress outputAddress, uint256 blindedScript)> outouts,\n\t\t\t\t\t\t\t\t\t\t List<(TxoRef input, byte[] proof, Coin coin, Key key)> inputs)>();\n\n\t\t\t\/\/ INPUS REGISTRATION PHASE --\n\t\t\tfor (var anosetIdx = 0; anosetIdx < anonymitySet; anosetIdx++)\n\t\t\t{\n\t\t\t\t\/\/ Create as many outputs as mixin levels (even when we do not have funds enough)\n\t\t\t\tvar outputs = new List<(Requester requester, BitcoinWitPubKeyAddress outputAddress, uint256 blindedScript)>();\n\t\t\t\tforeach (var level in round.MixingLevels.Levels)\n\t\t\t\t{\n\t\t\t\t\tvar requester = new Requester();\n\t\t\t\t\tvar outputsAddress = new Key().PubKey.GetSegwitAddress(network);\n\t\t\t\t\tvar scriptPubKey = outputsAddress.ScriptPubKey;\n\t\t\t\t\t\/\/ We blind the scriptPubKey with a new requester by mixin level\n\t\t\t\t\tvar blindedScript = requester.BlindScript(level.Signer.Key.PubKey, level.Signer.R.PubKey, scriptPubKey);\n\t\t\t\t\toutputs.Add((requester, outputsAddress, blindedScript));\n\t\t\t\t}\n\n\t\t\t\t\/\/ Calculate the SHA256( blind1 || blind2 || .....|| blindN )\n\t\t\t\tvar blindedOutputScriptList = outputs.Select(x => x.blindedScript);\n\t\t\t\tvar blindedOutputScriptListBytes = ByteHelpers.Combine(blindedOutputScriptList.Select(x => x.ToBytes()));\n\t\t\t\tvar blindedOutputScriptsHash = new uint256(Hashes.SHA256(blindedOutputScriptListBytes));\n\n\t\t\t\t\/\/ Create 4 new coins that we want to mix\n\t\t\t\tvar inputs = new List<(TxoRef input, byte[] proof, Coin coin, Key key)>();\n\t\t\t\tfor (var inputIdx = 0; inputIdx < 4; inputIdx++)\n\t\t\t\t{\n\t\t\t\t\tvar key = new Key();\n\t\t\t\t\tvar outputAddress = key.PubKey.GetSegwitAddress(network);\n\t\t\t\t\tvar hash = await rpc.SendToAddressAsync(outputAddress, Money.Coins(0.1m));\n\t\t\t\t\tawait rpc.GenerateAsync(1);\n\t\t\t\t\tvar tx = await rpc.GetRawTransactionAsync(hash);\n\t\t\t\t\tvar index = tx.Outputs.FindIndex(x => x.ScriptPubKey == outputAddress.ScriptPubKey);\n\t\t\t\t\tvar input = new OutPoint(hash, index);\n\n\t\t\t\t\tinputs.Add((\n\t\t\t\t\t\tinput.ToTxoRef(),\n\t\t\t\t\t\tkey.SignCompact(blindedOutputScriptsHash),\n\t\t\t\t\t\tnew Coin(tx, (uint)index),\n\t\t\t\t\t\tkey\n\t\t\t\t\t));\n\t\t\t\t}\n\n\t\t\t\t\/\/ Save alice client and the outputs, requesters, etc\n\t\t\t\tvar changeOutput = new Key().PubKey.GetAddress(ScriptPubKeyType.Segwit, network);\n\t\t\t\tvar inputProof = inputs.Select(x => new InputProofModel { Input = x.input, Proof = x.proof }).ToArray();\n\t\t\t\tvar aliceClient = await AliceClient.CreateNewAsync(\n\t\t\t\t\tround.RoundId,\n\t\t\t\t\toutputs.Select(x => x.outputAddress),\n\t\t\t\t\tround.MixingLevels.SchnorrPubKeys,\n\t\t\t\t\toutputs.Select(x => x.requester),\n\t\t\t\t\tnetwork, changeOutput, blindedOutputScriptList, inputProof, baseUri, null);\n\n\t\t\t\t\/\/ We check the coordinator signed all the alice blinded outputs\n\t\t\t\tparticipants.Add((aliceClient, outputs, inputs));\n\t\t\t}\n\n\t\t\t\/\/ CONNECTION CONFIRMATION PHASE --\n\t\t\tvar activeOutputs = new List<IEnumerable<ActiveOutput>>();\n\t\t\tvar j = 0;\n\t\t\tforeach (var (aliceClient, _, _) in participants)\n\t\t\t{\n\t\t\t\tvar res = await aliceClient.PostConfirmationAsync();\n\t\t\t\tactiveOutputs.Add(res.activeOutputs);\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\t\/\/ OUTPUTS REGISTRATION PHASE --\n\t\t\tvar roundState = await satoshiClient.GetRoundStateAsync(roundId);\n\t\t\tAssert.Equal(RoundPhase.OutputRegistration, roundState.Phase);\n\n\t\t\tvar l = 0;\n\t\t\tforeach (var (aliceClient, outputs, _) in participants)\n\t\t\t{\n\t\t\t\tusing (var bobClient = new BobClient(baseUri, null))\n\t\t\t\t{\n\t\t\t\t\tvar i = 0;\n\t\t\t\t\tforeach (var output in outputs.Take(activeOutputs[l].Count()))\n\t\t\t\t\t{\n\t\t\t\t\t\tawait bobClient.PostOutputAsync(aliceClient.RoundId, new ActiveOutput(output.outputAddress, activeOutputs[l].ElementAt(i).Signature, i));\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tl++;\n\t\t\t}\n\n\t\t\t\/\/ SIGNING PHASE --\n\t\t\troundState = await satoshiClient.GetRoundStateAsync(roundId);\n\t\t\tAssert.Equal(RoundPhase.Signing, roundState.Phase);\n\n\t\t\tuint256 transactionId = null;\n\t\t\tforeach (var (aliceClient, outputs, inputs) in participants)\n\t\t\t{\n\t\t\t\tvar unsignedTransaction = await aliceClient.GetUnsignedCoinJoinAsync();\n\t\t\t\ttransactionId = unsignedTransaction.GetHash();\n\n\t\t\t\t\/\/ Verify the transaction contains the expected inputs and outputs\n\n\t\t\t\t\/\/ Verify the inputs are the expected ones.\n\t\t\t\tforeach (var input in inputs)\n\t\t\t\t{\n\t\t\t\t\tAssert.Contains(input.input, unsignedTransaction.Inputs.Select(x => x.PrevOut.ToTxoRef()));\n\t\t\t\t}\n\n\t\t\t\t\/\/ Sign the transaction\n\t\t\t\tvar builder = Network.RegTest.CreateTransactionBuilder();\n\t\t\t\tvar partSignedCj = builder\n\t\t\t\t\t.ContinueToBuild(unsignedTransaction)\n\t\t\t\t\t.AddKeys(inputs.Select(x => x.key).ToArray())\n\t\t\t\t\t.AddCoins(inputs.Select(x => x.coin))\n\t\t\t\t\t.BuildTransaction(true);\n\n\t\t\t\tvar witnesses = partSignedCj.Inputs\n\t\t\t\t\t.AsIndexedInputs()\n\t\t\t\t\t.Where(x => x.WitScript != WitScript.Empty)\n\t\t\t\t\t.ToDictionary(x => (int)x.Index, x => x.WitScript);\n\n\t\t\t\tawait aliceClient.PostSignaturesAsync(witnesses);\n\t\t\t}\n\n\t\t\tuint256[] mempooltxs = await rpc.GetRawMempoolAsync();\n\t\t\tAssert.Contains(transactionId, mempooltxs);\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task NotingTestsAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\tMoney denomination = Money.Coins(1m);\n\t\t\tdecimal coordinatorFeePercent = 0.1m;\n\t\t\tint anonymitySet = 2;\n\t\t\tint connectionConfirmationTimeout = 1;\n\t\t\tbool doesNoteBeforeBan = true;\n\t\t\tCoordinatorRoundConfig roundConfig = RegTestFixture.CreateRoundConfig(denomination, 140, 0.7, coordinatorFeePercent, anonymitySet, 240, connectionConfirmationTimeout, 1, 1, 1, 24, doesNoteBeforeBan, 11);\n\t\t\tawait coordinator.RoundConfig.UpdateOrDefaultAsync(roundConfig, toFile: true);\n\t\t\tcoordinator.AbortAllRoundsInInputRegistration(\"\");\n\n\t\t\tUri baseUri = new Uri(RegTestFixture.BackendEndPoint);\n\n\t\t\tvar registerRequests = new List<(BitcoinWitPubKeyAddress changeOutputAddress, uint256 blindedData, InputProofModel[] inputsProofs)>();\n\t\t\tAliceClient aliceClientBackup = null;\n\t\t\tCoordinatorRound round = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\t\t\tfor (int i = 0; i < roundConfig.AnonymitySet; i++)\n\t\t\t{\n\t\t\t\tBitcoinWitPubKeyAddress activeOutputAddress = new Key().PubKey.GetSegwitAddress(network);\n\t\t\t\tBitcoinWitPubKeyAddress changeOutputAddress = new Key().PubKey.GetSegwitAddress(network);\n\t\t\t\tKey inputKey = new Key();\n\t\t\t\tBitcoinWitPubKeyAddress inputAddress = inputKey.PubKey.GetSegwitAddress(network);\n\n\t\t\t\tvar requester = new Requester();\n\t\t\t\tuint256 blinded = requester.BlindScript(round.MixingLevels.GetBaseLevel().Signer.Key.PubKey, round.MixingLevels.GetBaseLevel().Signer.R.PubKey, activeOutputAddress.ScriptPubKey);\n\t\t\t\tuint256 blindedOutputScriptsHash = new uint256(Hashes.SHA256(blinded.ToBytes()));\n\n\t\t\t\tuint256 txHash = await rpc.SendToAddressAsync(inputAddress, Money.Coins(2));\n\t\t\t\tawait rpc.GenerateAsync(1);\n\t\t\t\tTransaction transaction = await rpc.GetRawTransactionAsync(txHash);\n\t\t\t\tCoin coin = transaction.Outputs.GetCoins(inputAddress.ScriptPubKey).Single();\n\t\t\t\tOutPoint input = coin.Outpoint;\n\n\t\t\t\tInputProofModel inputProof = new InputProofModel { Input = input.ToTxoRef(), Proof = inputKey.SignCompact(blindedOutputScriptsHash) };\n\t\t\t\tInputProofModel[] inputsProofs = new InputProofModel[] { inputProof };\n\t\t\t\tregisterRequests.Add((changeOutputAddress, blinded, inputsProofs));\n\t\t\t\taliceClientBackup = await AliceClient.CreateNewAsync(round.RoundId, new[] { activeOutputAddress }, new[] { round.MixingLevels.GetBaseLevel().SchnorrKey.SchnorrPubKey }, new[] { requester }, network, changeOutputAddress, new[] { blinded }, inputsProofs, baseUri, null);\n\t\t\t}\n\n\t\t\tawait WaitForTimeoutAsync(baseUri);\n\n\t\t\tint bannedCount = coordinator.UtxoReferee.CountBanned(false);\n\t\t\tAssert.Equal(0, bannedCount);\n\t\t\tint notedCount = coordinator.UtxoReferee.CountBanned(true);\n\t\t\tAssert.Equal(anonymitySet, notedCount);\n\n\t\t\tround = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\n\t\t\tforeach (var registerRequest in registerRequests)\n\t\t\t{\n\t\t\t\tawait AliceClient.CreateNewAsync(round.RoundId, aliceClientBackup.RegisteredAddresses, round.MixingLevels.GetAllLevels().Select(x => x.SchnorrKey.SchnorrPubKey), aliceClientBackup.Requesters, network, registerRequest.changeOutputAddress, new[] { registerRequest.blindedData }, registerRequest.inputsProofs, baseUri, null);\n\t\t\t}\n\n\t\t\tawait WaitForTimeoutAsync(baseUri);\n\n\t\t\tbannedCount = coordinator.UtxoReferee.CountBanned(false);\n\t\t\tAssert.Equal(anonymitySet, bannedCount);\n\t\t\tnotedCount = coordinator.UtxoReferee.CountBanned(true);\n\t\t\tAssert.Equal(anonymitySet, notedCount);\n\t\t}\n\n\t\tprivate static async Task WaitForTimeoutAsync(Uri baseUri)\n\t\t{\n\t\t\tusing var satoshiClient = new SatoshiClient(baseUri, null);\n\t\t\tvar times = 0;\n\t\t\twhile (!(await satoshiClient.GetAllRoundStatesAsync()).All(x => x.Phase == RoundPhase.InputRegistration))\n\t\t\t{\n\t\t\t\tawait Task.Delay(100);\n\t\t\t\tif (times > 50) \/\/ 5 sec, 3 should be enough\n\t\t\t\t{\n\t\t\t\t\tthrow new TimeoutException(\"Not all rounds were in InputRegistration.\");\n\t\t\t\t}\n\t\t\t\ttimes++;\n\t\t\t}\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task BanningTestsAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\tMoney denomination = Money.Coins(0.1m);\n\t\t\tdecimal coordinatorFeePercent = 0.1m;\n\t\t\tint anonymitySet = 3;\n\t\t\tint connectionConfirmationTimeout = 120;\n\t\t\tvar roundConfig = RegTestFixture.CreateRoundConfig(denomination, 140, 0.7, coordinatorFeePercent, anonymitySet, 240, connectionConfirmationTimeout, 1, 1, 1, 24, true, 11);\n\t\t\tawait coordinator.RoundConfig.UpdateOrDefaultAsync(roundConfig, toFile: true);\n\t\t\tcoordinator.AbortAllRoundsInInputRegistration(\"\");\n\n\t\t\tawait rpc.GenerateAsync(3); \/\/ So to make sure we have enough money.\n\n\t\t\tUri baseUri = new Uri(RegTestFixture.BackendEndPoint);\n\t\t\tvar fundingTxCount = 0;\n\t\t\tvar inputRegistrationUsers = new List<(Requester requester, uint256 blinded, BitcoinAddress activeOutputAddress, BitcoinAddress changeOutputAddress, IEnumerable<InputProofModel> inputProofModels, List<(Key key, BitcoinWitPubKeyAddress address, uint256 txHash, Transaction tx, OutPoint input)> userInputData)>();\n\t\t\tCoordinatorRound round = null;\n\t\t\tfor (int i = 0; i < roundConfig.AnonymitySet; i++)\n\t\t\t{\n\t\t\t\tvar userInputData = new List<(Key key, BitcoinWitPubKeyAddress inputAddress, uint256 txHash, Transaction tx, OutPoint input)>();\n\t\t\t\tvar activeOutputAddress = new Key().PubKey.GetAddress(ScriptPubKeyType.Segwit, network);\n\t\t\t\tvar changeOutputAddress = new Key().PubKey.GetAddress(ScriptPubKeyType.Segwit, network);\n\t\t\t\tround = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\t\t\t\tRequester requester = new Requester();\n\t\t\t\tuint256 blinded = requester.BlindScript(round.MixingLevels.GetBaseLevel().Signer.Key.PubKey, round.MixingLevels.GetBaseLevel().Signer.R.PubKey, activeOutputAddress.ScriptPubKey);\n\t\t\t\tuint256 blindedOutputScriptsHash = new uint256(Hashes.SHA256(blinded.ToBytes()));\n\n\t\t\t\tvar inputProofModels = new List<InputProofModel>();\n\t\t\t\tint numberOfInputs = new Random().Next(1, 7);\n\t\t\t\tvar receiveSatoshiSum = 0;\n\t\t\t\tfor (int j = 0; j < numberOfInputs; j++)\n\t\t\t\t{\n\t\t\t\t\tvar key = new Key();\n\t\t\t\t\tvar receiveSatoshi = new Random().Next(1000, 100000000);\n\t\t\t\t\treceiveSatoshiSum += receiveSatoshi;\n\t\t\t\t\tif (j == numberOfInputs - 1)\n\t\t\t\t\t{\n\t\t\t\t\t\treceiveSatoshi = 100000000;\n\t\t\t\t\t}\n\t\t\t\t\tBitcoinWitPubKeyAddress inputAddress = key.PubKey.GetSegwitAddress(network);\n\t\t\t\t\tuint256 txHash = await rpc.SendToAddressAsync(inputAddress, Money.Satoshis(receiveSatoshi));\n\t\t\t\t\tfundingTxCount++;\n\t\t\t\t\tAssert.NotNull(txHash);\n\t\t\t\t\tTransaction transaction = await rpc.GetRawTransactionAsync(txHash);\n\n\t\t\t\t\tvar coin = transaction.Outputs.GetCoins(inputAddress.ScriptPubKey).Single();\n\n\t\t\t\t\tOutPoint input = coin.Outpoint;\n\t\t\t\t\tvar inputProof = new InputProofModel { Input = input.ToTxoRef(), Proof = key.SignCompact(blindedOutputScriptsHash) };\n\t\t\t\t\tinputProofModels.Add(inputProof);\n\n\t\t\t\t\tGetTxOutResponse getTxOutResponse = await rpc.GetTxOutAsync(input.Hash, (int)input.N, includeMempool: true);\n\t\t\t\t\t\/\/ Check if inputs are unspent.\n\t\t\t\t\tAssert.NotNull(getTxOutResponse);\n\n\t\t\t\t\tuserInputData.Add((key, inputAddress, txHash, transaction, input));\n\t\t\t\t}\n\n\t\t\t\tinputRegistrationUsers.Add((requester, blinded, activeOutputAddress, changeOutputAddress, inputProofModels, userInputData));\n\t\t\t}\n\n\t\t\tvar mempool = await rpc.GetRawMempoolAsync();\n\t\t\tAssert.Equal(inputRegistrationUsers.SelectMany(x => x.userInputData).Count(), mempool.Length);\n\n\t\t\twhile ((await rpc.GetRawMempoolAsync()).Length != 0)\n\t\t\t{\n\t\t\t\tawait rpc.GenerateAsync(1);\n\t\t\t}\n\n\t\t\tvar aliceClients = new List<Task<AliceClient>>();\n\n\t\t\tforeach (var user in inputRegistrationUsers)\n\t\t\t{\n\t\t\t\taliceClients.Add(AliceClient.CreateNewAsync(round.RoundId, new[] { user.activeOutputAddress }, new[] { round.MixingLevels.GetBaseLevel().SchnorrKey.SchnorrPubKey }, new[] { user.requester }, network, user.changeOutputAddress, new[] { user.blinded }, user.inputProofModels, baseUri, null));\n\t\t\t}\n\n\t\t\tlong roundId = 0;\n\t\t\tvar users = new List<(Requester requester, uint256 blinded, BitcoinAddress activeOutputAddress, BitcoinAddress changeOutputAddress, IEnumerable<InputProofModel> inputProofModels, List<(Key key, BitcoinWitPubKeyAddress address, uint256 txHash, Transaction tx, OutPoint input)> userInputData, AliceClient aliceClient, UnblindedSignature unblindedSignature)>();\n\t\t\tfor (int i = 0; i < inputRegistrationUsers.Count; i++)\n\t\t\t{\n\t\t\t\tvar user = inputRegistrationUsers[i];\n\t\t\t\tvar request = aliceClients[i];\n\n\t\t\t\tvar aliceClient = await request;\n\n\t\t\t\tif (roundId == 0)\n\t\t\t\t{\n\t\t\t\t\troundId = aliceClient.RoundId;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(roundId, aliceClient.RoundId);\n\t\t\t\t}\n\t\t\t\t\/\/ Because it's valuetuple.\n\t\t\t\tusers.Add((user.requester, user.blinded, user.activeOutputAddress, user.changeOutputAddress, user.inputProofModels, user.userInputData, aliceClient, null));\n\t\t\t}\n\n\t\t\tAssert.Equal(users.Count, roundConfig.AnonymitySet);\n\n\t\t\tvar confirmationRequests = new List<Task<(RoundPhase currentPhase, IEnumerable<ActiveOutput>)>>();\n\n\t\t\tforeach (var user in users)\n\t\t\t{\n\t\t\t\tconfirmationRequests.Add(user.aliceClient.PostConfirmationAsync());\n\t\t\t}\n\n\t\t\tRoundPhase roundPhase = RoundPhase.InputRegistration;\n\t\t\tint k = 0;\n\t\t\tforeach (var request in confirmationRequests)\n\t\t\t{\n\t\t\t\tvar resp = await request;\n\t\t\t\tif (roundPhase == RoundPhase.InputRegistration)\n\t\t\t\t{\n\t\t\t\t\troundPhase = resp.currentPhase;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(roundPhase, resp.currentPhase);\n\t\t\t\t}\n\n\t\t\t\tvar user = users.ElementAt(k);\n\t\t\t\tuser.unblindedSignature = resp.Item2.First().Signature;\n\t\t\t}\n\n\t\t\tusing (var satoshiClient = new SatoshiClient(baseUri, null))\n\t\t\t{\n\t\t\t\tvar times = 0;\n\t\t\t\twhile (!(await satoshiClient.GetAllRoundStatesAsync()).All(x => x.Phase == RoundPhase.InputRegistration))\n\t\t\t\t{\n\t\t\t\t\tawait Task.Delay(100);\n\t\t\t\t\tif (times > 50) \/\/ 5 sec, 3 should be enough\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new TimeoutException(\"Not all rounds were in InputRegistration.\");\n\t\t\t\t\t}\n\t\t\t\t\ttimes++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint bannedCount = coordinator.UtxoReferee.CountBanned(false);\n\t\t\tAssert.Equal(0, bannedCount);\n\n\t\t\taliceClients.Clear();\n\t\t\tround = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\t\t\tforeach (var user in inputRegistrationUsers)\n\t\t\t{\n\t\t\t\taliceClients.Add(AliceClient.CreateNewAsync(round.RoundId, new[] { user.activeOutputAddress }, new[] { round.MixingLevels.GetBaseLevel().SchnorrKey.SchnorrPubKey }, new[] { user.requester }, network, user.changeOutputAddress, new[] { user.blinded }, user.inputProofModels, baseUri, null));\n\t\t\t}\n\n\t\t\troundId = 0;\n\t\t\tusers = new List<(Requester requester, uint256 blinded, BitcoinAddress activeOutputAddress, BitcoinAddress changeOutputAddress, IEnumerable<InputProofModel> inputProofModels, List<(Key key, BitcoinWitPubKeyAddress address, uint256 txHash, Transaction tx, OutPoint input)> userInputData, AliceClient aliceClient, UnblindedSignature unblindedSignature)>();\n\t\t\tfor (int i = 0; i < inputRegistrationUsers.Count; i++)\n\t\t\t{\n\t\t\t\tvar user = inputRegistrationUsers[i];\n\t\t\t\tvar request = aliceClients[i];\n\n\t\t\t\tvar aliceClient = await request;\n\t\t\t\tif (roundId == 0)\n\t\t\t\t{\n\t\t\t\t\troundId = aliceClient.RoundId;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(roundId, aliceClient.RoundId);\n\t\t\t\t}\n\t\t\t\t\/\/ Because it's valuetuple.\n\t\t\t\tusers.Add((user.requester, user.blinded, user.activeOutputAddress, user.changeOutputAddress, user.inputProofModels, user.userInputData, aliceClient, null));\n\t\t\t}\n\n\t\t\tAssert.Equal(users.Count, roundConfig.AnonymitySet);\n\n\t\t\tconfirmationRequests = new List<Task<(RoundPhase currentPhase, IEnumerable<ActiveOutput>)>>();\n\n\t\t\tforeach (var user in users)\n\t\t\t{\n\t\t\t\tconfirmationRequests.Add(user.aliceClient.PostConfirmationAsync());\n\t\t\t}\n\n\t\t\tusing (var satoshiClient = new SatoshiClient(baseUri, null))\n\t\t\t{\n\t\t\t\tvar times = 0;\n\t\t\t\twhile (!(await satoshiClient.GetAllRoundStatesAsync()).All(x => x.Phase == RoundPhase.InputRegistration))\n\t\t\t\t{\n\t\t\t\t\tawait Task.Delay(100);\n\t\t\t\t\tif (times > 50) \/\/ 5 sec, 3 should be enough\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new TimeoutException(\"Not all rounds were in InputRegistration.\");\n\t\t\t\t\t}\n\t\t\t\t\ttimes++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbannedCount = coordinator.UtxoReferee.CountBanned(false);\n\t\t\tAssert.True(bannedCount >= roundConfig.AnonymitySet);\n\n\t\t\tforeach (var aliceClient in aliceClients)\n\t\t\t{\n\t\t\t\taliceClient?.Dispose();\n\t\t\t}\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task Ccj100ParticipantsTestsAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\tMoney denomination = Money.Coins(0.1m);\n\t\t\tdecimal coordinatorFeePercent = 0.003m;\n\t\t\tint anonymitySet = 100;\n\t\t\tint connectionConfirmationTimeout = 120;\n\t\t\tvar roundConfig = RegTestFixture.CreateRoundConfig(denomination, Constants.OneDayConfirmationTarget, 0.7, coordinatorFeePercent, anonymitySet, 240, connectionConfirmationTimeout, 50, 50, 1, 24, true, 11);\n\t\t\tawait coordinator.RoundConfig.UpdateOrDefaultAsync(roundConfig, toFile: true);\n\t\t\tcoordinator.AbortAllRoundsInInputRegistration(\"\");\n\t\t\tawait rpc.GenerateAsync(100); \/\/ So to make sure we have enough money.\n\n\t\t\tUri baseUri = new Uri(RegTestFixture.BackendEndPoint);\n\t\t\tvar spentCoins = new List<Coin>();\n\t\t\tvar fundingTxCount = 0;\n\t\t\tvar inputRegistrationUsers = new List<(Requester requester, uint256 blinded, BitcoinAddress activeOutputAddress, BitcoinAddress changeOutputAddress, IEnumerable<InputProofModel> inputProofModels, List<(Key key, BitcoinWitPubKeyAddress address, uint256 txHash, Transaction tx, OutPoint input)> userInputData)>();\n\t\t\tfor (int i = 0; i < roundConfig.AnonymitySet; i++)\n\t\t\t{\n\t\t\t\tvar userInputData = new List<(Key key, BitcoinWitPubKeyAddress inputAddress, uint256 txHash, Transaction tx, OutPoint input)>();\n\t\t\t\tvar activeOutputAddress = new Key().PubKey.GetAddress(ScriptPubKeyType.Segwit, network);\n\t\t\t\tvar changeOutputAddress = new Key().PubKey.GetAddress(ScriptPubKeyType.Segwit, network);\n\t\t\t\tCoordinatorRound round = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\t\t\t\tvar requester = new Requester();\n\t\t\t\tuint256 blinded = requester.BlindScript(round.MixingLevels.GetBaseLevel().Signer.Key.PubKey, round.MixingLevels.GetBaseLevel().Signer.R.PubKey, activeOutputAddress.ScriptPubKey);\n\t\t\t\tuint256 blindedOutputScriptsHash = new uint256(Hashes.SHA256(blinded.ToBytes()));\n\n\t\t\t\tvar inputProofModels = new List<InputProofModel>();\n\t\t\t\tint numberOfInputs = new Random().Next(1, 7);\n\t\t\t\tvar receiveSatoshiSum = 0;\n\t\t\t\tfor (int j = 0; j < numberOfInputs; j++)\n\t\t\t\t{\n\t\t\t\t\tvar key = new Key();\n\t\t\t\t\tvar receiveSatoshi = new Random().Next(1000, 100000000);\n\t\t\t\t\treceiveSatoshiSum += receiveSatoshi;\n\t\t\t\t\tif (j == numberOfInputs - 1)\n\t\t\t\t\t{\n\t\t\t\t\t\treceiveSatoshi = 100000000;\n\t\t\t\t\t}\n\t\t\t\t\tBitcoinWitPubKeyAddress inputAddress = key.PubKey.GetSegwitAddress(network);\n\t\t\t\t\tuint256 txHash = await rpc.SendToAddressAsync(inputAddress, Money.Satoshis(receiveSatoshi));\n\t\t\t\t\tfundingTxCount++;\n\t\t\t\t\tAssert.NotNull(txHash);\n\t\t\t\t\tTransaction transaction = await rpc.GetRawTransactionAsync(txHash);\n\n\t\t\t\t\tvar coin = transaction.Outputs.GetCoins(inputAddress.ScriptPubKey).Single();\n\t\t\t\t\tspentCoins.Add(coin);\n\n\t\t\t\t\tOutPoint input = coin.Outpoint;\n\t\t\t\t\tvar inputProof = new InputProofModel { Input = input.ToTxoRef(), Proof = key.SignCompact(blindedOutputScriptsHash) };\n\t\t\t\t\tinputProofModels.Add(inputProof);\n\n\t\t\t\t\tGetTxOutResponse getTxOutResponse = await rpc.GetTxOutAsync(input.Hash, (int)input.N, includeMempool: true);\n\t\t\t\t\t\/\/ Check if inputs are unspent.\n\t\t\t\t\tAssert.NotNull(getTxOutResponse);\n\n\t\t\t\t\tuserInputData.Add((key, inputAddress, txHash, transaction, input));\n\t\t\t\t}\n\n\t\t\t\tinputRegistrationUsers.Add((requester, blinded, activeOutputAddress, changeOutputAddress, inputProofModels, userInputData));\n\t\t\t}\n\n\t\t\tvar mempool = await rpc.GetRawMempoolAsync();\n\t\t\tAssert.Equal(inputRegistrationUsers.SelectMany(x => x.userInputData).Count(), mempool.Length);\n\n\t\t\twhile ((await rpc.GetRawMempoolAsync()).Length != 0)\n\t\t\t{\n\t\t\t\tawait rpc.GenerateAsync(1);\n\t\t\t}\n\n\t\t\tLogger.TurnOff();\n\n\t\t\tvar aliceClients = new List<Task<AliceClient>>();\n\n\t\t\tvar currentRound = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\n\t\t\tforeach (var user in inputRegistrationUsers)\n\t\t\t{\n\t\t\t\taliceClients.Add(AliceClient.CreateNewAsync(currentRound.RoundId, new[] { user.activeOutputAddress }, currentRound.MixingLevels.SchnorrPubKeys, new[] { user.requester }, network, user.changeOutputAddress, new[] { user.blinded }, user.inputProofModels, baseUri, null));\n\t\t\t}\n\n\t\t\tlong roundId = 0;\n\t\t\tvar users = new List<(Requester requester, uint256 blinded, BitcoinAddress activeOutputAddress, BitcoinAddress changeOutputAddress, IEnumerable<InputProofModel> inputProofModels, List<(Key key, BitcoinWitPubKeyAddress address, uint256 txHash, Transaction tx, OutPoint input)> userInputData, AliceClient aliceClient, UnblindedSignature unblindedSignature)>();\n\t\t\tfor (int i = 0; i < inputRegistrationUsers.Count; i++)\n\t\t\t{\n\t\t\t\tvar user = inputRegistrationUsers[i];\n\t\t\t\tvar request = aliceClients[i];\n\n\t\t\t\tvar aliceClient = await request;\n\t\t\t\tif (roundId == 0)\n\t\t\t\t{\n\t\t\t\t\troundId = aliceClient.RoundId;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(roundId, aliceClient.RoundId);\n\t\t\t\t}\n\t\t\t\t\/\/ Because it's valuetuple.\n\t\t\t\tusers.Add((user.requester, user.blinded, user.activeOutputAddress, user.changeOutputAddress, user.inputProofModels, user.userInputData, aliceClient, null));\n\t\t\t}\n\n\t\t\tLogger.TurnOn();\n\n\t\t\tAssert.Equal(users.Count, roundConfig.AnonymitySet);\n\t\t\tvar confirmationRequests = new List<Task<(RoundPhase currentPhase, IEnumerable<ActiveOutput>)>>();\n\n\t\t\tforeach (var user in users)\n\t\t\t{\n\t\t\t\tconfirmationRequests.Add(user.aliceClient.PostConfirmationAsync());\n\t\t\t}\n\n\t\t\tRoundPhase roundPhase = RoundPhase.InputRegistration;\n\t\t\tint k = 0;\n\t\t\tforeach (var request in confirmationRequests)\n\t\t\t{\n\t\t\t\tvar resp = await request;\n\t\t\t\tif (roundPhase == RoundPhase.InputRegistration)\n\t\t\t\t{\n\t\t\t\t\troundPhase = resp.currentPhase;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(roundPhase, resp.currentPhase);\n\t\t\t\t}\n\n\t\t\t\t\/\/ Because it's valuetuple.\n\t\t\t\tvar user = users.ElementAt(k);\n\t\t\t\tusers.RemoveAt(k);\n\t\t\t\tusers.Add((user.requester, user.blinded, user.activeOutputAddress, user.changeOutputAddress, user.inputProofModels, user.userInputData, user.aliceClient, resp.Item2.First().Signature));\n\t\t\t}\n\n\t\t\tvar outputRequests = new List<(BobClient, Task)>();\n\t\t\tforeach (var user in users)\n\t\t\t{\n\t\t\t\tvar bobClient = new BobClient(baseUri, null);\n\t\t\t\toutputRequests.Add((bobClient, bobClient.PostOutputAsync(roundId, new ActiveOutput(user.activeOutputAddress, user.unblindedSignature, 0))));\n\t\t\t}\n\n\t\t\tforeach (var request in outputRequests)\n\t\t\t{\n\t\t\t\tawait request.Item2;\n\t\t\t\trequest.Item1?.Dispose();\n\t\t\t}\n\n\t\t\tvar coinjoinRequests = new List<Task<Transaction>>();\n\t\t\tforeach (var user in users)\n\t\t\t{\n\t\t\t\tcoinjoinRequests.Add(user.aliceClient.GetUnsignedCoinJoinAsync());\n\t\t\t}\n\n\t\t\tTransaction unsignedCoinJoin = null;\n\t\t\tforeach (var request in coinjoinRequests)\n\t\t\t{\n\t\t\t\tif (unsignedCoinJoin is null)\n\t\t\t\t{\n\t\t\t\t\tunsignedCoinJoin = await request;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(unsignedCoinJoin.ToHex(), (await request).ToHex());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar signatureRequests = new List<Task>();\n\t\t\tforeach (var user in users)\n\t\t\t{\n\t\t\t\tvar partSignedCj = Transaction.Parse(unsignedCoinJoin.ToHex(), network);\n\t\t\t\tpartSignedCj = Network.RegTest.CreateTransactionBuilder()\n\t\t\t\t\t\t\t.ContinueToBuild(partSignedCj)\n\t\t\t\t\t\t\t.AddKeys(user.userInputData.Select(x => x.key).ToArray())\n\t\t\t\t\t\t\t.AddCoins(user.userInputData.Select(x => new Coin(x.tx, x.input.N)).ToArray())\n\t\t\t\t\t\t\t.BuildTransaction(true);\n\n\t\t\t\tvar myDic = new Dictionary<int, WitScript>();\n\n\t\t\t\tlong previousAmount = -1;\n\t\t\t\tfor (int i = 0; i < unsignedCoinJoin.Inputs.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tvar input = unsignedCoinJoin.Inputs[i];\n\t\t\t\t\tlong currentAmount = spentCoins.Single(x => x.Outpoint == unsignedCoinJoin.Inputs[i].PrevOut).Amount;\n\t\t\t\t\tAssert.True(previousAmount <= currentAmount);\n\t\t\t\t\tpreviousAmount = currentAmount;\n\t\t\t\t\tif (user.userInputData.Select(x => x.input).Contains(input.PrevOut))\n\t\t\t\t\t{\n\t\t\t\t\t\tmyDic.Add(i, partSignedCj.Inputs[i].WitScript);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsignatureRequests.Add(user.aliceClient.PostSignaturesAsync(myDic));\n\t\t\t}\n\n\t\t\tawait Task.WhenAll(signatureRequests);\n\n\t\t\tuint256[] mempooltxs = await rpc.GetRawMempoolAsync();\n\t\t\tAssert.Contains(unsignedCoinJoin.GetHash(), mempooltxs);\n\n\t\t\tvar coins = new List<Coin>();\n\t\t\tvar finalCoinjoin = await rpc.GetRawTransactionAsync(mempooltxs.First());\n\t\t\tforeach (var input in finalCoinjoin.Inputs)\n\t\t\t{\n\t\t\t\tvar getTxOut = await rpc.GetTxOutAsync(input.PrevOut.Hash, (int)input.PrevOut.N, includeMempool: false);\n\n\t\t\t\tcoins.Add(new Coin(input.PrevOut.Hash, input.PrevOut.N, getTxOut.TxOut.Value, getTxOut.TxOut.ScriptPubKey));\n\t\t\t}\n\n\t\t\tFeeRate feeRateTx = finalCoinjoin.GetFeeRate(coins.ToArray());\n\t\t\tvar esr = await rpc.EstimateSmartFeeAsync(roundConfig.ConfirmationTarget, EstimateSmartFeeMode.Conservative, simulateIfRegTest: true, tryOtherFeeRates: true);\n\t\t\tFeeRate feeRateReal = esr.FeeRate;\n\n\t\t\tAssert.True(feeRateReal.FeePerK - (feeRateReal.FeePerK \/ 2) < feeRateTx.FeePerK); \/\/ Max 50% mistake.\n\t\t\tAssert.True(2 * feeRateReal.FeePerK > feeRateTx.FeePerK); \/\/ Max 200% mistake.\n\n\t\t\tvar activeOutput = finalCoinjoin.GetIndistinguishableOutputs(includeSingle: true).OrderByDescending(x => x.count).First();\n\t\t\tAssert.True(activeOutput.value >= roundConfig.Denomination);\n\t\t\tAssert.True(activeOutput.count >= roundConfig.AnonymitySet);\n\n\t\t\tforeach (var aliceClient in aliceClients)\n\t\t\t{\n\t\t\t\taliceClient?.Dispose();\n\t\t\t}\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task CcjFeeTestsAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\tvar synchronizer = new WasabiSynchronizer(network, bitcoinStore, new Uri(RegTestFixture.BackendEndPoint), null);\n\t\t\tsynchronizer.Start(requestInterval: TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(5), 10000); \/\/ Start wasabi synchronizer service.\n\n\t\t\tMoney denomination = Money.Coins(0.9m);\n\t\t\tdecimal coordinatorFeePercent = 0.1m;\n\t\t\tint anonymitySet = 7;\n\t\t\tint connectionConfirmationTimeout = 14;\n\t\t\tvar roundConfig = RegTestFixture.CreateRoundConfig(denomination, 140, 0.7, coordinatorFeePercent, anonymitySet, 240, connectionConfirmationTimeout, 50, 50, 1, 24, true, 11);\n\t\t\tawait coordinator.RoundConfig.UpdateOrDefaultAsync(roundConfig, toFile: true);\n\t\t\tcoordinator.AbortAllRoundsInInputRegistration(\"\");\n\n\t\t\tvar participants = new List<dynamic>();\n\n\t\t\t\/\/ 1. Prepare and start services.\n\t\t\tfor (int i = 0; i < anonymitySet; i++)\n\t\t\t{\n\t\t\t\tdouble damount = i switch\n\t\t\t\t{\n\t\t\t\t\t0 => 1,\n\t\t\t\t\t1 => 1.1,\n\t\t\t\t\t2 => 1.2,\n\t\t\t\t\t3 => 3.1,\n\t\t\t\t\t4 => 4.1,\n\t\t\t\t\t5 => 7.1,\n\t\t\t\t\t6 => 8.1,\n\t\t\t\t\t_ => 1\n\t\t\t\t};\n\n\t\t\t\tvar amount = Money.Coins((decimal)damount);\n\n\t\t\t\tvar keyManager = KeyManager.CreateNew(out _, password);\n\t\t\t\tvar key = keyManager.GenerateNewKey(\"foo\", KeyState.Clean, false);\n\t\t\t\tvar bech = key.GetP2wpkhAddress(network);\n\t\t\t\tvar txId = await rpc.SendToAddressAsync(bech, amount, replaceable: false);\n\t\t\t\tkey.SetKeyState(KeyState.Used);\n\t\t\t\tvar tx = await rpc.GetRawTransactionAsync(txId);\n\t\t\t\tvar height = await rpc.GetBlockCountAsync();\n\t\t\t\tvar bechCoin = tx.Outputs.GetCoins(bech.ScriptPubKey).Single();\n\n\t\t\t\tvar smartCoin = new SmartCoin(bechCoin, tx.Inputs.Select(x => new TxoRef(x.PrevOut)).ToArray(), height + 1, replaceable: false, anonymitySet: tx.GetAnonymitySet(bechCoin.Outpoint.N), isLikelyCoinJoinOutput: false);\n\n\t\t\t\tvar chaumianClient = new CoinJoinClient(synchronizer, rpc.Network, keyManager, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\t\tparticipants.Add((smartCoin, chaumianClient));\n\t\t\t}\n\n\t\t\tawait rpc.GenerateAsync(1);\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\t\/\/ 2. Start mixing.\n\t\t\t\tforeach (var participant in participants)\n\t\t\t\t{\n\t\t\t\t\tSmartCoin coin = participant.Item1;\n\n\t\t\t\t\tCoinJoinClient chaumianClient = participant.Item2;\n\t\t\t\t\tchaumianClient.Start();\n\n\t\t\t\t\tawait chaumianClient.QueueCoinsToMixAsync(password, coin);\n\t\t\t\t}\n\n\t\t\t\tTask timeout = Task.Delay(TimeSpan.FromSeconds(connectionConfirmationTimeout * 2 + 7 * 2 + 7 * 2 + 7 * 2));\n\t\t\t\twhile ((await rpc.GetRawMempoolAsync()).Length == 0)\n\t\t\t\t{\n\t\t\t\t\tif (timeout.IsCompletedSuccessfully)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new TimeoutException(\"CoinJoin was not propagated.\");\n\t\t\t\t\t}\n\n\t\t\t\t\tawait Task.Delay(1000);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tforeach (var participant in participants)\n\t\t\t\t{\n\t\t\t\t\tSmartCoin coin = participant.Item1;\n\t\t\t\t\tCoinJoinClient chaumianClient = participant.Item2;\n\n\t\t\t\t\tTask timeout = Task.Delay(3000);\n\t\t\t\t\twhile (chaumianClient.State.GetActivelyMixingRounds().Any())\n\t\t\t\t\t{\n\t\t\t\t\t\tif (timeout.IsCompletedSuccessfully)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthrow new TimeoutException(\"CoinJoin was not noticed.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tawait Task.Delay(1000);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (chaumianClient != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tawait chaumianClient.DequeueAllCoinsFromMixAsync(DequeueReason.UserRequested);\n\t\t\t\t\t\tawait chaumianClient.StopAsync();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task CoinJoinClientTestsAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\tvar synchronizer = new WasabiSynchronizer(network, bitcoinStore, new Uri(RegTestFixture.BackendEndPoint), null);\n\t\t\tsynchronizer.Start(requestInterval: TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(5), 10000); \/\/ Start wasabi synchronizer service.\n\n\t\t\tMoney denomination = Money.Coins(0.1m);\n\t\t\tdecimal coordinatorFeePercent = 0.1m;\n\t\t\tint anonymitySet = 2;\n\t\t\tint connectionConfirmationTimeout = 14;\n\t\t\tvar roundConfig = RegTestFixture.CreateRoundConfig(denomination, 140, 0.7, coordinatorFeePercent, anonymitySet, 240, connectionConfirmationTimeout, 50, 50, 1, 24, true, 11);\n\t\t\tawait coordinator.RoundConfig.UpdateOrDefaultAsync(roundConfig, toFile: true);\n\t\t\tcoordinator.AbortAllRoundsInInputRegistration(\"\");\n\t\t\tawait rpc.GenerateAsync(3); \/\/ So to make sure we have enough money.\n\t\t\tvar keyManager = KeyManager.CreateNew(out _, password);\n\t\t\tvar key1 = keyManager.GenerateNewKey(\"foo\", KeyState.Clean, false);\n\t\t\tvar key2 = keyManager.GenerateNewKey(\"bar\", KeyState.Clean, false);\n\t\t\tvar key3 = keyManager.GenerateNewKey(\"baz\", KeyState.Clean, false);\n\t\t\tvar key4 = keyManager.GenerateNewKey(\"qux\", KeyState.Clean, false);\n\t\t\tvar bech1 = key1.GetP2wpkhAddress(network);\n\t\t\tvar bech2 = key2.GetP2wpkhAddress(network);\n\t\t\tvar bech3 = key3.GetP2wpkhAddress(network);\n\t\t\tvar bech4 = key4.GetP2wpkhAddress(network);\n\t\t\tvar amount1 = Money.Coins(0.03m);\n\t\t\tvar amount2 = Money.Coins(0.08m);\n\t\t\tvar amount3 = Money.Coins(0.3m);\n\t\t\tvar amount4 = Money.Coins(0.4m);\n\t\t\tvar txId1 = await rpc.SendToAddressAsync(bech1, amount1, replaceable: false);\n\t\t\tvar txId2 = await rpc.SendToAddressAsync(bech2, amount2, replaceable: false);\n\t\t\tvar txId3 = await rpc.SendToAddressAsync(bech3, amount3, replaceable: false);\n\t\t\tvar txId4 = await rpc.SendToAddressAsync(bech4, amount4, replaceable: false);\n\t\t\tkey1.SetKeyState(KeyState.Used);\n\t\t\tkey2.SetKeyState(KeyState.Used);\n\t\t\tkey3.SetKeyState(KeyState.Used);\n\t\t\tkey4.SetKeyState(KeyState.Used);\n\t\t\tvar tx1 = await rpc.GetRawTransactionAsync(txId1);\n\t\t\tvar tx2 = await rpc.GetRawTransactionAsync(txId2);\n\t\t\tvar tx3 = await rpc.GetRawTransactionAsync(txId3);\n\t\t\tvar tx4 = await rpc.GetRawTransactionAsync(txId4);\n\t\t\tawait rpc.GenerateAsync(1);\n\t\t\tvar height = await rpc.GetBlockCountAsync();\n\t\t\tvar bech1Coin = tx1.Outputs.GetCoins(bech1.ScriptPubKey).Single();\n\t\t\tvar bech2Coin = tx2.Outputs.GetCoins(bech2.ScriptPubKey).Single();\n\t\t\tvar bech3Coin = tx3.Outputs.GetCoins(bech3.ScriptPubKey).Single();\n\t\t\tvar bech4Coin = tx4.Outputs.GetCoins(bech4.ScriptPubKey).Single();\n\n\t\t\tvar smartCoin1 = new SmartCoin(bech1Coin, tx1.Inputs.Select(x => new TxoRef(x.PrevOut)).ToArray(), height, replaceable: false, anonymitySet: tx1.GetAnonymitySet(bech1Coin.Outpoint.N), isLikelyCoinJoinOutput: false);\n\t\t\tvar smartCoin2 = new SmartCoin(bech2Coin, tx2.Inputs.Select(x => new TxoRef(x.PrevOut)).ToArray(), height, replaceable: false, anonymitySet: tx2.GetAnonymitySet(bech2Coin.Outpoint.N), isLikelyCoinJoinOutput: false);\n\t\t\tvar smartCoin3 = new SmartCoin(bech3Coin, tx3.Inputs.Select(x => new TxoRef(x.PrevOut)).ToArray(), height, replaceable: false, anonymitySet: tx3.GetAnonymitySet(bech3Coin.Outpoint.N), isLikelyCoinJoinOutput: false);\n\t\t\tvar smartCoin4 = new SmartCoin(bech4Coin, tx4.Inputs.Select(x => new TxoRef(x.PrevOut)).ToArray(), height, replaceable: false, anonymitySet: tx4.GetAnonymitySet(bech4Coin.Outpoint.N), isLikelyCoinJoinOutput: false);\n\n\t\t\tvar chaumianClient1 = new CoinJoinClient(synchronizer, rpc.Network, keyManager, new Uri(RegTestFixture.BackendEndPoint), null);\n\t\t\tvar chaumianClient2 = new CoinJoinClient(synchronizer, rpc.Network, keyManager, new Uri(RegTestFixture.BackendEndPoint), null);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tchaumianClient1.Start(); \/\/ Exactly delay it for 2 seconds, this will make sure of timeout later.\n\t\t\t\tchaumianClient2.Start();\n\n\t\t\t\tsmartCoin1.CoinJoinInProgress = true;\n\t\t\t\tAssert.False((await chaumianClient1.QueueCoinsToMixAsync(password, smartCoin1)).Any()); \/\/ Inconsistent internal state, so do not try to add.\n\t\t\t\tAssert.True(smartCoin1.CoinJoinInProgress);\n\n\t\t\t\tawait Assert.ThrowsAsync<SecurityException>(async () => await chaumianClient1.QueueCoinsToMixAsync(\"asdasdasd\", smartCoin1, smartCoin2));\n\t\t\t\tAssert.True(smartCoin1.CoinJoinInProgress);\n\t\t\t\tAssert.False(smartCoin2.CoinJoinInProgress);\n\t\t\t\tsmartCoin1.CoinJoinInProgress = false;\n\n\t\t\t\tawait chaumianClient1.QueueCoinsToMixAsync(password, smartCoin1, smartCoin2);\n\t\t\t\tAssert.True(smartCoin1.CoinJoinInProgress);\n\t\t\t\tAssert.True(smartCoin2.CoinJoinInProgress);\n\n\t\t\t\t\/\/ Make sure it does not throw.\n\t\t\t\tawait chaumianClient1.DequeueCoinsFromMixAsync(new SmartCoin((network.Consensus.ConsensusFactory.CreateTransaction()).GetHash(), 1, new Script(), Money.Parse(\"3\"), new TxoRef[] { new TxoRef((network.Consensus.ConsensusFactory.CreateTransaction()).GetHash(), 0) }, Height.Mempool, replaceable: false, anonymitySet: 1, isLikelyCoinJoinOutput: false), DequeueReason.UserRequested);\n\n\t\t\t\tAssert.True(2 == (await chaumianClient1.QueueCoinsToMixAsync(password, smartCoin1, smartCoin2)).Count());\n\t\t\t\tawait chaumianClient1.DequeueCoinsFromMixAsync(smartCoin1, DequeueReason.UserRequested);\n\t\t\t\tAssert.False(smartCoin1.CoinJoinInProgress);\n\t\t\t\tawait chaumianClient1.DequeueCoinsFromMixAsync(new[] { smartCoin1, smartCoin2 }, DequeueReason.UserRequested);\n\t\t\t\tAssert.False(smartCoin1.CoinJoinInProgress);\n\t\t\t\tAssert.False(smartCoin2.CoinJoinInProgress);\n\t\t\t\tAssert.True(2 == (await chaumianClient1.QueueCoinsToMixAsync(password, smartCoin1, smartCoin2)).Count());\n\t\t\t\tAssert.True(smartCoin1.CoinJoinInProgress);\n\t\t\t\tAssert.True(smartCoin2.CoinJoinInProgress);\n\t\t\t\tawait chaumianClient1.DequeueCoinsFromMixAsync(smartCoin1, DequeueReason.UserRequested);\n\t\t\t\tawait chaumianClient1.DequeueCoinsFromMixAsync(smartCoin2, DequeueReason.UserRequested);\n\t\t\t\tAssert.False(smartCoin1.CoinJoinInProgress);\n\t\t\t\tAssert.False(smartCoin2.CoinJoinInProgress);\n\n\t\t\t\tAssert.True(2 == (await chaumianClient1.QueueCoinsToMixAsync(password, smartCoin1, smartCoin2)).Count());\n\t\t\t\tAssert.True(smartCoin1.CoinJoinInProgress);\n\t\t\t\tAssert.True(smartCoin2.CoinJoinInProgress);\n\t\t\t\tAssert.True(1 == (await chaumianClient2.QueueCoinsToMixAsync(password, smartCoin3)).Count());\n\n\t\t\t\tTask timeout = Task.Delay(TimeSpan.FromSeconds(connectionConfirmationTimeout * 2 + 7 * 2 + 7 * 2 + 7 * 2));\n\t\t\t\twhile ((await rpc.GetRawMempoolAsync()).Length == 0)\n\t\t\t\t{\n\t\t\t\t\tif (timeout.IsCompletedSuccessfully)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new TimeoutException(\"CoinJoin was not propagated.\");\n\t\t\t\t\t}\n\t\t\t\t\tawait Task.Delay(1000);\n\t\t\t\t}\n\n\t\t\t\tvar cj = (await rpc.GetRawMempoolAsync()).Single();\n\t\t\t\tsmartCoin1.SpenderTransactionId = cj;\n\t\t\t\tsmartCoin2.SpenderTransactionId = cj;\n\t\t\t\tsmartCoin3.SpenderTransactionId = cj;\n\n\t\t\t\t\/\/ Make sure if times out, it tries again.\n\t\t\t\tconnectionConfirmationTimeout = 1;\n\t\t\t\troundConfig = RegTestFixture.CreateRoundConfig(denomination, 140, 0.7, coordinatorFeePercent, anonymitySet, 240, connectionConfirmationTimeout, 50, 50, 1, 24, true, 11);\n\t\t\t\tawait coordinator.RoundConfig.UpdateOrDefaultAsync(roundConfig, toFile: true);\n\t\t\t\tcoordinator.AbortAllRoundsInInputRegistration(\"\");\n\t\t\t\tAssert.NotEmpty(chaumianClient1.State.GetAllQueuedCoins());\n\t\t\t\tawait chaumianClient1.DequeueAllCoinsFromMixAsync(DequeueReason.UserRequested);\n\t\t\t\tAssert.Empty(chaumianClient1.State.GetAllQueuedCoins());\n\t\t\t\tawait chaumianClient1.QueueCoinsToMixAsync(password, smartCoin4);\n\t\t\t\tAssert.NotEmpty(chaumianClient1.State.GetAllQueuedCoins());\n\t\t\t\tAssert.NotEmpty(chaumianClient1.State.GetAllWaitingCoins());\n\t\t\t\tAssert.Empty(chaumianClient1.State.GetAllRegisteredCoins());\n\t\t\t\twhile (chaumianClient1.State.GetAllWaitingCoins().Any())\n\t\t\t\t{\n\t\t\t\t\tawait Task.Delay(1000);\n\t\t\t\t}\n\t\t\t\tAssert.NotEmpty(chaumianClient1.State.GetAllQueuedCoins());\n\t\t\t\tAssert.Empty(chaumianClient1.State.GetAllWaitingCoins());\n\t\t\t\tAssert.NotEmpty(chaumianClient1.State.GetAllRegisteredCoins());\n\t\t\t\tint times = 0;\n\t\t\t\twhile (!chaumianClient1.State.GetAllWaitingCoins().Any()) \/\/ \/\/ Make sure to wait until times out.\n\t\t\t\t{\n\t\t\t\t\tawait Task.Delay(1000);\n\t\t\t\t\tif (times > 21)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new TimeoutException($\"{nameof(chaumianClient1.State)}.{nameof(chaumianClient1.State.GetAllWaitingCoins)}() always empty.\");\n\t\t\t\t\t}\n\t\t\t\t\ttimes++;\n\t\t\t\t}\n\n\t\t\t\tAssert.NotEmpty(chaumianClient1.State.GetAllQueuedCoins());\n\t\t\t\tAssert.Empty(chaumianClient1.State.GetAllRegisteredCoins());\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tif (chaumianClient1 != null)\n\t\t\t\t{\n\t\t\t\t\tawait chaumianClient1.StopAsync();\n\t\t\t\t}\n\t\t\t\tif (chaumianClient2 != null)\n\t\t\t\t{\n\t\t\t\t\tawait chaumianClient2.StopAsync();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task CoinJoinMultipleRoundTestsAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(3);\n\n\t\t\tMoney denomination = Money.Coins(0.1m);\n\t\t\tdecimal coordinatorFeePercent = 0.1m;\n\t\t\tint anonymitySet = 2;\n\t\t\tint connectionConfirmationTimeout = 14;\n\t\t\tvar roundConfig = RegTestFixture.CreateRoundConfig(denomination, 140, 0.7, coordinatorFeePercent, anonymitySet, 240, connectionConfirmationTimeout, 50, 50, 1, 24, true, 11);\n\t\t\tawait coordinator.RoundConfig.UpdateOrDefaultAsync(roundConfig, toFile: true);\n\t\t\tcoordinator.AbortAllRoundsInInputRegistration(\"\");\n\n\t\t\t\/\/ Create the services.\n\t\t\t\/\/ 1. Create connection service.\n\t\t\tvar nodes = new NodesGroup(global.Config.Network, requirements: Constants.NodeRequirements);\n\t\t\tnodes.ConnectedNodes.Add(await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync());\n\n\t\t\tvar nodes2 = new NodesGroup(global.Config.Network, requirements: Constants.NodeRequirements);\n\t\t\tnodes2.ConnectedNodes.Add(await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync());\n\n\t\t\t\/\/ 2. Create mempool service.\n\n\t\t\tNode node = await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync();\n\t\t\tnode.Behaviors.Add(bitcoinStore.CreateUntrustedP2pBehavior());\n\n\t\t\tNode node2 = await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync();\n\t\t\tnode2.Behaviors.Add(bitcoinStore.CreateUntrustedP2pBehavior());\n\n\t\t\t\/\/ 3. Create wasabi synchronizer service.\n\t\t\tvar synchronizer = new WasabiSynchronizer(network, bitcoinStore, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\tvar indexFilePath2 = Path.Combine(GetWorkDir(), $\"Index{network}2.dat\");\n\t\t\tvar synchronizer2 = new WasabiSynchronizer(network, bitcoinStore, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\t\/\/ 4. Create key manager service.\n\t\t\tvar keyManager = KeyManager.CreateNew(out _, password);\n\n\t\t\tvar keyManager2 = KeyManager.CreateNew(out _, password);\n\n\t\t\t\/\/ 5. Create chaumian coinjoin client.\n\t\t\tvar chaumianClient = new CoinJoinClient(synchronizer, network, keyManager, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\tvar chaumianClient2 = new CoinJoinClient(synchronizer, network, keyManager2, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\t\/\/ 6. Create wallet service.\n\t\t\tvar workDir = GetWorkDir();\n\t\t\tvar wallet = new WalletService(bitcoinStore, keyManager, synchronizer, chaumianClient, nodes, workDir, serviceConfiguration, synchronizer);\n\t\t\twallet.NewFilterProcessed += Wallet_NewFilterProcessed;\n\n\t\t\tvar workDir2 = Path.Combine(GetWorkDir(), \"2\");\n\t\t\tvar wallet2 = new WalletService(bitcoinStore, keyManager2, synchronizer2, chaumianClient2, nodes2, workDir2, serviceConfiguration, synchronizer2);\n\n\t\t\t\/\/ Get some money, make it confirm.\n\t\t\tvar key = keyManager.GetNextReceiveKey(\"fundZeroLink\", out _);\n\t\t\tvar txId = await rpc.SendToAddressAsync(key.GetP2wpkhAddress(network), Money.Coins(1m));\n\t\t\tAssert.NotNull(txId);\n\t\t\tvar key2 = keyManager2.GetNextReceiveKey(\"fundZeroLink\", out _);\n\t\t\tvar key3 = keyManager2.GetNextReceiveKey(\"fundZeroLink\", out _);\n\t\t\tvar key4 = keyManager2.GetNextReceiveKey(\"fundZeroLink\", out _);\n\t\t\tvar txId2 = await rpc.SendToAddressAsync(key2.GetP2wpkhAddress(network), Money.Coins(0.11m));\n\t\t\tvar txId3 = await rpc.SendToAddressAsync(key3.GetP2wpkhAddress(network), Money.Coins(0.12m));\n\t\t\tvar txId4 = await rpc.SendToAddressAsync(key4.GetP2wpkhAddress(network), Money.Coins(0.13m));\n\n\t\t\tawait rpc.GenerateAsync(1);\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tInterlocked.Exchange(ref _filtersProcessedByWalletCount, 0);\n\t\t\t\tnodes.Connect(); \/\/ Start connection service.\n\t\t\t\tnode.VersionHandshake(); \/\/ Start mempool service.\n\t\t\t\tsynchronizer.Start(requestInterval: TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(5), 10000); \/\/ Start wasabi synchronizer service.\n\t\t\t\tchaumianClient.Start(); \/\/ Start chaumian coinjoin client.\n\t\t\t\tnodes2.Connect(); \/\/ Start connection service.\n\t\t\t\tnode2.VersionHandshake(); \/\/ Start mempool service.\n\t\t\t\tsynchronizer2.Start(requestInterval: TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(5), 10000); \/\/ Start wasabi synchronizer service.\n\t\t\t\tchaumianClient2.Start(); \/\/ Start chaumian coinjoin client.\n\n\t\t\t\t\/\/ Wait until the filter our previous transaction is present.\n\t\t\t\tvar blockCount = await rpc.GetBlockCountAsync();\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), blockCount);\n\n\t\t\t\tusing (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30)))\n\t\t\t\t{\n\t\t\t\t\tawait wallet.InitializeAsync(cts.Token); \/\/ Initialize wallet service.\n\t\t\t\t}\n\t\t\t\tusing (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30)))\n\t\t\t\t{\n\t\t\t\t\tawait wallet2.InitializeAsync(cts.Token); \/\/ Initialize wallet service.\n\t\t\t\t}\n\n\t\t\t\tvar waitCount = 0;\n\t\t\t\twhile (wallet.Coins.Sum(x => x.Amount) == Money.Zero)\n\t\t\t\t{\n\t\t\t\t\tawait Task.Delay(1000);\n\t\t\t\t\twaitCount++;\n\t\t\t\t\tif (waitCount >= 21)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new TimeoutException(\"Funding transaction to the wallet1 did not arrive.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twaitCount = 0;\n\t\t\t\twhile (wallet2.Coins.Sum(x => x.Amount) == Money.Zero)\n\t\t\t\t{\n\t\t\t\t\tawait Task.Delay(1000);\n\t\t\t\t\twaitCount++;\n\t\t\t\t\tif (waitCount >= 21)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new TimeoutException(\"Funding transaction to the wallet2 did not arrive.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tAssert.True(1 == (await chaumianClient.QueueCoinsToMixAsync(password, wallet.Coins.ToArray())).Count());\n\t\t\t\tAssert.True(3 == (await chaumianClient2.QueueCoinsToMixAsync(password, wallet2.Coins.ToArray())).Count());\n\n\t\t\t\tTask timeout = Task.Delay(TimeSpan.FromSeconds(2 * (1 + 11 + 7 + 3 * (3 + 7))));\n\t\t\t\twhile (wallet.Coins.Count() != 4)\n\t\t\t\t{\n\t\t\t\t\tif (timeout.IsCompletedSuccessfully)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new TimeoutException(\"CoinJoin was not propagated or did not arrive.\");\n\t\t\t\t\t}\n\t\t\t\t\tawait Task.Delay(1000);\n\t\t\t\t}\n\n\t\t\t\tvar times = 0;\n\t\t\t\twhile (wallet.Coins.FirstOrDefault(x => x.Label.IsEmpty) is null)\n\t\t\t\t{\n\t\t\t\t\tawait Task.Delay(1000);\n\t\t\t\t\ttimes++;\n\t\t\t\t\tif (times >= 21)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new TimeoutException(\"Wallet spends were not recognized.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tDateTime start = DateTime.Now;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tawait chaumianClient.DequeueAllCoinsFromMixAsync(DequeueReason.UserRequested);\n\t\t\t\t\t\tawait chaumianClient2.DequeueAllCoinsFromMixAsync(DequeueReason.UserRequested);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NotSupportedException)\n\t\t\t\t\t{\n\t\t\t\t\t\tawait Task.Delay(1000);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (DateTime.Now - start > TimeSpan.FromMinutes(1))\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new TimeoutException(\"Dequeuing timed out.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (true);\n\n\t\t\t\tvar allCoins = wallet.TransactionProcessor.Coins.AsAllCoinsView().ToArray();\n\t\t\t\tvar allCoins2 = wallet2.TransactionProcessor.Coins.AsAllCoinsView().ToArray();\n\n\t\t\t\tAssert.Equal(4, allCoins.Count(x => x.Label.IsEmpty && !x.Unavailable));\n\t\t\t\tAssert.Equal(3, allCoins2.Count(x => x.Label.IsEmpty && !x.Unavailable));\n\t\t\t\tAssert.Equal(2, allCoins.Count(x => x.Label.IsEmpty && !x.Unspent));\n\t\t\t\tAssert.Equal(0, allCoins2.Count(x => x.Label.IsEmpty && !x.Unspent));\n\t\t\t\tAssert.Equal(3, allCoins2.Count(x => x.Label.IsEmpty));\n\t\t\t\tAssert.Equal(4, allCoins.Count(x => x.Label.IsEmpty && x.Unspent));\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\twallet.NewFilterProcessed -= Wallet_NewFilterProcessed;\n\t\t\t\twallet?.Dispose();\n\t\t\t\t\/\/ Dispose connection service.\n\t\t\t\tnodes?.Dispose();\n\t\t\t\t\/\/ Dispose mempool serving node.\n\t\t\t\tnode?.Disconnect();\n\t\t\t\t\/\/ Dispose chaumian coinjoin client.\n\t\t\t\tif (chaumianClient != null)\n\t\t\t\t{\n\t\t\t\t\tawait chaumianClient.StopAsync();\n\t\t\t\t}\n\t\t\t\twallet2?.Dispose();\n\t\t\t\t\/\/ Dispose wasabi synchronizer service.\n\t\t\t\tawait synchronizer?.StopAsync();\n\t\t\t\t\/\/ Dispose connection service.\n\t\t\t\tnodes2?.Dispose();\n\t\t\t\t\/\/ Dispose chaumian coinjoin client.\n\t\t\t\tif (chaumianClient2 != null)\n\t\t\t\t{\n\t\t\t\t\tawait chaumianClient2.StopAsync();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t#endregion ClientTests\n\n#pragma warning restore IDE0059 \/\/ Value assigned to symbol is never used\n\t}\n}\n","old_contents":"using NBitcoin;\nusing NBitcoin.BouncyCastle.Math;\nusing NBitcoin.Crypto;\nusing NBitcoin.Protocol;\nusing NBitcoin.RPC;\nusing System;\nusing System.Collections.Generic;\nusing System.Collections.Immutable;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing System.Runtime.CompilerServices;\nusing System.Runtime.InteropServices;\nusing System.Security;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing WalletWasabi.Backend;\nusing WalletWasabi.Backend.Models;\nusing WalletWasabi.Backend.Models.Responses;\nusing WalletWasabi.Blockchain.Analysis.Clustering;\nusing WalletWasabi.Blockchain.BlockFilters;\nusing WalletWasabi.Blockchain.Blocks;\nusing WalletWasabi.Blockchain.Keys;\nusing WalletWasabi.Blockchain.TransactionBroadcasting;\nusing WalletWasabi.Blockchain.TransactionBuilding;\nusing WalletWasabi.Blockchain.TransactionOutputs;\nusing WalletWasabi.Blockchain.TransactionProcessing;\nusing WalletWasabi.Blockchain.Transactions;\nusing WalletWasabi.CoinJoin.Client.Clients;\nusing WalletWasabi.CoinJoin.Client.Clients.Queuing;\nusing WalletWasabi.CoinJoin.Client.Rounds;\nusing WalletWasabi.CoinJoin.Common.Models;\nusing WalletWasabi.CoinJoin.Coordinator;\nusing WalletWasabi.CoinJoin.Coordinator.Rounds;\nusing WalletWasabi.Crypto;\nusing WalletWasabi.Exceptions;\nusing WalletWasabi.Helpers;\nusing WalletWasabi.Logging;\nusing WalletWasabi.Models;\nusing WalletWasabi.Services;\nusing WalletWasabi.Stores;\nusing WalletWasabi.Tests.XunitConfiguration;\nusing WalletWasabi.TorSocks5;\nusing WalletWasabi.WebClients.Wasabi;\nusing Xunit;\nusing static NBitcoin.Crypto.SchnorrBlinding;\n\nnamespace WalletWasabi.Tests.IntegrationTests\n{\n\t[Collection(\"RegTest collection\")]\n\tpublic class RegTests\n\t{\n#pragma warning disable IDE0059 \/\/ Value assigned to symbol is never used\n\t\tprivate RegTestFixture RegTestFixture { get; }\n\n\t\tpublic RegTests(RegTestFixture regTestFixture)\n\t\t{\n\t\t\tRegTestFixture = regTestFixture;\n\t\t}\n\n\t\tpublic static string GetWorkDir([CallerFilePath]string callerFilePath = null, [CallerMemberName]string callerMemberName = null)\n\t\t{\n\t\t\treturn Path.Combine(Global.Instance.DataDir, EnvironmentHelpers.ExtractFileName(callerFilePath), callerMemberName);\n\t\t}\n\n\t\tprivate async Task AssertFiltersInitializedAsync(Backend.Global global)\n\t\t{\n\t\t\tvar firstHash = await global.RpcClient.GetBlockHashAsync(0);\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tusing var client = new WasabiClient(new Uri(RegTestFixture.BackendEndPoint), null);\n\t\t\t\tFiltersResponse filtersResponse = await client.GetFiltersAsync(firstHash, 1000);\n\t\t\t\tAssert.NotNull(filtersResponse);\n\n\t\t\t\tvar filterCount = filtersResponse.Filters.Count();\n\t\t\t\tif (filterCount >= 101)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tawait Task.Delay(100);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate async Task<(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global)> InitializeTestEnvironmentAsync(int numberOfBlocksToGenerate, [CallerFilePath]string callerFilePath = null, [CallerMemberName] string callerMemberName = null)\n\t\t{\n\t\t\tvar global = RegTestFixture.Global;\n\t\t\tawait AssertFiltersInitializedAsync(global); \/\/ Make sure fitlers are created on the server side.\n\t\t\tif (numberOfBlocksToGenerate != 0)\n\t\t\t{\n\t\t\t\tawait global.RpcClient.GenerateAsync(numberOfBlocksToGenerate); \/\/ Make sure everything is confirmed.\n\t\t\t}\n\t\t\tglobal.Coordinator.UtxoReferee.Clear();\n\n\t\t\tvar network = global.RpcClient.Network;\n\t\t\tvar serviceConfiguration = new ServiceConfiguration(2, 2, 21, 50, RegTestFixture.BackendRegTestNode.P2pEndPoint, Money.Coins(Constants.DefaultDustThreshold));\n\t\t\tvar bitcoinStore = new BitcoinStore();\n\t\t\tvar dir = GetWorkDir(callerFilePath, callerMemberName);\n\t\t\tawait bitcoinStore.InitializeAsync(dir, network);\n\t\t\treturn (\"password\", global.RpcClient, network, global.Coordinator, serviceConfiguration, bitcoinStore, global);\n\t\t}\n\n\t\t#region BackendTests\n\n\t\t[Fact]\n\t\tpublic async Task GetExchangeRatesAsync()\n\t\t{\n\t\t\tusing var client = new TorHttpClient(new Uri(RegTestFixture.BackendEndPoint), null);\n\t\t\tusing var response = await client.SendAsync(HttpMethod.Get, $\"\/api\/v{Constants.BackendMajorVersion}\/btc\/offchain\/exchange-rates\");\n\t\t\tAssert.True(response.StatusCode == HttpStatusCode.OK);\n\n\t\t\tvar exchangeRates = await response.Content.ReadAsJsonAsync<List<ExchangeRate>>();\n\t\t\tAssert.Single(exchangeRates);\n\n\t\t\tvar rate = exchangeRates[0];\n\t\t\tAssert.Equal(\"USD\", rate.Ticker);\n\t\t\tAssert.True(rate.Rate > 0);\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task GetClientVersionAsync()\n\t\t{\n\t\t\tusing var client = new WasabiClient(new Uri(RegTestFixture.BackendEndPoint), null);\n\t\t\tvar uptodate = await client.CheckUpdatesAsync(CancellationToken.None);\n\t\t\tAssert.True(uptodate.BackendCompatible);\n\t\t\tAssert.True(uptodate.ClientUpToDate);\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task BroadcastReplayTxAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\tvar utxos = await rpc.ListUnspentAsync();\n\t\t\tvar utxo = utxos[0];\n\t\t\tvar tx = await rpc.GetRawTransactionAsync(utxo.OutPoint.Hash);\n\t\t\tvar content = new StringContent($\"'{tx.ToHex()}'\", Encoding.UTF8, \"application\/json\");\n\n\t\t\tLogger.TurnOff();\n\t\t\tusing (var client = new TorHttpClient(new Uri(RegTestFixture.BackendEndPoint), null))\n\t\t\tusing (var response = await client.SendAsync(HttpMethod.Post, $\"\/api\/v{Constants.BackendMajorVersion}\/btc\/blockchain\/broadcast\", content))\n\t\t\t{\n\t\t\t\tAssert.Equal(HttpStatusCode.OK, response.StatusCode);\n\t\t\t\tAssert.Equal(\"Transaction is already in the blockchain.\", await response.Content.ReadAsJsonAsync<string>());\n\t\t\t}\n\t\t\tLogger.TurnOn();\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task BroadcastInvalidTxAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\tvar content = new StringContent($\"''\", Encoding.UTF8, \"application\/json\");\n\n\t\t\tLogger.TurnOff();\n\t\t\tusing (var client = new TorHttpClient(new Uri(RegTestFixture.BackendEndPoint), null))\n\t\t\tusing (var response = await client.SendAsync(HttpMethod.Post, $\"\/api\/v{Constants.BackendMajorVersion}\/btc\/blockchain\/broadcast\", content))\n\t\t\t{\n\t\t\t\tAssert.NotEqual(HttpStatusCode.OK, response.StatusCode);\n\t\t\t\tAssert.Equal(HttpStatusCode.BadRequest, response.StatusCode);\n\t\t\t\tAssert.Equal(\"Invalid hex.\", await response.Content.ReadAsJsonAsync<string>());\n\t\t\t}\n\t\t\tLogger.TurnOn();\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task FilterBuilderTestAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\tvar indexBuilderServiceDir = GetWorkDir();\n\t\t\tvar indexFilePath = Path.Combine(indexBuilderServiceDir, $\"Index{rpc.Network}.dat\");\n\t\t\tvar utxoSetFilePath = Path.Combine(indexBuilderServiceDir, $\"UtxoSet{rpc.Network}.dat\");\n\n\t\t\tvar indexBuilderService = new IndexBuilderService(rpc, global.HostedServices.FirstOrDefault<BlockNotifier>(), indexFilePath, utxoSetFilePath);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tindexBuilderService.Synchronize();\n\n\t\t\t\t\/\/ Test initial synchronization.\n\t\t\t\tvar times = 0;\n\t\t\t\tuint256 firstHash = await rpc.GetBlockHashAsync(0);\n\t\t\t\twhile (indexBuilderService.GetFilterLinesExcluding(firstHash, 101, out _).filters.Count() != 101)\n\t\t\t\t{\n\t\t\t\t\tif (times > 500) \/\/ 30 sec\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new TimeoutException($\"{nameof(IndexBuilderService)} test timed out.\");\n\t\t\t\t\t}\n\t\t\t\t\tawait Task.Delay(100);\n\t\t\t\t\ttimes++;\n\t\t\t\t}\n\n\t\t\t\t\/\/ Test later synchronization.\n\t\t\t\tawait rpc.GenerateAsync(10);\n\t\t\t\ttimes = 0;\n\t\t\t\twhile (indexBuilderService.GetFilterLinesExcluding(firstHash, 111, out bool found5).filters.Count() != 111)\n\t\t\t\t{\n\t\t\t\t\tAssert.True(found5);\n\t\t\t\t\tif (times > 500) \/\/ 30 sec\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new TimeoutException($\"{nameof(IndexBuilderService)} test timed out.\");\n\t\t\t\t\t}\n\t\t\t\t\tawait Task.Delay(100);\n\t\t\t\t\ttimes++;\n\t\t\t\t}\n\n\t\t\t\t\/\/ Test correct number of filters is received.\n\t\t\t\tvar hundredthHash = await rpc.GetBlockHashAsync(100);\n\t\t\t\tAssert.Equal(11, indexBuilderService.GetFilterLinesExcluding(hundredthHash, 11, out bool found).filters.Count());\n\t\t\t\tAssert.True(found);\n\t\t\t\tvar bestHash = await rpc.GetBestBlockHashAsync();\n\t\t\t\tAssert.Empty(indexBuilderService.GetFilterLinesExcluding(bestHash, 1, out bool found2).filters);\n\t\t\t\tAssert.Empty(indexBuilderService.GetFilterLinesExcluding(uint256.Zero, 1, out bool found3).filters);\n\t\t\t\tAssert.False(found3);\n\n\t\t\t\t\/\/ Test filter block hashes are correct.\n\t\t\t\tvar filters = indexBuilderService.GetFilterLinesExcluding(firstHash, 111, out bool found4).filters.ToArray();\n\t\t\t\tAssert.True(found4);\n\t\t\t\tfor (int i = 0; i < 111; i++)\n\t\t\t\t{\n\t\t\t\t\tvar expectedHash = await rpc.GetBlockHashAsync(i + 1);\n\t\t\t\t\tvar filterModel = filters[i];\n\t\t\t\t\tAssert.Equal(expectedHash, filterModel.Header.BlockHash);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tif (indexBuilderService != null)\n\t\t\t\t{\n\t\t\t\t\tawait indexBuilderService.StopAsync();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t#endregion BackendTests\n\n\t\t#region ServicesTests\n\n\t\t[Fact]\n\t\tpublic async Task FilterDownloaderTestAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\tvar synchronizer = new WasabiSynchronizer(rpc.Network, bitcoinStore, new Uri(RegTestFixture.BackendEndPoint), null);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tsynchronizer.Start(requestInterval: TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(5), 1000);\n\n\t\t\t\tvar blockCount = await rpc.GetBlockCountAsync() + 1; \/\/ Plus one because of the zeroth.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \/\/ Test initial synchronization.\n\t\t\t\tvar times = 0;\n\t\t\t\tint filterCount;\n\t\t\t\twhile ((filterCount = bitcoinStore.SmartHeaderChain.HashCount) < blockCount)\n\t\t\t\t{\n\t\t\t\t\tif (times > 500) \/\/ 30 sec\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new TimeoutException($\"{nameof(WasabiSynchronizer)} test timed out. Needed filters: {blockCount}, got only: {filterCount}.\");\n\t\t\t\t\t}\n\t\t\t\t\tawait Task.Delay(100);\n\t\t\t\t\ttimes++;\n\t\t\t\t}\n\n\t\t\t\tAssert.Equal(blockCount, bitcoinStore.SmartHeaderChain.HashCount);\n\n\t\t\t\t\/\/ Test later synchronization.\n\t\t\t\tawait RegTestFixture.BackendRegTestNode.GenerateAsync(10);\n\t\t\t\ttimes = 0;\n\t\t\t\twhile ((filterCount = bitcoinStore.SmartHeaderChain.HashCount) < blockCount + 10)\n\t\t\t\t{\n\t\t\t\t\tif (times > 500) \/\/ 30 sec\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new TimeoutException($\"{nameof(WasabiSynchronizer)} test timed out. Needed filters: {blockCount + 10}, got only: {filterCount}.\");\n\t\t\t\t\t}\n\t\t\t\t\tawait Task.Delay(100);\n\t\t\t\t\ttimes++;\n\t\t\t\t}\n\n\t\t\t\t\/\/ Test correct number of filters is received.\n\t\t\t\tAssert.Equal(blockCount + 10, bitcoinStore.SmartHeaderChain.HashCount);\n\n\t\t\t\t\/\/ Test filter block hashes are correct.\n\t\t\t\tvar filterList = new List<FilterModel>();\n\t\t\t\tawait bitcoinStore.IndexStore.ForeachFiltersAsync(async x =>\n\t\t\t\t{\n\t\t\t\t\tfilterList.Add(x);\n\t\t\t\t\tawait Task.CompletedTask;\n\t\t\t\t},\n\t\t\t\tnew Height(0));\n\t\t\t\tFilterModel[] filters = filterList.ToArray();\n\t\t\t\tfor (int i = 0; i < 101; i++)\n\t\t\t\t{\n\t\t\t\t\tvar expectedHash = await rpc.GetBlockHashAsync(i);\n\t\t\t\t\tvar filter = filters[i];\n\t\t\t\t\tAssert.Equal(i, (int)filter.Header.Height);\n\t\t\t\t\tAssert.Equal(expectedHash, filter.Header.BlockHash);\n\t\t\t\t\tAssert.Equal(IndexBuilderService.CreateDummyEmptyFilter(expectedHash).ToString(), filter.Filter.ToString());\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tawait synchronizer?.StopAsync();\n\t\t\t}\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task ReorgTestAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\tvar keyManager = KeyManager.CreateNew(out _, password);\n\n\t\t\t\/\/ Mine some coins, make a few bech32 transactions then make it confirm.\n\t\t\tawait rpc.GenerateAsync(1);\n\t\t\tvar key = keyManager.GenerateNewKey(SmartLabel.Empty, KeyState.Clean, isInternal: false);\n\t\t\tvar tx2 = await rpc.SendToAddressAsync(key.GetP2wpkhAddress(network), Money.Coins(0.1m));\n\t\t\tkey = keyManager.GenerateNewKey(SmartLabel.Empty, KeyState.Clean, isInternal: false);\n\t\t\tvar tx3 = await rpc.SendToAddressAsync(key.GetP2wpkhAddress(network), Money.Coins(0.1m));\n\t\t\tvar tx4 = await rpc.SendToAddressAsync(key.GetP2pkhAddress(network), Money.Coins(0.1m));\n\t\t\tvar tx5 = await rpc.SendToAddressAsync(key.GetP2shOverP2wpkhAddress(network), Money.Coins(0.1m));\n\t\t\tvar tx1 = await rpc.SendToAddressAsync(key.GetP2wpkhAddress(network), Money.Coins(0.1m), replaceable: true);\n\n\t\t\tawait rpc.GenerateAsync(2); \/\/ Generate two, so we can test for two reorg\n\n\t\t\tvar node = RegTestFixture.BackendRegTestNode;\n\n\t\t\tvar synchronizer = new WasabiSynchronizer(rpc.Network, bitcoinStore, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tsynchronizer.Start(requestInterval: TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(5), 1000);\n\n\t\t\t\tvar reorgAwaiter = new EventsAwaiter<FilterModel>(\n\t\t\t\t\th => bitcoinStore.IndexStore.Reorged += h,\n\t\t\t\t\th => bitcoinStore.IndexStore.Reorged -= h,\n\t\t\t\t\t2);\n\n\t\t\t\t\/\/ Test initial synchronization.\n\t\t\t\tawait WaitForIndexesToSyncAsync(global, TimeSpan.FromSeconds(90), bitcoinStore);\n\n\t\t\t\tvar tip = await rpc.GetBestBlockHashAsync();\n\t\t\t\tAssert.Equal(tip, bitcoinStore.SmartHeaderChain.TipHash);\n\t\t\t\tvar tipBlock = await rpc.GetBlockHeaderAsync(tip);\n\t\t\t\tAssert.Equal(tipBlock.HashPrevBlock, bitcoinStore.SmartHeaderChain.GetChain().Select(x => x.header.BlockHash).ToArray()[bitcoinStore.SmartHeaderChain.HashCount - 2]);\n\n\t\t\t\tvar utxoPath = global.IndexBuilderService.Bech32UtxoSetFilePath;\n\t\t\t\tvar utxoLines = await File.ReadAllTextAsync(utxoPath);\n\t\t\t\tAssert.Contains(tx1.ToString(), utxoLines);\n\t\t\t\tAssert.Contains(tx2.ToString(), utxoLines);\n\t\t\t\tAssert.Contains(tx3.ToString(), utxoLines);\n\t\t\t\tAssert.DoesNotContain(tx4.ToString(), utxoLines); \/\/ make sure only bech is recorded\n\t\t\t\tAssert.DoesNotContain(tx5.ToString(), utxoLines); \/\/ make sure only bech is recorded\n\n\t\t\t\t\/\/ Test synchronization after fork.\n\t\t\t\tawait rpc.InvalidateBlockAsync(tip); \/\/ Reorg 1\n\t\t\t\ttip = await rpc.GetBestBlockHashAsync();\n\t\t\t\tawait rpc.InvalidateBlockAsync(tip); \/\/ Reorg 2\n\t\t\t\tvar tx1bumpRes = await rpc.BumpFeeAsync(tx1); \/\/ RBF it\n\n\t\t\t\tawait rpc.GenerateAsync(5);\n\t\t\t\tawait WaitForIndexesToSyncAsync(global, TimeSpan.FromSeconds(90), bitcoinStore);\n\n\t\t\t\tutxoLines = await File.ReadAllTextAsync(utxoPath);\n\t\t\t\tAssert.Contains(tx1bumpRes.TransactionId.ToString(), utxoLines); \/\/ assert the tx1bump is the correct tx\n\t\t\t\tAssert.DoesNotContain(tx1.ToString(), utxoLines); \/\/ assert tx1 is abandoned (despite it confirmed previously)\n\t\t\t\tAssert.Contains(tx2.ToString(), utxoLines);\n\t\t\t\tAssert.Contains(tx3.ToString(), utxoLines);\n\t\t\t\tAssert.DoesNotContain(tx4.ToString(), utxoLines);\n\t\t\t\tAssert.DoesNotContain(tx5.ToString(), utxoLines);\n\n\t\t\t\tvar hashes = bitcoinStore.SmartHeaderChain.GetChain().Select(x => x.header.BlockHash).ToArray();\n\t\t\t\tAssert.DoesNotContain(tip, hashes);\n\t\t\t\tAssert.DoesNotContain(tipBlock.HashPrevBlock, hashes);\n\n\t\t\t\ttip = await rpc.GetBestBlockHashAsync();\n\t\t\t\tAssert.Equal(tip, bitcoinStore.SmartHeaderChain.TipHash);\n\n\t\t\t\tvar filterList = new List<FilterModel>();\n\t\t\t\tawait bitcoinStore.IndexStore.ForeachFiltersAsync(async x =>\n\t\t\t\t{\n\t\t\t\t\tfilterList.Add(x);\n\t\t\t\t\tawait Task.CompletedTask;\n\t\t\t\t},\n\t\t\t\tnew Height(0));\n\t\t\t\tvar filterTip = filterList.Last();\n\t\t\t\tAssert.Equal(tip, filterTip.Header.BlockHash);\n\n\t\t\t\t\/\/ Test filter block hashes are correct after fork.\n\t\t\t\tvar blockCountIncludingGenesis = await rpc.GetBlockCountAsync() + 1;\n\n\t\t\t\tfilterList.Clear();\n\t\t\t\tawait bitcoinStore.IndexStore.ForeachFiltersAsync(async x =>\n\t\t\t\t{\n\t\t\t\t\tfilterList.Add(x);\n\t\t\t\t\tawait Task.CompletedTask;\n\t\t\t\t},\n\t\t\t\tnew Height(0));\n\t\t\t\tFilterModel[] filters = filterList.ToArray();\n\t\t\t\tfor (int i = 0; i < blockCountIncludingGenesis; i++)\n\t\t\t\t{\n\t\t\t\t\tvar expectedHash = await rpc.GetBlockHashAsync(i);\n\t\t\t\t\tvar filter = filters[i];\n\t\t\t\t\tAssert.Equal(i, (int)filter.Header.Height);\n\t\t\t\t\tAssert.Equal(expectedHash, filter.Header.BlockHash);\n\t\t\t\t\tif (i < 101) \/\/ Later other tests may fill the filter.\n\t\t\t\t\t{\n\t\t\t\t\t\tAssert.Equal(IndexBuilderService.CreateDummyEmptyFilter(expectedHash).ToString(), filter.Filter.ToString());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t\/\/ Test the serialization, too.\n\t\t\t\ttip = await rpc.GetBestBlockHashAsync();\n\t\t\t\tvar blockHash = tip;\n\t\t\t\tfor (var i = 0; i < hashes.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar block = await rpc.GetBlockHeaderAsync(blockHash);\n\t\t\t\t\tAssert.Equal(blockHash, hashes[hashes.Length - i - 1]);\n\t\t\t\t\tblockHash = block.HashPrevBlock;\n\t\t\t\t}\n\n\t\t\t\t\/\/ Assert reorg happened exactly as many times as we reorged.\n\t\t\t\tawait reorgAwaiter.WaitAsync(TimeSpan.FromSeconds(10));\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tawait synchronizer?.StopAsync();\n\t\t\t}\n\t\t}\n\n\t\tprivate async Task WaitForIndexesToSyncAsync(Backend.Global global, TimeSpan timeout, BitcoinStore bitcoinStore)\n\t\t{\n\t\t\tvar bestHash = await global.RpcClient.GetBestBlockHashAsync();\n\n\t\t\tvar times = 0;\n\t\t\twhile (bitcoinStore.SmartHeaderChain.TipHash != bestHash)\n\t\t\t{\n\t\t\t\tif (times > timeout.TotalSeconds)\n\t\t\t\t{\n\t\t\t\t\tthrow new TimeoutException($\"{nameof(WasabiSynchronizer)} test timed out. Filter was not downloaded.\");\n\t\t\t\t}\n\t\t\t\tawait Task.Delay(TimeSpan.FromSeconds(1));\n\t\t\t\ttimes++;\n\t\t\t}\n\t\t}\n\n\t\t#endregion ServicesTests\n\n\t\t#region ClientTests\n\n\t\t[Fact]\n\t\tpublic async Task WalletTestsAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\t\/\/ Create the services.\n\t\t\t\/\/ 1. Create connection service.\n\t\t\tvar nodes = new NodesGroup(global.Config.Network, requirements: Constants.NodeRequirements);\n\t\t\tnodes.ConnectedNodes.Add(await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync());\n\n\t\t\tNode node = await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync();\n\t\t\tnode.Behaviors.Add(bitcoinStore.CreateUntrustedP2pBehavior());\n\n\t\t\t\/\/ 3. Create wasabi synchronizer service.\n\t\t\tvar synchronizer = new WasabiSynchronizer(rpc.Network, bitcoinStore, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\t\/\/ 4. Create key manager service.\n\t\t\tvar keyManager = KeyManager.CreateNew(out _, password);\n\n\t\t\t\/\/ 5. Create chaumian coinjoin client.\n\t\t\tvar chaumianClient = new CoinJoinClient(synchronizer, rpc.Network, keyManager, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\t\/\/ 5. Create wallet service.\n\t\t\tvar workDir = GetWorkDir();\n\t\t\tvar wallet = new WalletService(bitcoinStore, keyManager, synchronizer, chaumianClient, nodes, workDir, serviceConfiguration, synchronizer);\n\t\t\twallet.NewFilterProcessed += Wallet_NewFilterProcessed;\n\n\t\t\t\/\/ Get some money, make it confirm.\n\t\t\tvar key = keyManager.GetNextReceiveKey(\"foo label\", out _);\n\t\t\tvar txId = await rpc.SendToAddressAsync(key.GetP2wpkhAddress(network), Money.Coins(0.1m));\n\t\t\tawait rpc.GenerateAsync(1);\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tInterlocked.Exchange(ref _filtersProcessedByWalletCount, 0);\n\t\t\t\tnodes.Connect(); \/\/ Start connection service.\n\t\t\t\tnode.VersionHandshake(); \/\/ Start mempool service.\n\t\t\t\tsynchronizer.Start(requestInterval: TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(5), 1000); \/\/ Start wasabi synchronizer service.\n\t\t\t\tchaumianClient.Start(); \/\/ Start chaumian coinjoin client.\n\n\t\t\t\t\/\/ Wait until the filter our previous transaction is present.\n\t\t\t\tvar blockCount = await rpc.GetBlockCountAsync();\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), blockCount);\n\n\t\t\t\tusing (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30)))\n\t\t\t\t{\n\t\t\t\t\tawait wallet.InitializeAsync(cts.Token); \/\/ Initialize wallet service.\n\t\t\t\t}\n\t\t\t\tAssert.Equal(1, await wallet.CountBlocksAsync());\n\n\t\t\t\tAssert.Single(wallet.Coins);\n\t\t\t\tvar firstCoin = wallet.Coins.Single();\n\t\t\t\tAssert.Equal(Money.Coins(0.1m), firstCoin.Amount);\n\t\t\t\tAssert.Equal(new Height((int)bitcoinStore.SmartHeaderChain.TipHeight), firstCoin.Height);\n\t\t\t\tAssert.InRange(firstCoin.Index, 0U, 1U);\n\t\t\t\tAssert.False(firstCoin.Unavailable);\n\t\t\t\tAssert.Equal(\"foo label\", firstCoin.Label);\n\t\t\t\tAssert.Equal(key.P2wpkhScript, firstCoin.ScriptPubKey);\n\t\t\t\tAssert.Null(firstCoin.SpenderTransactionId);\n\t\t\t\tAssert.NotNull(firstCoin.SpentOutputs);\n\t\t\t\tAssert.NotEmpty(firstCoin.SpentOutputs);\n\t\t\t\tAssert.Equal(txId, firstCoin.TransactionId);\n\t\t\t\tAssert.Single(keyManager.GetKeys(KeyState.Used, false));\n\t\t\t\tAssert.Equal(\"foo label\", keyManager.GetKeys(KeyState.Used, false).Single().Label);\n\n\t\t\t\t\/\/ Get some money, make it confirm.\n\t\t\t\tvar key2 = keyManager.GetNextReceiveKey(\"bar label\", out _);\n\t\t\t\tvar txId2 = await rpc.SendToAddressAsync(key2.GetP2wpkhAddress(network), Money.Coins(0.01m));\n\t\t\t\tInterlocked.Exchange(ref _filtersProcessedByWalletCount, 0);\n\t\t\t\tawait rpc.GenerateAsync(1);\n\t\t\t\tvar txId3 = await rpc.SendToAddressAsync(key2.GetP2wpkhAddress(network), Money.Coins(0.02m));\n\t\t\t\tawait rpc.GenerateAsync(1);\n\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), 2);\n\t\t\t\tAssert.Equal(3, await wallet.CountBlocksAsync());\n\n\t\t\t\tAssert.Equal(3, wallet.Coins.Count());\n\t\t\t\tfirstCoin = wallet.Coins.OrderBy(x => x.Height).First();\n\t\t\t\tvar secondCoin = wallet.Coins.OrderBy(x => x.Height).Take(2).Last();\n\t\t\t\tvar thirdCoin = wallet.Coins.OrderBy(x => x.Height).Last();\n\t\t\t\tAssert.Equal(Money.Coins(0.01m), secondCoin.Amount);\n\t\t\t\tAssert.Equal(Money.Coins(0.02m), thirdCoin.Amount);\n\t\t\t\tAssert.Equal(new Height(bitcoinStore.SmartHeaderChain.TipHeight).Value - 2, firstCoin.Height.Value);\n\t\t\t\tAssert.Equal(new Height(bitcoinStore.SmartHeaderChain.TipHeight).Value - 1, secondCoin.Height.Value);\n\t\t\t\tAssert.Equal(new Height(bitcoinStore.SmartHeaderChain.TipHeight), thirdCoin.Height);\n\t\t\t\tAssert.False(thirdCoin.Unavailable);\n\t\t\t\tAssert.Equal(\"foo label\", firstCoin.Label);\n\t\t\t\tAssert.Equal(\"bar label\", secondCoin.Label);\n\t\t\t\tAssert.Equal(\"bar label\", thirdCoin.Label);\n\t\t\t\tAssert.Equal(key.P2wpkhScript, firstCoin.ScriptPubKey);\n\t\t\t\tAssert.Equal(key2.P2wpkhScript, secondCoin.ScriptPubKey);\n\t\t\t\tAssert.Equal(key2.P2wpkhScript, thirdCoin.ScriptPubKey);\n\t\t\t\tAssert.Null(thirdCoin.SpenderTransactionId);\n\t\t\t\tAssert.NotNull(firstCoin.SpentOutputs);\n\t\t\t\tAssert.NotNull(secondCoin.SpentOutputs);\n\t\t\t\tAssert.NotNull(thirdCoin.SpentOutputs);\n\t\t\t\tAssert.NotEmpty(firstCoin.SpentOutputs);\n\t\t\t\tAssert.NotEmpty(secondCoin.SpentOutputs);\n\t\t\t\tAssert.NotEmpty(thirdCoin.SpentOutputs);\n\t\t\t\tAssert.Equal(txId, firstCoin.TransactionId);\n\t\t\t\tAssert.Equal(txId2, secondCoin.TransactionId);\n\t\t\t\tAssert.Equal(txId3, thirdCoin.TransactionId);\n\n\t\t\t\tAssert.Equal(2, keyManager.GetKeys(KeyState.Used, false).Count());\n\t\t\t\tAssert.Empty(keyManager.GetKeys(KeyState.Used, true));\n\t\t\t\tAssert.Equal(2, keyManager.GetKeys(KeyState.Used).Count());\n\t\t\t\tAssert.Empty(keyManager.GetKeys(KeyState.Locked, false));\n\t\t\t\tAssert.Equal(14, keyManager.GetKeys(KeyState.Locked, true).Count());\n\t\t\t\tAssert.Equal(14, keyManager.GetKeys(KeyState.Locked).Count());\n\t\t\t\tAssert.Equal(21, keyManager.GetKeys(KeyState.Clean, true).Count());\n\t\t\t\tAssert.Equal(21, keyManager.GetKeys(KeyState.Clean, false).Count());\n\t\t\t\tAssert.Equal(42, keyManager.GetKeys(KeyState.Clean).Count());\n\t\t\t\tAssert.Equal(58, keyManager.GetKeys().Count());\n\n\t\t\t\tAssert.Single(keyManager.GetKeys(x => x.Label == \"foo label\" && x.KeyState == KeyState.Used && !x.IsInternal));\n\t\t\t\tAssert.Single(keyManager.GetKeys(x => x.Label == \"bar label\" && x.KeyState == KeyState.Used && !x.IsInternal));\n\n\t\t\t\t\/\/ REORG TESTS\n\t\t\t\tvar txId4 = await rpc.SendToAddressAsync(key2.GetP2wpkhAddress(network), Money.Coins(0.03m), replaceable: true);\n\t\t\t\tInterlocked.Exchange(ref _filtersProcessedByWalletCount, 0);\n\t\t\t\tawait rpc.GenerateAsync(2);\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), 2);\n\n\t\t\t\tAssert.NotEmpty(wallet.Coins.Where(x => x.TransactionId == txId4));\n\t\t\t\tvar tip = await rpc.GetBestBlockHashAsync();\n\t\t\t\tawait rpc.InvalidateBlockAsync(tip); \/\/ Reorg 1\n\t\t\t\ttip = await rpc.GetBestBlockHashAsync();\n\t\t\t\tawait rpc.InvalidateBlockAsync(tip); \/\/ Reorg 2\n\t\t\t\tvar tx4bumpRes = await rpc.BumpFeeAsync(txId4); \/\/ RBF it\n\t\t\t\tInterlocked.Exchange(ref _filtersProcessedByWalletCount, 0);\n\t\t\t\tawait rpc.GenerateAsync(3);\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), 3);\n\t\t\t\tAssert.Equal(4, await wallet.CountBlocksAsync());\n\n\t\t\t\tAssert.Equal(4, wallet.Coins.Count());\n\t\t\t\tAssert.Empty(wallet.Coins.Where(x => x.TransactionId == txId4));\n\t\t\t\tAssert.NotEmpty(wallet.Coins.Where(x => x.TransactionId == tx4bumpRes.TransactionId));\n\t\t\t\tvar rbfCoin = wallet.Coins.Single(x => x.TransactionId == tx4bumpRes.TransactionId);\n\n\t\t\t\tAssert.Equal(Money.Coins(0.03m), rbfCoin.Amount);\n\t\t\t\tAssert.Equal(new Height(bitcoinStore.SmartHeaderChain.TipHeight).Value - 2, rbfCoin.Height.Value);\n\t\t\t\tAssert.False(rbfCoin.Unavailable);\n\t\t\t\tAssert.Equal(\"bar label\", rbfCoin.Label);\n\t\t\t\tAssert.Equal(key2.P2wpkhScript, rbfCoin.ScriptPubKey);\n\t\t\t\tAssert.Null(rbfCoin.SpenderTransactionId);\n\t\t\t\tAssert.NotNull(rbfCoin.SpentOutputs);\n\t\t\t\tAssert.NotEmpty(rbfCoin.SpentOutputs);\n\t\t\t\tAssert.Equal(tx4bumpRes.TransactionId, rbfCoin.TransactionId);\n\n\t\t\t\tAssert.Equal(2, keyManager.GetKeys(KeyState.Used, false).Count());\n\t\t\t\tAssert.Empty(keyManager.GetKeys(KeyState.Used, true));\n\t\t\t\tAssert.Equal(2, keyManager.GetKeys(KeyState.Used).Count());\n\t\t\t\tAssert.Empty(keyManager.GetKeys(KeyState.Locked, false));\n\t\t\t\tAssert.Equal(14, keyManager.GetKeys(KeyState.Locked, true).Count());\n\t\t\t\tAssert.Equal(14, keyManager.GetKeys(KeyState.Locked).Count());\n\t\t\t\tAssert.Equal(21, keyManager.GetKeys(KeyState.Clean, true).Count());\n\t\t\t\tAssert.Equal(21, keyManager.GetKeys(KeyState.Clean, false).Count());\n\t\t\t\tAssert.Equal(42, keyManager.GetKeys(KeyState.Clean).Count());\n\t\t\t\tAssert.Equal(58, keyManager.GetKeys().Count());\n\n\t\t\t\tAssert.Single(keyManager.GetKeys(KeyState.Used, false).Where(x => x.Label == \"foo label\"));\n\t\t\t\tAssert.Single(keyManager.GetKeys(KeyState.Used, false).Where(x => x.Label == \"bar label\"));\n\n\t\t\t\t\/\/ TEST MEMPOOL\n\t\t\t\tvar txId5 = await rpc.SendToAddressAsync(key.GetP2wpkhAddress(network), Money.Coins(0.1m));\n\t\t\t\tawait Task.Delay(1000); \/\/ Wait tx to arrive and get processed.\n\t\t\t\tAssert.NotEmpty(wallet.Coins.Where(x => x.TransactionId == txId5));\n\t\t\t\tvar mempoolCoin = wallet.Coins.Single(x => x.TransactionId == txId5);\n\t\t\t\tAssert.Equal(Height.Mempool, mempoolCoin.Height);\n\n\t\t\t\tInterlocked.Exchange(ref _filtersProcessedByWalletCount, 0);\n\t\t\t\tawait rpc.GenerateAsync(1);\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), 1);\n\t\t\t\tvar res = await rpc.GetTxOutAsync(mempoolCoin.TransactionId, (int)mempoolCoin.Index, true);\n\t\t\t\tAssert.Equal(new Height(bitcoinStore.SmartHeaderChain.TipHeight), mempoolCoin.Height);\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\twallet.NewFilterProcessed -= Wallet_NewFilterProcessed;\n\t\t\t\twallet?.Dispose();\n\t\t\t\t\/\/ Dispose wasabi synchronizer service.\n\t\t\t\tawait synchronizer?.StopAsync();\n\n\t\t\t\t\/\/ Dispose connection service.\n\t\t\t\tnodes?.Dispose();\n\n\t\t\t\t\/\/ Dispose mempool serving node.\n\t\t\t\tnode?.Disconnect();\n\n\t\t\t\t\/\/ Dispose chaumian coinjoin client.\n\t\t\t\tif (chaumianClient != null)\n\t\t\t\t{\n\t\t\t\t\tawait chaumianClient.StopAsync();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate async Task WaitForFiltersToBeProcessedAsync(TimeSpan timeout, int numberOfFiltersToWaitFor)\n\t\t{\n\t\t\tvar times = 0;\n\t\t\twhile (Interlocked.Read(ref _filtersProcessedByWalletCount) < numberOfFiltersToWaitFor)\n\t\t\t{\n\t\t\t\tif (times > timeout.TotalSeconds)\n\t\t\t\t{\n\t\t\t\t\tthrow new TimeoutException($\"{nameof(WalletService)} test timed out. Filter was not processed. Needed: {numberOfFiltersToWaitFor}, got only: {Interlocked.Read(ref _filtersProcessedByWalletCount)}.\");\n\t\t\t\t}\n\t\t\t\tawait Task.Delay(TimeSpan.FromSeconds(1));\n\t\t\t\ttimes++;\n\t\t\t}\n\t\t}\n\n\t\tprivate long _filtersProcessedByWalletCount;\n\n\t\tprivate void Wallet_NewFilterProcessed(object sender, FilterModel e)\n\t\t{\n\t\t\tInterlocked.Increment(ref _filtersProcessedByWalletCount);\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task SendTestsAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\t\/\/ Create the services.\n\t\t\t\/\/ 1. Create connection service.\n\t\t\tvar nodes = new NodesGroup(global.Config.Network, requirements: Constants.NodeRequirements);\n\t\t\tnodes.ConnectedNodes.Add(await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync());\n\n\t\t\t\/\/ 2. Create mempool service.\n\n\t\t\tNode node = await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync();\n\t\t\tnode.Behaviors.Add(bitcoinStore.CreateUntrustedP2pBehavior());\n\n\t\t\t\/\/ 3. Create wasabi synchronizer service.\n\t\t\tvar synchronizer = new WasabiSynchronizer(rpc.Network, bitcoinStore, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\t\/\/ 4. Create key manager service.\n\t\t\tvar keyManager = KeyManager.CreateNew(out _, password);\n\n\t\t\t\/\/ 5. Create chaumian coinjoin client.\n\t\t\tvar chaumianClient = new CoinJoinClient(synchronizer, rpc.Network, keyManager, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\t\/\/ 6. Create wallet service.\n\t\t\tvar workDir = GetWorkDir();\n\t\t\tvar wallet = new WalletService(bitcoinStore, keyManager, synchronizer, chaumianClient, nodes, workDir, serviceConfiguration, synchronizer);\n\t\t\twallet.NewFilterProcessed += Wallet_NewFilterProcessed;\n\n\t\t\t\/\/ Get some money, make it confirm.\n\t\t\tvar key = keyManager.GetNextReceiveKey(\"foo label\", out _);\n\t\t\tvar key2 = keyManager.GetNextReceiveKey(\"foo label\", out _);\n\t\t\tvar txId = await rpc.SendToAddressAsync(key.GetP2wpkhAddress(network), Money.Coins(1m));\n\t\t\tAssert.NotNull(txId);\n\t\t\tawait rpc.GenerateAsync(1);\n\t\t\tvar txId2 = await rpc.SendToAddressAsync(key2.GetP2wpkhAddress(network), Money.Coins(1m));\n\t\t\tAssert.NotNull(txId2);\n\t\t\tawait rpc.GenerateAsync(1);\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tInterlocked.Exchange(ref _filtersProcessedByWalletCount, 0);\n\t\t\t\tnodes.Connect(); \/\/ Start connection service.\n\t\t\t\tnode.VersionHandshake(); \/\/ Start mempool service.\n\t\t\t\tsynchronizer.Start(requestInterval: TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(5), 10000); \/\/ Start wasabi synchronizer service.\n\t\t\t\tchaumianClient.Start(); \/\/ Start chaumian coinjoin client.\n\n\t\t\t\t\/\/ Wait until the filter our previous transaction is present.\n\t\t\t\tvar blockCount = await rpc.GetBlockCountAsync();\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), blockCount);\n\n\t\t\t\tusing (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30)))\n\t\t\t\t{\n\t\t\t\t\tawait wallet.InitializeAsync(cts.Token); \/\/ Initialize wallet service.\n\t\t\t\t}\n\t\t\t\tvar broadcaster = new TransactionBroadcaster(network, bitcoinStore, synchronizer, nodes, rpc);\n\t\t\t\tbroadcaster.AddWalletService(wallet);\n\n\t\t\t\tvar waitCount = 0;\n\t\t\t\twhile (wallet.Coins.Sum(x => x.Amount) == Money.Zero)\n\t\t\t\t{\n\t\t\t\t\tawait Task.Delay(1000);\n\t\t\t\t\twaitCount++;\n\t\t\t\t\tif (waitCount >= 21)\n\t\t\t\t\t{\n\t\t\t\t\t\tLogger.LogInfo(\"Funding transaction to the wallet did not arrive.\");\n\t\t\t\t\t\treturn; \/\/ Very rarely this test fails. I have no clue why. Probably because all these RegTests are interconnected, anyway let's not bother the CI with it.\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar scp = new Key().ScriptPubKey;\n\t\t\t\tvar res2 = wallet.BuildTransaction(password, new PaymentIntent(scp, Money.Coins(0.05m), label: \"foo\"), FeeStrategy.CreateFromConfirmationTarget(5), allowUnconfirmed: false);\n\n\t\t\t\tAssert.NotNull(res2.Transaction);\n\t\t\t\tAssert.Single(res2.OuterWalletOutputs);\n\t\t\t\tAssert.Equal(scp, res2.OuterWalletOutputs.Single().ScriptPubKey);\n\t\t\t\tAssert.Single(res2.InnerWalletOutputs);\n\t\t\t\tAssert.True(res2.Fee > Money.Satoshis(2 * 100)); \/\/ since there is a sanity check of 2sat\/vb in the server\n\t\t\t\tAssert.InRange(res2.FeePercentOfSent, 0, 1);\n\t\t\t\tAssert.Single(res2.SpentCoins);\n\t\t\t\tvar spentCoin = Assert.Single(res2.SpentCoins);\n\t\t\t\tAssert.Contains(new[] { key.P2wpkhScript, key2.P2wpkhScript }, x => x == spentCoin.ScriptPubKey);\n\t\t\t\tAssert.Equal(Money.Coins(1m), res2.SpentCoins.Single().Amount);\n\t\t\t\tAssert.False(res2.SpendsUnconfirmed);\n\n\t\t\t\tawait broadcaster.SendTransactionAsync(res2.Transaction);\n\n\t\t\t\tAssert.Contains(res2.InnerWalletOutputs.Single(), wallet.Coins);\n\n\t\t\t\t#region Basic\n\n\t\t\t\tScript receive = keyManager.GetNextReceiveKey(\"Basic\", out _).P2wpkhScript;\n\t\t\t\tMoney amountToSend = wallet.Coins.Where(x => !x.Unavailable).Sum(x => x.Amount) \/ 2;\n\t\t\t\tvar res = wallet.BuildTransaction(password, new PaymentIntent(receive, amountToSend, label: \"foo\"), FeeStrategy.SevenDaysConfirmationTargetStrategy, allowUnconfirmed: true);\n\n\t\t\t\tforeach (SmartCoin coin in res.SpentCoins)\n\t\t\t\t{\n\t\t\t\t\tAssert.False(coin.CoinJoinInProgress);\n\t\t\t\t\tAssert.True(coin.Confirmed);\n\t\t\t\t\tAssert.Null(coin.SpenderTransactionId);\n\t\t\t\t\tAssert.True(coin.Unspent);\n\t\t\t\t}\n\n\t\t\t\tAssert.Equal(2, res.InnerWalletOutputs.Count());\n\t\t\t\tAssert.Empty(res.OuterWalletOutputs);\n\t\t\t\tvar activeOutput = res.InnerWalletOutputs.Single(x => x.ScriptPubKey == receive);\n\t\t\t\tvar changeOutput = res.InnerWalletOutputs.Single(x => x.ScriptPubKey != receive);\n\n\t\t\t\tAssert.Equal(receive, activeOutput.ScriptPubKey);\n\t\t\t\tAssert.Equal(amountToSend, activeOutput.Amount);\n\t\t\t\tif (res.SpentCoins.Sum(x => x.Amount) - activeOutput.Amount == res.Fee) \/\/ this happens when change is too small\n\t\t\t\t{\n\t\t\t\t\tAssert.Contains(res.Transaction.Transaction.Outputs, x => x.Value == activeOutput.Amount);\n\t\t\t\t\tLogger.LogInfo($\"Change Output: {changeOutput.Amount.ToString(false, true)} {changeOutput.ScriptPubKey.GetDestinationAddress(network)}\");\n\t\t\t\t}\n\t\t\t\tLogger.LogInfo($\"{nameof(res.Fee)}: {res.Fee}\");\n\t\t\t\tLogger.LogInfo($\"{nameof(res.FeePercentOfSent)}: {res.FeePercentOfSent} %\");\n\t\t\t\tLogger.LogInfo($\"{nameof(res.SpendsUnconfirmed)}: {res.SpendsUnconfirmed}\");\n\t\t\t\tLogger.LogInfo($\"Active Output: {activeOutput.Amount.ToString(false, true)} {activeOutput.ScriptPubKey.GetDestinationAddress(network)}\");\n\t\t\t\tLogger.LogInfo($\"TxId: {res.Transaction.GetHash()}\");\n\n\t\t\t\tvar foundReceive = false;\n\t\t\t\tAssert.InRange(res.Transaction.Transaction.Outputs.Count, 1, 2);\n\t\t\t\tforeach (var output in res.Transaction.Transaction.Outputs)\n\t\t\t\t{\n\t\t\t\t\tif (output.ScriptPubKey == receive)\n\t\t\t\t\t{\n\t\t\t\t\t\tfoundReceive = true;\n\t\t\t\t\t\tAssert.Equal(amountToSend, output.Value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tAssert.True(foundReceive);\n\n\t\t\t\tawait broadcaster.SendTransactionAsync(res.Transaction);\n\n\t\t\t\t#endregion Basic\n\n\t\t\t\t#region SubtractFeeFromAmount\n\n\t\t\t\treceive = keyManager.GetNextReceiveKey(\"SubtractFeeFromAmount\", out _).P2wpkhScript;\n\t\t\t\tamountToSend = wallet.Coins.Where(x => !x.Unavailable).Sum(x => x.Amount) \/ 3;\n\t\t\t\tres = wallet.BuildTransaction(password, new PaymentIntent(receive, amountToSend, subtractFee: true, label: \"foo\"), FeeStrategy.SevenDaysConfirmationTargetStrategy, allowUnconfirmed: true);\n\n\t\t\t\tAssert.Equal(2, res.InnerWalletOutputs.Count());\n\t\t\t\tAssert.Empty(res.OuterWalletOutputs);\n\t\t\t\tactiveOutput = res.InnerWalletOutputs.Single(x => x.ScriptPubKey == receive);\n\t\t\t\tchangeOutput = res.InnerWalletOutputs.Single(x => x.ScriptPubKey != receive);\n\n\t\t\t\tAssert.Equal(receive, activeOutput.ScriptPubKey);\n\t\t\t\tAssert.Equal(amountToSend - res.Fee, activeOutput.Amount);\n\t\t\t\tAssert.Contains(res.Transaction.Transaction.Outputs, x => x.Value == changeOutput.Amount);\n\t\t\t\tLogger.LogInfo($\"{nameof(res.Fee)}: {res.Fee}\");\n\t\t\t\tLogger.LogInfo($\"{nameof(res.FeePercentOfSent)}: {res.FeePercentOfSent} %\");\n\t\t\t\tLogger.LogInfo($\"{nameof(res.SpendsUnconfirmed)}: {res.SpendsUnconfirmed}\");\n\t\t\t\tLogger.LogInfo($\"Active Output: {activeOutput.Amount.ToString(false, true)} {activeOutput.ScriptPubKey.GetDestinationAddress(network)}\");\n\t\t\t\tLogger.LogInfo($\"Change Output: {changeOutput.Amount.ToString(false, true)} {changeOutput.ScriptPubKey.GetDestinationAddress(network)}\");\n\t\t\t\tLogger.LogInfo($\"TxId: {res.Transaction.GetHash()}\");\n\n\t\t\t\tfoundReceive = false;\n\t\t\t\tAssert.InRange(res.Transaction.Transaction.Outputs.Count, 1, 2);\n\t\t\t\tforeach (var output in res.Transaction.Transaction.Outputs)\n\t\t\t\t{\n\t\t\t\t\tif (output.ScriptPubKey == receive)\n\t\t\t\t\t{\n\t\t\t\t\t\tfoundReceive = true;\n\t\t\t\t\t\tAssert.Equal(amountToSend - res.Fee, output.Value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tAssert.True(foundReceive);\n\n\t\t\t\t#endregion SubtractFeeFromAmount\n\n\t\t\t\t#region LowFee\n\n\t\t\t\tres = wallet.BuildTransaction(password, new PaymentIntent(receive, amountToSend, label: \"foo\"), FeeStrategy.SevenDaysConfirmationTargetStrategy, allowUnconfirmed: true);\n\n\t\t\t\tAssert.Equal(2, res.InnerWalletOutputs.Count());\n\t\t\t\tAssert.Empty(res.OuterWalletOutputs);\n\t\t\t\tactiveOutput = res.InnerWalletOutputs.Single(x => x.ScriptPubKey == receive);\n\t\t\t\tchangeOutput = res.InnerWalletOutputs.Single(x => x.ScriptPubKey != receive);\n\n\t\t\t\tAssert.Equal(receive, activeOutput.ScriptPubKey);\n\t\t\t\tAssert.Equal(amountToSend, activeOutput.Amount);\n\t\t\t\tAssert.Contains(res.Transaction.Transaction.Outputs, x => x.Value == changeOutput.Amount);\n\t\t\t\tLogger.LogInfo($\"{nameof(res.Fee)}: {res.Fee}\");\n\t\t\t\tLogger.LogInfo($\"{nameof(res.FeePercentOfSent)}: {res.FeePercentOfSent} %\");\n\t\t\t\tLogger.LogInfo($\"{nameof(res.SpendsUnconfirmed)}: {res.SpendsUnconfirmed}\");\n\t\t\t\tLogger.LogInfo($\"Active Output: {activeOutput.Amount.ToString(false, true)} {activeOutput.ScriptPubKey.GetDestinationAddress(network)}\");\n\t\t\t\tLogger.LogInfo($\"Change Output: {changeOutput.Amount.ToString(false, true)} {changeOutput.ScriptPubKey.GetDestinationAddress(network)}\");\n\t\t\t\tLogger.LogInfo($\"TxId: {res.Transaction.GetHash()}\");\n\n\t\t\t\tfoundReceive = false;\n\t\t\t\tAssert.InRange(res.Transaction.Transaction.Outputs.Count, 1, 2);\n\t\t\t\tforeach (var output in res.Transaction.Transaction.Outputs)\n\t\t\t\t{\n\t\t\t\t\tif (output.ScriptPubKey == receive)\n\t\t\t\t\t{\n\t\t\t\t\t\tfoundReceive = true;\n\t\t\t\t\t\tAssert.Equal(amountToSend, output.Value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tAssert.True(foundReceive);\n\n\t\t\t\t#endregion LowFee\n\n\t\t\t\t#region MediumFee\n\n\t\t\t\tres = wallet.BuildTransaction(password, new PaymentIntent(receive, amountToSend, label: \"foo\"), FeeStrategy.OneDayConfirmationTargetStrategy, allowUnconfirmed: true);\n\n\t\t\t\tAssert.Equal(2, res.InnerWalletOutputs.Count());\n\t\t\t\tAssert.Empty(res.OuterWalletOutputs);\n\t\t\t\tactiveOutput = res.InnerWalletOutputs.Single(x => x.ScriptPubKey == receive);\n\t\t\t\tchangeOutput = res.InnerWalletOutputs.Single(x => x.ScriptPubKey != receive);\n\n\t\t\t\tAssert.Equal(receive, activeOutput.ScriptPubKey);\n\t\t\t\tAssert.Equal(amountToSend, activeOutput.Amount);\n\t\t\t\tAssert.Contains(res.Transaction.Transaction.Outputs, x => x.Value == changeOutput.Amount);\n\t\t\t\tLogger.LogInfo($\"{nameof(res.Fee)}: {res.Fee}\");\n\t\t\t\tLogger.LogInfo($\"{nameof(res.FeePercentOfSent)}: {res.FeePercentOfSent} %\");\n\t\t\t\tLogger.LogInfo($\"{nameof(res.SpendsUnconfirmed)}: {res.SpendsUnconfirmed}\");\n\t\t\t\tLogger.LogInfo($\"Active Output: {activeOutput.Amount.ToString(false, true)} {activeOutput.ScriptPubKey.GetDestinationAddress(network)}\");\n\t\t\t\tLogger.LogInfo($\"Change Output: {changeOutput.Amount.ToString(false, true)} {changeOutput.ScriptPubKey.GetDestinationAddress(network)}\");\n\t\t\t\tLogger.LogInfo($\"TxId: {res.Transaction.GetHash()}\");\n\n\t\t\t\tfoundReceive = false;\n\t\t\t\tAssert.InRange(res.Transaction.Transaction.Outputs.Count, 1, 2);\n\t\t\t\tforeach (var output in res.Transaction.Transaction.Outputs)\n\t\t\t\t{\n\t\t\t\t\tif (output.ScriptPubKey == receive)\n\t\t\t\t\t{\n\t\t\t\t\t\tfoundReceive = true;\n\t\t\t\t\t\tAssert.Equal(amountToSend, output.Value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tAssert.True(foundReceive);\n\n\t\t\t\t#endregion MediumFee\n\n\t\t\t\t#region HighFee\n\n\t\t\t\tres = wallet.BuildTransaction(password, new PaymentIntent(receive, amountToSend, label: \"foo\"), FeeStrategy.TwentyMinutesConfirmationTargetStrategy, allowUnconfirmed: true);\n\n\t\t\t\tAssert.Equal(2, res.InnerWalletOutputs.Count());\n\t\t\t\tAssert.Empty(res.OuterWalletOutputs);\n\t\t\t\tactiveOutput = res.InnerWalletOutputs.Single(x => x.ScriptPubKey == receive);\n\t\t\t\tchangeOutput = res.InnerWalletOutputs.Single(x => x.ScriptPubKey != receive);\n\n\t\t\t\tAssert.Equal(receive, activeOutput.ScriptPubKey);\n\t\t\t\tAssert.Equal(amountToSend, activeOutput.Amount);\n\t\t\t\tAssert.Contains(res.Transaction.Transaction.Outputs, x => x.Value == changeOutput.Amount);\n\t\t\t\tLogger.LogInfo($\"{nameof(res.Fee)}: {res.Fee}\");\n\t\t\t\tLogger.LogInfo($\"{nameof(res.FeePercentOfSent)}: {res.FeePercentOfSent} %\");\n\t\t\t\tLogger.LogInfo($\"{nameof(res.SpendsUnconfirmed)}: {res.SpendsUnconfirmed}\");\n\t\t\t\tLogger.LogInfo($\"Active Output: {activeOutput.Amount.ToString(false, true)} {activeOutput.ScriptPubKey.GetDestinationAddress(network)}\");\n\t\t\t\tLogger.LogInfo($\"Change Output: {changeOutput.Amount.ToString(false, true)} {changeOutput.ScriptPubKey.GetDestinationAddress(network)}\");\n\t\t\t\tLogger.LogInfo($\"TxId: {res.Transaction.GetHash()}\");\n\n\t\t\t\tfoundReceive = false;\n\t\t\t\tAssert.InRange(res.Transaction.Transaction.Outputs.Count, 1, 2);\n\t\t\t\tforeach (var output in res.Transaction.Transaction.Outputs)\n\t\t\t\t{\n\t\t\t\t\tif (output.ScriptPubKey == receive)\n\t\t\t\t\t{\n\t\t\t\t\t\tfoundReceive = true;\n\t\t\t\t\t\tAssert.Equal(amountToSend, output.Value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tAssert.True(foundReceive);\n\n\t\t\t\tAssert.InRange(res.Fee, Money.Zero, res.Fee);\n\t\t\t\tAssert.InRange(res.Fee, res.Fee, res.Fee);\n\n\t\t\t\tawait broadcaster.SendTransactionAsync(res.Transaction);\n\n\t\t\t\t#endregion HighFee\n\n\t\t\t\t#region MaxAmount\n\n\t\t\t\treceive = keyManager.GetNextReceiveKey(\"MaxAmount\", out _).P2wpkhScript;\n\n\t\t\t\tres = wallet.BuildTransaction(password, new PaymentIntent(receive, MoneyRequest.CreateAllRemaining(), \"foo\"), FeeStrategy.SevenDaysConfirmationTargetStrategy, allowUnconfirmed: true);\n\n\t\t\t\tAssert.Single(res.InnerWalletOutputs);\n\t\t\t\tAssert.Empty(res.OuterWalletOutputs);\n\t\t\t\tactiveOutput = res.InnerWalletOutputs.Single();\n\n\t\t\t\tAssert.Equal(receive, activeOutput.ScriptPubKey);\n\n\t\t\t\tAssert.Single(res.Transaction.Transaction.Outputs);\n\t\t\t\tvar maxBuiltTxOutput = res.Transaction.Transaction.Outputs.Single();\n\t\t\t\tAssert.Equal(receive, maxBuiltTxOutput.ScriptPubKey);\n\t\t\t\tAssert.Equal(wallet.Coins.Where(x => !x.Unavailable).Sum(x => x.Amount) - res.Fee, maxBuiltTxOutput.Value);\n\n\t\t\t\tawait broadcaster.SendTransactionAsync(res.Transaction);\n\n\t\t\t\t#endregion MaxAmount\n\n\t\t\t\t#region InputSelection\n\n\t\t\t\treceive = keyManager.GetNextReceiveKey(\"InputSelection\", out _).P2wpkhScript;\n\n\t\t\t\tvar inputCountBefore = res.SpentCoins.Count();\n\n\t\t\t\tres = wallet.BuildTransaction(password, new PaymentIntent(receive, MoneyRequest.CreateAllRemaining(), \"foo\"), FeeStrategy.SevenDaysConfirmationTargetStrategy,\n\t\t\t\t\tallowUnconfirmed: true,\n\t\t\t\t\tallowedInputs: wallet.Coins.Where(x => !x.Unavailable).Select(x => new TxoRef(x.TransactionId, x.Index)).Take(1));\n\n\t\t\t\tAssert.Single(res.InnerWalletOutputs);\n\t\t\t\tAssert.Empty(res.OuterWalletOutputs);\n\t\t\t\tactiveOutput = res.InnerWalletOutputs.Single(x => x.ScriptPubKey == receive);\n\n\t\t\t\tAssert.True(inputCountBefore >= res.SpentCoins.Count());\n\t\t\t\tAssert.Equal(res.SpentCoins.Count(), res.Transaction.Transaction.Inputs.Count);\n\n\t\t\t\tAssert.Equal(receive, activeOutput.ScriptPubKey);\n\t\t\t\tLogger.LogInfo($\"{nameof(res.Fee)}: {res.Fee}\");\n\t\t\t\tLogger.LogInfo($\"{nameof(res.FeePercentOfSent)}: {res.FeePercentOfSent} %\");\n\t\t\t\tLogger.LogInfo($\"{nameof(res.SpendsUnconfirmed)}: {res.SpendsUnconfirmed}\");\n\t\t\t\tLogger.LogInfo($\"Active Output: {activeOutput.Amount.ToString(false, true)} {activeOutput.ScriptPubKey.GetDestinationAddress(network)}\");\n\t\t\t\tLogger.LogInfo($\"TxId: {res.Transaction.GetHash()}\");\n\n\t\t\t\tAssert.Single(res.Transaction.Transaction.Outputs);\n\n\t\t\t\tres = wallet.BuildTransaction(password, new PaymentIntent(receive, MoneyRequest.CreateAllRemaining(), \"foo\"), FeeStrategy.SevenDaysConfirmationTargetStrategy,\n\t\t\t\t\tallowUnconfirmed: true,\n\t\t\t\t\tallowedInputs: new[] { res.SpentCoins.Select(x => new TxoRef(x.TransactionId, x.Index)).First() });\n\n\t\t\t\tAssert.Single(res.InnerWalletOutputs);\n\t\t\t\tAssert.Empty(res.OuterWalletOutputs);\n\t\t\t\tactiveOutput = res.InnerWalletOutputs.Single(x => x.ScriptPubKey == receive);\n\n\t\t\t\tAssert.Single(res.Transaction.Transaction.Inputs);\n\t\t\t\tAssert.Single(res.Transaction.Transaction.Outputs);\n\t\t\t\tAssert.Single(res.SpentCoins);\n\n\t\t\t\t#endregion InputSelection\n\n\t\t\t\t#region Labeling\n\n\t\t\t\tScript receive2 = keyManager.GetNextReceiveKey(\"foo\", out _).P2wpkhScript;\n\t\t\t\tres = wallet.BuildTransaction(password, new PaymentIntent(receive2, MoneyRequest.CreateAllRemaining(), \"my label\"), FeeStrategy.SevenDaysConfirmationTargetStrategy, allowUnconfirmed: true);\n\n\t\t\t\tAssert.Single(res.InnerWalletOutputs);\n\t\t\t\tAssert.Equal(\"foo, my label\", res.InnerWalletOutputs.Single().Label);\n\n\t\t\t\tamountToSend = wallet.Coins.Where(x => !x.Unavailable).Sum(x => x.Amount) \/ 3;\n\t\t\t\tres = wallet.BuildTransaction(\n\t\t\t\t\tpassword,\n\t\t\t\t\tnew PaymentIntent(\n\t\t\t\t\t\tnew DestinationRequest(new Key(), amountToSend, label: \"outgoing\"),\n\t\t\t\t\t\tnew DestinationRequest(new Key(), amountToSend, label: \"outgoing2\")),\n\t\t\t\t\tFeeStrategy.SevenDaysConfirmationTargetStrategy,\n\t\t\t\t\tallowUnconfirmed: true);\n\n\t\t\t\tAssert.Single(res.InnerWalletOutputs);\n\t\t\t\tAssert.Equal(2, res.OuterWalletOutputs.Count());\n\t\t\t\tIEnumerable<string> change = res.InnerWalletOutputs.Single().Label.Labels;\n\t\t\t\tAssert.Contains(\"outgoing\", change);\n\t\t\t\tAssert.Contains(\"outgoing2\", change);\n\n\t\t\t\tawait broadcaster.SendTransactionAsync(res.Transaction);\n\n\t\t\t\tIEnumerable<SmartCoin> unconfirmedCoins = wallet.Coins.Where(x => x.Height == Height.Mempool).ToArray();\n\t\t\t\tIEnumerable<string> unconfirmedCoinLabels = unconfirmedCoins.SelectMany(x => x.Label.Labels).ToArray();\n\t\t\t\tAssert.Contains(\"outgoing\", unconfirmedCoinLabels);\n\t\t\t\tAssert.Contains(\"outgoing2\", unconfirmedCoinLabels);\n\t\t\t\tIEnumerable<string> allKeyLabels = keyManager.GetKeys().SelectMany(x => x.Label.Labels);\n\t\t\t\tAssert.Contains(\"outgoing\", allKeyLabels);\n\t\t\t\tAssert.Contains(\"outgoing2\", allKeyLabels);\n\n\t\t\t\tInterlocked.Exchange(ref _filtersProcessedByWalletCount, 0);\n\t\t\t\tawait rpc.GenerateAsync(1);\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), 1);\n\n\t\t\t\tvar bestHeight = new Height(bitcoinStore.SmartHeaderChain.TipHeight);\n\t\t\t\tIEnumerable<string> confirmedCoinLabels = wallet.Coins.Where(x => x.Height == bestHeight).SelectMany(x => x.Label.Labels);\n\t\t\t\tAssert.Contains(\"outgoing\", confirmedCoinLabels);\n\t\t\t\tAssert.Contains(\"outgoing2\", confirmedCoinLabels);\n\t\t\t\tallKeyLabels = keyManager.GetKeys().SelectMany(x => x.Label.Labels);\n\t\t\t\tAssert.Contains(\"outgoing\", allKeyLabels);\n\t\t\t\tAssert.Contains(\"outgoing2\", allKeyLabels);\n\n\t\t\t\t#endregion Labeling\n\n\t\t\t\t#region AllowedInputsDisallowUnconfirmed\n\n\t\t\t\tinputCountBefore = res.SpentCoins.Count();\n\n\t\t\t\treceive = keyManager.GetNextReceiveKey(\"AllowedInputsDisallowUnconfirmed\", out _).P2wpkhScript;\n\n\t\t\t\tvar allowedInputs = wallet.Coins.Where(x => !x.Unavailable).Select(x => new TxoRef(x.TransactionId, x.Index)).Take(1);\n\t\t\t\tvar toSend = new PaymentIntent(receive, MoneyRequest.CreateAllRemaining(), \"fizz\");\n\n\t\t\t\t\/\/ covers:\n\t\t\t\t\/\/ disallow unconfirmed with allowed inputs\n\t\t\t\tres = wallet.BuildTransaction(password, toSend, FeeStrategy.TwentyMinutesConfirmationTargetStrategy, false, allowedInputs: allowedInputs);\n\n\t\t\t\tactiveOutput = res.InnerWalletOutputs.Single(x => x.ScriptPubKey == receive);\n\t\t\t\tAssert.Single(res.InnerWalletOutputs);\n\t\t\t\tAssert.Empty(res.OuterWalletOutputs);\n\n\t\t\t\tAssert.Equal(receive, activeOutput.ScriptPubKey);\n\t\t\t\tLogger.LogDebug($\"{nameof(res.Fee)}: {res.Fee}\");\n\t\t\t\tLogger.LogDebug($\"{nameof(res.FeePercentOfSent)}: {res.FeePercentOfSent} %\");\n\t\t\t\tLogger.LogDebug($\"{nameof(res.SpendsUnconfirmed)}: {res.SpendsUnconfirmed}\");\n\t\t\t\tLogger.LogDebug($\"Active Output: {activeOutput.Amount.ToString(false, true)} {activeOutput.ScriptPubKey.GetDestinationAddress(network)}\");\n\t\t\t\tLogger.LogDebug($\"TxId: {res.Transaction.GetHash()}\");\n\n\t\t\t\tAssert.True(inputCountBefore >= res.SpentCoins.Count());\n\t\t\t\tAssert.False(res.SpendsUnconfirmed);\n\n\t\t\t\tAssert.Single(res.Transaction.Transaction.Inputs);\n\t\t\t\tAssert.Single(res.Transaction.Transaction.Outputs);\n\t\t\t\tAssert.Single(res.SpentCoins);\n\n\t\t\t\tAssert.True(inputCountBefore >= res.SpentCoins.Count());\n\t\t\t\tAssert.Equal(res.SpentCoins.Count(), res.Transaction.Transaction.Inputs.Count);\n\n\t\t\t\t#endregion AllowedInputsDisallowUnconfirmed\n\n\t\t\t\t#region CustomChange\n\n\t\t\t\t\/\/ covers:\n\t\t\t\t\/\/ customchange\n\t\t\t\t\/\/ feePc > 1\n\t\t\t\tvar k1 = new Key();\n\t\t\t\tvar k2 = new Key();\n\t\t\t\tres = wallet.BuildTransaction(\n\t\t\t\t\tpassword,\n\t\t\t\t\tnew PaymentIntent(\n\t\t\t\t\t\tnew DestinationRequest(k1, MoneyRequest.CreateChange()),\n\t\t\t\t\t\tnew DestinationRequest(k2, Money.Coins(0.0003m), label: \"outgoing\")),\n\t\t\t\t\tFeeStrategy.TwentyMinutesConfirmationTargetStrategy);\n\n\t\t\t\tAssert.Contains(k1.ScriptPubKey, res.OuterWalletOutputs.Select(x => x.ScriptPubKey));\n\t\t\t\tAssert.Contains(k2.ScriptPubKey, res.OuterWalletOutputs.Select(x => x.ScriptPubKey));\n\n\t\t\t\t#endregion CustomChange\n\n\t\t\t\t#region FeePcHigh\n\n\t\t\t\tres = wallet.BuildTransaction(\n\t\t\t\t\tpassword,\n\t\t\t\t\tnew PaymentIntent(new Key(), Money.Coins(0.0003m), label: \"outgoing\"),\n\t\t\t\t\tFeeStrategy.TwentyMinutesConfirmationTargetStrategy);\n\n\t\t\t\tAssert.True(res.FeePercentOfSent > 1);\n\n\t\t\t\tvar newChangeK = keyManager.GenerateNewKey(\"foo\", KeyState.Clean, isInternal: true);\n\t\t\t\tres = wallet.BuildTransaction(\n\t\t\t\t\tpassword,\n\t\t\t\t\tnew PaymentIntent(\n\t\t\t\t\t\tnew DestinationRequest(newChangeK.P2wpkhScript, MoneyRequest.CreateChange(), \"boo\"),\n\t\t\t\t\t\tnew DestinationRequest(new Key(), Money.Coins(0.0003m), label: \"outgoing\")),\n\t\t\t\t\tFeeStrategy.TwentyMinutesConfirmationTargetStrategy);\n\n\t\t\t\tAssert.True(res.FeePercentOfSent > 1);\n\t\t\t\tAssert.Single(res.OuterWalletOutputs);\n\t\t\t\tAssert.Single(res.InnerWalletOutputs);\n\t\t\t\tSmartCoin changeRes = res.InnerWalletOutputs.Single();\n\t\t\t\tAssert.Equal(newChangeK.P2wpkhScript, changeRes.ScriptPubKey);\n\t\t\t\tAssert.Equal(newChangeK.Label, changeRes.Label);\n\t\t\t\tAssert.Equal(KeyState.Clean, newChangeK.KeyState); \/\/ Still clean, because the tx wasn't yet propagated.\n\n\t\t\t\t#endregion FeePcHigh\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\twallet.NewFilterProcessed -= Wallet_NewFilterProcessed;\n\t\t\t\twallet?.Dispose();\n\t\t\t\t\/\/ Dispose wasabi synchronizer service.\n\t\t\t\tawait synchronizer?.StopAsync();\n\t\t\t\t\/\/ Dispose connection service.\n\t\t\t\tnodes?.Dispose();\n\t\t\t\t\/\/ Dispose mempool serving node.\n\t\t\t\tnode?.Disconnect();\n\t\t\t\t\/\/ Dispose chaumian coinjoin client.\n\t\t\t\tif (chaumianClient != null)\n\t\t\t\t{\n\t\t\t\t\tawait chaumianClient.StopAsync();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task BuildTransactionValidationsTestAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\t\/\/ Create the services.\n\t\t\t\/\/ 1. Create connection service.\n\t\t\tvar nodes = new NodesGroup(global.Config.Network, requirements: Constants.NodeRequirements);\n\t\t\tnodes.ConnectedNodes.Add(await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync());\n\n\t\t\t\/\/ 2. Create mempool service.\n\n\t\t\tNode node = await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync();\n\t\t\tnode.Behaviors.Add(bitcoinStore.CreateUntrustedP2pBehavior());\n\n\t\t\t\/\/ 3. Create wasabi synchronizer service.\n\t\t\tvar synchronizer = new WasabiSynchronizer(rpc.Network, bitcoinStore, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\t\/\/ 4. Create key manager service.\n\t\t\tvar keyManager = KeyManager.CreateNew(out _, password);\n\n\t\t\t\/\/ 5. Create chaumian coinjoin client.\n\t\t\tvar chaumianClient = new CoinJoinClient(synchronizer, rpc.Network, keyManager, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\t\/\/ 6. Create wallet service.\n\t\t\tvar workDir = GetWorkDir();\n\t\t\tvar wallet = new WalletService(bitcoinStore, keyManager, synchronizer, chaumianClient, nodes, workDir, serviceConfiguration, synchronizer);\n\t\t\twallet.NewFilterProcessed += Wallet_NewFilterProcessed;\n\n\t\t\tvar scp = new Key().ScriptPubKey;\n\n\t\t\tvar validIntent = new PaymentIntent(scp, Money.Coins(1));\n\t\t\tvar invalidIntent = new PaymentIntent(\n\t\t\t\tnew DestinationRequest(scp, Money.Coins(10 * 1000 * 1000)),\n\t\t\t\tnew DestinationRequest(scp, Money.Coins(12 * 1000 * 1000)));\n\n\t\t\tAssert.Throws<OverflowException>(() => new PaymentIntent(\n\t\t\t\tnew DestinationRequest(scp, Money.Satoshis(long.MaxValue)),\n\t\t\t\tnew DestinationRequest(scp, Money.Satoshis(long.MaxValue)),\n\t\t\t\tnew DestinationRequest(scp, Money.Satoshis(5))));\n\n\t\t\tLogger.TurnOff();\n\t\t\tAssert.Throws<ArgumentNullException>(() => wallet.BuildTransaction(null, null, FeeStrategy.CreateFromConfirmationTarget(4)));\n\n\t\t\t\/\/ toSend cannot have a null element\n\t\t\tAssert.Throws<ArgumentNullException>(() => wallet.BuildTransaction(null, new PaymentIntent(new[] { (DestinationRequest)null }), FeeStrategy.CreateFromConfirmationTarget(0)));\n\n\t\t\t\/\/ toSend cannot have a zero element\n\t\t\tAssert.Throws<ArgumentException>(() => wallet.BuildTransaction(null, new PaymentIntent(Array.Empty<DestinationRequest>()), FeeStrategy.SevenDaysConfirmationTargetStrategy));\n\n\t\t\t\/\/ feeTarget has to be in the range 0 to 1008\n\t\t\tAssert.Throws<ArgumentOutOfRangeException>(() => wallet.BuildTransaction(null, validIntent, FeeStrategy.CreateFromConfirmationTarget(-10)));\n\t\t\tAssert.Throws<ArgumentOutOfRangeException>(() => wallet.BuildTransaction(null, validIntent, FeeStrategy.CreateFromConfirmationTarget(2000)));\n\n\t\t\t\/\/ toSend amount sum has to be in range 0 to 2099999997690000\n\t\t\tAssert.Throws<ArgumentOutOfRangeException>(() => wallet.BuildTransaction(null, invalidIntent, FeeStrategy.TwentyMinutesConfirmationTargetStrategy));\n\n\t\t\t\/\/ toSend negative sum amount\n\t\t\tAssert.Throws<ArgumentOutOfRangeException>(() => wallet.BuildTransaction(null, new PaymentIntent(scp, Money.Satoshis(-10000)), FeeStrategy.TwentyMinutesConfirmationTargetStrategy));\n\n\t\t\t\/\/ toSend negative operation amount\n\t\t\tAssert.Throws<ArgumentOutOfRangeException>(() => wallet.BuildTransaction(\n\t\t\t\tnull,\n\t\t\t\tnew PaymentIntent(\n\t\t\t\t\tnew DestinationRequest(scp, Money.Satoshis(20000)),\n\t\t\t\t\tnew DestinationRequest(scp, Money.Satoshis(-10000))),\n\t\t\t\tFeeStrategy.TwentyMinutesConfirmationTargetStrategy));\n\n\t\t\t\/\/ allowedInputs cannot be empty\n\t\t\tAssert.Throws<ArgumentException>(() => wallet.BuildTransaction(null, validIntent, FeeStrategy.TwentyMinutesConfirmationTargetStrategy, allowedInputs: Array.Empty<TxoRef>()));\n\n\t\t\t\/\/ \"Only one element can contain the AllRemaining flag.\n\t\t\tAssert.Throws<ArgumentException>(() => wallet.BuildTransaction(\n\t\t\t\tpassword,\n\t\t\t\tnew PaymentIntent(\n\t\t\t\t\tnew DestinationRequest(scp, MoneyRequest.CreateAllRemaining(), \"zero\"),\n\t\t\t\t\tnew DestinationRequest(scp, MoneyRequest.CreateAllRemaining(), \"zero\")),\n\t\t\t\tFeeStrategy.SevenDaysConfirmationTargetStrategy,\n\t\t\t\tfalse));\n\n\t\t\t\/\/ Get some money, make it confirm.\n\t\t\tvar key = keyManager.GetNextReceiveKey(\"foo label\", out _);\n\t\t\tvar txId = await rpc.SendToAddressAsync(key.GetP2wpkhAddress(network), Money.Coins(1m));\n\n\t\t\t\/\/ Generate some coins\n\t\t\tawait rpc.GenerateAsync(2);\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tnodes.Connect(); \/\/ Start connection service.\n\t\t\t\tnode.VersionHandshake(); \/\/ Start mempool service.\n\t\t\t\tsynchronizer.Start(requestInterval: TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(5), 10000); \/\/ Start wasabi synchronizer service.\n\t\t\t\tchaumianClient.Start(); \/\/ Start chaumian coinjoin client.\n\n\t\t\t\t\/\/ Wait until the filter our previous transaction is present.\n\t\t\t\tvar blockCount = await rpc.GetBlockCountAsync();\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), blockCount);\n\n\t\t\t\tusing (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30)))\n\t\t\t\t{\n\t\t\t\t\tawait wallet.InitializeAsync(cts.Token); \/\/ Initialize wallet service.\n\t\t\t\t}\n\n\t\t\t\t\/\/ subtract Fee from amount index with no enough money\n\t\t\t\tvar operations = new PaymentIntent(\n\t\t\t\t\tnew DestinationRequest(scp, Money.Coins(1m), subtractFee: true),\n\t\t\t\t\tnew DestinationRequest(scp, Money.Coins(0.5m)));\n\t\t\t\tAssert.Throws<InsufficientBalanceException>(() => wallet.BuildTransaction(password, operations, FeeStrategy.TwentyMinutesConfirmationTargetStrategy, false));\n\n\t\t\t\t\/\/ No enough money (only one confirmed coin, no unconfirmed allowed)\n\t\t\t\toperations = new PaymentIntent(scp, Money.Coins(1.5m));\n\t\t\t\tAssert.Throws<InsufficientBalanceException>(() => wallet.BuildTransaction(null, operations, FeeStrategy.TwentyMinutesConfirmationTargetStrategy));\n\n\t\t\t\t\/\/ No enough money (only one confirmed coin, unconfirmed allowed)\n\t\t\t\tAssert.Throws<InsufficientBalanceException>(() => wallet.BuildTransaction(null, operations, FeeStrategy.TwentyMinutesConfirmationTargetStrategy, true));\n\n\t\t\t\t\/\/ Add new money with no confirmation\n\t\t\t\tvar txId2 = await rpc.SendToAddressAsync(key.GetP2wpkhAddress(network), Money.Coins(2m));\n\t\t\t\tawait Task.Delay(1000); \/\/ Wait tx to arrive and get processed.\n\n\t\t\t\t\/\/ Enough money (one confirmed coin and one unconfirmed coin, unconfirmed are NOT allowed)\n\t\t\t\tAssert.Throws<InsufficientBalanceException>(() => wallet.BuildTransaction(null, operations, FeeStrategy.TwentyMinutesConfirmationTargetStrategy, false));\n\n\t\t\t\t\/\/ Enough money (one unconfirmed coin, unconfirmed are allowed)\n\t\t\t\tvar btx = wallet.BuildTransaction(password, operations, FeeStrategy.TwentyMinutesConfirmationTargetStrategy, true);\n\t\t\t\tvar spentCoin = Assert.Single(btx.SpentCoins);\n\t\t\t\tAssert.False(spentCoin.Confirmed);\n\n\t\t\t\t\/\/ Enough money (one confirmed coin and one unconfirmed coin, unconfirmed are allowed)\n\t\t\t\toperations = new PaymentIntent(scp, Money.Coins(2.5m));\n\t\t\t\tbtx = wallet.BuildTransaction(password, operations, FeeStrategy.TwentyMinutesConfirmationTargetStrategy, true);\n\t\t\t\tAssert.Equal(2, btx.SpentCoins.Count());\n\t\t\t\tAssert.Equal(1, btx.SpentCoins.Count(c => c.Confirmed));\n\t\t\t\tAssert.Equal(1, btx.SpentCoins.Count(c => !c.Confirmed));\n\n\t\t\t\t\/\/ Only one operation with AllRemainingFlag\n\n\t\t\t\tAssert.Throws<ArgumentException>(() => wallet.BuildTransaction(\n\t\t\t\t\tnull,\n\t\t\t\t\tnew PaymentIntent(\n\t\t\t\t\t\tnew DestinationRequest(scp, MoneyRequest.CreateAllRemaining()),\n\t\t\t\t\t\tnew DestinationRequest(scp, MoneyRequest.CreateAllRemaining())),\n\t\t\t\t\tFeeStrategy.TwentyMinutesConfirmationTargetStrategy));\n\n\t\t\t\tLogger.TurnOn();\n\n\t\t\t\toperations = new PaymentIntent(scp, Money.Coins(0.5m));\n\t\t\t\tbtx = wallet.BuildTransaction(password, operations, FeeStrategy.TwentyMinutesConfirmationTargetStrategy);\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\twallet?.Dispose();\n\t\t\t\t\/\/ Dispose wasabi synchronizer service.\n\t\t\t\tawait synchronizer?.StopAsync();\n\t\t\t\t\/\/ Dispose connection service.\n\t\t\t\tnodes?.Dispose();\n\t\t\t\t\/\/ Dispose mempool serving node.\n\t\t\t\tnode?.Disconnect();\n\t\t\t\t\/\/ Dispose chaumian coinjoin client.\n\t\t\t\tif (chaumianClient != null)\n\t\t\t\t{\n\t\t\t\t\tawait chaumianClient.StopAsync();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task BuildTransactionReorgsTestAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\t\/\/ Create the services.\n\t\t\t\/\/ 1. Create connection service.\n\t\t\tvar nodes = new NodesGroup(global.Config.Network, requirements: Constants.NodeRequirements);\n\t\t\tnodes.ConnectedNodes.Add(await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync());\n\n\t\t\t\/\/ 2. Create mempool service.\n\n\t\t\tNode node = await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync();\n\t\t\tnode.Behaviors.Add(bitcoinStore.CreateUntrustedP2pBehavior());\n\n\t\t\t\/\/ 3. Create wasabi synchronizer service.\n\t\t\tvar synchronizer = new WasabiSynchronizer(rpc.Network, bitcoinStore, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\t\/\/ 4. Create key manager service.\n\t\t\tvar keyManager = KeyManager.CreateNew(out _, password);\n\n\t\t\t\/\/ 5. Create chaumian coinjoin client.\n\t\t\tvar chaumianClient = new CoinJoinClient(synchronizer, rpc.Network, keyManager, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\t\/\/ 6. Create wallet service.\n\t\t\tvar workDir = GetWorkDir();\n\t\t\tvar wallet = new WalletService(bitcoinStore, keyManager, synchronizer, chaumianClient, nodes, workDir, serviceConfiguration, synchronizer);\n\t\t\twallet.NewFilterProcessed += Wallet_NewFilterProcessed;\n\n\t\t\tAssert.Empty(wallet.Coins);\n\t\t\tvar baseTip = await rpc.GetBestBlockHashAsync();\n\n\t\t\t\/\/ Generate script\n\t\t\tvar scp = new Key().ScriptPubKey;\n\n\t\t\t\/\/ Get some money, make it confirm.\n\t\t\tvar key = keyManager.GetNextReceiveKey(\"foo label\", out _);\n\t\t\tvar fundingTxId = await rpc.SendToAddressAsync(key.GetP2wpkhAddress(network), Money.Coins(0.1m));\n\n\t\t\t\/\/ Generate some coins\n\t\t\tawait rpc.GenerateAsync(2);\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tnodes.Connect(); \/\/ Start connection service.\n\t\t\t\tnode.VersionHandshake(); \/\/ Start mempool service.\n\t\t\t\tsynchronizer.Start(requestInterval: TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(5), 10000); \/\/ Start wasabi synchronizer service.\n\t\t\t\tchaumianClient.Start(); \/\/ Start chaumian coinjoin client.\n\n\t\t\t\t\/\/ Wait until the filter our previous transaction is present.\n\t\t\t\tvar blockCount = await rpc.GetBlockCountAsync();\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), blockCount);\n\n\t\t\t\tusing (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30)))\n\t\t\t\t{\n\t\t\t\t\tawait wallet.InitializeAsync(cts.Token); \/\/ Initialize wallet service.\n\t\t\t\t}\n\t\t\t\tvar coin = Assert.Single(wallet.Coins);\n\t\t\t\tAssert.True(coin.Confirmed);\n\t\t\t\tvar broadcaster = new TransactionBroadcaster(network, bitcoinStore, synchronizer, nodes, rpc);\n\t\t\t\tbroadcaster.AddWalletService(wallet);\n\n\t\t\t\t\/\/ Send money before reorg.\n\t\t\t\tvar operations = new PaymentIntent(scp, Money.Coins(0.011m));\n\t\t\t\tvar btx1 = wallet.BuildTransaction(password, operations, FeeStrategy.TwentyMinutesConfirmationTargetStrategy);\n\t\t\t\tawait broadcaster.SendTransactionAsync(btx1.Transaction);\n\t\t\t\tvar coin2 = Assert.Single(wallet.Coins);\n\t\t\t\tAssert.NotEqual(coin, coin2);\n\t\t\t\tAssert.False(coin2.Confirmed);\n\n\t\t\t\toperations = new PaymentIntent(scp, Money.Coins(0.012m));\n\t\t\t\tvar btx2 = wallet.BuildTransaction(password, operations, FeeStrategy.TwentyMinutesConfirmationTargetStrategy, allowUnconfirmed: true);\n\t\t\t\tawait broadcaster.SendTransactionAsync(btx2.Transaction);\n\t\t\t\tvar coin3 = Assert.Single(wallet.Coins);\n\t\t\t\tAssert.NotEqual(coin2, coin3);\n\t\t\t\tAssert.False(coin3.Confirmed);\n\n\t\t\t\t\/\/ Test synchronization after fork.\n\t\t\t\t\/\/ Invalidate the blocks containing the funding transaction\n\t\t\t\tvar tip = await rpc.GetBestBlockHashAsync();\n\t\t\t\tawait rpc.InvalidateBlockAsync(tip); \/\/ Reorg 1\n\t\t\t\ttip = await rpc.GetBestBlockHashAsync();\n\t\t\t\tawait rpc.InvalidateBlockAsync(tip); \/\/ Reorg 2\n\n\t\t\t\t\/\/ Generate three new blocks (replace the previous invalidated ones)\n\t\t\t\tInterlocked.Exchange(ref _filtersProcessedByWalletCount, 0);\n\t\t\t\tawait rpc.GenerateAsync(3);\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), 3);\n\n\t\t\t\tvar coin4 = Assert.Single(wallet.Coins);\n\t\t\t\tAssert.Equal(coin3, coin4);\n\t\t\t\tAssert.True(coin.Confirmed);\n\t\t\t\tAssert.True(coin2.Confirmed);\n\t\t\t\tAssert.True(coin3.Confirmed);\n\t\t\t\tAssert.True(coin4.Confirmed);\n\n\t\t\t\t\/\/ Send money after reorg.\n\t\t\t\t\/\/ When we invalidate a block, the transactions set in the invalidated block\n\t\t\t\t\/\/ are reintroduced when we generate a new block through the rpc call\n\t\t\t\toperations = new PaymentIntent(scp, Money.Coins(0.013m));\n\t\t\t\tvar btx3 = wallet.BuildTransaction(password, operations, FeeStrategy.TwentyMinutesConfirmationTargetStrategy);\n\t\t\t\tawait broadcaster.SendTransactionAsync(btx3.Transaction);\n\t\t\t\tvar coin5 = Assert.Single(wallet.Coins);\n\t\t\t\tAssert.NotEqual(coin4, coin5);\n\t\t\t\tAssert.False(coin5.Confirmed);\n\n\t\t\t\toperations = new PaymentIntent(scp, Money.Coins(0.014m));\n\t\t\t\tvar btx4 = wallet.BuildTransaction(password, operations, FeeStrategy.TwentyMinutesConfirmationTargetStrategy, allowUnconfirmed: true);\n\t\t\t\tawait broadcaster.SendTransactionAsync(btx4.Transaction);\n\t\t\t\tvar coin6 = Assert.Single(wallet.Coins);\n\t\t\t\tAssert.NotEqual(coin5, coin6);\n\t\t\t\tAssert.False(coin6.Confirmed);\n\n\t\t\t\t\/\/ Test synchronization after fork with different transactions.\n\t\t\t\t\/\/ Create a fork that invalidates the blocks containing the funding transaction\n\t\t\t\tInterlocked.Exchange(ref _filtersProcessedByWalletCount, 0);\n\t\t\t\tawait rpc.InvalidateBlockAsync(baseTip);\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tawait rpc.AbandonTransactionAsync(fundingTxId);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\tif (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t\treturn; \/\/ Occassionally this fails on Linux or OSX, I have no idea why.\n\t\t\t\t}\n\t\t\t\t\/\/ Spend the inputs of the tx so we know\n\t\t\t\tvar success = bitcoinStore.TransactionStore.TryGetTransaction(fundingTxId, out SmartTransaction invalidSmartTransaction);\n\t\t\t\tAssert.True(success);\n\t\t\t\tvar invalidCoin = Assert.Single(((CoinsRegistry)wallet.Coins).AsAllCoinsView().CreatedBy(invalidSmartTransaction.GetHash()));\n\t\t\t\tAssert.True(invalidCoin.SpenderTransactionId != null);\n\t\t\t\tAssert.True(invalidCoin.Confirmed);\n\n\t\t\t\tvar overwriteTx = Transaction.Create(network);\n\t\t\t\toverwriteTx.Inputs.AddRange(invalidSmartTransaction.Transaction.Inputs);\n\t\t\t\tvar walletAddress = keyManager.GetNextReceiveKey(\"foo\", out _).GetP2wpkhAddress(network);\n\t\t\t\tbool onAddress = false;\n\t\t\t\tforeach (var invalidOutput in invalidSmartTransaction.Transaction.Outputs)\n\t\t\t\t{\n\t\t\t\t\tif (onAddress)\n\t\t\t\t\t{\n\t\t\t\t\t\toverwriteTx.Outputs.Add(new TxOut(invalidOutput.Value, new Key().PubKey.GetAddress(ScriptPubKeyType.Segwit, network)));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\toverwriteTx.Outputs.Add(new TxOut(invalidOutput.Value, walletAddress));\n\t\t\t\t\t\tonAddress = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar srtxwwreq = new SignRawTransactionRequest();\n\t\t\t\tsrtxwwreq.Transaction = overwriteTx;\n\t\t\t\tvar srtxwwres = await rpc.SignRawTransactionWithWalletAsync(srtxwwreq);\n\n\t\t\t\tvar eventAwaiter = new EventAwaiter<ProcessedResult>(\n\t\t\t\t\th => wallet.TransactionProcessor.WalletRelevantTransactionProcessed += h,\n\t\t\t\t\th => wallet.TransactionProcessor.WalletRelevantTransactionProcessed -= h);\n\t\t\t\tawait rpc.SendRawTransactionAsync(srtxwwres.SignedTransaction);\n\t\t\t\tawait rpc.GenerateAsync(10);\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), 10);\n\t\t\t\tvar eventArgs = await eventAwaiter.WaitAsync(TimeSpan.FromSeconds(21));\n\t\t\t\tvar doubleSpend = Assert.Single(eventArgs.SuccessfullyDoubleSpentCoins);\n\t\t\t\tAssert.Equal(invalidCoin.TransactionId, doubleSpend.TransactionId);\n\n\t\t\t\tvar curBlockHash = await rpc.GetBestBlockHashAsync();\n\t\t\t\tblockCount = await rpc.GetBlockCountAsync();\n\t\t\t\tAssert.Equal(bitcoinStore.SmartHeaderChain.TipHash, curBlockHash);\n\t\t\t\tAssert.Equal((int)bitcoinStore.SmartHeaderChain.TipHeight, blockCount);\n\n\t\t\t\t\/\/ Make sure the funding transaction is not in any block of the chain\n\t\t\t\twhile (curBlockHash != rpc.Network.GenesisHash)\n\t\t\t\t{\n\t\t\t\t\tvar block = await rpc.GetBlockAsync(curBlockHash);\n\n\t\t\t\t\tif (block.Transactions.Any(tx => tx.GetHash() == fundingTxId))\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new Exception($\"Transaction found in block at height {blockCount} hash: {block.GetHash()}\");\n\t\t\t\t\t}\n\t\t\t\t\tcurBlockHash = block.Header.HashPrevBlock;\n\t\t\t\t\tblockCount--;\n\t\t\t\t}\n\n\t\t\t\t\/\/ Get some money, make it confirm.\n\t\t\t\t\/\/ this is necesary because we are in a fork now.\n\t\t\t\teventAwaiter = new EventAwaiter<ProcessedResult>(\n\t\t\t\t\t\t\t\th => wallet.TransactionProcessor.WalletRelevantTransactionProcessed += h,\n\t\t\t\t\t\t\t\th => wallet.TransactionProcessor.WalletRelevantTransactionProcessed -= h);\n\t\t\t\tfundingTxId = await rpc.SendToAddressAsync(key.GetP2wpkhAddress(network), Money.Coins(1m), replaceable: true);\n\t\t\t\teventArgs = await eventAwaiter.WaitAsync(TimeSpan.FromSeconds(21));\n\t\t\t\tAssert.Equal(fundingTxId, eventArgs.NewlyReceivedCoins.Single().TransactionId);\n\t\t\t\tAssert.Contains(fundingTxId, wallet.Coins.Select(x => x.TransactionId));\n\n\t\t\t\tvar fundingBumpTxId = await rpc.BumpFeeAsync(fundingTxId);\n\t\t\t\tawait Task.Delay(2000); \/\/ Waits for the funding transaction get to the mempool.\n\t\t\t\tAssert.Contains(fundingBumpTxId.TransactionId, wallet.Coins.Select(x => x.TransactionId));\n\t\t\t\tAssert.DoesNotContain(fundingTxId, wallet.Coins.Select(x => x.TransactionId));\n\t\t\t\tAssert.Single(wallet.Coins.Where(x => x.TransactionId == fundingBumpTxId.TransactionId));\n\n\t\t\t\t\/\/ Confirm the coin\n\t\t\t\tInterlocked.Exchange(ref _filtersProcessedByWalletCount, 0);\n\t\t\t\tawait rpc.GenerateAsync(1);\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), 1);\n\n\t\t\t\tAssert.Single(wallet.Coins.Where(x => x.Confirmed && x.TransactionId == fundingBumpTxId.TransactionId));\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\twallet?.Dispose();\n\t\t\t\t\/\/ Dispose wasabi synchronizer service.\n\t\t\t\tawait synchronizer?.StopAsync();\n\t\t\t\t\/\/ Dispose connection service.\n\t\t\t\tnodes?.Dispose();\n\t\t\t\t\/\/ Dispose mempool serving node.\n\t\t\t\tnode?.Disconnect();\n\t\t\t\t\/\/ Dispose chaumian coinjoin client.\n\t\t\t\tif (chaumianClient != null)\n\t\t\t\t{\n\t\t\t\t\tawait chaumianClient.StopAsync();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task SpendUnconfirmedTxTestAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\t\/\/ Create the services.\n\t\t\t\/\/ 1. Create connection service.\n\t\t\tvar nodes = new NodesGroup(global.Config.Network, requirements: Constants.NodeRequirements);\n\t\t\tnodes.ConnectedNodes.Add(await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync());\n\n\t\t\t\/\/ 2. Create mempool service.\n\n\t\t\tNode node = await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync();\n\t\t\tnode.Behaviors.Add(bitcoinStore.CreateUntrustedP2pBehavior());\n\n\t\t\t\/\/ 3. Create wasabi synchronizer service.\n\t\t\tvar synchronizer = new WasabiSynchronizer(rpc.Network, bitcoinStore, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\t\/\/ 4. Create key manager service.\n\t\t\tvar keyManager = KeyManager.CreateNew(out _, password);\n\n\t\t\t\/\/ 5. Create chaumian coinjoin client.\n\t\t\tvar chaumianClient = new CoinJoinClient(synchronizer, rpc.Network, keyManager, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\t\/\/ 6. Create wallet service.\n\t\t\tvar workDir = GetWorkDir();\n\t\t\tvar wallet = new WalletService(bitcoinStore, keyManager, synchronizer, chaumianClient, nodes, workDir, serviceConfiguration, synchronizer);\n\t\t\twallet.NewFilterProcessed += Wallet_NewFilterProcessed;\n\n\t\t\tAssert.Empty(wallet.Coins);\n\n\t\t\t\/\/ Get some money, make it confirm.\n\t\t\tvar key = keyManager.GetNextReceiveKey(\"foo label\", out _);\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tnodes.Connect(); \/\/ Start connection service.\n\t\t\t\tnode.VersionHandshake(); \/\/ Start mempool service.\n\t\t\t\tsynchronizer.Start(requestInterval: TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(5), 10000); \/\/ Start wasabi synchronizer service.\n\t\t\t\tchaumianClient.Start(); \/\/ Start chaumian coinjoin client.\n\n\t\t\t\t\/\/ Wait until the filter our previous transaction is present.\n\t\t\t\tvar blockCount = await rpc.GetBlockCountAsync();\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), blockCount);\n\n\t\t\t\tusing (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30)))\n\t\t\t\t{\n\t\t\t\t\tawait wallet.InitializeAsync(cts.Token); \/\/ Initialize wallet service.\n\t\t\t\t}\n\n\t\t\t\tAssert.Empty(wallet.Coins);\n\n\t\t\t\t\/\/ Get some money, make it confirm.\n\t\t\t\t\/\/ this is necesary because we are in a fork now.\n\t\t\t\tvar eventAwaiter = new EventAwaiter<ProcessedResult>(\n\t\t\t\t\th => wallet.TransactionProcessor.WalletRelevantTransactionProcessed += h,\n\t\t\t\t\th => wallet.TransactionProcessor.WalletRelevantTransactionProcessed -= h);\n\t\t\t\tvar tx0Id = await rpc.SendToAddressAsync(\n\t\t\t\t\tkey.GetP2wpkhAddress(network),\n\t\t\t\t\tMoney.Coins(1m),\n\t\t\t\t\treplaceable: true);\n\t\t\t\tvar eventArgs = await eventAwaiter.WaitAsync(TimeSpan.FromSeconds(21));\n\t\t\t\tAssert.Equal(tx0Id, eventArgs.NewlyReceivedCoins.Single().TransactionId);\n\t\t\t\tAssert.Single(wallet.Coins);\n\n\t\t\t\tvar broadcaster = new TransactionBroadcaster(network, bitcoinStore, synchronizer, nodes, rpc);\n\t\t\t\tbroadcaster.AddWalletService(wallet);\n\n\t\t\t\tvar operations = new PaymentIntent(\n\t\t\t\t\tnew DestinationRequest(key.P2wpkhScript, Money.Coins(0.01m)),\n\t\t\t\t\tnew DestinationRequest(new Key().ScriptPubKey, Money.Coins(0.01m)),\n\t\t\t\t\tnew DestinationRequest(new Key().ScriptPubKey, Money.Coins(0.01m)));\n\t\t\t\tvar tx1Res = wallet.BuildTransaction(password, operations, FeeStrategy.TwentyMinutesConfirmationTargetStrategy, allowUnconfirmed: true);\n\t\t\t\tAssert.Equal(2, tx1Res.InnerWalletOutputs.Count());\n\t\t\t\tAssert.Equal(2, tx1Res.OuterWalletOutputs.Count());\n\n\t\t\t\t\/\/ Spend the unconfirmed coin (send it to ourself)\n\t\t\t\toperations = new PaymentIntent(key.PubKey.WitHash.ScriptPubKey, Money.Coins(0.5m));\n\t\t\t\ttx1Res = wallet.BuildTransaction(password, operations, FeeStrategy.TwentyMinutesConfirmationTargetStrategy, allowUnconfirmed: true);\n\t\t\t\teventAwaiter = new EventAwaiter<ProcessedResult>(\n\t\t\t\t\th => wallet.TransactionProcessor.WalletRelevantTransactionProcessed += h,\n\t\t\t\t\th => wallet.TransactionProcessor.WalletRelevantTransactionProcessed -= h);\n\t\t\t\tawait broadcaster.SendTransactionAsync(tx1Res.Transaction);\n\t\t\t\teventArgs = await eventAwaiter.WaitAsync(TimeSpan.FromSeconds(21));\n\t\t\t\tAssert.Equal(tx0Id, eventArgs.NewlySpentCoins.Single().TransactionId);\n\t\t\t\tAssert.Equal(tx1Res.Transaction.GetHash(), eventArgs.NewlyReceivedCoins.First().TransactionId);\n\n\t\t\t\t\/\/ There is a coin created by the latest spending transaction\n\t\t\t\tAssert.Contains(wallet.Coins, x => x.TransactionId == tx1Res.Transaction.GetHash());\n\n\t\t\t\t\/\/ There is a coin destroyed\n\t\t\t\tvar allCoins = wallet.TransactionProcessor.Coins.AsAllCoinsView();\n\t\t\t\tAssert.Equal(1, allCoins.Count(x => x.Unavailable && x.SpenderTransactionId == tx1Res.Transaction.GetHash()));\n\n\t\t\t\t\/\/ There is at least one coin created from the destruction of the first coin\n\t\t\t\tAssert.Contains(wallet.Coins, x => x.SpentOutputs.Any(o => o.TransactionId == tx0Id));\n\n\t\t\t\tvar totalWallet = wallet.Coins.Where(c => !c.Unavailable).Sum(c => c.Amount);\n\t\t\t\tAssert.Equal((1 * Money.COIN) - tx1Res.Fee.Satoshi, totalWallet);\n\n\t\t\t\t\/\/ Spend the unconfirmed and unspent coin (send it to ourself)\n\t\t\t\toperations = new PaymentIntent(key.PubKey.WitHash.ScriptPubKey, Money.Coins(0.6m), subtractFee: true);\n\t\t\t\tvar tx2Res = wallet.BuildTransaction(password, operations, FeeStrategy.TwentyMinutesConfirmationTargetStrategy, allowUnconfirmed: true);\n\n\t\t\t\teventAwaiter = new EventAwaiter<ProcessedResult>(\n\t\t\t\t\t\t\t\th => wallet.TransactionProcessor.WalletRelevantTransactionProcessed += h,\n\t\t\t\t\t\t\t\th => wallet.TransactionProcessor.WalletRelevantTransactionProcessed -= h);\n\t\t\t\tawait broadcaster.SendTransactionAsync(tx2Res.Transaction);\n\t\t\t\teventArgs = await eventAwaiter.WaitAsync(TimeSpan.FromSeconds(21));\n\t\t\t\tvar spentCoins = eventArgs.NewlySpentCoins.ToArray();\n\t\t\t\tAssert.Equal(tx1Res.Transaction.GetHash(), spentCoins.First().TransactionId);\n\t\t\t\tuint256 tx2Hash = tx2Res.Transaction.GetHash();\n\t\t\t\tvar receivedCoins = eventArgs.NewlyReceivedCoins.ToArray();\n\t\t\t\tAssert.Equal(tx2Hash, receivedCoins[0].TransactionId);\n\t\t\t\tAssert.Equal(tx2Hash, receivedCoins[1].TransactionId);\n\n\t\t\t\t\/\/ There is a coin created by the latest spending transaction\n\t\t\t\tAssert.Contains(wallet.Coins, x => x.TransactionId == tx2Res.Transaction.GetHash());\n\n\t\t\t\t\/\/ There is a coin destroyed\n\t\t\t\tallCoins = wallet.TransactionProcessor.Coins.AsAllCoinsView();\n\t\t\t\tAssert.Equal(2, allCoins.Count(x => x.Unavailable && x.SpenderTransactionId == tx2Hash));\n\n\t\t\t\t\/\/ There is at least one coin created from the destruction of the first coin\n\t\t\t\tAssert.Contains(wallet.Coins, x => x.SpentOutputs.Any(o => o.TransactionId == tx1Res.Transaction.GetHash()));\n\n\t\t\t\ttotalWallet = wallet.Coins.Where(c => !c.Unavailable).Sum(c => c.Amount);\n\t\t\t\tAssert.Equal((1 * Money.COIN) - tx1Res.Fee.Satoshi - tx2Res.Fee.Satoshi, totalWallet);\n\n\t\t\t\tInterlocked.Exchange(ref _filtersProcessedByWalletCount, 0);\n\t\t\t\tvar blockId = (await rpc.GenerateAsync(1)).Single();\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), 1);\n\t\t\t\t}\n\t\t\t\tcatch (TimeoutException)\n\t\t\t\t{\n\t\t\t\t\tLogger.LogInfo(\"Index was not processed.\");\n\t\t\t\t\treturn; \/\/ Very rarely this test fails. I have no clue why. Probably because all these RegTests are interconnected, anyway let's not bother the CI with it.\n\t\t\t\t}\n\n\t\t\t\t\/\/ Verify transactions are confirmed in the blockchain\n\t\t\t\tvar block = await rpc.GetBlockAsync(blockId);\n\t\t\t\tAssert.Contains(block.Transactions, x => x.GetHash() == tx2Res.Transaction.GetHash());\n\t\t\t\tAssert.Contains(block.Transactions, x => x.GetHash() == tx1Res.Transaction.GetHash());\n\t\t\t\tAssert.Contains(block.Transactions, x => x.GetHash() == tx0Id);\n\n\t\t\t\tAssert.True(wallet.Coins.All(x => x.Confirmed));\n\n\t\t\t\t\/\/ Test coin basic count.\n\t\t\t\tICoinsView GetAllCoins() => wallet.TransactionProcessor.Coins.AsAllCoinsView();\n\t\t\t\tvar coinCount = GetAllCoins().Count();\n\t\t\t\tvar to = keyManager.GetNextReceiveKey(\"foo\", out _);\n\t\t\t\tvar res = wallet.BuildTransaction(password, new PaymentIntent(to.P2wpkhScript, Money.Coins(0.2345m), label: \"bar\"), FeeStrategy.TwentyMinutesConfirmationTargetStrategy, allowUnconfirmed: true);\n\t\t\t\tawait broadcaster.SendTransactionAsync(res.Transaction);\n\t\t\t\tAssert.Equal(coinCount + 2, GetAllCoins().Count());\n\t\t\t\tAssert.Equal(2, GetAllCoins().Count(x => !x.Confirmed));\n\t\t\t\tInterlocked.Exchange(ref _filtersProcessedByWalletCount, 0);\n\t\t\t\tawait rpc.GenerateAsync(1);\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), 1);\n\t\t\t\tAssert.Equal(coinCount + 2, GetAllCoins().Count());\n\t\t\t\tAssert.Equal(0, GetAllCoins().Count(x => !x.Confirmed));\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\twallet?.Dispose();\n\t\t\t\t\/\/ Dispose wasabi synchronizer service.\n\t\t\t\tawait synchronizer?.StopAsync();\n\t\t\t\t\/\/ Dispose connection service.\n\t\t\t\tnodes?.Dispose();\n\t\t\t\t\/\/ Dispose mempool serving node.\n\t\t\t\tnode?.Disconnect();\n\t\t\t\t\/\/ Dispose chaumian coinjoin client.\n\t\t\t\tif (chaumianClient != null)\n\t\t\t\t{\n\t\t\t\t\tawait chaumianClient.StopAsync();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task ReplaceByFeeTxTestAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\t\/\/ Create the services.\n\t\t\t\/\/ 1. Create connection service.\n\t\t\tvar nodes = new NodesGroup(global.Config.Network, requirements: Constants.NodeRequirements);\n\t\t\tnodes.ConnectedNodes.Add(await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync());\n\n\t\t\t\/\/ 2. Create mempool service.\n\n\t\t\tNode node = await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync();\n\t\t\tnode.Behaviors.Add(bitcoinStore.CreateUntrustedP2pBehavior());\n\n\t\t\t\/\/ 3. Create wasabi synchronizer service.\n\t\t\tvar synchronizer = new WasabiSynchronizer(rpc.Network, bitcoinStore, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\t\/\/ 4. Create key manager service.\n\t\t\tvar keyManager = KeyManager.CreateNew(out _, password);\n\n\t\t\t\/\/ 5. Create chaumian coinjoin client.\n\t\t\tvar chaumianClient = new CoinJoinClient(synchronizer, rpc.Network, keyManager, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\t\/\/ 6. Create wallet service.\n\t\t\tvar workDir = GetWorkDir();\n\t\t\tvar wallet = new WalletService(bitcoinStore, keyManager, synchronizer, chaumianClient, nodes, workDir, serviceConfiguration, synchronizer);\n\t\t\twallet.NewFilterProcessed += Wallet_NewFilterProcessed;\n\n\t\t\tAssert.Empty(wallet.Coins);\n\n\t\t\t\/\/ Get some money, make it confirm.\n\t\t\tvar key = keyManager.GetNextReceiveKey(\"foo label\", out _);\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tnodes.Connect(); \/\/ Start connection service.\n\t\t\t\tnode.VersionHandshake(); \/\/ Start mempool service.\n\t\t\t\tsynchronizer.Start(requestInterval: TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(5), 10000); \/\/ Start wasabi synchronizer service.\n\t\t\t\tchaumianClient.Start(); \/\/ Start chaumian coinjoin client.\n\n\t\t\t\t\/\/ Wait until the filter our previous transaction is present.\n\t\t\t\tvar blockCount = await rpc.GetBlockCountAsync();\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), blockCount);\n\n\t\t\t\tusing (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30)))\n\t\t\t\t{\n\t\t\t\t\tawait wallet.InitializeAsync(cts.Token); \/\/ Initialize wallet service.\n\t\t\t\t}\n\n\t\t\t\tAssert.Empty(wallet.Coins);\n\n\t\t\t\tvar tx0Id = await rpc.SendToAddressAsync(key.GetP2wpkhAddress(network), Money.Coins(1m), replaceable: true);\n\t\t\t\twhile (wallet.Coins.Count() == 0)\n\t\t\t\t{\n\t\t\t\t\tawait Task.Delay(500); \/\/ Waits for the funding transaction get to the mempool.\n\t\t\t\t}\n\n\t\t\t\tAssert.Single(wallet.Coins);\n\t\t\t\tAssert.True(wallet.Coins.First().IsReplaceable);\n\n\t\t\t\tvar bfr = await rpc.BumpFeeAsync(tx0Id);\n\t\t\t\tvar tx1Id = bfr.TransactionId;\n\t\t\t\tawait Task.Delay(2000); \/\/ Waits for the replacement transaction get to the mempool.\n\t\t\t\tAssert.Single(wallet.Coins);\n\t\t\t\tAssert.True(wallet.Coins.First().IsReplaceable);\n\t\t\t\tAssert.Equal(tx1Id, wallet.Coins.First().TransactionId);\n\n\t\t\t\tbfr = await rpc.BumpFeeAsync(tx1Id);\n\t\t\t\tvar tx2Id = bfr.TransactionId;\n\t\t\t\tawait Task.Delay(2000); \/\/ Waits for the replacement transaction get to the mempool.\n\t\t\t\tAssert.Single(wallet.Coins);\n\t\t\t\tAssert.True(wallet.Coins.First().IsReplaceable);\n\t\t\t\tAssert.Equal(tx2Id, wallet.Coins.First().TransactionId);\n\n\t\t\t\tInterlocked.Exchange(ref _filtersProcessedByWalletCount, 0);\n\t\t\t\tawait rpc.GenerateAsync(1);\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), 1);\n\t\t\t\tusing (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30)))\n\t\t\t\t{\n\t\t\t\t\tawait wallet.InitializeAsync(cts.Token); \/\/ Initialize wallet service.\n\t\t\t\t}\n\n\t\t\t\tvar coin = wallet.Coins.First();\n\t\t\t\tAssert.Single(wallet.Coins);\n\t\t\t\tAssert.True(coin.Confirmed);\n\t\t\t\tAssert.False(coin.IsReplaceable);\n\t\t\t\tAssert.Equal(tx2Id, coin.TransactionId);\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\twallet?.Dispose();\n\t\t\t\t\/\/ Dispose wasabi synchronizer service.\n\t\t\t\tawait synchronizer?.StopAsync();\n\t\t\t\t\/\/ Dispose connection service.\n\t\t\t\tnodes?.Dispose();\n\t\t\t\t\/\/ Dispose mempool serving node.\n\t\t\t\tnode?.Disconnect();\n\t\t\t\t\/\/ Dispose chaumian coinjoin client.\n\t\t\t\tif (chaumianClient != null)\n\t\t\t\t{\n\t\t\t\t\tawait chaumianClient.StopAsync();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task CoordinatorCtorTestsAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\tLogger.TurnOff(); \/\/ turn off at the end, otherwise, the tests logs would have of warnings\n\n\t\t\tvar bestBlockHash = await rpc.GetBestBlockHashAsync();\n\t\t\tvar bestBlock = await rpc.GetBlockAsync(bestBlockHash);\n\t\t\tvar coinbaseTxId = bestBlock.Transactions[0].GetHash();\n\t\t\tvar offchainTxId = network.Consensus.ConsensusFactory.CreateTransaction().GetHash();\n\t\t\tvar mempoolTxId = rpc.SendToAddress(new Key().PubKey.GetSegwitAddress(network), Money.Coins(1));\n\n\t\t\tvar folder = GetWorkDir();\n\t\t\tawait IoHelpers.DeleteRecursivelyWithMagicDustAsync(folder);\n\t\t\tDirectory.CreateDirectory(folder);\n\t\t\tvar cjfile = Path.Combine(folder, $\"CoinJoins{network}.txt\");\n\t\t\tFile.WriteAllLines(cjfile, new[] { coinbaseTxId.ToString(), offchainTxId.ToString(), mempoolTxId.ToString() });\n\n\t\t\tusing (var coordinatorToTest = new Coordinator(network, global.HostedServices.FirstOrDefault<BlockNotifier>(), folder, rpc, coordinator.RoundConfig))\n\t\t\t{\n\t\t\t\tvar txIds = await File.ReadAllLinesAsync(cjfile);\n\n\t\t\t\tAssert.Contains(coinbaseTxId.ToString(), txIds);\n\t\t\t\tAssert.Contains(mempoolTxId.ToString(), txIds);\n\t\t\t\tAssert.DoesNotContain(offchainTxId.ToString(), txIds);\n\n\t\t\t\tawait IoHelpers.DeleteRecursivelyWithMagicDustAsync(folder);\n\t\t\t\tDirectory.CreateDirectory(folder);\n\t\t\t\tFile.WriteAllLines(cjfile, new[] { coinbaseTxId.ToString(), \"This line is invalid (the file is corrupted)\", offchainTxId.ToString() });\n\n\t\t\t\tvar coordinatorToTest2 = new Coordinator(network, global.HostedServices.FirstOrDefault<BlockNotifier>(), folder, rpc, coordinatorToTest.RoundConfig);\n\t\t\t\tcoordinatorToTest2?.Dispose();\n\t\t\t\ttxIds = await File.ReadAllLinesAsync(cjfile);\n\t\t\t\tAssert.Single(txIds);\n\t\t\t\tAssert.Contains(coinbaseTxId.ToString(), txIds);\n\t\t\t\tAssert.DoesNotContain(offchainTxId.ToString(), txIds);\n\t\t\t\tAssert.DoesNotContain(\"This line is invalid (the file is corrupted)\", txIds);\n\t\t\t}\n\n\t\t\tLogger.TurnOn();\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task CcjTestsAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\tMoney denomination = Money.Coins(0.2m);\n\t\t\tdecimal coordinatorFeePercent = 0.2m;\n\t\t\tint anonymitySet = 2;\n\t\t\tint connectionConfirmationTimeout = 50;\n\t\t\tvar roundConfig = RegTestFixture.CreateRoundConfig(denomination, 2, 0.7, coordinatorFeePercent, anonymitySet, 100, connectionConfirmationTimeout, 50, 50, 2, 24, false, 11);\n\t\t\tawait coordinator.RoundConfig.UpdateOrDefaultAsync(roundConfig, toFile: true);\n\t\t\tcoordinator.AbortAllRoundsInInputRegistration(\"\");\n\n\t\t\tUri baseUri = new Uri(RegTestFixture.BackendEndPoint);\n\t\t\tusing var torClient = new TorHttpClient(baseUri, Global.Instance.TorSocks5Endpoint);\n\t\t\tusing var satoshiClient = new SatoshiClient(baseUri, null);\n\n\t\t\t#region PostInputsGetStates\n\n\t\t\t\/\/ <-------------------------->\n\t\t\t\/\/ POST INPUTS and GET STATES tests\n\t\t\t\/\/ <-------------------------->\n\n\t\t\tIEnumerable<RoundStateResponse> states = await satoshiClient.GetAllRoundStatesAsync();\n\t\t\tAssert.Equal(2, states.Count());\n\t\t\tforeach (RoundStateResponse rs in states)\n\t\t\t{\n\t\t\t\t\/\/ Never changes.\n\t\t\t\tAssert.True(0 < rs.RoundId);\n\t\t\t\tAssert.Equal(Money.Coins(0.00009648m), rs.FeePerInputs);\n\t\t\t\tAssert.Equal(Money.Coins(0.00004752m), rs.FeePerOutputs);\n\t\t\t\tAssert.Equal(7, rs.MaximumInputCountPerPeer);\n\t\t\t\t\/\/ Changes per rounds.\n\t\t\t\tAssert.Equal(denomination, rs.Denomination);\n\t\t\t\tAssert.Equal(coordinatorFeePercent, rs.CoordinatorFeePercent);\n\t\t\t\tAssert.Equal(anonymitySet, rs.RequiredPeerCount);\n\t\t\t\tAssert.Equal(connectionConfirmationTimeout, rs.RegistrationTimeout);\n\t\t\t\t\/\/ Changes per phases.\n\t\t\t\tAssert.Equal(RoundPhase.InputRegistration, rs.Phase);\n\t\t\t\tAssert.Equal(0, rs.RegisteredPeerCount);\n\t\t\t}\n\n\t\t\t\/\/ Inputs request tests\n\t\t\tvar inputsRequest = new InputsRequest\n\t\t\t{\n\t\t\t\tBlindedOutputScripts = null,\n\t\t\t\tChangeOutputAddress = null,\n\t\t\t\tInputs = null,\n\t\t\t};\n\n\t\t\tvar round = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\t\t\tvar roundId = round.RoundId;\n\t\t\tinputsRequest.RoundId = roundId;\n\t\t\tvar registeredAddresses = Array.Empty<BitcoinAddress>();\n\t\t\tvar schnorrPubKeys = round.MixingLevels.SchnorrPubKeys;\n\t\t\tvar requesters = Array.Empty<Requester>();\n\n\t\t\tHttpRequestException httpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.Equal($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nInvalid request.\", httpRequestException.Message);\n\n\t\t\tbyte[] dummySignature = new byte[65];\n\n\t\t\tinputsRequest.BlindedOutputScripts = Enumerable.Range(0, round.MixingLevels.Count() + 1).Select(x => uint256.One);\n\t\t\tinputsRequest.ChangeOutputAddress = new Key().PubKey.GetAddress(ScriptPubKeyType.Segwit, network);\n\t\t\tinputsRequest.Inputs = new List<InputProofModel> { new InputProofModel { Input = new TxoRef(uint256.One, 0), Proof = dummySignature } };\n\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.StartsWith($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nToo many blinded output was provided\", httpRequestException.Message);\n\n\t\t\tinputsRequest.BlindedOutputScripts = Enumerable.Range(0, round.MixingLevels.Count() - 2).Select(x => uint256.One);\n\t\t\tinputsRequest.ChangeOutputAddress = new Key().PubKey.GetAddress(ScriptPubKeyType.Segwit, network);\n\t\t\tinputsRequest.Inputs = new List<InputProofModel> { new InputProofModel { Input = new TxoRef(uint256.One, 0), Proof = dummySignature } };\n\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.StartsWith($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nDuplicate blinded output found\", httpRequestException.Message);\n\n\t\t\tinputsRequest.BlindedOutputScripts = new[] { uint256.Zero };\n\t\t\tinputsRequest.ChangeOutputAddress = new Key().PubKey.GetAddress(ScriptPubKeyType.Segwit, network);\n\t\t\tinputsRequest.Inputs = new List<InputProofModel> { new InputProofModel { Input = new TxoRef(uint256.One, 0), Proof = dummySignature } };\n\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.StartsWith($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nProvided input is not unspent\", httpRequestException.Message);\n\n\t\t\tvar addr = await rpc.GetNewAddressAsync();\n\t\t\tvar hash = await rpc.SendToAddressAsync(addr, Money.Coins(0.01m));\n\t\t\tvar tx = await rpc.GetRawTransactionAsync(hash);\n\t\t\tvar coin = tx.Outputs.GetCoins(addr.ScriptPubKey).Single();\n\n\t\t\tinputsRequest.Inputs = new List<InputProofModel> { new InputProofModel { Input = coin.Outpoint.ToTxoRef(), Proof = dummySignature } };\n\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.Equal($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nProvided input is neither confirmed, nor is from an unconfirmed coinjoin.\", httpRequestException.Message);\n\n\t\t\tvar blocks = await rpc.GenerateAsync(1);\n\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.Equal($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nProvided input must be witness_v0_keyhash.\", httpRequestException.Message);\n\n\t\t\tvar blockHash = blocks.Single();\n\t\t\tvar block = await rpc.GetBlockAsync(blockHash);\n\t\t\tvar coinbase = block.Transactions.First();\n\t\t\tinputsRequest.Inputs = new List<InputProofModel> { new InputProofModel { Input = new TxoRef(coinbase.GetHash(), 0), Proof = dummySignature } };\n\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.Equal($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nProvided input is immature.\", httpRequestException.Message);\n\n\t\t\tvar key = new Key();\n\t\t\tvar witnessAddress = key.PubKey.GetSegwitAddress(network);\n\t\t\thash = await rpc.SendToAddressAsync(witnessAddress, Money.Coins(0.01m));\n\t\t\tawait rpc.GenerateAsync(1);\n\t\t\ttx = await rpc.GetRawTransactionAsync(hash);\n\t\t\tcoin = tx.Outputs.GetCoins(witnessAddress.ScriptPubKey).Single();\n\t\t\tinputsRequest.Inputs = new List<InputProofModel> { new InputProofModel { Input = coin.Outpoint.ToTxoRef(), Proof = dummySignature } };\n\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.StartsWith($\"{HttpStatusCode.BadRequest.ToReasonString()}\", httpRequestException.Message);\n\n\t\t\tvar proof = key.SignCompact(uint256.One);\n\t\t\tinputsRequest.Inputs.First().Proof = proof;\n\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.Equal($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nProvided proof is invalid.\", httpRequestException.Message);\n\n\t\t\tround = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\t\t\tvar requester = new Requester();\n\t\t\tuint256 msg = new uint256(Hashes.SHA256(network.Consensus.ConsensusFactory.CreateTransaction().ToBytes()));\n\t\t\tuint256 blindedData = requester.BlindMessage(msg, round.MixingLevels.GetBaseLevel().SchnorrKey.SchnorrPubKey);\n\t\t\tinputsRequest.BlindedOutputScripts = new[] { blindedData };\n\t\t\tuint256 blindedOutputScriptsHash = new uint256(Hashes.SHA256(blindedData.ToBytes()));\n\n\t\t\tproof = key.SignCompact(blindedOutputScriptsHash);\n\t\t\tinputsRequest.Inputs.First().Proof = proof;\n\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.StartsWith($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nNot enough inputs are provided. Fee to pay:\", httpRequestException.Message);\n\n\t\t\troundConfig.Denomination = Money.Coins(0.01m); \/\/ exactly the same as our output\n\t\t\tawait coordinator.RoundConfig.UpdateOrDefaultAsync(roundConfig, toFile: true);\n\t\t\tcoordinator.AbortAllRoundsInInputRegistration(\"\");\n\t\t\tround = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\t\t\troundId = round.RoundId;\n\t\t\tinputsRequest.RoundId = roundId;\n\t\t\tschnorrPubKeys = round.MixingLevels.SchnorrPubKeys;\n\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.StartsWith($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nNot enough inputs are provided. Fee to pay:\", httpRequestException.Message);\n\n\t\t\troundConfig.Denomination = Money.Coins(0.00999999m); \/\/ one satoshi less than our output\n\t\t\tawait coordinator.RoundConfig.UpdateOrDefaultAsync(roundConfig, toFile: true);\n\t\t\tcoordinator.AbortAllRoundsInInputRegistration(\"\");\n\t\t\tround = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\t\t\troundId = round.RoundId;\n\t\t\tinputsRequest.RoundId = roundId;\n\t\t\tschnorrPubKeys = round.MixingLevels.SchnorrPubKeys;\n\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.StartsWith($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nNot enough inputs are provided. Fee to pay:\", httpRequestException.Message);\n\n\t\t\troundConfig.Denomination = Money.Coins(0.008m); \/\/ one satoshi less than our output\n\t\t\troundConfig.ConnectionConfirmationTimeout = 7;\n\t\t\tawait coordinator.RoundConfig.UpdateOrDefaultAsync(roundConfig, toFile: true);\n\t\t\tcoordinator.AbortAllRoundsInInputRegistration(\"\");\n\t\t\tround = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\t\t\troundId = round.RoundId;\n\t\t\tinputsRequest.RoundId = roundId;\n\t\t\tschnorrPubKeys = round.MixingLevels.SchnorrPubKeys;\n\t\t\trequester = new Requester();\n\t\t\trequesters = new[] { requester };\n\t\t\tmsg = network.Consensus.ConsensusFactory.CreateTransaction().GetHash();\n\t\t\tblindedData = requester.BlindMessage(msg, round.MixingLevels.GetBaseLevel().SchnorrKey.SchnorrPubKey);\n\t\t\tinputsRequest.BlindedOutputScripts = new[] { blindedData };\n\t\t\tblindedOutputScriptsHash = new uint256(Hashes.SHA256(blindedData.ToBytes()));\n\t\t\tproof = key.SignCompact(blindedOutputScriptsHash);\n\t\t\tinputsRequest.Inputs.First().Proof = proof;\n\t\t\tusing (var aliceClient = await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null))\n\t\t\t{\n\t\t\t\t\/\/ Test DelayedClientRoundRegistration logic.\n\t\t\t\tClientRoundRegistration first = null;\n\t\t\t\tvar second = new ClientRoundRegistration(aliceClient,\n\t\t\t\t\tnew[] { new SmartCoin(uint256.One, 1, Script.Empty, Money.Zero, new[] { new TxoRef(uint256.One, 1) }, Height.Unknown, true, 2, isLikelyCoinJoinOutput: false) },\n\t\t\t\t\tBitcoinAddress.Create(\"12Rty3c8j3QiZSwLVaBtch6XUMZaja3RC7\", Network.Main));\n\t\t\t\tfirst = second;\n\t\t\t\tsecond = null;\n\t\t\t\tAssert.NotNull(first);\n\t\t\t\tAssert.Null(second);\n\n\t\t\t\tAssert.NotEqual(Guid.Empty, aliceClient.UniqueId);\n\t\t\t\tAssert.True(aliceClient.RoundId > 0);\n\n\t\t\t\tRoundStateResponse roundState = await satoshiClient.GetRoundStateAsync(aliceClient.RoundId);\n\t\t\t\tAssert.Equal(RoundPhase.InputRegistration, roundState.Phase);\n\t\t\t\tAssert.Equal(1, roundState.RegisteredPeerCount);\n\n\t\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\t\tAssert.Equal($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nBlinded output has already been registered.\", httpRequestException.Message);\n\n\t\t\t\troundState = await satoshiClient.GetRoundStateAsync(aliceClient.RoundId);\n\t\t\t\tAssert.Equal(RoundPhase.InputRegistration, roundState.Phase);\n\t\t\t\tAssert.Equal(1, roundState.RegisteredPeerCount);\n\n\t\t\t\troundState = await satoshiClient.GetRoundStateAsync(aliceClient.RoundId);\n\t\t\t\tAssert.Equal(RoundPhase.InputRegistration, roundState.Phase);\n\t\t\t\tAssert.Equal(1, roundState.RegisteredPeerCount);\n\t\t\t\tawait aliceClient.PostUnConfirmationAsync();\n\t\t\t}\n\n\t\t\tround = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\t\t\trequester = new Requester();\n\t\t\tblindedData = requester.BlindScript(round.MixingLevels.GetBaseLevel().SchnorrKey.SchnorrPubKey.SignerPubKey, round.MixingLevels.GetBaseLevel().SchnorrKey.SchnorrPubKey.RpubKey, key.ScriptPubKey);\n\t\t\tinputsRequest.BlindedOutputScripts = new[] { blindedData };\n\t\t\tblindedOutputScriptsHash = new uint256(Hashes.SHA256(blindedData.ToBytes()));\n\t\t\tproof = key.SignCompact(blindedOutputScriptsHash);\n\t\t\tinputsRequest.Inputs.First().Proof = proof;\n\n\t\t\tvar currentRound = coordinator.TryGetRound(roundId);\n\t\t\tAssert.NotNull(currentRound);\n\t\t\tAssert.Equal(RoundPhase.InputRegistration, currentRound.Phase);\n\t\t\tAssert.Equal(2, currentRound.AnonymitySet);\n\t\t\tAssert.Equal(0, currentRound.CountAlices());\n\n\t\t\tusing (var aliceClient = await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null))\n\t\t\t{\n\t\t\t\tAssert.NotEqual(Guid.Empty, aliceClient.UniqueId);\n\t\t\t\tAssert.True(aliceClient.RoundId > 0);\n\n\t\t\t\tAssert.Equal(2, currentRound.AnonymitySet);\n\t\t\t\tAssert.Equal(1, currentRound.CountAlices());\n\n\t\t\t\tvar roundState = await satoshiClient.GetRoundStateAsync(aliceClient.RoundId);\n\t\t\t\tAssert.Equal(RoundPhase.InputRegistration, roundState.Phase);\n\t\t\t\tAssert.Equal(1, roundState.RegisteredPeerCount);\n\t\t\t}\n\n\t\t\tinputsRequest.BlindedOutputScripts = new[] { uint256.One };\n\t\t\tblindedOutputScriptsHash = new uint256(Hashes.SHA256(uint256.One.ToBytes()));\n\t\t\tproof = key.SignCompact(blindedOutputScriptsHash);\n\t\t\tinputsRequest.Inputs.First().Proof = proof;\n\t\t\tinputsRequest.Inputs = new List<InputProofModel> { inputsRequest.Inputs.First(), inputsRequest.Inputs.First() };\n\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.Equal($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nCannot register an input twice.\", httpRequestException.Message);\n\n\t\t\tvar inputProofs = new List<InputProofModel>();\n\t\t\tfor (int j = 0; j < 8; j++)\n\t\t\t{\n\t\t\t\tkey = new Key();\n\t\t\t\twitnessAddress = key.PubKey.GetSegwitAddress(network);\n\t\t\t\thash = await rpc.SendToAddressAsync(witnessAddress, Money.Coins(0.01m));\n\t\t\t\tawait rpc.GenerateAsync(1);\n\t\t\t\ttx = await rpc.GetRawTransactionAsync(hash);\n\t\t\t\tcoin = tx.Outputs.GetCoins(witnessAddress.ScriptPubKey).Single();\n\t\t\t\tproof = key.SignCompact(blindedOutputScriptsHash);\n\t\t\t\tinputProofs.Add(new InputProofModel { Input = coin.Outpoint.ToTxoRef(), Proof = proof });\n\t\t\t}\n\t\t\tvar blockHashed = await rpc.GenerateAsync(1);\n\n\t\t\tinputsRequest.Inputs = inputProofs;\n\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.Equal($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nMaximum 7 inputs can be registered.\", httpRequestException.Message);\n\t\t\tinputProofs.RemoveLast();\n\t\t\tinputsRequest.Inputs = inputProofs;\n\n\t\t\tAssert.NotNull(currentRound);\n\t\t\tAssert.Equal(RoundPhase.InputRegistration, currentRound.Phase);\n\t\t\tAssert.Equal(2, currentRound.AnonymitySet);\n\t\t\tAssert.Equal(1, currentRound.CountAlices());\n\n\t\t\tvar awaiter = new EventAwaiter<RoundPhase>(\n\t\t\t\th => currentRound.PhaseChanged += h,\n\t\t\t\th => currentRound.PhaseChanged -= h);\n\n\t\t\tusing (var aliceClient = await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null))\n\t\t\t{\n\t\t\t\tAssert.Equal(2, currentRound.AnonymitySet);\n\t\t\t\tAssert.Equal(2, currentRound.CountAlices());\n\t\t\t\tAssert.NotEqual(Guid.Empty, aliceClient.UniqueId);\n\t\t\t\tAssert.True(aliceClient.RoundId > 0);\n\n\t\t\t\tawait awaiter.WaitAsync(TimeSpan.FromSeconds(7));\n\n\t\t\t\tvar roundState = await satoshiClient.GetRoundStateAsync(aliceClient.RoundId);\n\t\t\t\tAssert.Equal(RoundPhase.ConnectionConfirmation, roundState.Phase);\n\t\t\t\tAssert.Equal(2, roundState.RegisteredPeerCount);\n\t\t\t\tvar inputRegistrableRoundState = await satoshiClient.GetRegistrableRoundStateAsync();\n\t\t\t\tAssert.Equal(0, inputRegistrableRoundState.RegisteredPeerCount);\n\n\t\t\t\troundConfig.ConnectionConfirmationTimeout = 1; \/\/ One second.\n\t\t\t\tawait coordinator.RoundConfig.UpdateOrDefaultAsync(roundConfig, toFile: true);\n\t\t\t\tcoordinator.AbortAllRoundsInInputRegistration(\"\");\n\t\t\t\tround = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\t\t\t\troundId = round.RoundId;\n\t\t\t\tinputsRequest.RoundId = roundId;\n\t\t\t\tschnorrPubKeys = round.MixingLevels.SchnorrPubKeys;\n\n\t\t\t\troundState = await satoshiClient.GetRoundStateAsync(aliceClient.RoundId);\n\t\t\t\tAssert.Equal(RoundPhase.ConnectionConfirmation, roundState.Phase);\n\t\t\t\tAssert.Equal(2, roundState.RegisteredPeerCount);\n\t\t\t}\n\n\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.Equal($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nInput is already registered in another round.\", httpRequestException.Message);\n\n\t\t\t\/\/ Wait until input registration times out.\n\t\t\tawait Task.Delay(TimeSpan.FromSeconds(8));\n\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, inputsRequest, baseUri, null));\n\t\t\tAssert.StartsWith($\"{HttpStatusCode.BadRequest.ToReasonString()}\\nInput is banned from participation for\", httpRequestException.Message);\n\n\t\t\tvar spendingTx = network.Consensus.ConsensusFactory.CreateTransaction();\n\t\t\tvar bannedCoin = inputsRequest.Inputs.First().Input;\n\t\t\tvar utxos = coordinator.UtxoReferee;\n\t\t\tAssert.NotNull(await utxos.TryGetBannedAsync(bannedCoin.ToOutPoint(), false));\n\t\t\tspendingTx.Inputs.Add(new TxIn(bannedCoin.ToOutPoint()));\n\t\t\tspendingTx.Outputs.Add(new TxOut(Money.Coins(1), new Key().PubKey.GetSegwitAddress(network)));\n\t\t\tawait coordinator.ProcessConfirmedTransactionAsync(spendingTx);\n\n\t\t\tAssert.NotNull(await utxos.TryGetBannedAsync(new OutPoint(spendingTx.GetHash(), 0), false));\n\t\t\tAssert.Null(await utxos.TryGetBannedAsync(bannedCoin.ToOutPoint(), false));\n\n\t\t\tstates = await satoshiClient.GetAllRoundStatesAsync();\n\t\t\tforeach (var rs in states.Where(x => x.Phase == RoundPhase.InputRegistration))\n\t\t\t{\n\t\t\t\tAssert.Equal(0, rs.RegisteredPeerCount);\n\t\t\t}\n\n\t\t\t#endregion PostInputsGetStates\n\n\t\t\t#region PostConfirmationPostUnconfirmation\n\n\t\t\t\/\/ <-------------------------->\n\t\t\t\/\/ POST CONFIRMATION and POST UNCONFIRMATION tests\n\t\t\t\/\/ <-------------------------->\n\n\t\t\tkey = new Key();\n\t\t\twitnessAddress = key.PubKey.GetSegwitAddress(network);\n\t\t\thash = await rpc.SendToAddressAsync(witnessAddress, Money.Coins(0.01m));\n\t\t\tawait rpc.GenerateAsync(1);\n\t\t\ttx = await rpc.GetRawTransactionAsync(hash);\n\t\t\tcoin = tx.Outputs.GetCoins(witnessAddress.ScriptPubKey).Single();\n\t\t\tround = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\t\t\trequester = new Requester();\n\t\t\trequesters = new[] { requester };\n\t\t\tBitcoinWitPubKeyAddress bitcoinWitPubKeyAddress = new Key().PubKey.GetSegwitAddress(network);\n\t\t\tregisteredAddresses = new[] { bitcoinWitPubKeyAddress };\n\t\t\tScript script = bitcoinWitPubKeyAddress.ScriptPubKey;\n\t\t\tblindedData = requester.BlindScript(round.MixingLevels.GetBaseLevel().Signer.Key.PubKey, round.MixingLevels.GetBaseLevel().Signer.R.PubKey, script);\n\t\t\tblindedOutputScriptsHash = new uint256(Hashes.SHA256(blindedData.ToBytes()));\n\n\t\t\tusing (var aliceClient = await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, new Key().PubKey.GetAddress(ScriptPubKeyType.Segwit, network), new[] { blindedData }, new InputProofModel[] { new InputProofModel { Input = coin.Outpoint.ToTxoRef(), Proof = key.SignCompact(blindedOutputScriptsHash) } }, baseUri, null))\n\t\t\t{\n\t\t\t\tAssert.NotEqual(Guid.Empty, aliceClient.UniqueId);\n\t\t\t\tAssert.True(aliceClient.RoundId > 0);\n\t\t\t\t\/\/ Double the request.\n\t\t\t\t\/\/ badrequests\n\t\t\t\tusing (var response = await torClient.SendAsync(HttpMethod.Post, $\"\/api\/v{Constants.BackendMajorVersion}\/btc\/chaumiancoinjoin\/confirmation\"))\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(HttpStatusCode.BadRequest, response.StatusCode);\n\t\t\t\t}\n\t\t\t\tusing (var response = await torClient.SendAsync(HttpMethod.Post, $\"\/api\/v{Constants.BackendMajorVersion}\/btc\/chaumiancoinjoin\/confirmation?uniqueId={aliceClient.UniqueId}\"))\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(HttpStatusCode.BadRequest, response.StatusCode);\n\t\t\t\t}\n\t\t\t\tusing (var response = await torClient.SendAsync(HttpMethod.Post, $\"\/api\/v{Constants.BackendMajorVersion}\/btc\/chaumiancoinjoin\/confirmation?roundId={aliceClient.RoundId}\"))\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(HttpStatusCode.BadRequest, response.StatusCode);\n\t\t\t\t}\n\t\t\t\tusing (var response = await torClient.SendAsync(HttpMethod.Post, $\"\/api\/v{Constants.BackendMajorVersion}\/btc\/chaumiancoinjoin\/confirmation?uniqueId=foo&roundId={aliceClient.RoundId}\"))\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(HttpStatusCode.BadRequest, response.StatusCode);\n\t\t\t\t\tAssert.Equal(\"Invalid uniqueId provided.\", await response.Content.ReadAsJsonAsync<string>());\n\t\t\t\t}\n\t\t\t\tusing (var response = await torClient.SendAsync(HttpMethod.Post, $\"\/api\/v{Constants.BackendMajorVersion}\/btc\/chaumiancoinjoin\/confirmation?uniqueId={aliceClient.UniqueId}&roundId=bar\"))\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(HttpStatusCode.BadRequest, response.StatusCode);\n\t\t\t\t\tAssert.Null(await response.Content.ReadAsJsonAsync<string>());\n\t\t\t\t}\n\n\t\t\t\troundConfig.ConnectionConfirmationTimeout = 60;\n\t\t\t\tawait coordinator.RoundConfig.UpdateOrDefaultAsync(roundConfig, toFile: true);\n\t\t\t\tcoordinator.AbortAllRoundsInInputRegistration(\"\");\n\t\t\t\tround = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\t\t\t\troundId = round.RoundId;\n\t\t\t\tinputsRequest.RoundId = roundId;\n\t\t\t\tschnorrPubKeys = round.MixingLevels.SchnorrPubKeys;\n\t\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await aliceClient.PostConfirmationAsync());\n\t\t\t\tAssert.Equal($\"{HttpStatusCode.Gone.ToReasonString()}\\nRound is not running.\", httpRequestException.Message);\n\t\t\t}\n\n\t\t\tusing (var aliceClient = await AliceClient.CreateNewAsync(roundId, registeredAddresses, schnorrPubKeys, requesters, network, new Key().PubKey.GetAddress(ScriptPubKeyType.Segwit, network), new[] { blindedData }, new InputProofModel[] { new InputProofModel { Input = coin.Outpoint.ToTxoRef(), Proof = key.SignCompact(blindedOutputScriptsHash) } }, baseUri, null))\n\t\t\t{\n\t\t\t\tAssert.NotEqual(Guid.Empty, aliceClient.UniqueId);\n\t\t\t\tAssert.True(aliceClient.RoundId > 0);\n\t\t\t\tawait aliceClient.PostUnConfirmationAsync();\n\t\t\t\tusing HttpResponseMessage response = await torClient.SendAsync(HttpMethod.Post, $\"\/api\/v{Constants.BackendMajorVersion}\/btc\/chaumiancoinjoin\/unconfirmation?uniqueId={aliceClient.UniqueId}&roundId={aliceClient.RoundId}\");\n\t\t\t\tAssert.True(response.IsSuccessStatusCode);\n\t\t\t\tAssert.Equal(HttpStatusCode.OK, response.StatusCode);\n\t\t\t\tAssert.Equal(\"Alice not found.\", await response.Content.ReadAsJsonAsync<string>());\n\t\t\t}\n\n\t\t\t#endregion PostConfirmationPostUnconfirmation\n\n\t\t\t#region PostOutput\n\n\t\t\t\/\/ <-------------------------->\n\t\t\t\/\/ POST OUTPUT tests\n\t\t\t\/\/ <-------------------------->\n\n\t\t\tvar key1 = new Key();\n\t\t\tvar key2 = new Key();\n\t\t\tvar outputAddress1 = key1.PubKey.GetSegwitAddress(network);\n\t\t\tvar outputAddress2 = key2.PubKey.GetSegwitAddress(network);\n\t\t\tvar hash1 = await rpc.SendToAddressAsync(outputAddress1, Money.Coins(0.01m));\n\t\t\tvar hash2 = await rpc.SendToAddressAsync(outputAddress2, Money.Coins(0.01m));\n\t\t\tawait rpc.GenerateAsync(1);\n\t\t\tvar tx1 = await rpc.GetRawTransactionAsync(hash1);\n\t\t\tvar tx2 = await rpc.GetRawTransactionAsync(hash2);\n\t\t\tvar index1 = 0;\n\t\t\tfor (int i = 0; i < tx1.Outputs.Count; i++)\n\t\t\t{\n\t\t\t\tvar output = tx1.Outputs[i];\n\t\t\t\tif (output.ScriptPubKey == outputAddress1.ScriptPubKey)\n\t\t\t\t{\n\t\t\t\t\tindex1 = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar index2 = 0;\n\t\t\tfor (int i = 0; i < tx2.Outputs.Count; i++)\n\t\t\t{\n\t\t\t\tvar output = tx2.Outputs[i];\n\t\t\t\tif (output.ScriptPubKey == outputAddress2.ScriptPubKey)\n\t\t\t\t{\n\t\t\t\t\tindex2 = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tround = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\t\t\tschnorrPubKeys = round.MixingLevels.SchnorrPubKeys;\n\t\t\troundId = round.RoundId;\n\n\t\t\tvar requester1 = new Requester();\n\t\t\tvar requester2 = new Requester();\n\n\t\t\tuint256 blinded1 = requester1.BlindScript(round.MixingLevels.GetBaseLevel().Signer.Key.PubKey, round.MixingLevels.GetBaseLevel().Signer.R.PubKey, outputAddress1.ScriptPubKey);\n\t\t\tuint256 blindedOutputScriptsHash1 = new uint256(Hashes.SHA256(blinded1.ToBytes()));\n\t\t\tuint256 blinded2 = requester2.BlindScript(round.MixingLevels.GetBaseLevel().Signer.Key.PubKey, round.MixingLevels.GetBaseLevel().Signer.R.PubKey, outputAddress2.ScriptPubKey);\n\t\t\tuint256 blindedOutputScriptsHash2 = new uint256(Hashes.SHA256(blinded2.ToBytes()));\n\n\t\t\tvar input1 = new OutPoint(hash1, index1);\n\t\t\tvar input2 = new OutPoint(hash2, index2);\n\n\t\t\tusing (var aliceClient1 = await AliceClient.CreateNewAsync(roundId, new[] { outputAddress1 }, schnorrPubKeys, new[] { requester1 }, network, new Key().PubKey.GetAddress(ScriptPubKeyType.Segwit, network), new[] { blinded1 }, new InputProofModel[] { new InputProofModel { Input = input1.ToTxoRef(), Proof = key1.SignCompact(blindedOutputScriptsHash1) } }, baseUri, null))\n\t\t\tusing (var aliceClient2 = await AliceClient.CreateNewAsync(roundId, new[] { outputAddress2 }, schnorrPubKeys, new[] { requester2 }, network, new Key().PubKey.GetAddress(ScriptPubKeyType.Segwit, network), new[] { blinded2 }, new InputProofModel[] { new InputProofModel { Input = input2.ToTxoRef(), Proof = key2.SignCompact(blindedOutputScriptsHash2) } }, baseUri, null))\n\t\t\t{\n\t\t\t\tAssert.Equal(aliceClient2.RoundId, aliceClient1.RoundId);\n\t\t\t\tAssert.NotEqual(aliceClient2.UniqueId, aliceClient1.UniqueId);\n\n\t\t\t\tvar connConfResp = await aliceClient1.PostConfirmationAsync();\n\t\t\t\tAssert.Equal(connConfResp.currentPhase, (await aliceClient1.PostConfirmationAsync()).currentPhase); \/\/ Make sure it won't throw error for double confirming.\n\t\t\t\tvar connConfResp2 = await aliceClient2.PostConfirmationAsync();\n\n\t\t\t\tAssert.Equal(connConfResp.currentPhase, connConfResp2.currentPhase);\n\t\t\t\thttpRequestException = await Assert.ThrowsAsync<HttpRequestException>(async () => await aliceClient2.PostConfirmationAsync());\n\t\t\t\tAssert.Equal($\"{HttpStatusCode.Gone.ToReasonString()}\\nParticipation can be only confirmed from InputRegistration or ConnectionConfirmation phase. Current phase: OutputRegistration.\", httpRequestException.Message);\n\n\t\t\t\tvar roundState = await satoshiClient.GetRoundStateAsync(aliceClient1.RoundId);\n\t\t\t\tAssert.Equal(RoundPhase.OutputRegistration, roundState.Phase);\n\n\t\t\t\tif (!round.MixingLevels.GetBaseLevel().Signer.VerifyUnblindedSignature(connConfResp2.activeOutputs.First().Signature, outputAddress2.ScriptPubKey.ToBytes()))\n\t\t\t\t{\n\t\t\t\t\tthrow new NotSupportedException(\"Coordinator did not sign the blinded output properly.\");\n\t\t\t\t}\n\n\t\t\t\tusing (var bobClient1 = new BobClient(baseUri, null))\n\t\t\t\tusing (var bobClient2 = new BobClient(baseUri, null))\n\t\t\t\t{\n\t\t\t\t\tawait bobClient1.PostOutputAsync(aliceClient1.RoundId, new ActiveOutput(outputAddress1, connConfResp.activeOutputs.First().Signature, 0));\n\t\t\t\t\tawait bobClient2.PostOutputAsync(aliceClient2.RoundId, new ActiveOutput(outputAddress2, connConfResp2.activeOutputs.First().Signature, 0));\n\t\t\t\t}\n\n\t\t\t\troundState = await satoshiClient.GetRoundStateAsync(aliceClient1.RoundId);\n\t\t\t\tAssert.Equal(RoundPhase.Signing, roundState.Phase);\n\t\t\t\tAssert.Equal(2, roundState.RegisteredPeerCount);\n\t\t\t\tAssert.Equal(2, roundState.RequiredPeerCount);\n\n\t\t\t\t#endregion PostOutput\n\n\t\t\t\t#region GetCoinjoin\n\n\t\t\t\t\/\/ <-------------------------->\n\t\t\t\t\/\/ GET COINJOIN tests\n\t\t\t\t\/\/ <-------------------------->\n\n\t\t\t\tTransaction unsignedCoinJoin = await aliceClient1.GetUnsignedCoinJoinAsync();\n\t\t\t\tAssert.Equal(unsignedCoinJoin.ToHex(), (await aliceClient1.GetUnsignedCoinJoinAsync()).ToHex());\n\t\t\t\tAssert.Equal(unsignedCoinJoin.ToHex(), (await aliceClient2.GetUnsignedCoinJoinAsync()).ToHex());\n\n\t\t\t\tAssert.Contains(outputAddress1.ScriptPubKey, unsignedCoinJoin.Outputs.Select(x => x.ScriptPubKey));\n\t\t\t\tAssert.Contains(outputAddress2.ScriptPubKey, unsignedCoinJoin.Outputs.Select(x => x.ScriptPubKey));\n\t\t\t\tAssert.True(2 == unsignedCoinJoin.Outputs.Count); \/\/ Because the two input is equal, so change addresses won't be used, nor coordinator fee will be taken.\n\t\t\t\tAssert.Contains(input1, unsignedCoinJoin.Inputs.Select(x => x.PrevOut));\n\t\t\t\tAssert.Contains(input2, unsignedCoinJoin.Inputs.Select(x => x.PrevOut));\n\t\t\t\tAssert.True(2 == unsignedCoinJoin.Inputs.Count);\n\n\t\t\t\t#endregion GetCoinjoin\n\n\t\t\t\t#region PostSignatures\n\n\t\t\t\t\/\/ <-------------------------->\n\t\t\t\t\/\/ POST SIGNATURES tests\n\t\t\t\t\/\/ <-------------------------->\n\n\t\t\t\tvar partSignedCj1 = Transaction.Parse(unsignedCoinJoin.ToHex(), network);\n\t\t\t\tvar partSignedCj2 = Transaction.Parse(unsignedCoinJoin.ToHex(), network);\n\n\t\t\t\tvar builder = Network.RegTest.CreateTransactionBuilder();\n\t\t\t\tpartSignedCj1 = builder\n\t\t\t\t\t.ContinueToBuild(partSignedCj1)\n\t\t\t\t\t.AddKeys(key1)\n\t\t\t\t\t.AddCoins(new Coin(tx1, input1.N))\n\t\t\t\t\t.BuildTransaction(true);\n\n\t\t\t\tbuilder = Network.RegTest.CreateTransactionBuilder();\n\t\t\t\tpartSignedCj2 = builder\n\t\t\t\t\t.ContinueToBuild(partSignedCj2)\n\t\t\t\t\t.AddKeys(key2)\n\t\t\t\t\t.AddCoins(new Coin(tx2, input2.N))\n\t\t\t\t\t.BuildTransaction(true);\n\n\t\t\t\tvar myDic1 = new Dictionary<int, WitScript>();\n\t\t\t\tvar myDic2 = new Dictionary<int, WitScript>();\n\n\t\t\t\tfor (int i = 0; i < unsignedCoinJoin.Inputs.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tvar input = unsignedCoinJoin.Inputs[i];\n\t\t\t\t\tif (input.PrevOut == input1)\n\t\t\t\t\t{\n\t\t\t\t\t\tmyDic1.Add(i, partSignedCj1.Inputs[i].WitScript);\n\t\t\t\t\t}\n\t\t\t\t\tif (input.PrevOut == input2)\n\t\t\t\t\t{\n\t\t\t\t\t\tmyDic2.Add(i, partSignedCj2.Inputs[i].WitScript);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tawait aliceClient1.PostSignaturesAsync(myDic1);\n\t\t\t\tawait aliceClient2.PostSignaturesAsync(myDic2);\n\n\t\t\t\tuint256[] mempooltxs = await rpc.GetRawMempoolAsync();\n\t\t\t\tAssert.Contains(unsignedCoinJoin.GetHash(), mempooltxs);\n\n\t\t\t\tvar wasabiClient = new WasabiClient(baseUri, null);\n\t\t\t\tvar syncInfo = await wasabiClient.GetSynchronizeAsync(blockHashed[0], 1);\n\t\t\t\tAssert.Contains(unsignedCoinJoin.GetHash(), syncInfo.UnconfirmedCoinJoins);\n\t\t\t\tvar txs = await wasabiClient.GetTransactionsAsync(network, new[] { unsignedCoinJoin.GetHash() }, CancellationToken.None);\n\t\t\t\tAssert.NotEmpty(txs);\n\n\t\t\t\t#endregion PostSignatures\n\t\t\t}\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task CcjEqualInputTestsAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\tMoney denomination = Money.Coins(0.1m);\n\t\t\tdecimal coordinatorFeePercent = 0.0002m;\n\t\t\tint anonymitySet = 4;\n\t\t\tint connectionConfirmationTimeout = 50;\n\t\t\tvar roundConfig = RegTestFixture.CreateRoundConfig(denomination, 2, 0.7, coordinatorFeePercent, anonymitySet, 100, connectionConfirmationTimeout, 50, 50, 2, 24, false, 11);\n\t\t\tawait coordinator.RoundConfig.UpdateOrDefaultAsync(roundConfig, toFile: true);\n\t\t\tcoordinator.AbortAllRoundsInInputRegistration(\"\");\n\n\t\t\tUri baseUri = new Uri(RegTestFixture.BackendEndPoint);\n\t\t\tusing var torClient = new TorHttpClient(baseUri, Global.Instance.TorSocks5Endpoint);\n\t\t\tusing var satoshiClient = new SatoshiClient(baseUri, null);\n\t\t\tvar round = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\t\t\tvar roundId = round.RoundId;\n\n\t\t\t\/\/ We have to 4 participant so, this data structure is for keeping track of\n\t\t\t\/\/ important data for each of the participants in the coinjoin session.\n\t\t\tvar participants = new List<(AliceClient aliceClient,\n\t\t\t\t\t\t\t\t\t\t List<(Requester requester, BitcoinWitPubKeyAddress outputAddress, uint256 blindedScript)> outouts,\n\t\t\t\t\t\t\t\t\t\t List<(TxoRef input, byte[] proof, Coin coin, Key key)> inputs)>();\n\n\t\t\t\/\/ INPUS REGISTRATION PHASE --\n\t\t\tfor (var anosetIdx = 0; anosetIdx < anonymitySet; anosetIdx++)\n\t\t\t{\n\t\t\t\t\/\/ Create as many outputs as mixin levels (even when we do not have funds enough)\n\t\t\t\tvar outputs = new List<(Requester requester, BitcoinWitPubKeyAddress outputAddress, uint256 blindedScript)>();\n\t\t\t\tforeach (var level in round.MixingLevels.Levels)\n\t\t\t\t{\n\t\t\t\t\tvar requester = new Requester();\n\t\t\t\t\tvar outputsAddress = new Key().PubKey.GetSegwitAddress(network);\n\t\t\t\t\tvar scriptPubKey = outputsAddress.ScriptPubKey;\n\t\t\t\t\t\/\/ We blind the scriptPubKey with a new requester by mixin level\n\t\t\t\t\tvar blindedScript = requester.BlindScript(level.Signer.Key.PubKey, level.Signer.R.PubKey, scriptPubKey);\n\t\t\t\t\toutputs.Add((requester, outputsAddress, blindedScript));\n\t\t\t\t}\n\n\t\t\t\t\/\/ Calculate the SHA256( blind1 || blind2 || .....|| blindN )\n\t\t\t\tvar blindedOutputScriptList = outputs.Select(x => x.blindedScript);\n\t\t\t\tvar blindedOutputScriptListBytes = ByteHelpers.Combine(blindedOutputScriptList.Select(x => x.ToBytes()));\n\t\t\t\tvar blindedOutputScriptsHash = new uint256(Hashes.SHA256(blindedOutputScriptListBytes));\n\n\t\t\t\t\/\/ Create 4 new coins that we want to mix\n\t\t\t\tvar inputs = new List<(TxoRef input, byte[] proof, Coin coin, Key key)>();\n\t\t\t\tfor (var inputIdx = 0; inputIdx < 4; inputIdx++)\n\t\t\t\t{\n\t\t\t\t\tvar key = new Key();\n\t\t\t\t\tvar outputAddress = key.PubKey.GetSegwitAddress(network);\n\t\t\t\t\tvar hash = await rpc.SendToAddressAsync(outputAddress, Money.Coins(0.1m));\n\t\t\t\t\tawait rpc.GenerateAsync(1);\n\t\t\t\t\tvar tx = await rpc.GetRawTransactionAsync(hash);\n\t\t\t\t\tvar index = tx.Outputs.FindIndex(x => x.ScriptPubKey == outputAddress.ScriptPubKey);\n\t\t\t\t\tvar input = new OutPoint(hash, index);\n\n\t\t\t\t\tinputs.Add((\n\t\t\t\t\t\tinput.ToTxoRef(),\n\t\t\t\t\t\tkey.SignCompact(blindedOutputScriptsHash),\n\t\t\t\t\t\tnew Coin(tx, (uint)index),\n\t\t\t\t\t\tkey\n\t\t\t\t\t));\n\t\t\t\t}\n\n\t\t\t\t\/\/ Save alice client and the outputs, requesters, etc\n\t\t\t\tvar changeOutput = new Key().PubKey.GetAddress(ScriptPubKeyType.Segwit, network);\n\t\t\t\tvar inputProof = inputs.Select(x => new InputProofModel { Input = x.input, Proof = x.proof }).ToArray();\n\t\t\t\tvar aliceClient = await AliceClient.CreateNewAsync(\n\t\t\t\t\tround.RoundId,\n\t\t\t\t\toutputs.Select(x => x.outputAddress),\n\t\t\t\t\tround.MixingLevels.SchnorrPubKeys,\n\t\t\t\t\toutputs.Select(x => x.requester),\n\t\t\t\t\tnetwork, changeOutput, blindedOutputScriptList, inputProof, baseUri, null);\n\n\t\t\t\t\/\/ We check the coordinator signed all the alice blinded outputs\n\t\t\t\tparticipants.Add((aliceClient, outputs, inputs));\n\t\t\t}\n\n\t\t\t\/\/ CONNECTION CONFIRMATION PHASE --\n\t\t\tvar activeOutputs = new List<IEnumerable<ActiveOutput>>();\n\t\t\tvar j = 0;\n\t\t\tforeach (var (aliceClient, _, _) in participants)\n\t\t\t{\n\t\t\t\tvar res = await aliceClient.PostConfirmationAsync();\n\t\t\t\tactiveOutputs.Add(res.activeOutputs);\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\t\/\/ OUTPUTS REGISTRATION PHASE --\n\t\t\tvar roundState = await satoshiClient.GetRoundStateAsync(roundId);\n\t\t\tAssert.Equal(RoundPhase.OutputRegistration, roundState.Phase);\n\n\t\t\tvar l = 0;\n\t\t\tforeach (var (aliceClient, outputs, _) in participants)\n\t\t\t{\n\t\t\t\tusing (var bobClient = new BobClient(baseUri, null))\n\t\t\t\t{\n\t\t\t\t\tvar i = 0;\n\t\t\t\t\tforeach (var output in outputs.Take(activeOutputs[l].Count()))\n\t\t\t\t\t{\n\t\t\t\t\t\tawait bobClient.PostOutputAsync(aliceClient.RoundId, new ActiveOutput(output.outputAddress, activeOutputs[l].ElementAt(i).Signature, i));\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tl++;\n\t\t\t}\n\n\t\t\t\/\/ SIGNING PHASE --\n\t\t\troundState = await satoshiClient.GetRoundStateAsync(roundId);\n\t\t\tAssert.Equal(RoundPhase.Signing, roundState.Phase);\n\n\t\t\tuint256 transactionId = null;\n\t\t\tforeach (var (aliceClient, outputs, inputs) in participants)\n\t\t\t{\n\t\t\t\tvar unsignedTransaction = await aliceClient.GetUnsignedCoinJoinAsync();\n\t\t\t\ttransactionId = unsignedTransaction.GetHash();\n\n\t\t\t\t\/\/ Verify the transaction contains the expected inputs and outputs\n\n\t\t\t\t\/\/ Verify the inputs are the expected ones.\n\t\t\t\tforeach (var input in inputs)\n\t\t\t\t{\n\t\t\t\t\tAssert.Contains(input.input, unsignedTransaction.Inputs.Select(x => x.PrevOut.ToTxoRef()));\n\t\t\t\t}\n\n\t\t\t\t\/\/ Sign the transaction\n\t\t\t\tvar builder = Network.RegTest.CreateTransactionBuilder();\n\t\t\t\tvar partSignedCj = builder\n\t\t\t\t\t.ContinueToBuild(unsignedTransaction)\n\t\t\t\t\t.AddKeys(inputs.Select(x => x.key).ToArray())\n\t\t\t\t\t.AddCoins(inputs.Select(x => x.coin))\n\t\t\t\t\t.BuildTransaction(true);\n\n\t\t\t\tvar witnesses = partSignedCj.Inputs\n\t\t\t\t\t.AsIndexedInputs()\n\t\t\t\t\t.Where(x => x.WitScript != WitScript.Empty)\n\t\t\t\t\t.ToDictionary(x => (int)x.Index, x => x.WitScript);\n\n\t\t\t\tawait aliceClient.PostSignaturesAsync(witnesses);\n\t\t\t}\n\n\t\t\tuint256[] mempooltxs = await rpc.GetRawMempoolAsync();\n\t\t\tAssert.Contains(transactionId, mempooltxs);\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task NotingTestsAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\tMoney denomination = Money.Coins(1m);\n\t\t\tdecimal coordinatorFeePercent = 0.1m;\n\t\t\tint anonymitySet = 2;\n\t\t\tint connectionConfirmationTimeout = 1;\n\t\t\tbool doesNoteBeforeBan = true;\n\t\t\tCoordinatorRoundConfig roundConfig = RegTestFixture.CreateRoundConfig(denomination, 140, 0.7, coordinatorFeePercent, anonymitySet, 240, connectionConfirmationTimeout, 1, 1, 1, 24, doesNoteBeforeBan, 11);\n\t\t\tawait coordinator.RoundConfig.UpdateOrDefaultAsync(roundConfig, toFile: true);\n\t\t\tcoordinator.AbortAllRoundsInInputRegistration(\"\");\n\n\t\t\tUri baseUri = new Uri(RegTestFixture.BackendEndPoint);\n\n\t\t\tvar registerRequests = new List<(BitcoinWitPubKeyAddress changeOutputAddress, uint256 blindedData, InputProofModel[] inputsProofs)>();\n\t\t\tAliceClient aliceClientBackup = null;\n\t\t\tCoordinatorRound round = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\t\t\tfor (int i = 0; i < roundConfig.AnonymitySet; i++)\n\t\t\t{\n\t\t\t\tBitcoinWitPubKeyAddress activeOutputAddress = new Key().PubKey.GetSegwitAddress(network);\n\t\t\t\tBitcoinWitPubKeyAddress changeOutputAddress = new Key().PubKey.GetSegwitAddress(network);\n\t\t\t\tKey inputKey = new Key();\n\t\t\t\tBitcoinWitPubKeyAddress inputAddress = inputKey.PubKey.GetSegwitAddress(network);\n\n\t\t\t\tvar requester = new Requester();\n\t\t\t\tuint256 blinded = requester.BlindScript(round.MixingLevels.GetBaseLevel().Signer.Key.PubKey, round.MixingLevels.GetBaseLevel().Signer.R.PubKey, activeOutputAddress.ScriptPubKey);\n\t\t\t\tuint256 blindedOutputScriptsHash = new uint256(Hashes.SHA256(blinded.ToBytes()));\n\n\t\t\t\tuint256 txHash = await rpc.SendToAddressAsync(inputAddress, Money.Coins(2));\n\t\t\t\tawait rpc.GenerateAsync(1);\n\t\t\t\tTransaction transaction = await rpc.GetRawTransactionAsync(txHash);\n\t\t\t\tCoin coin = transaction.Outputs.GetCoins(inputAddress.ScriptPubKey).Single();\n\t\t\t\tOutPoint input = coin.Outpoint;\n\n\t\t\t\tInputProofModel inputProof = new InputProofModel { Input = input.ToTxoRef(), Proof = inputKey.SignCompact(blindedOutputScriptsHash) };\n\t\t\t\tInputProofModel[] inputsProofs = new InputProofModel[] { inputProof };\n\t\t\t\tregisterRequests.Add((changeOutputAddress, blinded, inputsProofs));\n\t\t\t\taliceClientBackup = await AliceClient.CreateNewAsync(round.RoundId, new[] { activeOutputAddress }, new[] { round.MixingLevels.GetBaseLevel().SchnorrKey.SchnorrPubKey }, new[] { requester }, network, changeOutputAddress, new[] { blinded }, inputsProofs, baseUri, null);\n\t\t\t}\n\n\t\t\tawait WaitForTimeoutAsync(baseUri);\n\n\t\t\tint bannedCount = coordinator.UtxoReferee.CountBanned(false);\n\t\t\tAssert.Equal(0, bannedCount);\n\t\t\tint notedCount = coordinator.UtxoReferee.CountBanned(true);\n\t\t\tAssert.Equal(anonymitySet, notedCount);\n\n\t\t\tround = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\n\t\t\tforeach (var registerRequest in registerRequests)\n\t\t\t{\n\t\t\t\tawait AliceClient.CreateNewAsync(round.RoundId, aliceClientBackup.RegisteredAddresses, round.MixingLevels.GetAllLevels().Select(x => x.SchnorrKey.SchnorrPubKey), aliceClientBackup.Requesters, network, registerRequest.changeOutputAddress, new[] { registerRequest.blindedData }, registerRequest.inputsProofs, baseUri, null);\n\t\t\t}\n\n\t\t\tawait WaitForTimeoutAsync(baseUri);\n\n\t\t\tbannedCount = coordinator.UtxoReferee.CountBanned(false);\n\t\t\tAssert.Equal(anonymitySet, bannedCount);\n\t\t\tnotedCount = coordinator.UtxoReferee.CountBanned(true);\n\t\t\tAssert.Equal(anonymitySet, notedCount);\n\t\t}\n\n\t\tprivate static async Task WaitForTimeoutAsync(Uri baseUri)\n\t\t{\n\t\t\tusing var satoshiClient = new SatoshiClient(baseUri, null);\n\t\t\tvar times = 0;\n\t\t\twhile (!(await satoshiClient.GetAllRoundStatesAsync()).All(x => x.Phase == RoundPhase.InputRegistration))\n\t\t\t{\n\t\t\t\tawait Task.Delay(100);\n\t\t\t\tif (times > 50) \/\/ 5 sec, 3 should be enough\n\t\t\t\t{\n\t\t\t\t\tthrow new TimeoutException(\"Not all rounds were in InputRegistration.\");\n\t\t\t\t}\n\t\t\t\ttimes++;\n\t\t\t}\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task BanningTestsAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\tMoney denomination = Money.Coins(0.1m);\n\t\t\tdecimal coordinatorFeePercent = 0.1m;\n\t\t\tint anonymitySet = 3;\n\t\t\tint connectionConfirmationTimeout = 120;\n\t\t\tvar roundConfig = RegTestFixture.CreateRoundConfig(denomination, 140, 0.7, coordinatorFeePercent, anonymitySet, 240, connectionConfirmationTimeout, 1, 1, 1, 24, true, 11);\n\t\t\tawait coordinator.RoundConfig.UpdateOrDefaultAsync(roundConfig, toFile: true);\n\t\t\tcoordinator.AbortAllRoundsInInputRegistration(\"\");\n\n\t\t\tawait rpc.GenerateAsync(3); \/\/ So to make sure we have enough money.\n\n\t\t\tUri baseUri = new Uri(RegTestFixture.BackendEndPoint);\n\t\t\tvar fundingTxCount = 0;\n\t\t\tvar inputRegistrationUsers = new List<(Requester requester, uint256 blinded, BitcoinAddress activeOutputAddress, BitcoinAddress changeOutputAddress, IEnumerable<InputProofModel> inputProofModels, List<(Key key, BitcoinWitPubKeyAddress address, uint256 txHash, Transaction tx, OutPoint input)> userInputData)>();\n\t\t\tCoordinatorRound round = null;\n\t\t\tfor (int i = 0; i < roundConfig.AnonymitySet; i++)\n\t\t\t{\n\t\t\t\tvar userInputData = new List<(Key key, BitcoinWitPubKeyAddress inputAddress, uint256 txHash, Transaction tx, OutPoint input)>();\n\t\t\t\tvar activeOutputAddress = new Key().PubKey.GetAddress(ScriptPubKeyType.Segwit, network);\n\t\t\t\tvar changeOutputAddress = new Key().PubKey.GetAddress(ScriptPubKeyType.Segwit, network);\n\t\t\t\tround = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\t\t\t\tRequester requester = new Requester();\n\t\t\t\tuint256 blinded = requester.BlindScript(round.MixingLevels.GetBaseLevel().Signer.Key.PubKey, round.MixingLevels.GetBaseLevel().Signer.R.PubKey, activeOutputAddress.ScriptPubKey);\n\t\t\t\tuint256 blindedOutputScriptsHash = new uint256(Hashes.SHA256(blinded.ToBytes()));\n\n\t\t\t\tvar inputProofModels = new List<InputProofModel>();\n\t\t\t\tint numberOfInputs = new Random().Next(1, 7);\n\t\t\t\tvar receiveSatoshiSum = 0;\n\t\t\t\tfor (int j = 0; j < numberOfInputs; j++)\n\t\t\t\t{\n\t\t\t\t\tvar key = new Key();\n\t\t\t\t\tvar receiveSatoshi = new Random().Next(1000, 100000000);\n\t\t\t\t\treceiveSatoshiSum += receiveSatoshi;\n\t\t\t\t\tif (j == numberOfInputs - 1)\n\t\t\t\t\t{\n\t\t\t\t\t\treceiveSatoshi = 100000000;\n\t\t\t\t\t}\n\t\t\t\t\tBitcoinWitPubKeyAddress inputAddress = key.PubKey.GetSegwitAddress(network);\n\t\t\t\t\tuint256 txHash = await rpc.SendToAddressAsync(inputAddress, Money.Satoshis(receiveSatoshi));\n\t\t\t\t\tfundingTxCount++;\n\t\t\t\t\tAssert.NotNull(txHash);\n\t\t\t\t\tTransaction transaction = await rpc.GetRawTransactionAsync(txHash);\n\n\t\t\t\t\tvar coin = transaction.Outputs.GetCoins(inputAddress.ScriptPubKey).Single();\n\n\t\t\t\t\tOutPoint input = coin.Outpoint;\n\t\t\t\t\tvar inputProof = new InputProofModel { Input = input.ToTxoRef(), Proof = key.SignCompact(blindedOutputScriptsHash) };\n\t\t\t\t\tinputProofModels.Add(inputProof);\n\n\t\t\t\t\tGetTxOutResponse getTxOutResponse = await rpc.GetTxOutAsync(input.Hash, (int)input.N, includeMempool: true);\n\t\t\t\t\t\/\/ Check if inputs are unspent.\n\t\t\t\t\tAssert.NotNull(getTxOutResponse);\n\n\t\t\t\t\tuserInputData.Add((key, inputAddress, txHash, transaction, input));\n\t\t\t\t}\n\n\t\t\t\tinputRegistrationUsers.Add((requester, blinded, activeOutputAddress, changeOutputAddress, inputProofModels, userInputData));\n\t\t\t}\n\n\t\t\tvar mempool = await rpc.GetRawMempoolAsync();\n\t\t\tAssert.Equal(inputRegistrationUsers.SelectMany(x => x.userInputData).Count(), mempool.Length);\n\n\t\t\twhile ((await rpc.GetRawMempoolAsync()).Length != 0)\n\t\t\t{\n\t\t\t\tawait rpc.GenerateAsync(1);\n\t\t\t}\n\n\t\t\tvar aliceClients = new List<Task<AliceClient>>();\n\n\t\t\tforeach (var user in inputRegistrationUsers)\n\t\t\t{\n\t\t\t\taliceClients.Add(AliceClient.CreateNewAsync(round.RoundId, new[] { user.activeOutputAddress }, new[] { round.MixingLevels.GetBaseLevel().SchnorrKey.SchnorrPubKey }, new[] { user.requester }, network, user.changeOutputAddress, new[] { user.blinded }, user.inputProofModels, baseUri, null));\n\t\t\t}\n\n\t\t\tlong roundId = 0;\n\t\t\tvar users = new List<(Requester requester, uint256 blinded, BitcoinAddress activeOutputAddress, BitcoinAddress changeOutputAddress, IEnumerable<InputProofModel> inputProofModels, List<(Key key, BitcoinWitPubKeyAddress address, uint256 txHash, Transaction tx, OutPoint input)> userInputData, AliceClient aliceClient, UnblindedSignature unblindedSignature)>();\n\t\t\tfor (int i = 0; i < inputRegistrationUsers.Count; i++)\n\t\t\t{\n\t\t\t\tvar user = inputRegistrationUsers[i];\n\t\t\t\tvar request = aliceClients[i];\n\n\t\t\t\tvar aliceClient = await request;\n\n\t\t\t\tif (roundId == 0)\n\t\t\t\t{\n\t\t\t\t\troundId = aliceClient.RoundId;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(roundId, aliceClient.RoundId);\n\t\t\t\t}\n\t\t\t\t\/\/ Because it's valuetuple.\n\t\t\t\tusers.Add((user.requester, user.blinded, user.activeOutputAddress, user.changeOutputAddress, user.inputProofModels, user.userInputData, aliceClient, null));\n\t\t\t}\n\n\t\t\tAssert.Equal(users.Count, roundConfig.AnonymitySet);\n\n\t\t\tvar confirmationRequests = new List<Task<(RoundPhase currentPhase, IEnumerable<ActiveOutput>)>>();\n\n\t\t\tforeach (var user in users)\n\t\t\t{\n\t\t\t\tconfirmationRequests.Add(user.aliceClient.PostConfirmationAsync());\n\t\t\t}\n\n\t\t\tRoundPhase roundPhase = RoundPhase.InputRegistration;\n\t\t\tint k = 0;\n\t\t\tforeach (var request in confirmationRequests)\n\t\t\t{\n\t\t\t\tvar resp = await request;\n\t\t\t\tif (roundPhase == RoundPhase.InputRegistration)\n\t\t\t\t{\n\t\t\t\t\troundPhase = resp.currentPhase;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(roundPhase, resp.currentPhase);\n\t\t\t\t}\n\n\t\t\t\tvar user = users.ElementAt(k);\n\t\t\t\tuser.unblindedSignature = resp.Item2.First().Signature;\n\t\t\t}\n\n\t\t\tusing (var satoshiClient = new SatoshiClient(baseUri, null))\n\t\t\t{\n\t\t\t\tvar times = 0;\n\t\t\t\twhile (!(await satoshiClient.GetAllRoundStatesAsync()).All(x => x.Phase == RoundPhase.InputRegistration))\n\t\t\t\t{\n\t\t\t\t\tawait Task.Delay(100);\n\t\t\t\t\tif (times > 50) \/\/ 5 sec, 3 should be enough\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new TimeoutException(\"Not all rounds were in InputRegistration.\");\n\t\t\t\t\t}\n\t\t\t\t\ttimes++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint bannedCount = coordinator.UtxoReferee.CountBanned(false);\n\t\t\tAssert.Equal(0, bannedCount);\n\n\t\t\taliceClients.Clear();\n\t\t\tround = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\t\t\tforeach (var user in inputRegistrationUsers)\n\t\t\t{\n\t\t\t\taliceClients.Add(AliceClient.CreateNewAsync(round.RoundId, new[] { user.activeOutputAddress }, new[] { round.MixingLevels.GetBaseLevel().SchnorrKey.SchnorrPubKey }, new[] { user.requester }, network, user.changeOutputAddress, new[] { user.blinded }, user.inputProofModels, baseUri, null));\n\t\t\t}\n\n\t\t\troundId = 0;\n\t\t\tusers = new List<(Requester requester, uint256 blinded, BitcoinAddress activeOutputAddress, BitcoinAddress changeOutputAddress, IEnumerable<InputProofModel> inputProofModels, List<(Key key, BitcoinWitPubKeyAddress address, uint256 txHash, Transaction tx, OutPoint input)> userInputData, AliceClient aliceClient, UnblindedSignature unblindedSignature)>();\n\t\t\tfor (int i = 0; i < inputRegistrationUsers.Count; i++)\n\t\t\t{\n\t\t\t\tvar user = inputRegistrationUsers[i];\n\t\t\t\tvar request = aliceClients[i];\n\n\t\t\t\tvar aliceClient = await request;\n\t\t\t\tif (roundId == 0)\n\t\t\t\t{\n\t\t\t\t\troundId = aliceClient.RoundId;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(roundId, aliceClient.RoundId);\n\t\t\t\t}\n\t\t\t\t\/\/ Because it's valuetuple.\n\t\t\t\tusers.Add((user.requester, user.blinded, user.activeOutputAddress, user.changeOutputAddress, user.inputProofModels, user.userInputData, aliceClient, null));\n\t\t\t}\n\n\t\t\tAssert.Equal(users.Count, roundConfig.AnonymitySet);\n\n\t\t\tconfirmationRequests = new List<Task<(RoundPhase currentPhase, IEnumerable<ActiveOutput>)>>();\n\n\t\t\tforeach (var user in users)\n\t\t\t{\n\t\t\t\tconfirmationRequests.Add(user.aliceClient.PostConfirmationAsync());\n\t\t\t}\n\n\t\t\tusing (var satoshiClient = new SatoshiClient(baseUri, null))\n\t\t\t{\n\t\t\t\tvar times = 0;\n\t\t\t\twhile (!(await satoshiClient.GetAllRoundStatesAsync()).All(x => x.Phase == RoundPhase.InputRegistration))\n\t\t\t\t{\n\t\t\t\t\tawait Task.Delay(100);\n\t\t\t\t\tif (times > 50) \/\/ 5 sec, 3 should be enough\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new TimeoutException(\"Not all rounds were in InputRegistration.\");\n\t\t\t\t\t}\n\t\t\t\t\ttimes++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbannedCount = coordinator.UtxoReferee.CountBanned(false);\n\t\t\tAssert.True(bannedCount >= roundConfig.AnonymitySet);\n\n\t\t\tforeach (var aliceClient in aliceClients)\n\t\t\t{\n\t\t\t\taliceClient?.Dispose();\n\t\t\t}\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task Ccj100ParticipantsTestsAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\tMoney denomination = Money.Coins(0.1m);\n\t\t\tdecimal coordinatorFeePercent = 0.003m;\n\t\t\tint anonymitySet = 100;\n\t\t\tint connectionConfirmationTimeout = 120;\n\t\t\tvar roundConfig = RegTestFixture.CreateRoundConfig(denomination, Constants.OneDayConfirmationTarget, 0.7, coordinatorFeePercent, anonymitySet, 240, connectionConfirmationTimeout, 50, 50, 1, 24, true, 11);\n\t\t\tawait coordinator.RoundConfig.UpdateOrDefaultAsync(roundConfig, toFile: true);\n\t\t\tcoordinator.AbortAllRoundsInInputRegistration(\"\");\n\t\t\tawait rpc.GenerateAsync(100); \/\/ So to make sure we have enough money.\n\n\t\t\tUri baseUri = new Uri(RegTestFixture.BackendEndPoint);\n\t\t\tvar spentCoins = new List<Coin>();\n\t\t\tvar fundingTxCount = 0;\n\t\t\tvar inputRegistrationUsers = new List<(Requester requester, uint256 blinded, BitcoinAddress activeOutputAddress, BitcoinAddress changeOutputAddress, IEnumerable<InputProofModel> inputProofModels, List<(Key key, BitcoinWitPubKeyAddress address, uint256 txHash, Transaction tx, OutPoint input)> userInputData)>();\n\t\t\tfor (int i = 0; i < roundConfig.AnonymitySet; i++)\n\t\t\t{\n\t\t\t\tvar userInputData = new List<(Key key, BitcoinWitPubKeyAddress inputAddress, uint256 txHash, Transaction tx, OutPoint input)>();\n\t\t\t\tvar activeOutputAddress = new Key().PubKey.GetAddress(ScriptPubKeyType.Segwit, network);\n\t\t\t\tvar changeOutputAddress = new Key().PubKey.GetAddress(ScriptPubKeyType.Segwit, network);\n\t\t\t\tCoordinatorRound round = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\t\t\t\tvar requester = new Requester();\n\t\t\t\tuint256 blinded = requester.BlindScript(round.MixingLevels.GetBaseLevel().Signer.Key.PubKey, round.MixingLevels.GetBaseLevel().Signer.R.PubKey, activeOutputAddress.ScriptPubKey);\n\t\t\t\tuint256 blindedOutputScriptsHash = new uint256(Hashes.SHA256(blinded.ToBytes()));\n\n\t\t\t\tvar inputProofModels = new List<InputProofModel>();\n\t\t\t\tint numberOfInputs = new Random().Next(1, 7);\n\t\t\t\tvar receiveSatoshiSum = 0;\n\t\t\t\tfor (int j = 0; j < numberOfInputs; j++)\n\t\t\t\t{\n\t\t\t\t\tvar key = new Key();\n\t\t\t\t\tvar receiveSatoshi = new Random().Next(1000, 100000000);\n\t\t\t\t\treceiveSatoshiSum += receiveSatoshi;\n\t\t\t\t\tif (j == numberOfInputs - 1)\n\t\t\t\t\t{\n\t\t\t\t\t\treceiveSatoshi = 100000000;\n\t\t\t\t\t}\n\t\t\t\t\tBitcoinWitPubKeyAddress inputAddress = key.PubKey.GetSegwitAddress(network);\n\t\t\t\t\tuint256 txHash = await rpc.SendToAddressAsync(inputAddress, Money.Satoshis(receiveSatoshi));\n\t\t\t\t\tfundingTxCount++;\n\t\t\t\t\tAssert.NotNull(txHash);\n\t\t\t\t\tTransaction transaction = await rpc.GetRawTransactionAsync(txHash);\n\n\t\t\t\t\tvar coin = transaction.Outputs.GetCoins(inputAddress.ScriptPubKey).Single();\n\t\t\t\t\tspentCoins.Add(coin);\n\n\t\t\t\t\tOutPoint input = coin.Outpoint;\n\t\t\t\t\tvar inputProof = new InputProofModel { Input = input.ToTxoRef(), Proof = key.SignCompact(blindedOutputScriptsHash) };\n\t\t\t\t\tinputProofModels.Add(inputProof);\n\n\t\t\t\t\tGetTxOutResponse getTxOutResponse = await rpc.GetTxOutAsync(input.Hash, (int)input.N, includeMempool: true);\n\t\t\t\t\t\/\/ Check if inputs are unspent.\n\t\t\t\t\tAssert.NotNull(getTxOutResponse);\n\n\t\t\t\t\tuserInputData.Add((key, inputAddress, txHash, transaction, input));\n\t\t\t\t}\n\n\t\t\t\tinputRegistrationUsers.Add((requester, blinded, activeOutputAddress, changeOutputAddress, inputProofModels, userInputData));\n\t\t\t}\n\n\t\t\tvar mempool = await rpc.GetRawMempoolAsync();\n\t\t\tAssert.Equal(inputRegistrationUsers.SelectMany(x => x.userInputData).Count(), mempool.Length);\n\n\t\t\twhile ((await rpc.GetRawMempoolAsync()).Length != 0)\n\t\t\t{\n\t\t\t\tawait rpc.GenerateAsync(1);\n\t\t\t}\n\n\t\t\tLogger.TurnOff();\n\n\t\t\tvar aliceClients = new List<Task<AliceClient>>();\n\n\t\t\tvar currentRound = coordinator.GetCurrentInputRegisterableRoundOrDefault();\n\n\t\t\tforeach (var user in inputRegistrationUsers)\n\t\t\t{\n\t\t\t\taliceClients.Add(AliceClient.CreateNewAsync(currentRound.RoundId, new[] { user.activeOutputAddress }, currentRound.MixingLevels.SchnorrPubKeys, new[] { user.requester }, network, user.changeOutputAddress, new[] { user.blinded }, user.inputProofModels, baseUri, null));\n\t\t\t}\n\n\t\t\tlong roundId = 0;\n\t\t\tvar users = new List<(Requester requester, uint256 blinded, BitcoinAddress activeOutputAddress, BitcoinAddress changeOutputAddress, IEnumerable<InputProofModel> inputProofModels, List<(Key key, BitcoinWitPubKeyAddress address, uint256 txHash, Transaction tx, OutPoint input)> userInputData, AliceClient aliceClient, UnblindedSignature unblindedSignature)>();\n\t\t\tfor (int i = 0; i < inputRegistrationUsers.Count; i++)\n\t\t\t{\n\t\t\t\tvar user = inputRegistrationUsers[i];\n\t\t\t\tvar request = aliceClients[i];\n\n\t\t\t\tvar aliceClient = await request;\n\t\t\t\tif (roundId == 0)\n\t\t\t\t{\n\t\t\t\t\troundId = aliceClient.RoundId;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(roundId, aliceClient.RoundId);\n\t\t\t\t}\n\t\t\t\t\/\/ Because it's valuetuple.\n\t\t\t\tusers.Add((user.requester, user.blinded, user.activeOutputAddress, user.changeOutputAddress, user.inputProofModels, user.userInputData, aliceClient, null));\n\t\t\t}\n\n\t\t\tLogger.TurnOn();\n\n\t\t\tAssert.Equal(users.Count, roundConfig.AnonymitySet);\n\t\t\tvar confirmationRequests = new List<Task<(RoundPhase currentPhase, IEnumerable<ActiveOutput>)>>();\n\n\t\t\tforeach (var user in users)\n\t\t\t{\n\t\t\t\tconfirmationRequests.Add(user.aliceClient.PostConfirmationAsync());\n\t\t\t}\n\n\t\t\tRoundPhase roundPhase = RoundPhase.InputRegistration;\n\t\t\tint k = 0;\n\t\t\tforeach (var request in confirmationRequests)\n\t\t\t{\n\t\t\t\tvar resp = await request;\n\t\t\t\tif (roundPhase == RoundPhase.InputRegistration)\n\t\t\t\t{\n\t\t\t\t\troundPhase = resp.currentPhase;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(roundPhase, resp.currentPhase);\n\t\t\t\t}\n\n\t\t\t\t\/\/ Because it's valuetuple.\n\t\t\t\tvar user = users.ElementAt(k);\n\t\t\t\tusers.RemoveAt(k);\n\t\t\t\tusers.Add((user.requester, user.blinded, user.activeOutputAddress, user.changeOutputAddress, user.inputProofModels, user.userInputData, user.aliceClient, resp.Item2.First().Signature));\n\t\t\t}\n\n\t\t\tvar outputRequests = new List<(BobClient, Task)>();\n\t\t\tforeach (var user in users)\n\t\t\t{\n\t\t\t\tvar bobClient = new BobClient(baseUri, null);\n\t\t\t\toutputRequests.Add((bobClient, bobClient.PostOutputAsync(roundId, new ActiveOutput(user.activeOutputAddress, user.unblindedSignature, 0))));\n\t\t\t}\n\n\t\t\tforeach (var request in outputRequests)\n\t\t\t{\n\t\t\t\tawait request.Item2;\n\t\t\t\trequest.Item1?.Dispose();\n\t\t\t}\n\n\t\t\tvar coinjoinRequests = new List<Task<Transaction>>();\n\t\t\tforeach (var user in users)\n\t\t\t{\n\t\t\t\tcoinjoinRequests.Add(user.aliceClient.GetUnsignedCoinJoinAsync());\n\t\t\t}\n\n\t\t\tTransaction unsignedCoinJoin = null;\n\t\t\tforeach (var request in coinjoinRequests)\n\t\t\t{\n\t\t\t\tif (unsignedCoinJoin is null)\n\t\t\t\t{\n\t\t\t\t\tunsignedCoinJoin = await request;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAssert.Equal(unsignedCoinJoin.ToHex(), (await request).ToHex());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar signatureRequests = new List<Task>();\n\t\t\tforeach (var user in users)\n\t\t\t{\n\t\t\t\tvar partSignedCj = Transaction.Parse(unsignedCoinJoin.ToHex(), network);\n\t\t\t\tpartSignedCj = Network.RegTest.CreateTransactionBuilder()\n\t\t\t\t\t\t\t.ContinueToBuild(partSignedCj)\n\t\t\t\t\t\t\t.AddKeys(user.userInputData.Select(x => x.key).ToArray())\n\t\t\t\t\t\t\t.AddCoins(user.userInputData.Select(x => new Coin(x.tx, x.input.N)).ToArray())\n\t\t\t\t\t\t\t.BuildTransaction(true);\n\n\t\t\t\tvar myDic = new Dictionary<int, WitScript>();\n\n\t\t\t\tlong previousAmount = -1;\n\t\t\t\tfor (int i = 0; i < unsignedCoinJoin.Inputs.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tvar input = unsignedCoinJoin.Inputs[i];\n\t\t\t\t\tlong currentAmount = spentCoins.Single(x => x.Outpoint == unsignedCoinJoin.Inputs[i].PrevOut).Amount;\n\t\t\t\t\tAssert.True(previousAmount <= currentAmount);\n\t\t\t\t\tpreviousAmount = currentAmount;\n\t\t\t\t\tif (user.userInputData.Select(x => x.input).Contains(input.PrevOut))\n\t\t\t\t\t{\n\t\t\t\t\t\tmyDic.Add(i, partSignedCj.Inputs[i].WitScript);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsignatureRequests.Add(user.aliceClient.PostSignaturesAsync(myDic));\n\t\t\t}\n\n\t\t\tawait Task.WhenAll(signatureRequests);\n\n\t\t\tuint256[] mempooltxs = await rpc.GetRawMempoolAsync();\n\t\t\tAssert.Contains(unsignedCoinJoin.GetHash(), mempooltxs);\n\n\t\t\tvar coins = new List<Coin>();\n\t\t\tvar finalCoinjoin = await rpc.GetRawTransactionAsync(mempooltxs.First());\n\t\t\tforeach (var input in finalCoinjoin.Inputs)\n\t\t\t{\n\t\t\t\tvar getTxOut = await rpc.GetTxOutAsync(input.PrevOut.Hash, (int)input.PrevOut.N, includeMempool: false);\n\n\t\t\t\tcoins.Add(new Coin(input.PrevOut.Hash, input.PrevOut.N, getTxOut.TxOut.Value, getTxOut.TxOut.ScriptPubKey));\n\t\t\t}\n\n\t\t\tFeeRate feeRateTx = finalCoinjoin.GetFeeRate(coins.ToArray());\n\t\t\tvar esr = await rpc.EstimateSmartFeeAsync(roundConfig.ConfirmationTarget, EstimateSmartFeeMode.Conservative, simulateIfRegTest: true, tryOtherFeeRates: true);\n\t\t\tFeeRate feeRateReal = esr.FeeRate;\n\n\t\t\tAssert.True(feeRateReal.FeePerK - (feeRateReal.FeePerK \/ 2) < feeRateTx.FeePerK); \/\/ Max 50% mistake.\n\t\t\tAssert.True(2 * feeRateReal.FeePerK > feeRateTx.FeePerK); \/\/ Max 200% mistake.\n\n\t\t\tvar activeOutput = finalCoinjoin.GetIndistinguishableOutputs(includeSingle: true).OrderByDescending(x => x.count).First();\n\t\t\tAssert.True(activeOutput.value >= roundConfig.Denomination);\n\t\t\tAssert.True(activeOutput.count >= roundConfig.AnonymitySet);\n\n\t\t\tforeach (var aliceClient in aliceClients)\n\t\t\t{\n\t\t\t\taliceClient?.Dispose();\n\t\t\t}\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task CcjFeeTestsAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\tvar synchronizer = new WasabiSynchronizer(network, bitcoinStore, new Uri(RegTestFixture.BackendEndPoint), null);\n\t\t\tsynchronizer.Start(requestInterval: TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(5), 10000); \/\/ Start wasabi synchronizer service.\n\n\t\t\tMoney denomination = Money.Coins(0.9m);\n\t\t\tdecimal coordinatorFeePercent = 0.1m;\n\t\t\tint anonymitySet = 7;\n\t\t\tint connectionConfirmationTimeout = 14;\n\t\t\tvar roundConfig = RegTestFixture.CreateRoundConfig(denomination, 140, 0.7, coordinatorFeePercent, anonymitySet, 240, connectionConfirmationTimeout, 50, 50, 1, 24, true, 11);\n\t\t\tawait coordinator.RoundConfig.UpdateOrDefaultAsync(roundConfig, toFile: true);\n\t\t\tcoordinator.AbortAllRoundsInInputRegistration(\"\");\n\n\t\t\tvar participants = new List<dynamic>();\n\n\t\t\t\/\/ 1. Prepare and start services.\n\t\t\tfor (int i = 0; i < anonymitySet; i++)\n\t\t\t{\n\t\t\t\tdouble damount = i switch\n\t\t\t\t{\n\t\t\t\t\t0 => 1,\n\t\t\t\t\t1 => 1.1,\n\t\t\t\t\t2 => 1.2,\n\t\t\t\t\t3 => 3.1,\n\t\t\t\t\t4 => 4.1,\n\t\t\t\t\t5 => 7.1,\n\t\t\t\t\t6 => 8.1,\n\t\t\t\t\t_ => 1\n\t\t\t\t};\n\n\t\t\t\tvar amount = Money.Coins((decimal)damount);\n\n\t\t\t\tvar keyManager = KeyManager.CreateNew(out _, password);\n\t\t\t\tvar key = keyManager.GenerateNewKey(\"foo\", KeyState.Clean, false);\n\t\t\t\tvar bech = key.GetP2wpkhAddress(network);\n\t\t\t\tvar txId = await rpc.SendToAddressAsync(bech, amount, replaceable: false);\n\t\t\t\tkey.SetKeyState(KeyState.Used);\n\t\t\t\tvar tx = await rpc.GetRawTransactionAsync(txId);\n\t\t\t\tvar height = await rpc.GetBlockCountAsync();\n\t\t\t\tvar bechCoin = tx.Outputs.GetCoins(bech.ScriptPubKey).Single();\n\n\t\t\t\tvar smartCoin = new SmartCoin(bechCoin, tx.Inputs.Select(x => new TxoRef(x.PrevOut)).ToArray(), height + 1, replaceable: false, anonymitySet: tx.GetAnonymitySet(bechCoin.Outpoint.N), isLikelyCoinJoinOutput: false);\n\n\t\t\t\tvar chaumianClient = new CoinJoinClient(synchronizer, rpc.Network, keyManager, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\t\tparticipants.Add((smartCoin, chaumianClient));\n\t\t\t}\n\n\t\t\tawait rpc.GenerateAsync(1);\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\t\/\/ 2. Start mixing.\n\t\t\t\tforeach (var participant in participants)\n\t\t\t\t{\n\t\t\t\t\tSmartCoin coin = participant.Item1;\n\n\t\t\t\t\tCoinJoinClient chaumianClient = participant.Item2;\n\t\t\t\t\tchaumianClient.Start();\n\n\t\t\t\t\tawait chaumianClient.QueueCoinsToMixAsync(password, coin);\n\t\t\t\t}\n\n\t\t\t\tTask timeout = Task.Delay(TimeSpan.FromSeconds(connectionConfirmationTimeout * 2 + 7 * 2 + 7 * 2 + 7 * 2));\n\t\t\t\twhile ((await rpc.GetRawMempoolAsync()).Length == 0)\n\t\t\t\t{\n\t\t\t\t\tif (timeout.IsCompletedSuccessfully)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new TimeoutException(\"CoinJoin was not propagated.\");\n\t\t\t\t\t}\n\n\t\t\t\t\tawait Task.Delay(1000);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tforeach (var participant in participants)\n\t\t\t\t{\n\t\t\t\t\tSmartCoin coin = participant.Item1;\n\t\t\t\t\tCoinJoinClient chaumianClient = participant.Item2;\n\n\t\t\t\t\tTask timeout = Task.Delay(3000);\n\t\t\t\t\twhile (chaumianClient.State.GetActivelyMixingRounds().Any())\n\t\t\t\t\t{\n\t\t\t\t\t\tif (timeout.IsCompletedSuccessfully)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthrow new TimeoutException(\"CoinJoin was not noticed.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tawait Task.Delay(1000);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (chaumianClient != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tawait chaumianClient.DequeueAllCoinsFromMixAsync(DequeueReason.UserRequested);\n\t\t\t\t\t\tawait chaumianClient.StopAsync();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task CoinJoinClientTestsAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(1);\n\n\t\t\tvar synchronizer = new WasabiSynchronizer(network, bitcoinStore, new Uri(RegTestFixture.BackendEndPoint), null);\n\t\t\tsynchronizer.Start(requestInterval: TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(5), 10000); \/\/ Start wasabi synchronizer service.\n\n\t\t\tMoney denomination = Money.Coins(0.1m);\n\t\t\tdecimal coordinatorFeePercent = 0.1m;\n\t\t\tint anonymitySet = 2;\n\t\t\tint connectionConfirmationTimeout = 14;\n\t\t\tvar roundConfig = RegTestFixture.CreateRoundConfig(denomination, 140, 0.7, coordinatorFeePercent, anonymitySet, 240, connectionConfirmationTimeout, 50, 50, 1, 24, true, 11);\n\t\t\tawait coordinator.RoundConfig.UpdateOrDefaultAsync(roundConfig, toFile: true);\n\t\t\tcoordinator.AbortAllRoundsInInputRegistration(\"\");\n\t\t\tawait rpc.GenerateAsync(3); \/\/ So to make sure we have enough money.\n\t\t\tvar keyManager = KeyManager.CreateNew(out _, password);\n\t\t\tvar key1 = keyManager.GenerateNewKey(\"foo\", KeyState.Clean, false);\n\t\t\tvar key2 = keyManager.GenerateNewKey(\"bar\", KeyState.Clean, false);\n\t\t\tvar key3 = keyManager.GenerateNewKey(\"baz\", KeyState.Clean, false);\n\t\t\tvar key4 = keyManager.GenerateNewKey(\"qux\", KeyState.Clean, false);\n\t\t\tvar bech1 = key1.GetP2wpkhAddress(network);\n\t\t\tvar bech2 = key2.GetP2wpkhAddress(network);\n\t\t\tvar bech3 = key3.GetP2wpkhAddress(network);\n\t\t\tvar bech4 = key4.GetP2wpkhAddress(network);\n\t\t\tvar amount1 = Money.Coins(0.03m);\n\t\t\tvar amount2 = Money.Coins(0.08m);\n\t\t\tvar amount3 = Money.Coins(0.3m);\n\t\t\tvar amount4 = Money.Coins(0.4m);\n\t\t\tvar txId1 = await rpc.SendToAddressAsync(bech1, amount1, replaceable: false);\n\t\t\tvar txId2 = await rpc.SendToAddressAsync(bech2, amount2, replaceable: false);\n\t\t\tvar txId3 = await rpc.SendToAddressAsync(bech3, amount3, replaceable: false);\n\t\t\tvar txId4 = await rpc.SendToAddressAsync(bech4, amount4, replaceable: false);\n\t\t\tkey1.SetKeyState(KeyState.Used);\n\t\t\tkey2.SetKeyState(KeyState.Used);\n\t\t\tkey3.SetKeyState(KeyState.Used);\n\t\t\tkey4.SetKeyState(KeyState.Used);\n\t\t\tvar tx1 = await rpc.GetRawTransactionAsync(txId1);\n\t\t\tvar tx2 = await rpc.GetRawTransactionAsync(txId2);\n\t\t\tvar tx3 = await rpc.GetRawTransactionAsync(txId3);\n\t\t\tvar tx4 = await rpc.GetRawTransactionAsync(txId4);\n\t\t\tawait rpc.GenerateAsync(1);\n\t\t\tvar height = await rpc.GetBlockCountAsync();\n\t\t\tvar bech1Coin = tx1.Outputs.GetCoins(bech1.ScriptPubKey).Single();\n\t\t\tvar bech2Coin = tx2.Outputs.GetCoins(bech2.ScriptPubKey).Single();\n\t\t\tvar bech3Coin = tx3.Outputs.GetCoins(bech3.ScriptPubKey).Single();\n\t\t\tvar bech4Coin = tx4.Outputs.GetCoins(bech4.ScriptPubKey).Single();\n\n\t\t\tvar smartCoin1 = new SmartCoin(bech1Coin, tx1.Inputs.Select(x => new TxoRef(x.PrevOut)).ToArray(), height, replaceable: false, anonymitySet: tx1.GetAnonymitySet(bech1Coin.Outpoint.N), isLikelyCoinJoinOutput: false);\n\t\t\tvar smartCoin2 = new SmartCoin(bech2Coin, tx2.Inputs.Select(x => new TxoRef(x.PrevOut)).ToArray(), height, replaceable: false, anonymitySet: tx2.GetAnonymitySet(bech2Coin.Outpoint.N), isLikelyCoinJoinOutput: false);\n\t\t\tvar smartCoin3 = new SmartCoin(bech3Coin, tx3.Inputs.Select(x => new TxoRef(x.PrevOut)).ToArray(), height, replaceable: false, anonymitySet: tx3.GetAnonymitySet(bech3Coin.Outpoint.N), isLikelyCoinJoinOutput: false);\n\t\t\tvar smartCoin4 = new SmartCoin(bech4Coin, tx4.Inputs.Select(x => new TxoRef(x.PrevOut)).ToArray(), height, replaceable: false, anonymitySet: tx4.GetAnonymitySet(bech4Coin.Outpoint.N), isLikelyCoinJoinOutput: false);\n\n\t\t\tvar chaumianClient1 = new CoinJoinClient(synchronizer, rpc.Network, keyManager, new Uri(RegTestFixture.BackendEndPoint), null);\n\t\t\tvar chaumianClient2 = new CoinJoinClient(synchronizer, rpc.Network, keyManager, new Uri(RegTestFixture.BackendEndPoint), null);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tchaumianClient1.Start(); \/\/ Exactly delay it for 2 seconds, this will make sure of timeout later.\n\t\t\t\tchaumianClient2.Start();\n\n\t\t\t\tsmartCoin1.CoinJoinInProgress = true;\n\t\t\t\tAssert.False((await chaumianClient1.QueueCoinsToMixAsync(password, smartCoin1)).Any()); \/\/ Inconsistent internal state, so do not try to add.\n\t\t\t\tAssert.True(smartCoin1.CoinJoinInProgress);\n\n\t\t\t\tawait Assert.ThrowsAsync<SecurityException>(async () => await chaumianClient1.QueueCoinsToMixAsync(\"asdasdasd\", smartCoin1, smartCoin2));\n\t\t\t\tAssert.True(smartCoin1.CoinJoinInProgress);\n\t\t\t\tAssert.False(smartCoin2.CoinJoinInProgress);\n\t\t\t\tsmartCoin1.CoinJoinInProgress = false;\n\n\t\t\t\tawait chaumianClient1.QueueCoinsToMixAsync(password, smartCoin1, smartCoin2);\n\t\t\t\tAssert.True(smartCoin1.CoinJoinInProgress);\n\t\t\t\tAssert.True(smartCoin2.CoinJoinInProgress);\n\n\t\t\t\t\/\/ Make sure it does not throw.\n\t\t\t\tawait chaumianClient1.DequeueCoinsFromMixAsync(new SmartCoin((network.Consensus.ConsensusFactory.CreateTransaction()).GetHash(), 1, new Script(), Money.Parse(\"3\"), new TxoRef[] { new TxoRef((network.Consensus.ConsensusFactory.CreateTransaction()).GetHash(), 0) }, Height.Mempool, replaceable: false, anonymitySet: 1, isLikelyCoinJoinOutput: false), DequeueReason.UserRequested);\n\n\t\t\t\tAssert.True(2 == (await chaumianClient1.QueueCoinsToMixAsync(password, smartCoin1, smartCoin2)).Count());\n\t\t\t\tawait chaumianClient1.DequeueCoinsFromMixAsync(smartCoin1, DequeueReason.UserRequested);\n\t\t\t\tAssert.False(smartCoin1.CoinJoinInProgress);\n\t\t\t\tawait chaumianClient1.DequeueCoinsFromMixAsync(new[] { smartCoin1, smartCoin2 }, DequeueReason.UserRequested);\n\t\t\t\tAssert.False(smartCoin1.CoinJoinInProgress);\n\t\t\t\tAssert.False(smartCoin2.CoinJoinInProgress);\n\t\t\t\tAssert.True(2 == (await chaumianClient1.QueueCoinsToMixAsync(password, smartCoin1, smartCoin2)).Count());\n\t\t\t\tAssert.True(smartCoin1.CoinJoinInProgress);\n\t\t\t\tAssert.True(smartCoin2.CoinJoinInProgress);\n\t\t\t\tawait chaumianClient1.DequeueCoinsFromMixAsync(smartCoin1, DequeueReason.UserRequested);\n\t\t\t\tawait chaumianClient1.DequeueCoinsFromMixAsync(smartCoin2, DequeueReason.UserRequested);\n\t\t\t\tAssert.False(smartCoin1.CoinJoinInProgress);\n\t\t\t\tAssert.False(smartCoin2.CoinJoinInProgress);\n\n\t\t\t\tAssert.True(2 == (await chaumianClient1.QueueCoinsToMixAsync(password, smartCoin1, smartCoin2)).Count());\n\t\t\t\tAssert.True(smartCoin1.CoinJoinInProgress);\n\t\t\t\tAssert.True(smartCoin2.CoinJoinInProgress);\n\t\t\t\tAssert.True(1 == (await chaumianClient2.QueueCoinsToMixAsync(password, smartCoin3)).Count());\n\n\t\t\t\tTask timeout = Task.Delay(TimeSpan.FromSeconds(connectionConfirmationTimeout * 2 + 7 * 2 + 7 * 2 + 7 * 2));\n\t\t\t\twhile ((await rpc.GetRawMempoolAsync()).Length == 0)\n\t\t\t\t{\n\t\t\t\t\tif (timeout.IsCompletedSuccessfully)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new TimeoutException(\"CoinJoin was not propagated.\");\n\t\t\t\t\t}\n\t\t\t\t\tawait Task.Delay(1000);\n\t\t\t\t}\n\n\t\t\t\tvar cj = (await rpc.GetRawMempoolAsync()).Single();\n\t\t\t\tsmartCoin1.SpenderTransactionId = cj;\n\t\t\t\tsmartCoin2.SpenderTransactionId = cj;\n\t\t\t\tsmartCoin3.SpenderTransactionId = cj;\n\n\t\t\t\t\/\/ Make sure if times out, it tries again.\n\t\t\t\tconnectionConfirmationTimeout = 1;\n\t\t\t\troundConfig = RegTestFixture.CreateRoundConfig(denomination, 140, 0.7, coordinatorFeePercent, anonymitySet, 240, connectionConfirmationTimeout, 50, 50, 1, 24, true, 11);\n\t\t\t\tawait coordinator.RoundConfig.UpdateOrDefaultAsync(roundConfig, toFile: true);\n\t\t\t\tcoordinator.AbortAllRoundsInInputRegistration(\"\");\n\t\t\t\tAssert.NotEmpty(chaumianClient1.State.GetAllQueuedCoins());\n\t\t\t\tawait chaumianClient1.DequeueAllCoinsFromMixAsync(DequeueReason.UserRequested);\n\t\t\t\tAssert.Empty(chaumianClient1.State.GetAllQueuedCoins());\n\t\t\t\tawait chaumianClient1.QueueCoinsToMixAsync(password, smartCoin4);\n\t\t\t\tAssert.NotEmpty(chaumianClient1.State.GetAllQueuedCoins());\n\t\t\t\tAssert.NotEmpty(chaumianClient1.State.GetAllWaitingCoins());\n\t\t\t\tAssert.Empty(chaumianClient1.State.GetAllRegisteredCoins());\n\t\t\t\twhile (chaumianClient1.State.GetAllWaitingCoins().Any())\n\t\t\t\t{\n\t\t\t\t\tawait Task.Delay(1000);\n\t\t\t\t}\n\t\t\t\tAssert.NotEmpty(chaumianClient1.State.GetAllQueuedCoins());\n\t\t\t\tAssert.Empty(chaumianClient1.State.GetAllWaitingCoins());\n\t\t\t\tAssert.NotEmpty(chaumianClient1.State.GetAllRegisteredCoins());\n\t\t\t\tint times = 0;\n\t\t\t\twhile (!chaumianClient1.State.GetAllWaitingCoins().Any()) \/\/ \/\/ Make sure to wait until times out.\n\t\t\t\t{\n\t\t\t\t\tawait Task.Delay(1000);\n\t\t\t\t\tif (times > 21)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new TimeoutException($\"{nameof(chaumianClient1.State)}.{nameof(chaumianClient1.State.GetAllWaitingCoins)}() always empty.\");\n\t\t\t\t\t}\n\t\t\t\t\ttimes++;\n\t\t\t\t}\n\n\t\t\t\tAssert.NotEmpty(chaumianClient1.State.GetAllQueuedCoins());\n\t\t\t\tAssert.Empty(chaumianClient1.State.GetAllRegisteredCoins());\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tif (chaumianClient1 != null)\n\t\t\t\t{\n\t\t\t\t\tawait chaumianClient1.StopAsync();\n\t\t\t\t}\n\t\t\t\tif (chaumianClient2 != null)\n\t\t\t\t{\n\t\t\t\t\tawait chaumianClient2.StopAsync();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t[Fact]\n\t\tpublic async Task CoinJoinMultipleRoundTestsAsync()\n\t\t{\n\t\t\t(string password, RPCClient rpc, Network network, Coordinator coordinator, ServiceConfiguration serviceConfiguration, BitcoinStore bitcoinStore, Backend.Global global) = await InitializeTestEnvironmentAsync(3);\n\n\t\t\tMoney denomination = Money.Coins(0.1m);\n\t\t\tdecimal coordinatorFeePercent = 0.1m;\n\t\t\tint anonymitySet = 2;\n\t\t\tint connectionConfirmationTimeout = 14;\n\t\t\tvar roundConfig = RegTestFixture.CreateRoundConfig(denomination, 140, 0.7, coordinatorFeePercent, anonymitySet, 240, connectionConfirmationTimeout, 50, 50, 1, 24, true, 11);\n\t\t\tawait coordinator.RoundConfig.UpdateOrDefaultAsync(roundConfig, toFile: true);\n\t\t\tcoordinator.AbortAllRoundsInInputRegistration(\"\");\n\n\t\t\t\/\/ Create the services.\n\t\t\t\/\/ 1. Create connection service.\n\t\t\tvar nodes = new NodesGroup(global.Config.Network, requirements: Constants.NodeRequirements);\n\t\t\tnodes.ConnectedNodes.Add(await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync());\n\n\t\t\tvar nodes2 = new NodesGroup(global.Config.Network, requirements: Constants.NodeRequirements);\n\t\t\tnodes2.ConnectedNodes.Add(await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync());\n\n\t\t\t\/\/ 2. Create mempool service.\n\n\t\t\tNode node = await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync();\n\t\t\tnode.Behaviors.Add(bitcoinStore.CreateUntrustedP2pBehavior());\n\n\t\t\tNode node2 = await RegTestFixture.BackendRegTestNode.CreateNewP2pNodeAsync();\n\t\t\tnode2.Behaviors.Add(bitcoinStore.CreateUntrustedP2pBehavior());\n\n\t\t\t\/\/ 3. Create wasabi synchronizer service.\n\t\t\tvar synchronizer = new WasabiSynchronizer(network, bitcoinStore, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\tvar indexFilePath2 = Path.Combine(GetWorkDir(), $\"Index{network}2.dat\");\n\t\t\tvar synchronizer2 = new WasabiSynchronizer(network, bitcoinStore, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\t\/\/ 4. Create key manager service.\n\t\t\tvar keyManager = KeyManager.CreateNew(out _, password);\n\n\t\t\tvar keyManager2 = KeyManager.CreateNew(out _, password);\n\n\t\t\t\/\/ 5. Create chaumian coinjoin client.\n\t\t\tvar chaumianClient = new CoinJoinClient(synchronizer, network, keyManager, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\tvar chaumianClient2 = new CoinJoinClient(synchronizer, network, keyManager2, new Uri(RegTestFixture.BackendEndPoint), null);\n\n\t\t\t\/\/ 6. Create wallet service.\n\t\t\tvar workDir = GetWorkDir();\n\t\t\tvar wallet = new WalletService(bitcoinStore, keyManager, synchronizer, chaumianClient, nodes, workDir, serviceConfiguration, synchronizer);\n\t\t\twallet.NewFilterProcessed += Wallet_NewFilterProcessed;\n\n\t\t\tvar workDir2 = Path.Combine(GetWorkDir(), \"2\");\n\t\t\tvar wallet2 = new WalletService(bitcoinStore, keyManager2, synchronizer2, chaumianClient2, nodes2, workDir2, serviceConfiguration, synchronizer2);\n\n\t\t\t\/\/ Get some money, make it confirm.\n\t\t\tvar key = keyManager.GetNextReceiveKey(\"fundZeroLink\", out _);\n\t\t\tvar txId = await rpc.SendToAddressAsync(key.GetP2wpkhAddress(network), Money.Coins(1m));\n\t\t\tAssert.NotNull(txId);\n\t\t\tvar key2 = keyManager2.GetNextReceiveKey(\"fundZeroLink\", out _);\n\t\t\tvar key3 = keyManager2.GetNextReceiveKey(\"fundZeroLink\", out _);\n\t\t\tvar key4 = keyManager2.GetNextReceiveKey(\"fundZeroLink\", out _);\n\t\t\tvar txId2 = await rpc.SendToAddressAsync(key2.GetP2wpkhAddress(network), Money.Coins(0.11m));\n\t\t\tvar txId3 = await rpc.SendToAddressAsync(key3.GetP2wpkhAddress(network), Money.Coins(0.12m));\n\t\t\tvar txId4 = await rpc.SendToAddressAsync(key4.GetP2wpkhAddress(network), Money.Coins(0.13m));\n\n\t\t\tawait rpc.GenerateAsync(1);\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tInterlocked.Exchange(ref _filtersProcessedByWalletCount, 0);\n\t\t\t\tnodes.Connect(); \/\/ Start connection service.\n\t\t\t\tnode.VersionHandshake(); \/\/ Start mempool service.\n\t\t\t\tsynchronizer.Start(requestInterval: TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(5), 10000); \/\/ Start wasabi synchronizer service.\n\t\t\t\tchaumianClient.Start(); \/\/ Start chaumian coinjoin client.\n\t\t\t\tnodes2.Connect(); \/\/ Start connection service.\n\t\t\t\tnode2.VersionHandshake(); \/\/ Start mempool service.\n\t\t\t\tsynchronizer2.Start(requestInterval: TimeSpan.FromSeconds(3), TimeSpan.FromSeconds(5), 10000); \/\/ Start wasabi synchronizer service.\n\t\t\t\tchaumianClient2.Start(); \/\/ Start chaumian coinjoin client.\n\n\t\t\t\t\/\/ Wait until the filter our previous transaction is present.\n\t\t\t\tvar blockCount = await rpc.GetBlockCountAsync();\n\t\t\t\tawait WaitForFiltersToBeProcessedAsync(TimeSpan.FromSeconds(120), blockCount);\n\n\t\t\t\tusing (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30)))\n\t\t\t\t{\n\t\t\t\t\tawait wallet.InitializeAsync(cts.Token); \/\/ Initialize wallet service.\n\t\t\t\t}\n\t\t\t\tusing (var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30)))\n\t\t\t\t{\n\t\t\t\t\tawait wallet2.InitializeAsync(cts.Token); \/\/ Initialize wallet service.\n\t\t\t\t}\n\n\t\t\t\tvar waitCount = 0;\n\t\t\t\twhile (wallet.Coins.Sum(x => x.Amount) == Money.Zero)\n\t\t\t\t{\n\t\t\t\t\tawait Task.Delay(1000);\n\t\t\t\t\twaitCount++;\n\t\t\t\t\tif (waitCount >= 21)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new TimeoutException(\"Funding transaction to the wallet1 did not arrive.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twaitCount = 0;\n\t\t\t\twhile (wallet2.Coins.Sum(x => x.Amount) == Money.Zero)\n\t\t\t\t{\n\t\t\t\t\tawait Task.Delay(1000);\n\t\t\t\t\twaitCount++;\n\t\t\t\t\tif (waitCount >= 21)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new TimeoutException(\"Funding transaction to the wallet2 did not arrive.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tAssert.True(1 == (await chaumianClient.QueueCoinsToMixAsync(password, wallet.Coins.ToArray())).Count());\n\t\t\t\tAssert.True(3 == (await chaumianClient2.QueueCoinsToMixAsync(password, wallet2.Coins.ToArray())).Count());\n\n\t\t\t\tTask timeout = Task.Delay(TimeSpan.FromSeconds(2 * (1 + 11 + 7 + 3 * (3 + 7))));\n\t\t\t\twhile (wallet.Coins.Count() != 4)\n\t\t\t\t{\n\t\t\t\t\tif (timeout.IsCompletedSuccessfully)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new TimeoutException(\"CoinJoin was not propagated or did not arrive.\");\n\t\t\t\t\t}\n\t\t\t\t\tawait Task.Delay(1000);\n\t\t\t\t}\n\n\t\t\t\tvar times = 0;\n\t\t\t\twhile (wallet.Coins.FirstOrDefault(x => x.Label.IsEmpty) is null)\n\t\t\t\t{\n\t\t\t\t\tawait Task.Delay(1000);\n\t\t\t\t\ttimes++;\n\t\t\t\t\tif (times >= 21)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new TimeoutException(\"Wallet spends were not recognized.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tDateTime start = DateTime.Now;\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tawait chaumianClient.DequeueAllCoinsFromMixAsync(DequeueReason.UserRequested);\n\t\t\t\t\t\tawait chaumianClient2.DequeueAllCoinsFromMixAsync(DequeueReason.UserRequested);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (NotSupportedException)\n\t\t\t\t\t{\n\t\t\t\t\t\tawait Task.Delay(1000);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (DateTime.Now - start > TimeSpan.FromMinutes(1))\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new TimeoutException(\"Dequeuing timed out.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (true);\n\n\t\t\t\tvar allCoins = wallet.TransactionProcessor.Coins.AsAllCoinsView().ToArray();\n\t\t\t\tvar allCoins2 = wallet2.TransactionProcessor.Coins.AsAllCoinsView().ToArray();\n\n\t\t\t\tAssert.Equal(4, allCoins.Count(x => x.Label.IsEmpty && !x.Unavailable));\n\t\t\t\tAssert.Equal(3, allCoins2.Count(x => x.Label.IsEmpty && !x.Unavailable));\n\t\t\t\tAssert.Equal(2, allCoins.Count(x => x.Label.IsEmpty && !x.Unspent));\n\t\t\t\tAssert.Equal(0, allCoins2.Count(x => x.Label.IsEmpty && !x.Unspent));\n\t\t\t\tAssert.Equal(3, allCoins2.Count(x => x.Label.IsEmpty));\n\t\t\t\tAssert.Equal(4, allCoins.Count(x => x.Label.IsEmpty && x.Unspent));\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\twallet.NewFilterProcessed -= Wallet_NewFilterProcessed;\n\t\t\t\twallet?.Dispose();\n\t\t\t\t\/\/ Dispose connection service.\n\t\t\t\tnodes?.Dispose();\n\t\t\t\t\/\/ Dispose mempool serving node.\n\t\t\t\tnode?.Disconnect();\n\t\t\t\t\/\/ Dispose chaumian coinjoin client.\n\t\t\t\tif (chaumianClient != null)\n\t\t\t\t{\n\t\t\t\t\tawait chaumianClient.StopAsync();\n\t\t\t\t}\n\t\t\t\twallet2?.Dispose();\n\t\t\t\t\/\/ Dispose wasabi synchronizer service.\n\t\t\t\tawait synchronizer?.StopAsync();\n\t\t\t\t\/\/ Dispose connection service.\n\t\t\t\tnodes2?.Dispose();\n\t\t\t\t\/\/ Dispose chaumian coinjoin client.\n\t\t\t\tif (chaumianClient2 != null)\n\t\t\t\t{\n\t\t\t\t\tawait chaumianClient2.StopAsync();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t#endregion ClientTests\n\n#pragma warning restore IDE0059 \/\/ Value assigned to symbol is never used\n\t}\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"f84538b9c64e3d6323402eec91f44e63661db519","subject":"Correct mistake in torch crafting recipe","message":"Correct mistake in torch crafting recipe\n\nThe output is four torches, not one\n","repos":"blha303\/TrueCraft,robinkanters\/TrueCraft,illblew\/TrueCraft,robinkanters\/TrueCraft,SirCmpwn\/TrueCraft,Mitch528\/TrueCraft,manio143\/TrueCraft,christopherbauer\/TrueCraft,SirCmpwn\/TrueCraft,creatorfromhell\/TrueCraft,thdtjsdn\/TrueCraft,Mitch528\/TrueCraft,robinkanters\/TrueCraft,SirCmpwn\/TrueCraft,blha303\/TrueCraft,flibitijibibo\/TrueCraft,Mitch528\/TrueCraft,manio143\/TrueCraft,thdtjsdn\/TrueCraft,thdtjsdn\/TrueCraft,manio143\/TrueCraft,christopherbauer\/TrueCraft,illblew\/TrueCraft,blha303\/TrueCraft,creatorfromhell\/TrueCraft,illblew\/TrueCraft,flibitijibibo\/TrueCraft,flibitijibibo\/TrueCraft,christopherbauer\/TrueCraft","old_file":"TrueCraft.Core\/Logic\/Blocks\/TorchBlock.cs","new_file":"TrueCraft.Core\/Logic\/Blocks\/TorchBlock.cs","new_contents":"using System;\nusing TrueCraft.API.Logic;\nusing TrueCraft.API;\nusing TrueCraft.Core.Logic.Items;\nusing TrueCraft.API.World;\nusing TrueCraft.API.Networking;\n\nnamespace TrueCraft.Core.Logic.Blocks\n{\n    public class TorchBlock : BlockProvider, ICraftingRecipe\n    {\n        public enum TorchDirection\n        {\n            South = 0x01, \/\/ Positive Z\n            North = 0x02,\n            West = 0x03,\n            East = 0x04,\n            Ground = 0x05\n        }\n\n        public static readonly byte BlockID = 0x32;\n        \n        public override byte ID { get { return 0x32; } }\n        \n        public override double BlastResistance { get { return 0; } }\n\n        public override double Hardness { get { return 0; } }\n\n        public override byte Luminance { get { return 13; } }\n\n        public override bool Opaque { get { return false; } }\n        \n        public override string DisplayName { get { return \"Torch\"; } }\n\n        public override void BlockPlaced(BlockDescriptor descriptor, BlockFace face, IWorld world, IRemoteClient user)\n        {\n            TorchDirection direction;\n            switch (face)\n            {\n                case BlockFace.PositiveZ:\n                    direction = TorchDirection.West;\n                    break;\n                case BlockFace.NegativeZ:\n                    direction = TorchDirection.East;\n                    break;\n                case BlockFace.PositiveX:\n                    direction = TorchDirection.South;\n                    break;\n                case BlockFace.NegativeX:\n                    direction = TorchDirection.North;\n                    break;\n                default:\n                    direction = TorchDirection.Ground;\n                    break;\n            }\n            world.SetMetadata(descriptor.Coordinates, (byte)direction);\n        }\n\n        public override Tuple<int, int> GetTextureMap(byte metadata)\n        {\n            return new Tuple<int, int>(0, 5);\n        }\n            \n        public virtual ItemStack[,] Pattern\n        {\n            get\n            {\n                return new[,]\n                {\n                    { new ItemStack(CoalItem.ItemID) },\n                    { new ItemStack(StickItem.ItemID) }\n                };\n            }\n        }\n\n        public virtual ItemStack Output\n        {\n            get\n            {\n                return new ItemStack(TorchBlock.BlockID, 4);\n            }\n        }\n\n        public virtual bool SignificantMetadata\n        {\n            get\n            {\n                return false;\n            }\n        }\n    }\n}","old_contents":"using System;\nusing TrueCraft.API.Logic;\nusing TrueCraft.API;\nusing TrueCraft.Core.Logic.Items;\nusing TrueCraft.API.World;\nusing TrueCraft.API.Networking;\n\nnamespace TrueCraft.Core.Logic.Blocks\n{\n    public class TorchBlock : BlockProvider, ICraftingRecipe\n    {\n        public enum TorchDirection\n        {\n            South = 0x01, \/\/ Positive Z\n            North = 0x02,\n            West = 0x03,\n            East = 0x04,\n            Ground = 0x05\n        }\n\n        public static readonly byte BlockID = 0x32;\n        \n        public override byte ID { get { return 0x32; } }\n        \n        public override double BlastResistance { get { return 0; } }\n\n        public override double Hardness { get { return 0; } }\n\n        public override byte Luminance { get { return 13; } }\n\n        public override bool Opaque { get { return false; } }\n        \n        public override string DisplayName { get { return \"Torch\"; } }\n\n        public override void BlockPlaced(BlockDescriptor descriptor, BlockFace face, IWorld world, IRemoteClient user)\n        {\n            TorchDirection direction;\n            switch (face)\n            {\n                case BlockFace.PositiveZ:\n                    direction = TorchDirection.West;\n                    break;\n                case BlockFace.NegativeZ:\n                    direction = TorchDirection.East;\n                    break;\n                case BlockFace.PositiveX:\n                    direction = TorchDirection.South;\n                    break;\n                case BlockFace.NegativeX:\n                    direction = TorchDirection.North;\n                    break;\n                default:\n                    direction = TorchDirection.Ground;\n                    break;\n            }\n            world.SetMetadata(descriptor.Coordinates, (byte)direction);\n        }\n\n        public override Tuple<int, int> GetTextureMap(byte metadata)\n        {\n            return new Tuple<int, int>(0, 5);\n        }\n            \n        public virtual ItemStack[,] Pattern\n        {\n            get\n            {\n                return new[,]\n                {\n                    { new ItemStack(CoalItem.ItemID) },\n                    { new ItemStack(StickItem.ItemID) }\n                };\n            }\n        }\n\n        public virtual ItemStack Output\n        {\n            get\n            {\n                return new ItemStack(TorchBlock.BlockID, 1);\n            }\n        }\n\n        public virtual bool SignificantMetadata\n        {\n            get\n            {\n                return false;\n            }\n        }\n    }\n}","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"fbb938b04c90cbcd13c65795064831138a60c100","subject":"added CmdSnoopModScopeDependents menu entry","message":"added CmdSnoopModScopeDependents menu entry\n","repos":"joespiff\/RevitLookup,joespiff\/RevitLookup,joespiff\/RevitLookup,jeremytammik\/RevitLookup","old_file":"CS\/App.cs","new_file":"CS\/App.cs","new_contents":"#region Header\r\n\/\/\r\n\/\/ Copyright 2003-2019 by Autodesk, Inc. \r\n\/\/\r\n\/\/ Permission to use, copy, modify, and distribute this software in\r\n\/\/ object code form for any purpose and without fee is hereby granted, \r\n\/\/ provided that the above copyright notice appears in all copies and \r\n\/\/ that both that copyright notice and the limited warranty and\r\n\/\/ restricted rights notice below appear in all supporting \r\n\/\/ documentation.\r\n\/\/\r\n\/\/ AUTODESK PROVIDES THIS PROGRAM \"AS IS\" AND WITH ALL FAULTS. \r\n\/\/ AUTODESK SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF\r\n\/\/ MERCHANTABILITY OR FITNESS FOR A PARTICULAR USE.  AUTODESK, INC. \r\n\/\/ DOES NOT WARRANT THAT THE OPERATION OF THE PROGRAM WILL BE\r\n\/\/ UNINTERRUPTED OR ERROR FREE.\r\n\/\/\r\n\/\/ Use, duplication, or disclosure by the U.S. Government is subject to \r\n\/\/ restrictions set forth in FAR 52.227-19 (Commercial Computer\r\n\/\/ Software - Restricted Rights) and DFAR 252.227-7013(c)(1)(ii)\r\n\/\/ (Rights in Technical Data and Computer Software), as applicable.\r\n\/\/\r\n#endregion \/\/ Header\r\n\r\nusing System;\r\nusing System.IO;\r\nusing System.Reflection;\r\nusing System.Windows.Media.Imaging;\r\nusing Autodesk.Revit.ApplicationServices;\r\nusing Autodesk.Revit.DB;\r\nusing Autodesk.Revit.UI;\r\n\r\nnamespace RevitLookup\r\n{\r\n  public class App : IExternalApplication\r\n  {\r\n    static AddInId m_appId = new AddInId( new Guid(\r\n      \"356CDA5A-E6C5-4c2f-A9EF-B3222116B8C8\" ) );\r\n\r\n    \/\/ get the absolute path of this assembly\r\n    static string ExecutingAssemblyPath = System.Reflection.Assembly\r\n      .GetExecutingAssembly().Location;\r\n\r\n    private AppDocEvents m_appDocEvents;\r\n\r\n    public Result OnStartup(\r\n      UIControlledApplication application )\r\n    {\r\n      \/\/ Call this method explicitly in App.cs when Revit starts up because,\r\n      \/\/ in .NET 4, the static variables will not be initialized until use them.\r\n      Snoop.Collectors.CollectorObj.InitializeCollectors();\r\n      AddMenu( application );\r\n      AddAppDocEvents( application.ControlledApplication );\r\n\r\n      return Result.Succeeded;\r\n    }\r\n\r\n    public Result OnShutdown(\r\n      UIControlledApplication application )\r\n    {\r\n      RemoveAppDocEvents();\r\n\r\n      return Result.Succeeded;\r\n    }\r\n\r\n    private void AddMenu( UIControlledApplication app )\r\n    {\r\n      RibbonPanel rvtRibbonPanel = app.CreateRibbonPanel( \"Revit Lookup\" );\r\n      PulldownButtonData data = new PulldownButtonData( \"Options\", \"Revit Lookup\" );\r\n\r\n      RibbonItem item = rvtRibbonPanel.AddItem( data );\r\n      PulldownButton optionsBtn = item as PulldownButton;\r\n\r\n      \/\/ Add Icons to main RevitLookup Menu\r\n      optionsBtn.Image = GetEmbeddedImage( \"RevitLookup.Resources.RLookup-16.png\" );\r\n      optionsBtn.LargeImage = GetEmbeddedImage( \"RevitLookup.Resources.RLookup-32.png\" );\r\n      optionsBtn.AddPushButton( new PushButtonData( \"HelloWorld\", \"Hello World...\", ExecutingAssemblyPath, \"RevitLookup.HelloWorld\" ) );\r\n      optionsBtn.AddPushButton( new PushButtonData( \"Snoop Db..\", \"Snoop DB...\", ExecutingAssemblyPath, \"RevitLookup.CmdSnoopDb\" ) );\r\n      optionsBtn.AddPushButton( new PushButtonData( \"Snoop Current Selection...\", \"Snoop Current Selection...\", ExecutingAssemblyPath, \"RevitLookup.CmdSnoopModScope\" ) );\r\n      optionsBtn.AddPushButton( new PushButtonData( \"Snoop Pick Face...\", \"Snoop Pick Face...\", ExecutingAssemblyPath, \"RevitLookup.CmdSnoopModScopePickSurface\" ) );\r\n      optionsBtn.AddPushButton( new PushButtonData( \"Snoop Pick Edge...\", \"Snoop Pick Edge...\", ExecutingAssemblyPath, \"RevitLookup.CmdSnoopModScopePickEdge\" ) );\r\n      optionsBtn.AddPushButton( new PushButtonData( \"Snoop Pick Linked Element...\", \"Snoop Linked Element...\", ExecutingAssemblyPath, \"RevitLookup.CmdSnoopModScopeLinkedElement\" ) );\r\n      optionsBtn.AddPushButton( new PushButtonData( \"Snoop Dependent Elements...\", \"Snoop Dependent Elements...\", ExecutingAssemblyPath, \"RevitLookup.CmdSnoopModScopeDependents\" ) );\r\n      optionsBtn.AddPushButton( new PushButtonData( \"Snoop Active View...\", \"Snoop Active View...\", ExecutingAssemblyPath, \"RevitLookup.CmdSnoopActiveView\" ) );\r\n      optionsBtn.AddPushButton( new PushButtonData( \"Snoop Application...\", \"Snoop Application...\", ExecutingAssemblyPath, \"RevitLookup.CmdSnoopApp\" ) );\r\n      optionsBtn.AddPushButton( new PushButtonData( \"Search and Snoop...\", \"Search and Snoop...\", ExecutingAssemblyPath, \"RevitLookup.CmdSearchBy\" ) );\r\n      optionsBtn.AddPushButton( new PushButtonData( \"Test Framework...\", \"Test Framework...\", ExecutingAssemblyPath, \"RevitLookup.CmdTestShell\" ) );\r\n    }\r\n\r\n    private void AddAppDocEvents( ControlledApplication app )\r\n    {\r\n      m_appDocEvents = new AppDocEvents( app );\r\n      m_appDocEvents.EnableEvents();\r\n    }\r\n\r\n    private void RemoveAppDocEvents()\r\n    {\r\n      m_appDocEvents.DisableEvents();\r\n    }\r\n\r\n    static BitmapSource GetEmbeddedImage( string name )\r\n    {\r\n      try\r\n      {\r\n        Assembly a = Assembly.GetExecutingAssembly();\r\n        Stream s = a.GetManifestResourceStream( name );\r\n        return BitmapFrame.Create( s );\r\n      }\r\n      catch\r\n      {\r\n        return null;\r\n      }\r\n    }\r\n  }\r\n}\r\n","old_contents":"#region Header\r\n\/\/\r\n\/\/ Copyright 2003-2019 by Autodesk, Inc. \r\n\/\/\r\n\/\/ Permission to use, copy, modify, and distribute this software in\r\n\/\/ object code form for any purpose and without fee is hereby granted, \r\n\/\/ provided that the above copyright notice appears in all copies and \r\n\/\/ that both that copyright notice and the limited warranty and\r\n\/\/ restricted rights notice below appear in all supporting \r\n\/\/ documentation.\r\n\/\/\r\n\/\/ AUTODESK PROVIDES THIS PROGRAM \"AS IS\" AND WITH ALL FAULTS. \r\n\/\/ AUTODESK SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTY OF\r\n\/\/ MERCHANTABILITY OR FITNESS FOR A PARTICULAR USE.  AUTODESK, INC. \r\n\/\/ DOES NOT WARRANT THAT THE OPERATION OF THE PROGRAM WILL BE\r\n\/\/ UNINTERRUPTED OR ERROR FREE.\r\n\/\/\r\n\/\/ Use, duplication, or disclosure by the U.S. Government is subject to \r\n\/\/ restrictions set forth in FAR 52.227-19 (Commercial Computer\r\n\/\/ Software - Restricted Rights) and DFAR 252.227-7013(c)(1)(ii)\r\n\/\/ (Rights in Technical Data and Computer Software), as applicable.\r\n\/\/\r\n#endregion \/\/ Header\r\n\r\nusing System;\r\nusing System.IO;\r\nusing System.Reflection;\r\nusing System.Windows.Media.Imaging;\r\nusing Autodesk.Revit.ApplicationServices;\r\nusing Autodesk.Revit.DB;\r\nusing Autodesk.Revit.UI;\r\n\r\nnamespace RevitLookup\r\n{\r\n  public class App : IExternalApplication\r\n  {\r\n    static AddInId m_appId = new AddInId( new Guid(\r\n      \"356CDA5A-E6C5-4c2f-A9EF-B3222116B8C8\" ) );\r\n\r\n    \/\/ get the absolute path of this assembly\r\n    static string ExecutingAssemblyPath = System.Reflection.Assembly\r\n      .GetExecutingAssembly().Location;\r\n\r\n    private AppDocEvents m_appDocEvents;\r\n\r\n    public Result OnStartup(\r\n      UIControlledApplication application )\r\n    {\r\n      \/\/ Call this method explicitly in App.cs when Revit starts up because,\r\n      \/\/ in .NET 4, the static variables will not be initialized until use them.\r\n      Snoop.Collectors.CollectorObj.InitializeCollectors();\r\n      AddMenu( application );\r\n      AddAppDocEvents( application.ControlledApplication );\r\n\r\n      return Result.Succeeded;\r\n    }\r\n\r\n    public Result OnShutdown(\r\n      UIControlledApplication application )\r\n    {\r\n      RemoveAppDocEvents();\r\n\r\n      return Result.Succeeded;\r\n    }\r\n\r\n    private void AddMenu( UIControlledApplication app )\r\n    {\r\n      RibbonPanel rvtRibbonPanel = app.CreateRibbonPanel( \"Revit Lookup\" );\r\n      PulldownButtonData data = new PulldownButtonData( \"Options\", \"Revit Lookup\" );\r\n\r\n      RibbonItem item = rvtRibbonPanel.AddItem( data );\r\n      PulldownButton optionsBtn = item as PulldownButton;\r\n\r\n      \/\/ Add Icons to main RevitLookup Menu\r\n      optionsBtn.Image = GetEmbeddedImage( \"RevitLookup.Resources.RLookup-16.png\" );\r\n      optionsBtn.LargeImage = GetEmbeddedImage( \"RevitLookup.Resources.RLookup-32.png\" );\r\n      optionsBtn.AddPushButton( new PushButtonData( \"HelloWorld\", \"Hello World...\", ExecutingAssemblyPath, \"RevitLookup.HelloWorld\" ) );\r\n      optionsBtn.AddPushButton( new PushButtonData( \"Snoop Db..\", \"Snoop DB...\", ExecutingAssemblyPath, \"RevitLookup.CmdSnoopDb\" ) );\r\n      optionsBtn.AddPushButton( new PushButtonData( \"Snoop Current Selection...\", \"Snoop Current Selection...\", ExecutingAssemblyPath, \"RevitLookup.CmdSnoopModScope\" ) );\r\n      optionsBtn.AddPushButton( new PushButtonData( \"Snoop Pick Face...\", \"Snoop Pick Face...\", ExecutingAssemblyPath, \"RevitLookup.CmdSnoopModScopePickSurface\" ) );\r\n      optionsBtn.AddPushButton( new PushButtonData( \"Snoop Pick Edge...\", \"Snoop Pick Edge...\", ExecutingAssemblyPath, \"RevitLookup.CmdSnoopModScopePickEdge\" ) );\r\n      optionsBtn.AddPushButton( new PushButtonData( \"Snoop Pick Linked Element...\", \"Snoop Linked Element...\", ExecutingAssemblyPath, \"RevitLookup.CmdSnoopModScopeLinkedElement\" ) );\r\n      optionsBtn.AddPushButton( new PushButtonData( \"Snoop Active View...\", \"Snoop Active View...\", ExecutingAssemblyPath, \"RevitLookup.CmdSnoopActiveView\" ) );\r\n      optionsBtn.AddPushButton( new PushButtonData( \"Snoop Application...\", \"Snoop Application...\", ExecutingAssemblyPath, \"RevitLookup.CmdSnoopApp\" ) );\r\n      optionsBtn.AddPushButton( new PushButtonData( \"Search and Snoop...\", \"Search and Snoop...\", ExecutingAssemblyPath, \"RevitLookup.CmdSearchBy\" ) );\r\n      optionsBtn.AddPushButton( new PushButtonData( \"Test Framework...\", \"Test Framework...\", ExecutingAssemblyPath, \"RevitLookup.CmdTestShell\" ) );\r\n    }\r\n\r\n    private void AddAppDocEvents( ControlledApplication app )\r\n    {\r\n      m_appDocEvents = new AppDocEvents( app );\r\n      m_appDocEvents.EnableEvents();\r\n    }\r\n\r\n    private void RemoveAppDocEvents()\r\n    {\r\n      m_appDocEvents.DisableEvents();\r\n    }\r\n\r\n    static BitmapSource GetEmbeddedImage( string name )\r\n    {\r\n      try\r\n      {\r\n        Assembly a = Assembly.GetExecutingAssembly();\r\n        Stream s = a.GetManifestResourceStream( name );\r\n        return BitmapFrame.Create( s );\r\n      }\r\n      catch\r\n      {\r\n        return null;\r\n      }\r\n    }\r\n  }\r\n}\r\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"1245b9b329ebea6b6f2d2b835f4f50d8029e059b","subject":"slight updates, still working on collision manager","message":"slight updates, still working on collision manager\n","repos":"IGME-UnanimousOverkill\/working_title,IGME-UnanimousOverkill\/working_title","old_file":"UnanimousOverkillGame\/CollisionManager.cs","new_file":"UnanimousOverkillGame\/CollisionManager.cs","new_contents":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace UnanimousOverkillGame\n{\n    class CollisionManager\n    {\n        private List<GameObject> objects;\n        private List<PhysicsEntity> collisioCheckObjects;\n\n\n\n\n\n\n        public void CheckCollisions()\n        {\n            for (int col = 0; col < collisioCheckObjects.Count; col++)\n            {\n                for (int obj = 0; obj < objects.Count; obj++)\n                {\n                    if (objects.ElementAt(obj) != collisioCheckObjects.ElementAt(col) && collisioCheckObjects.ElementAt(col).Rect.Intersects(objects.ElementAt(obj).Rect))\n                    {\n                        \n                    }\n                }\n            }\n        }\n\n        private double findIntercept(int x1, int y1, int x2, int y2)\n        {\n            return y1-(((y2-y1)\/(x2-x1))*x1);\n        }\n\n\n\n        public CollisionManager(GameObject[] allGameObjects, params PhysicsEntity[] objectsToBeChecked)\n        {\n            objects = new List<GameObject>(allGameObjects);\n            collisioCheckObjects = new List<PhysicsEntity>(objectsToBeChecked);\n        }\n\n    }\n}\n","old_contents":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace UnanimousOverkillGame\n{\n    class CollisionManager\n    {\n        private List<GameObject> objects;\n        private List<PhysicsEntity> collisioCheckObjects;\n\n\n\n\n\n\n        public void CheckCollisions()\n        {\n            for (int col = 0; col < collisioCheckObjects.Count; col++)\n            {\n                for (int obj = 0; obj < objects.Count; obj++)\n                {\n                    if (objects.ElementAt(obj) != collisioCheckObjects.ElementAt(col) && collisioCheckObjects.ElementAt(col).Rect.Intersects(objects.ElementAt(obj).Rect))\n                    {\n                        \/\/previous position and current position required? or do we not think clipping will happen\n                        \/\/i do fix position here\n                        \/\/i feel there needs to be a way for the movables to know they've collided, like an on collision method \n\n                    }\n                }\n            }\n        }\n\n        public CollisionManager(GameObject[] allGameObjects, params PhysicsEntity[] objectsToBeChecked)\n        {\n            objects = new List<GameObject>(allGameObjects);\n            collisioCheckObjects = new List<PhysicsEntity>(objectsToBeChecked);\n        }\n\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"e8bec771df6aa77cc69a93013a319bb4702b0f46","subject":"Fix #13 PauseWhileDebugging Description","message":"Fix #13 PauseWhileDebugging Description\n\nIf ~~False~~ True, Auto Shelve will pause while debugging","repos":"vercellone\/tfsautoshelve","old_file":"VsExt.AutoShelve\/IO\/OptionsPageGeneral.cs","new_file":"VsExt.AutoShelve\/IO\/OptionsPageGeneral.cs","new_contents":"\ufeffusing System;\nusing System.ComponentModel;\nusing System.Runtime.InteropServices;\nusing System.Windows.Forms;\nusing Microsoft.VisualStudio.Shell;\nusing VsExt.AutoShelve.EventArgs;\n\nnamespace VsExt.AutoShelve.IO {\n\n    [ComVisible(true)]\n    [Guid(\"0f98bfc6-8c54-426a-94f5-256df616a90a\")]\n    public class OptionsPageGeneral : DialogPage {\n        private const string GeneralCat = \"General\";\n\n        #region Properties\n\n        [Category(GeneralCat), DisplayName(@\"Pause while Debugging\"), Description(\"If True, Auto Shelve will pause while debugging\")]\n        public bool PauseWhileDebugging { get; set; }\n\n        private string _shelveSetName;\n        [Category(GeneralCat), DisplayName(@\"Shelveset Name\"), Description(\"Shelve set name used as a string.Format input value where {0}=WorkspaceInfo.Name, {1}=WorkspaceInfo.OwnerName, {2}=DateTime.Now, {3}=Domain of WorkspaceInfo.OwnerName, {4}=UserName of WorkspaceInfo.OwnerName.  IMPORTANT: If you use multiple workspaces, and don't include WorkspaceInfo.Name then only the pending changes in the last workspace will be included in the shelveset. Anything greater than 64 characters will be truncated!\")]\n        public string ShelvesetName { \n            get { \n                if (String.IsNullOrWhiteSpace(_shelveSetName)) {\n                    _shelveSetName = \"Auto {0}\";\n                }\n                return _shelveSetName;\n            }\n            set {\n                _shelveSetName = value;\n            } \n        }\n\n        private double _interval;\n\n        [Category(GeneralCat)]\n        [DisplayName(@\"Interval\")]\n        [Description(\"The interval (in minutes) between shelvesets when running.\")]\n        public double TimerSaveInterval {\n            get {\n                return _interval;\n            }\n            set {\n                if (value <= 0) {\n                    WinFormsHelper.ShowMessageBox(\"TimerSaveInterval must be greater than 0.\", string.Format(\"Error - {0} Settings\", Resources.ExtensionName), MessageBoxButtons.OK, MessageBoxIcon.Hand);\n                } else {\n                    _interval = value;\n                }\n            }\n        }\n\n        [Category(GeneralCat), DisplayName(@\"Output Pane\"), Description(\"Output window pane to write status messages.  If you set this to an empty string, nothing is written to the Output window.  Note: Regardless, the output pane is no longer explicitly activated.  So, no more focus stealing!\")]\n        public string OutputPane { get; set; }\n\n        [Category(GeneralCat), DisplayName(@\"\u039caximum Shelvesets\"), Description(\"Maximum number of shelvesets to retain.  Older shelvesets will be deleted. 0=Disabled. Note: ShelvesetName must include a {2} (DateTime.Now component) unique enough to generate more than the maximum for this to have any impact.  If {0} (WorkspaceInfo.Name) is included, then the max is applied per workspace.\")]\n        public ushort MaximumShelvesets { get; set; }\n\n        #endregion\n\n        public OptionsPageGeneral() {\n            OutputPane = Resources.ExtensionName;\n            MaximumShelvesets = 0;\n            ShelvesetName = \"Auto {0}\";\n            TimerSaveInterval = 5;\n            PauseWhileDebugging = false;\n        }\n\n        protected override void OnApply(PageApplyEventArgs e) {\n            base.OnApply(e);\n            bool flag = OnOptionsChanged == null;\n            if (!flag) {\n                var optionsEventArg = new OptionsChangedEventArgs\n                {\n                    PauseWhileDebugging = PauseWhileDebugging,\n                    Interval = TimerSaveInterval,\n                    MaximumShelvesets = MaximumShelvesets,\n                \tOutputPane = OutputPane,\n                    ShelvesetName = ShelvesetName,\n                };\n                OnOptionsChanged(this, optionsEventArg);\n            }\n        }\n\n        public event EventHandler<OptionsChangedEventArgs> OnOptionsChanged;\n\n        \/\/protected virtual IWin32Window Window {\n        \/\/    get {\n        \/\/        return new OptionsToolWindow().Window;\n        \/\/    }\n        \/\/}\n\n     }\n}\n","old_contents":"\ufeffusing System;\nusing System.ComponentModel;\nusing System.Runtime.InteropServices;\nusing System.Windows.Forms;\nusing Microsoft.VisualStudio.Shell;\nusing VsExt.AutoShelve.EventArgs;\n\nnamespace VsExt.AutoShelve.IO {\n\n    [ComVisible(true)]\n    [Guid(\"0f98bfc6-8c54-426a-94f5-256df616a90a\")]\n    public class OptionsPageGeneral : DialogPage {\n        private const string GeneralCat = \"General\";\n\n        #region Properties\n\n        [Category(GeneralCat), DisplayName(@\"Pause while Debugging\"), Description(\"If False, Auto Shelve will pause while debugging\")]\n        public bool PauseWhileDebugging { get; set; }\n\n        private string _shelveSetName;\n        [Category(GeneralCat), DisplayName(@\"Shelveset Name\"), Description(\"Shelve set name used as a string.Format input value where {0}=WorkspaceInfo.Name, {1}=WorkspaceInfo.OwnerName, {2}=DateTime.Now, {3}=Domain of WorkspaceInfo.OwnerName, {4}=UserName of WorkspaceInfo.OwnerName.  IMPORTANT: If you use multiple workspaces, and don't include WorkspaceInfo.Name then only the pending changes in the last workspace will be included in the shelveset. Anything greater than 64 characters will be truncated!\")]\n        public string ShelvesetName { \n            get { \n                if (String.IsNullOrWhiteSpace(_shelveSetName)) {\n                    _shelveSetName = \"Auto {0}\";\n                }\n                return _shelveSetName;\n            }\n            set {\n                _shelveSetName = value;\n            } \n        }\n\n        private double _interval;\n\n        [Category(GeneralCat)]\n        [DisplayName(@\"Interval\")]\n        [Description(\"The interval (in minutes) between shelvesets when running.\")]\n        public double TimerSaveInterval {\n            get {\n                return _interval;\n            }\n            set {\n                if (value <= 0) {\n                    WinFormsHelper.ShowMessageBox(\"TimerSaveInterval must be greater than 0.\", string.Format(\"Error - {0} Settings\", Resources.ExtensionName), MessageBoxButtons.OK, MessageBoxIcon.Hand);\n                } else {\n                    _interval = value;\n                }\n            }\n        }\n\n        [Category(GeneralCat), DisplayName(@\"Output Pane\"), Description(\"Output window pane to write status messages.  If you set this to an empty string, nothing is written to the Output window.  Note: Regardless, the output pane is no longer explicitly activated.  So, no more focus stealing!\")]\n        public string OutputPane { get; set; }\n\n        [Category(GeneralCat), DisplayName(@\"\u039caximum Shelvesets\"), Description(\"Maximum number of shelvesets to retain.  Older shelvesets will be deleted. 0=Disabled. Note: ShelvesetName must include a {2} (DateTime.Now component) unique enough to generate more than the maximum for this to have any impact.  If {0} (WorkspaceInfo.Name) is included, then the max is applied per workspace.\")]\n        public ushort MaximumShelvesets { get; set; }\n\n        #endregion\n\n        public OptionsPageGeneral() {\n            OutputPane = Resources.ExtensionName;\n            MaximumShelvesets = 0;\n            ShelvesetName = \"Auto {0}\";\n            TimerSaveInterval = 5;\n            PauseWhileDebugging = false;\n        }\n\n        protected override void OnApply(PageApplyEventArgs e) {\n            base.OnApply(e);\n            bool flag = OnOptionsChanged == null;\n            if (!flag) {\n                var optionsEventArg = new OptionsChangedEventArgs\n                {\n                    PauseWhileDebugging = PauseWhileDebugging,\n                    Interval = TimerSaveInterval,\n                    MaximumShelvesets = MaximumShelvesets,\n                \tOutputPane = OutputPane,\n                    ShelvesetName = ShelvesetName,\n                };\n                OnOptionsChanged(this, optionsEventArg);\n            }\n        }\n\n        public event EventHandler<OptionsChangedEventArgs> OnOptionsChanged;\n\n        \/\/protected virtual IWin32Window Window {\n        \/\/    get {\n        \/\/        return new OptionsToolWindow().Window;\n        \/\/    }\n        \/\/}\n\n     }\n}","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"0fb067e8728c3fa1edc607d4012e82e429acc256","subject":"config var to self host added","message":"config var to self host added\n","repos":"phonicmouse\/SharpPaste,phonicmouse\/SharpPaste","old_file":"Config.cs","new_file":"Config.cs","new_contents":"\ufeff\/*\n * Created by SharpDevelop.\n * User: Phonic Mouse\n * Date: 02\/08\/2016\n * Time: 15:16\n *\/\nusing System;\n\nnamespace SharpPaste\n{\n\tpublic class Config\n\t{\n\t\t\/\/\/----Application Config----\/\/\/\n\t\tpublic static string HOSTINGTYPE = \"ASP.NET\";\n\t\tpublic static string DBPATH = string.Format(@\"{0}db\\Pastes.db\", AppDomain.CurrentDomain.BaseDirectory);\n\t\t\n\t\t\/\/\/----Paste Config----\/\/\/\n\t\tpublic static int TOKENLENGTH = 23;\n\t}\n}\n","old_contents":"\ufeff\/*\n * Created by SharpDevelop.\n * User: Phonic Mouse\n * Date: 02\/08\/2016\n * Time: 15:16\n *\/\nusing System;\n\nnamespace SharpPaste\n{\n\tpublic class Config\n\t{\n\t\t\/\/\/----Application Config----\/\/\/\n\t\tpublic static string DBPATH = string.Format(@\"{0}db\\Pastes.db\", AppDomain.CurrentDomain.BaseDirectory);\n\t\t\n\t\t\/\/\/----Paste Config----\/\/\/\n\t\tpublic static int TOKENLENGTH = 23;\n\t}\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"3c0edd24dbedfc773ac193683bbfc3f1de90f499","subject":"Use 4-arg overload of PackStart","message":"Use 4-arg overload of PackStart\n\nFor some reason it doesn't build with the 1-arg overload.\n","repos":"antmicro\/xwt","old_file":"Xwt.Gtk\/Xwt.GtkBackend\/NotebookBackend.cs","new_file":"Xwt.Gtk\/Xwt.GtkBackend\/NotebookBackend.cs","new_contents":"\/\/ \n\/\/ NotebookBackend.cs\n\/\/  \n\/\/ Author:\n\/\/       Lluis Sanchez <lluis@xamarin.com>\n\/\/ \n\/\/ Copyright (c) 2011 Xamarin Inc\n\/\/ \n\/\/ Permission is hereby granted, free of charge, to any person obtaining a copy\n\/\/ of this software and associated documentation files (the \"Software\"), to deal\n\/\/ in the Software without restriction, including without limitation the rights\n\/\/ to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\n\/\/ copies of the Software, and to permit persons to whom the Software is\n\/\/ furnished to do so, subject to the following conditions:\n\/\/ \n\/\/ The above copyright notice and this permission notice shall be included in\n\/\/ all copies or substantial portions of the Software.\n\/\/ \n\/\/ THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\/\/ IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\/\/ FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\/\/ AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\/\/ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\/\/ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\/\/ THE SOFTWARE.\n\nusing System;\nusing Xwt.Backends;\nusing System.Reflection;\n\nnamespace Xwt.GtkBackend\n{\n\tpublic class NotebookBackend: WidgetBackend, INotebookBackend\n\t{\n\t\tpublic NotebookBackend ()\n\t\t{\n\t\t\tWidget = new Gtk.Notebook ();\n\t\t\tWidget.Scrollable = true;\n\t\t\tWidget.Show ();\n\t\t}\n\t\t\n\t\tnew Gtk.Notebook Widget {\n\t\t\tget { return (Gtk.Notebook)base.Widget; }\n\t\t\tset { base.Widget = value; }\n\t\t}\n\n\t\tpublic override void EnableEvent (object eventId)\n\t\t{\n\t\t\tif (eventId is NotebookEvent) {\n\t\t\t\tNotebookEvent ev = (NotebookEvent) eventId;\n\t\t\t\tif (ev == NotebookEvent.CurrentTabChanged) {\n\t\t\t\t\tWidget.SwitchPage += HandleWidgetSwitchPage;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbase.EnableEvent (eventId);\n\t\t}\n\t\t\n\t\tpublic override void DisableEvent (object eventId)\n\t\t{\n\t\t\tif (eventId is NotebookEvent) {\n\t\t\t\tNotebookEvent ev = (NotebookEvent) eventId;\n\t\t\t\tif (ev == NotebookEvent.CurrentTabChanged) {\n\t\t\t\t\tWidget.SwitchPage -= HandleWidgetSwitchPage;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbase.DisableEvent (eventId);\n\t\t}\n\n\t\tvoid HandleWidgetSwitchPage (object o, Gtk.SwitchPageArgs args)\n\t\t{\n\t\t\t((INotebookEventSink)EventSink).OnCurrentTabChanged ();\n\t\t}\n\t\t\n\t\tpublic void Add (IWidgetBackend widget, NotebookTab tab)\n\t\t{\n\t\t\tWidget.AppendPage (GetWidgetWithPlacement (widget), CreateLabel (tab));\n\t\t}\n\n\t\tpublic void Remove (IWidgetBackend widget)\n\t\t{\n\t\t\tWidget.Remove (GetWidgetWithPlacement (widget));\n\t\t}\n\t\t\n\t\tpublic void UpdateLabel (NotebookTab tab, string hint)\n\t\t{\n\t\t\tIWidgetBackend widget = (IWidgetBackend) Toolkit.GetBackend (tab.Child);\n\t\t\tWidget.SetTabLabel (GetWidget (widget), CreateLabel (tab));\n\t\t}\n\t\t\n\t\tpublic int CurrentTab {\n\t\t\tget {\n\t\t\t\treturn Widget.CurrentPage;\n\t\t\t}\n\t\t\tset {\n\t\t\t\tWidget.CurrentPage = value;\n\t\t\t}\n\t\t}\n\n\t\tpublic Xwt.NotebookTabOrientation TabOrientation {\n\t\t\tget {\n\t\t\t\tXwt.NotebookTabOrientation tabPos = Xwt.NotebookTabOrientation.Top;\n\t\t\t\tEnum.TryParse (Widget.TabPos.ToString (), out tabPos);\n\t\t\t\treturn tabPos;\n\t\t\t}\n\t\t\tset {\n\t\t\t\tGtk.PositionType tabPos = Gtk.PositionType.Top;\n\t\t\t\tEnum.TryParse (value.ToString (), out tabPos);\n\t\t\t\tWidget.TabPos = tabPos;\n\t\t\t}\n\t\t}\n\t\t\n\t\tGtk.Widget CreateLabel(NotebookTab tab)\n\t\t{\n\t\t\tvar vbox = new Gtk.HBox();\n\t\t\tGtk.Label label = new Gtk.Label ();\n\n            \/* INTRODUCED BY houen *\/\n\n            if (tab.Label.Contains(\"\\\\_\"))\n            {\n                label.Text = tab.Label.Replace(\"\\\\_\", \"_\");\n            }\n            else\n            {\n                label.TextWithMnemonic = tab.Label.Replace(\"\\\\_\", \"_\");\n            }\n\n            \/* INTRODUCED BY houen *\/\n                            \n\t\t\tlabel.Show ();\n\t\t\tvbox.PackStart(label, false, false, 0u);\n\n\t\t\tif(!label.Text.StartsWith(char.ConvertFromUtf32(0x200B)))\n\t\t\t{\n\t\t\t\tvar closeImage = new Gtk.Image(Assembly.GetExecutingAssembly(), \"Xwt.GtkBackend.delete.png\");\n\t\t\t\tvar button = new Gtk.ToolButton(closeImage, \"\");\n\t\t\t\tvbox.PackEnd(button, false, false, 0);\n\t\t\t\tbutton.Show();\n\t\t\t\tcloseImage.Show();\n\t\t\t\tvar nativeWidget = GetWidget((IWidgetBackend)Toolkit.GetBackend(tab.Child));\n\t\t\t\tbutton.Clicked += (object sender, EventArgs e) => \n\t\t\t\t{\n                    tab.OnClosing();\n\t\t\t\t\tWidget.Remove(nativeWidget);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn vbox;\n\t\t}\n\t}\n}\n\n","old_contents":"\/\/ \n\/\/ NotebookBackend.cs\n\/\/  \n\/\/ Author:\n\/\/       Lluis Sanchez <lluis@xamarin.com>\n\/\/ \n\/\/ Copyright (c) 2011 Xamarin Inc\n\/\/ \n\/\/ Permission is hereby granted, free of charge, to any person obtaining a copy\n\/\/ of this software and associated documentation files (the \"Software\"), to deal\n\/\/ in the Software without restriction, including without limitation the rights\n\/\/ to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\n\/\/ copies of the Software, and to permit persons to whom the Software is\n\/\/ furnished to do so, subject to the following conditions:\n\/\/ \n\/\/ The above copyright notice and this permission notice shall be included in\n\/\/ all copies or substantial portions of the Software.\n\/\/ \n\/\/ THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\/\/ IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\/\/ FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\/\/ AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\/\/ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\/\/ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\/\/ THE SOFTWARE.\n\nusing System;\nusing Xwt.Backends;\nusing System.Reflection;\n\nnamespace Xwt.GtkBackend\n{\n\tpublic class NotebookBackend: WidgetBackend, INotebookBackend\n\t{\n\t\tpublic NotebookBackend ()\n\t\t{\n\t\t\tWidget = new Gtk.Notebook ();\n\t\t\tWidget.Scrollable = true;\n\t\t\tWidget.Show ();\n\t\t}\n\t\t\n\t\tnew Gtk.Notebook Widget {\n\t\t\tget { return (Gtk.Notebook)base.Widget; }\n\t\t\tset { base.Widget = value; }\n\t\t}\n\n\t\tpublic override void EnableEvent (object eventId)\n\t\t{\n\t\t\tif (eventId is NotebookEvent) {\n\t\t\t\tNotebookEvent ev = (NotebookEvent) eventId;\n\t\t\t\tif (ev == NotebookEvent.CurrentTabChanged) {\n\t\t\t\t\tWidget.SwitchPage += HandleWidgetSwitchPage;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbase.EnableEvent (eventId);\n\t\t}\n\t\t\n\t\tpublic override void DisableEvent (object eventId)\n\t\t{\n\t\t\tif (eventId is NotebookEvent) {\n\t\t\t\tNotebookEvent ev = (NotebookEvent) eventId;\n\t\t\t\tif (ev == NotebookEvent.CurrentTabChanged) {\n\t\t\t\t\tWidget.SwitchPage -= HandleWidgetSwitchPage;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbase.DisableEvent (eventId);\n\t\t}\n\n\t\tvoid HandleWidgetSwitchPage (object o, Gtk.SwitchPageArgs args)\n\t\t{\n\t\t\t((INotebookEventSink)EventSink).OnCurrentTabChanged ();\n\t\t}\n\t\t\n\t\tpublic void Add (IWidgetBackend widget, NotebookTab tab)\n\t\t{\n\t\t\tWidget.AppendPage (GetWidgetWithPlacement (widget), CreateLabel (tab));\n\t\t}\n\n\t\tpublic void Remove (IWidgetBackend widget)\n\t\t{\n\t\t\tWidget.Remove (GetWidgetWithPlacement (widget));\n\t\t}\n\t\t\n\t\tpublic void UpdateLabel (NotebookTab tab, string hint)\n\t\t{\n\t\t\tIWidgetBackend widget = (IWidgetBackend) Toolkit.GetBackend (tab.Child);\n\t\t\tWidget.SetTabLabel (GetWidget (widget), CreateLabel (tab));\n\t\t}\n\t\t\n\t\tpublic int CurrentTab {\n\t\t\tget {\n\t\t\t\treturn Widget.CurrentPage;\n\t\t\t}\n\t\t\tset {\n\t\t\t\tWidget.CurrentPage = value;\n\t\t\t}\n\t\t}\n\n\t\tpublic Xwt.NotebookTabOrientation TabOrientation {\n\t\t\tget {\n\t\t\t\tXwt.NotebookTabOrientation tabPos = Xwt.NotebookTabOrientation.Top;\n\t\t\t\tEnum.TryParse (Widget.TabPos.ToString (), out tabPos);\n\t\t\t\treturn tabPos;\n\t\t\t}\n\t\t\tset {\n\t\t\t\tGtk.PositionType tabPos = Gtk.PositionType.Top;\n\t\t\t\tEnum.TryParse (value.ToString (), out tabPos);\n\t\t\t\tWidget.TabPos = tabPos;\n\t\t\t}\n\t\t}\n\t\t\n\t\tGtk.Widget CreateLabel(NotebookTab tab)\n\t\t{\n\t\t\tvar vbox = new Gtk.HBox();\n\t\t\tGtk.Label label = new Gtk.Label ();\n\n            \/* INTRODUCED BY houen *\/\n\n            if (tab.Label.Contains(\"\\\\_\"))\n            {\n                label.Text = tab.Label.Replace(\"\\\\_\", \"_\");\n            }\n            else\n            {\n                label.TextWithMnemonic = tab.Label.Replace(\"\\\\_\", \"_\");\n            }\n\n            \/* INTRODUCED BY houen *\/\n                            \n\t\t\tlabel.Show ();\n\t\t\tvbox.PackStart(label);\n\n\t\t\tif(!label.Text.StartsWith(char.ConvertFromUtf32(0x200B)))\n\t\t\t{\n\t\t\t\tvar closeImage = new Gtk.Image(Assembly.GetExecutingAssembly(), \"Xwt.GtkBackend.delete.png\");\n\t\t\t\tvar button = new Gtk.ToolButton(closeImage, \"\");\n\t\t\t\tvbox.PackEnd(button, false, false, 0);\n\t\t\t\tbutton.Show();\n\t\t\t\tcloseImage.Show();\n\t\t\t\tvar nativeWidget = GetWidget((IWidgetBackend)Toolkit.GetBackend(tab.Child));\n\t\t\t\tbutton.Clicked += (object sender, EventArgs e) => \n\t\t\t\t{\n                    tab.OnClosing();\n\t\t\t\t\tWidget.Remove(nativeWidget);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn vbox;\n\t\t}\n\t}\n}\n\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"3a4731fca507049b2d75133f24a9835c1cc285aa","subject":"Fix #29: Ctrl-Backspace","message":"Fix #29: Ctrl-Backspace\n","repos":"Leun4m\/symbsearch,Leun4m\/symbsearch","old_file":"SymbSearch\/FormMain.cs","new_file":"SymbSearch\/FormMain.cs","new_contents":"\ufeffusing System;\nusing System.Windows.Forms;\nusing System.Xml;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Runtime.InteropServices;\n\nnamespace SymbSearch\n{\n    public partial class FormMain : Form\n    {\n        [DllImport(\"user32.dll\")]\n        private static extern bool RegisterHotKey(IntPtr hWnd, int id, int fsModifiers, int vk);\n\n        [DllImport(\"user32.dll\")]\n        private static extern bool UnregisterHotKey(IntPtr hWnd, int id);\n\n        const int MOD_ALT = 0x0001;\n        const int MOD_CONTROL = 0x0002;\n        const int MOD_SHIFT = 0x0004;\n        const int WM_HOTKEY = 0x0312;\n\n        private List<Symb> symbols = new List<Symb>();\n\n        public FormMain()\n        {\n            InitializeComponent();\n            SetAutoCompletion();\n            symbols = MakeList();\n            ShowList(symbols);\n            ShowCats(GetCats());\n        }\n        \/\/\/ <summary>\n        \/\/\/ Filters symbols by category and search\n        \/\/\/ <\/summary>\n        private void FilterList()\n        {\n            List<Symb> newList = new List<Symb>();\n            for (int i = 0; i < symbols.Count; i++)\n            {\n                if (symbols[i].name.ToLower().Contains(searchbox.Text.ToLower()))\n                {\n                    if (cbCategory.SelectedItem.ToString() == \"all\" || cbCategory.SelectedItem.ToString() == symbols[i].cat)\n                    {\n                        newList.Add(symbols[i]);\n                    }\n                }\n            }\n            DeleteList();\n            ShowList(newList);\n        }\n        \/\/\/ <summary>\n        \/\/\/ Enables Ctrl-Backspace to remove whole word\n        \/\/\/ <\/summary>\n        private void SetAutoCompletion()\n        {\n            searchbox.AutoCompleteSource = AutoCompleteSource.CustomSource;\n            searchbox.AutoCompleteMode = AutoCompleteMode.Suggest;\n        }\n        #region List of Symb\n        \/\/\/ <summary>\n        \/\/\/ Reads and parses symbols.xml\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>Returns list of Symb by symbols.xml<\/returns>\n        private List<Symb> MakeList()\n        {\n            XmlReader reader = XmlReader.Create(@\"symbols.xml\");\n            List<Symb> list = new List<Symb>();\n            Symb symb = null;\n            while (reader.Read())\n            {\n                if (reader.NodeType == XmlNodeType.Element && reader.Name == \"symb\")\n                {\n                    symb = new Symb();\n                    list.Add(symb);\n                    if (reader.HasAttributes)\n                    {\n                        while (reader.MoveToNextAttribute())\n                        {\n                            switch (reader.Name)\n                            {\n                                case \"name\":\n                                    symb.name = reader.Value;\n                                    break;\n                                case \"sign\":\n                                    symb.sign = reader.Value.ToCharArray()[0];\n                                    break;\n                                case \"cat\":\n                                    symb.cat = reader.Value;\n                                    break;\n                            }\n                        }   \n                    }\n                }\n            }\n            return list;\n        }\n        \/\/\/ <summary>\n        \/\/\/ Adds the given list to listBox\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"list\"><\/param>\n        private void ShowList(List<Symb> list)\n        {\n            foreach (Symb temp in list)\n            {\n                listBox.Items.Add(temp.sign + \"\\t\" + temp.name);\n            }\n        }\n        \/\/\/ <summary>\n        \/\/\/ Clears the listBox\n        \/\/\/ <\/summary>\n        private void DeleteList()\n        {\n            listBox.Items.Clear();\n        }\n        #endregion\n        #region Cats of Symb\n        \/\/\/ <summary>\n        \/\/\/ Returns the categories of symbols\n        \/\/\/ <\/summary>\n        \/\/\/ <returns><\/returns>\n        private List<string> GetCats()\n        {\n            List<string> cats = new List<string>();\n            cats.Add(\"all\");\n            foreach (Symb temp in symbols)\n            {\n                cats.Add(temp.cat);\n            }\n            return RemoveDoubles(cats);\n        }\n        \/\/\/ <summary>\n        \/\/\/ Adds the given categories to list\n        \/\/\/ <\/summary>\n        private void ShowCats(List<string> cats)\n        {\n            cbCategory.Items.Clear();\n            foreach (string temp in cats)\n            {\n                cbCategory.Items.Add(temp);\n            }\n            cbCategory.Text = \"all\";\n        }\n        \/\/\/ <summary>\n        \/\/\/ Removes doubles of the given list\n        \/\/\/ <\/summary>\n        private List<string> RemoveDoubles(List<string> l)\n        {\n            return l.Distinct().ToList();\n        }\n        #endregion\n        #region Show and Hide\n        protected override void WndProc(ref Message m)\n        {\n            if (m.Msg == WM_HOTKEY && (int)m.WParam == 1)\n            {\n                if (WindowState == FormWindowState.Normal)\n                    MiniForm();\n                else if (WindowState == FormWindowState.Minimized)\n                    ShowForm();\n            }\n            base.WndProc(ref m);\n        }\n        private void MiniForm()\n        {\n            WindowState = FormWindowState.Minimized;\n        }\n        private void ShowForm()\n        {\n            WindowState = FormWindowState.Normal;\n            searchbox.Select();\n        }\n        #endregion\n        #region Keys and Actions\n        private void KeyControl(KeyEventArgs e)\n        {\n            switch (e.KeyCode)\n            {\n                case Keys.Down:\n                    NextElement(listBox);\n                    break;\n                case Keys.Up:\n                    PrevElement(listBox);\n                    break;\n                case Keys.PageDown:\n                    NextElement(cbCategory);\n                    break;\n                case Keys.PageUp:\n                    PrevElement(cbCategory);\n                    break;\n                case Keys.Enter:\n                    ChooseSymb();\n                    break;\n            }\n        }\n        private static void NextElement(ListBox a)\n        {\n            if (a.SelectedIndex < a.Items.Count - 1)\n                a.SelectedIndex = a.SelectedIndex + 1;\n            else\n                a.SelectedIndex = 0;\n        }\n        private static void NextElement(ComboBox a)\n        {\n            if (a.SelectedIndex < a.Items.Count - 1)\n                a.SelectedIndex = a.SelectedIndex + 1;\n            else\n                a.SelectedIndex = 0;\n        }\n        private static void PrevElement(ListBox a)\n        {\n            if (a.SelectedIndex > 0)\n                a.SelectedIndex = a.SelectedIndex - 1;\n            else\n                a.SelectedIndex = a.Items.Count - 1;\n        }\n        private static void PrevElement(ComboBox a)\n        {\n            if (a.SelectedIndex > 0)\n                a.SelectedIndex = a.SelectedIndex - 1;\n            else\n                a.SelectedIndex = a.Items.Count - 1;\n        }\n        private void ChooseSymb()\n        {\n            if (listBox.SelectedItem != null)\n            {\n                Clipboard.SetText(listBox.SelectedItem.ToString().Substring(0, 1));\n            }\n            MiniForm();\n        }\n        #endregion \n        #region Events on Form\n        private void btnQuit_Click(object sender, EventArgs e)\n        {\n            Application.Exit();\n        }\n        private void listBox_SelectedIndexChanged(object sender, EventArgs e)\n        {\n            lblSign.Text = listBox.SelectedItem.ToString().Substring(0, 1);\n        }\n        private void cbCategory_SelectedIndexChanged(object sender, EventArgs e)\n        {\n            FilterList();\n        }\n        private void searchbox_TextChanged(object sender, EventArgs e)\n        {\n            FilterList();\n        }\n        private void Form_Load(object sender, EventArgs e)\n        {\n            RegisterHotKey(this.Handle, 1, MOD_CONTROL + MOD_ALT, (int)Keys.W);\n        }\n\n        private void Form_FormClosing(object sender, FormClosingEventArgs e)\n        {\n            UnregisterHotKey(this.Handle, 1);\n        }\n\n        private void listBox_KeyDown(object sender, KeyEventArgs e)\n        {\n            e.Handled = true;\n            KeyControl(e);\n        }\n\n        private void searchbox_KeyDown(object sender, KeyEventArgs e)\n        {\n            e.Handled = true;\n            if (e.KeyCode == Keys.Enter)\n            {\n                e.SuppressKeyPress = true;\n            }\n            KeyControl(e);\n        }\n        #endregion\n    }\n}\n","old_contents":"\ufeffusing System;\nusing System.Windows.Forms;\nusing System.Xml;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Runtime.InteropServices;\n\nnamespace SymbSearch\n{\n    public partial class FormMain : Form\n    {\n        [DllImport(\"user32.dll\")]\n        private static extern bool RegisterHotKey(IntPtr hWnd, int id, int fsModifiers, int vk);\n\n        [DllImport(\"user32.dll\")]\n        private static extern bool UnregisterHotKey(IntPtr hWnd, int id);\n\n        const int MOD_ALT = 0x0001;\n        const int MOD_CONTROL = 0x0002;\n        const int MOD_SHIFT = 0x0004;\n        const int WM_HOTKEY = 0x0312;\n\n        private List<Symb> symbols = new List<Symb>();\n\n        public FormMain()\n        {\n            InitializeComponent();\n            symbols = MakeList();\n            ShowList(symbols);\n            ShowCats(GetCats());\n        }\n        \/\/\/ <summary>\n        \/\/\/ Filters symbols by category and search\n        \/\/\/ <\/summary>\n        private void FilterList()\n        {\n            List<Symb> newList = new List<Symb>();\n            for (int i = 0; i < symbols.Count; i++)\n            {\n                if (symbols[i].name.ToLower().Contains(searchbox.Text.ToLower()))\n                {\n                    if (cbCategory.SelectedItem.ToString() == \"all\" || cbCategory.SelectedItem.ToString() == symbols[i].cat)\n                    {\n                        newList.Add(symbols[i]);\n                    }\n                }\n            }\n            DeleteList();\n            ShowList(newList);\n        }\n        #region List of Symb\n        \/\/\/ <summary>\n        \/\/\/ Reads and parses symbols.xml\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>Returns list of Symb by symbols.xml<\/returns>\n        private List<Symb> MakeList()\n        {\n            XmlReader reader = XmlReader.Create(@\"symbols.xml\");\n            List<Symb> list = new List<Symb>();\n            Symb symb = null;\n            while (reader.Read())\n            {\n                if (reader.NodeType == XmlNodeType.Element && reader.Name == \"symb\")\n                {\n                    symb = new Symb();\n                    list.Add(symb);\n                    if (reader.HasAttributes)\n                    {\n                        while (reader.MoveToNextAttribute())\n                        {\n                            switch (reader.Name)\n                            {\n                                case \"name\":\n                                    symb.name = reader.Value;\n                                    break;\n                                case \"sign\":\n                                    symb.sign = reader.Value.ToCharArray()[0];\n                                    break;\n                                case \"cat\":\n                                    symb.cat = reader.Value;\n                                    break;\n                            }\n                        }   \n                    }\n                }\n            }\n            return list;\n        }\n        \/\/\/ <summary>\n        \/\/\/ Adds the given list to listBox\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"list\"><\/param>\n        private void ShowList(List<Symb> list)\n        {\n            foreach (Symb temp in list)\n            {\n                listBox.Items.Add(temp.sign + \"\\t\" + temp.name);\n            }\n        }\n        \/\/\/ <summary>\n        \/\/\/ Clears the listBox\n        \/\/\/ <\/summary>\n        private void DeleteList()\n        {\n            listBox.Items.Clear();\n        }\n        #endregion\n        #region Cats of Symb\n        \/\/\/ <summary>\n        \/\/\/ Returns the categories of symbols\n        \/\/\/ <\/summary>\n        \/\/\/ <returns><\/returns>\n        private List<string> GetCats()\n        {\n            List<string> cats = new List<string>();\n            cats.Add(\"all\");\n            foreach (Symb temp in symbols)\n            {\n                cats.Add(temp.cat);\n            }\n            return RemoveDoubles(cats);\n        }\n        \/\/\/ <summary>\n        \/\/\/ Adds the given categories to list\n        \/\/\/ <\/summary>\n        private void ShowCats(List<string> cats)\n        {\n            cbCategory.Items.Clear();\n            foreach (string temp in cats)\n            {\n                cbCategory.Items.Add(temp);\n            }\n            cbCategory.Text = \"all\";\n        }\n        \/\/\/ <summary>\n        \/\/\/ Removes doubles of the given list\n        \/\/\/ <\/summary>\n        private List<string> RemoveDoubles(List<string> l)\n        {\n            return l.Distinct().ToList();\n        }\n        #endregion\n        #region Show and Hide\n        protected override void WndProc(ref Message m)\n        {\n            if (m.Msg == WM_HOTKEY && (int)m.WParam == 1)\n            {\n                if (WindowState == FormWindowState.Normal)\n                    MiniForm();\n                else if (WindowState == FormWindowState.Minimized)\n                    ShowForm();\n            }\n            base.WndProc(ref m);\n        }\n        private void MiniForm()\n        {\n            WindowState = FormWindowState.Minimized;\n        }\n        private void ShowForm()\n        {\n            WindowState = FormWindowState.Normal;\n            searchbox.Select();\n        }\n        #endregion\n        #region Keys and Actions\n        private void KeyControl(KeyEventArgs e)\n        {\n            switch (e.KeyCode)\n            {\n                case Keys.Down:\n                    NextElement(listBox);\n                    break;\n                case Keys.Up:\n                    PrevElement(listBox);\n                    break;\n                case Keys.PageDown:\n                    NextElement(cbCategory);\n                    break;\n                case Keys.PageUp:\n                    PrevElement(cbCategory);\n                    break;\n                case Keys.Enter:\n                    ChooseSymb();\n                    break;\n            }\n        }\n        private static void NextElement(ListBox a)\n        {\n            if (a.SelectedIndex < a.Items.Count - 1)\n                a.SelectedIndex = a.SelectedIndex + 1;\n            else\n                a.SelectedIndex = 0;\n        }\n        private static void NextElement(ComboBox a)\n        {\n            if (a.SelectedIndex < a.Items.Count - 1)\n                a.SelectedIndex = a.SelectedIndex + 1;\n            else\n                a.SelectedIndex = 0;\n        }\n        private static void PrevElement(ListBox a)\n        {\n            if (a.SelectedIndex > 0)\n                a.SelectedIndex = a.SelectedIndex - 1;\n            else\n                a.SelectedIndex = a.Items.Count - 1;\n        }\n        private static void PrevElement(ComboBox a)\n        {\n            if (a.SelectedIndex > 0)\n                a.SelectedIndex = a.SelectedIndex - 1;\n            else\n                a.SelectedIndex = a.Items.Count - 1;\n        }\n        private void ChooseSymb()\n        {\n            if (listBox.SelectedItem != null)\n            {\n                Clipboard.SetText(listBox.SelectedItem.ToString().Substring(0, 1));\n            }\n            MiniForm();\n        }\n        #endregion \n        #region Events on Form\n        private void btnQuit_Click(object sender, EventArgs e)\n        {\n            Application.Exit();\n        }\n        private void listBox_SelectedIndexChanged(object sender, EventArgs e)\n        {\n            lblSign.Text = listBox.SelectedItem.ToString().Substring(0, 1);\n        }\n        private void cbCategory_SelectedIndexChanged(object sender, EventArgs e)\n        {\n            FilterList();\n        }\n        private void searchbox_TextChanged(object sender, EventArgs e)\n        {\n            FilterList();\n        }\n        private void Form_Load(object sender, EventArgs e)\n        {\n            RegisterHotKey(this.Handle, 1, MOD_CONTROL + MOD_ALT, (int)Keys.W);\n        }\n\n        private void Form_FormClosing(object sender, FormClosingEventArgs e)\n        {\n            UnregisterHotKey(this.Handle, 1);\n        }\n\n        private void listBox_KeyDown(object sender, KeyEventArgs e)\n        {\n            e.Handled = true;\n            KeyControl(e);\n        }\n\n        private void searchbox_KeyDown(object sender, KeyEventArgs e)\n        {\n            e.Handled = true;\n            if (e.KeyCode == Keys.Enter)\n            {\n                e.SuppressKeyPress = true;\n            }\n            KeyControl(e);\n        }\n        #endregion\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"4533a5d7a7ad9a63a71a6c6f3d506325f5120f95","subject":"Fix IoC registration","message":"Fix IoC registration\n","repos":"mattgwagner\/Battery-Commander,mattgwagner\/Battery-Commander,mattgwagner\/Battery-Commander,mattgwagner\/Battery-Commander","old_file":"Battery-Commander.Web\/Startup.cs","new_file":"Battery-Commander.Web\/Startup.cs","new_contents":"\ufeffusing BatteryCommander.Web.Jobs;\nusing BatteryCommander.Web.Models;\nusing BatteryCommander.Web.Services;\nusing Microsoft.AspNetCore.Authentication.Cookies;\nusing Microsoft.AspNetCore.Authentication.OpenIdConnect;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Logging;\nusing Newtonsoft.Json.Converters;\nusing Serilog;\nusing Swashbuckle.AspNetCore.Swagger;\nusing System;\nusing System.IO;\nusing System.Net;\nusing System.Security.Claims;\nusing System.Threading.Tasks;\n\nnamespace BatteryCommander.Web\n{\n    public class Startup\n    {\n        public static String API_Version => \"v1\";\n\n        public static String API_Name => $\"Battery Commander {API_Version}\";\n\n        public static String APP_INSIGHTS_KEY = \"66d7081f-e4a1-421f-b57a-38656917ee3d\";\n\n        private static Boolean IsDevelopment;\n\n        public Startup(IHostingEnvironment env)\n        {\n            Log.Logger = new LoggerConfiguration()\n                .Enrich.FromLogContext()\n                .WriteTo.RollingFile(pathFormat: @\"logs\\{Date}.log\")\n                .WriteTo.ApplicationInsightsTraces(APP_INSIGHTS_KEY)\n                .MinimumLevel.Information()\n                .CreateLogger();\n\n            var builder = new ConfigurationBuilder()\n                .SetBasePath(env.ContentRootPath)\n                .AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true)\n                .AddJsonFile($\"appsettings.{env.EnvironmentName}.json\", optional: true)\n                .AddEnvironmentVariables();\n            Configuration = builder.Build();\n            IsDevelopment = env.IsDevelopment();\n        }\n\n        public IConfigurationRoot Configuration { get; }\n\n        \/\/ This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddMemoryCache();\n\n            \/\/ Add functionality to inject IOptions<T>\n            services.AddOptions();\n\n            \/\/ Add the Auth0 Settings object so it can be injected\n            services.Configure<Auth0Settings>(Configuration.GetSection(\"Auth0\"));\n            services.Configure<AirTableSettings>(Configuration.GetSection(\"AirTable\"));\n            services.Configure<SendGridSettings>(Configuration.GetSection(\"SendGrid\"));\n\n            \/\/ Register jobs as services for IoC\n            services.AddTransient<SqliteBackupJob>();\n\n            var auth0Settings = new Auth0Settings { };\n\n            Configuration.GetSection(\"Auth0\").Bind(auth0Settings);\n\n            services.AddTransient<AirTableService>();\n            services.AddTransient<IEmailService, EmailService>();\n\n            services.AddCors(options =>\n            {\n                options.AddPolicy(\"Policy\", builder =>\n                    builder\n                        .AllowAnyHeader()\n                        .AllowAnyMethod()\n                        .AllowAnyOrigin()\n                        .AllowCredentials()\n                        .Build()\n                    );\n            });\n\n            \/\/ Add authentication services\n\n            services\n                .AddAuthentication(options =>\n                {\n                    options.DefaultAuthenticateScheme = CookieAuthenticationDefaults.AuthenticationScheme;\n                    options.DefaultSignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;\n                    options.DefaultChallengeScheme = CookieAuthenticationDefaults.AuthenticationScheme;\n                })\n                .AddJwtBearer(o =>\n                {\n                    o.Authority = $\"https:\/\/{auth0Settings.Domain}\/\";\n                    o.Audience = auth0Settings.ApiIdentifier;\n                    o.RequireHttpsMetadata = !IsDevelopment;\n\n                    \/\/o.TokenValidationParameters = new Microsoft.IdentityModel.Tokens.TokenValidationParameters\n                    \/\/{\n                    \/\/    ValidateIssuer = true,\n                    \/\/    ValidateAudience = true,\n                    \/\/    ValidateLifetime = true,\n\n                    \/\/    ValidateIssuerSigningKey = true,\n                    \/\/    ValidIssuer = \"\",\n                    \/\/    ValidAudience = auth0Settings.ApiIdentifier\n                    \/\/};\n                })\n                .AddCookie(o => o.LoginPath = new PathString(\"\/Home\/Login\"))\n                .AddOpenIdConnect(\"Auth0\", options =>\n                {\n                    options.GetClaimsFromUserInfoEndpoint = true;\n\n                    \/\/ Set the authority to your Auth0 Domain\n                    options.Authority = $\"https:\/\/{auth0Settings.Domain}\/\";\n\n                    \/\/ Configure the Auth0 Client ID and Client Secret\n                    options.ClientId = auth0Settings.ClientId;\n                    options.ClientSecret = auth0Settings.ClientSecret;\n\n                    \/\/ Do not automatically authenticate and challenge\n                    \/\/options.AutomaticAuthenticate = false;\n                    \/\/options.AutomaticChallenge = false;\n\n                    \/\/ Set response type to code\n                    options.ResponseType = \"code\";\n\n                    \/\/ Configure the scope\n                    options.Scope.Clear();\n                    options.Scope.Add(\"openid\");\n\n                    \/\/ Set the callback path, so Auth0 will call back to http:\/\/localhost:5000\/signin-auth0\n                    \/\/ Also ensure that you have added the URL as an Allowed Callback URL in your Auth0 dashboard\n                    options.CallbackPath = new PathString(\"\/signin-auth0\");\n\n                    \/\/ Configure the Claims Issuer to be Auth0\n                    options.ClaimsIssuer = \"Auth0\";\n\n                    options.Events = new OpenIdConnectEvents\n                    {\n                        OnRedirectToIdentityProvider = (context) =>\n                        {\n                            if (context.Request.Path.StartsWithSegments(\"\/api\"))\n                            {\n                                context.Response.StatusCode = (int)HttpStatusCode.Unauthorized;\n                                return Task.CompletedTask;\n                            }\n\n                            context.Response.Redirect(context.Options.SignedOutRedirectUri);\n\n                            return Task.CompletedTask;\n                        },\n\n                        OnTicketReceived = (context) =>\n                        {\n                            var identity = context.Principal.Identity as ClaimsIdentity;\n\n                            if (identity != null)\n                            {\n                                var name = identity.FindFirst(\"email\");\n\n                                if (name != null)\n                                {\n                                    identity.AddClaim(new Claim(ClaimTypes.Name, name.Value));\n                                }\n                            }\n\n                            return Task.CompletedTask;\n                        },\n\n                        OnRedirectToIdentityProviderForSignOut = (context) =>\n                        {\n                            var logoutUri = $\"https:\/\/{auth0Settings.Domain}\/v2\/logout?client_id={auth0Settings.ClientId}\";\n\n                            var postLogoutUri = context.Properties.RedirectUri;\n                            if (!string.IsNullOrEmpty(postLogoutUri))\n                            {\n                                if (postLogoutUri.StartsWith(\"\/\"))\n                                {\n                                    \/\/ transform to absolute\n                                    var request = context.Request;\n                                    postLogoutUri = request.Scheme + \":\/\/\" + request.Host + request.PathBase + postLogoutUri;\n                                }\n                                logoutUri += $\"&returnTo={ Uri.EscapeDataString(postLogoutUri) }\";\n                            }\n\n                            context.Response.Redirect(logoutUri);\n                            context.HandleResponse();\n\n                            return Task.CompletedTask;\n                        }\n                    };\n                });\n\n            \/\/ Add framework services.\n            services.AddMvc(options =>\n            {\n                if (!IsDevelopment)\n                {\n                    options.Filters.Add(new RequireHttpsAttribute { });\n                }\n            })\n            .AddJsonOptions(options =>\n            {\n                options.SerializerSettings.Converters.Add(new StringEnumConverter { });\n            });\n\n            \/\/ Add functionality to inject IOptions<T>\n            services.AddOptions();\n\n            services.AddDbContext<Database>();\n\n            \/\/ Register the Swagger generator, defining one or more Swagger documents\n            services.AddSwaggerGen(c =>\n            {\n                c.DescribeAllEnumsAsStrings();\n\n                c.SwaggerDoc(API_Version, new Info { Title = API_Name, Version = API_Version });\n\n                c.CustomSchemaIds(x => x.FullName);\n\n                c.IncludeXmlComments(Path.Combine(AppContext.BaseDirectory, \"BatteryCommander.Web.xml\"));\n            });\n        }\n\n        \/\/ This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory, Database db)\n        {\n            loggerFactory.AddConsole(Configuration.GetSection(\"Logging\"));\n            loggerFactory.AddSerilog();\n            loggerFactory.AddDebug();\n\n            if (env.IsDevelopment())\n            {\n                app.UseBrowserLink();\n            }\n\n            app.UseDeveloperExceptionPage();\n\n            app.UseStaticFiles();\n\n            \/\/ Enable middleware to serve generated Swagger as a JSON endpoint.\n            app.UseSwagger();\n\n            \/\/ Enable middleware to serve swagger-ui (HTML, JS, CSS, etc.), specifying the Swagger JSON endpoint.\n            app.UseSwaggerUI(c =>\n            {\n                c.SwaggerEndpoint(\"\/swagger\/v1\/swagger.json\", API_Name);\n            });\n\n            app.UseAuthentication();\n\n            app.UseCors(\"Policy\");\n\n            app.UseMvc(routes =>\n            {\n                routes.MapRoute(\n                    name: \"default\",\n                    template: \"{controller=Home}\/{action=Index}\/{id?}\");\n            });\n\n            app.WithScheduler(loggerFactory);\n\n            Database.Init(db);\n        }\n    }\n}","old_contents":"\ufeffusing BatteryCommander.Web.Jobs;\nusing BatteryCommander.Web.Models;\nusing BatteryCommander.Web.Services;\nusing Microsoft.AspNetCore.Authentication.Cookies;\nusing Microsoft.AspNetCore.Authentication.OpenIdConnect;\nusing Microsoft.AspNetCore.Builder;\nusing Microsoft.AspNetCore.Hosting;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Logging;\nusing Newtonsoft.Json.Converters;\nusing Serilog;\nusing Swashbuckle.AspNetCore.Swagger;\nusing System;\nusing System.IO;\nusing System.Net;\nusing System.Security.Claims;\nusing System.Threading.Tasks;\n\nnamespace BatteryCommander.Web\n{\n    public class Startup\n    {\n        public static String API_Version => \"v1\";\n\n        public static String API_Name => $\"Battery Commander {API_Version}\";\n\n        public static String APP_INSIGHTS_KEY = \"66d7081f-e4a1-421f-b57a-38656917ee3d\";\n\n        private static Boolean IsDevelopment;\n\n        public Startup(IHostingEnvironment env)\n        {\n            Log.Logger = new LoggerConfiguration()\n                .Enrich.FromLogContext()\n                .WriteTo.RollingFile(pathFormat: @\"logs\\{Date}.log\")\n                .WriteTo.ApplicationInsightsTraces(APP_INSIGHTS_KEY)\n                .MinimumLevel.Information()\n                .CreateLogger();\n\n            var builder = new ConfigurationBuilder()\n                .SetBasePath(env.ContentRootPath)\n                .AddJsonFile(\"appsettings.json\", optional: true, reloadOnChange: true)\n                .AddJsonFile($\"appsettings.{env.EnvironmentName}.json\", optional: true)\n                .AddEnvironmentVariables();\n            Configuration = builder.Build();\n            IsDevelopment = env.IsDevelopment();\n        }\n\n        public IConfigurationRoot Configuration { get; }\n\n        \/\/ This method gets called by the runtime. Use this method to add services to the container.\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddMemoryCache();\n\n            \/\/ Add functionality to inject IOptions<T>\n            services.AddOptions();\n\n            \/\/ Add the Auth0 Settings object so it can be injected\n            services.Configure<Auth0Settings>(Configuration.GetSection(\"Auth0\"));\n            services.Configure<AirTableSettings>(Configuration.GetSection(\"AirTable\"));\n            services.Configure<SendGridSettings>(Configuration.GetSection(\"SendGrid\"));\n\n            var auth0Settings = new Auth0Settings { };\n\n            Configuration.GetSection(\"Auth0\").Bind(auth0Settings);\n\n            services.AddTransient<AirTableService>();\n\n            services.AddCors(options =>\n            {\n                options.AddPolicy(\"Policy\", builder =>\n                    builder\n                        .AllowAnyHeader()\n                        .AllowAnyMethod()\n                        .AllowAnyOrigin()\n                        .AllowCredentials()\n                        .Build()\n                    );\n            });\n\n            \/\/ Add authentication services\n\n            services\n                .AddAuthentication(options =>\n                {\n                    options.DefaultAuthenticateScheme = CookieAuthenticationDefaults.AuthenticationScheme;\n                    options.DefaultSignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;\n                    options.DefaultChallengeScheme = CookieAuthenticationDefaults.AuthenticationScheme;\n                })\n                .AddJwtBearer(o =>\n                {\n                    o.Authority = $\"https:\/\/{auth0Settings.Domain}\/\";\n                    o.Audience = auth0Settings.ApiIdentifier;\n                    o.RequireHttpsMetadata = !IsDevelopment;\n\n                    \/\/o.TokenValidationParameters = new Microsoft.IdentityModel.Tokens.TokenValidationParameters\n                    \/\/{\n                    \/\/    ValidateIssuer = true,\n                    \/\/    ValidateAudience = true,\n                    \/\/    ValidateLifetime = true,\n\n                    \/\/    ValidateIssuerSigningKey = true,\n                    \/\/    ValidIssuer = \"\",\n                    \/\/    ValidAudience = auth0Settings.ApiIdentifier\n                    \/\/};\n                })\n                .AddCookie(o => o.LoginPath = new PathString(\"\/Home\/Login\"))\n                .AddOpenIdConnect(\"Auth0\", options =>\n                {\n                    options.GetClaimsFromUserInfoEndpoint = true;\n\n                    \/\/ Set the authority to your Auth0 Domain\n                    options.Authority = $\"https:\/\/{auth0Settings.Domain}\/\";\n\n                    \/\/ Configure the Auth0 Client ID and Client Secret\n                    options.ClientId = auth0Settings.ClientId;\n                    options.ClientSecret = auth0Settings.ClientSecret;\n\n                    \/\/ Do not automatically authenticate and challenge\n                    \/\/options.AutomaticAuthenticate = false;\n                    \/\/options.AutomaticChallenge = false;\n\n                    \/\/ Set response type to code\n                    options.ResponseType = \"code\";\n\n                    \/\/ Configure the scope\n                    options.Scope.Clear();\n                    options.Scope.Add(\"openid\");\n\n                    \/\/ Set the callback path, so Auth0 will call back to http:\/\/localhost:5000\/signin-auth0\n                    \/\/ Also ensure that you have added the URL as an Allowed Callback URL in your Auth0 dashboard\n                    options.CallbackPath = new PathString(\"\/signin-auth0\");\n\n                    \/\/ Configure the Claims Issuer to be Auth0\n                    options.ClaimsIssuer = \"Auth0\";\n\n                    options.Events = new OpenIdConnectEvents\n                    {\n                        OnRedirectToIdentityProvider = (context) =>\n                        {\n                            if (context.Request.Path.StartsWithSegments(\"\/api\"))\n                            {\n                                context.Response.StatusCode = (int)HttpStatusCode.Unauthorized;\n                                return Task.CompletedTask;\n                            }\n\n                            context.Response.Redirect(context.Options.SignedOutRedirectUri);\n\n                            return Task.CompletedTask;\n                        },\n\n                        OnTicketReceived = (context) =>\n                        {\n                            var identity = context.Principal.Identity as ClaimsIdentity;\n\n                            if (identity != null)\n                            {\n                                var name = identity.FindFirst(\"email\");\n\n                                if (name != null)\n                                {\n                                    identity.AddClaim(new Claim(ClaimTypes.Name, name.Value));\n                                }\n                            }\n\n                            return Task.CompletedTask;\n                        },\n\n                        OnRedirectToIdentityProviderForSignOut = (context) =>\n                        {\n                            var logoutUri = $\"https:\/\/{auth0Settings.Domain}\/v2\/logout?client_id={auth0Settings.ClientId}\";\n\n                            var postLogoutUri = context.Properties.RedirectUri;\n                            if (!string.IsNullOrEmpty(postLogoutUri))\n                            {\n                                if (postLogoutUri.StartsWith(\"\/\"))\n                                {\n                                    \/\/ transform to absolute\n                                    var request = context.Request;\n                                    postLogoutUri = request.Scheme + \":\/\/\" + request.Host + request.PathBase + postLogoutUri;\n                                }\n                                logoutUri += $\"&returnTo={ Uri.EscapeDataString(postLogoutUri) }\";\n                            }\n\n                            context.Response.Redirect(logoutUri);\n                            context.HandleResponse();\n\n                            return Task.CompletedTask;\n                        }\n                    };\n                });\n\n            \/\/ Add framework services.\n            services.AddMvc(options =>\n            {\n                if (!IsDevelopment)\n                {\n                    options.Filters.Add(new RequireHttpsAttribute { });\n                }\n            })\n            .AddJsonOptions(options =>\n            {\n                options.SerializerSettings.Converters.Add(new StringEnumConverter { });\n            });\n\n            \/\/ Add functionality to inject IOptions<T>\n            services.AddOptions();\n\n            services.AddDbContext<Database>();\n\n            \/\/ Register the Swagger generator, defining one or more Swagger documents\n            services.AddSwaggerGen(c =>\n            {\n                c.DescribeAllEnumsAsStrings();\n\n                c.SwaggerDoc(API_Version, new Info { Title = API_Name, Version = API_Version });\n\n                c.CustomSchemaIds(x => x.FullName);\n\n                c.IncludeXmlComments(Path.Combine(AppContext.BaseDirectory, \"BatteryCommander.Web.xml\"));\n            });\n        }\n\n        \/\/ This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\n        public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory, Database db)\n        {\n            loggerFactory.AddConsole(Configuration.GetSection(\"Logging\"));\n            loggerFactory.AddSerilog();\n            loggerFactory.AddDebug();\n\n            if (env.IsDevelopment())\n            {\n                app.UseBrowserLink();\n            }\n\n            app.UseDeveloperExceptionPage();\n\n            app.UseStaticFiles();\n\n            \/\/ Enable middleware to serve generated Swagger as a JSON endpoint.\n            app.UseSwagger();\n\n            \/\/ Enable middleware to serve swagger-ui (HTML, JS, CSS, etc.), specifying the Swagger JSON endpoint.\n            app.UseSwaggerUI(c =>\n            {\n                c.SwaggerEndpoint(\"\/swagger\/v1\/swagger.json\", API_Name);\n            });\n\n            app.UseAuthentication();\n\n            app.UseCors(\"Policy\");\n\n            app.UseMvc(routes =>\n            {\n                routes.MapRoute(\n                    name: \"default\",\n                    template: \"{controller=Home}\/{action=Index}\/{id?}\");\n            });\n\n            app.WithScheduler(loggerFactory);\n\n            Database.Init(db);\n        }\n    }\n}","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"cb1d5dbc842b5c6794248fd98a1bd59b25a05041","subject":"SportsStore.WebUI -> Changed Edit view - added upload fiel functionality.","message":"SportsStore.WebUI -> Changed Edit view - added upload fiel functionality.\n","repos":"plamenti\/ProAsp.NetMvc5,plamenti\/ProAsp.NetMvc5","old_file":"SportsStore\/SportsStore\/SportsStore.WebUI\/Views\/Admin\/Edit.cshtml","new_file":"SportsStore\/SportsStore\/SportsStore.WebUI\/Views\/Admin\/Edit.cshtml","new_contents":"\ufeff@model SportsStore.Domain.Entities.Product\n\n@{\n    ViewBag.Title = \"Admin: Edit\" + Model.Name;\n    Layout = \"~\/Views\/Shared\/_AdminLayout.cshtml\";\n}\n\n<div class=\"panel\">\n    <div class=\"panel-heading\">\n        <h3>Edit @Model.Name<\/h3>\n    <\/div>\n\n    @using (Html.BeginForm(\"Edit\", \"Admin\", FormMethod.Post, new { enctype = \"multipart\/form-data\" }))\n    {\n        <div class=\"panel-body\">\n            @Html.HiddenFor(m => m.ProductID)\n            @foreach (var property in ViewData.ModelMetadata.Properties)\n            {\n                switch (property.PropertyName)\n                {\n                    case \"ProductID\":\n                    case \"ImageData\":\n                    case \"ImageMimeType\":\n                        break;\n                    default:\n                        <div class=\"form-group\">\n                            <label>@(property.DisplayName ?? property.PropertyName)<\/label>\n                            @if (property.PropertyName == \"Description\")\n                            {\n                                @Html.TextArea(property.PropertyName, null, new { @class = \"form-control\", rows = 5 })\n                            }\n                            else\n                            {\n                                @Html.TextBox(property.PropertyName, null, new { @class = \"form-control\" })\n                            }\n\n                            @Html.ValidationMessage(property.PropertyName)\n                        <\/div>\n                        break;\n                }\n            }\n\n            <div class=\"form-group\">\n                <div style=\"position:relative;\">\n                    <label>Image<\/label>\n                    <a class=\"btn\" href=\"javascript:;\">\n                        Choose File...\n                        <input type=\"file\" name=\"Image\" size=\"40\"\n                               style=\"position:absolute;\n                                    z-index:2;\n                                    top:0;\n                                    left:0;\n                                    filter:alpha(opacity=0);\n                                    opacity:0;\n                                    background-color:transparent;\n                                    color:transparent;\"\n                               onchange='$(\"#upload-file-info\").html($(this).val());' \/>\n                    <\/a>\n                    <span class=\"label label-info\" id=\"upload-file-info\"><\/span>\n                <\/div>\n\n                @if (Model.ImageData == null)\n                {\n                    <div class=\"form-control-static\">No image<\/div>\n                }\n                else\n                {\n                    <img class=\"img-thumbnail\" width=\"150\" height=\"150\" src=\"@Url.Action(\"GetImage\", \"Product\", new { Model.ProductID})\" \/>\n                }\n            <\/div>\n        <\/div>\n\n        <div class=\"panel-footer\">\n            <input type=\"submit\" value=\"Save\" class=\"btn btn-primary\" \/>\n            @Html.ActionLink(\"Cancel and erturn to List\", \"Index\", null, new { @class = \"btn btn-default\" })\n        <\/div>\n    }\n<\/div>\n","old_contents":"\ufeff@model SportsStore.Domain.Entities.Product\n\n@{\n    ViewBag.Title = \"Admin: Edit\" + Model.Name;\n    Layout = \"~\/Views\/Shared\/_AdminLayout.cshtml\";\n}\n\n<div class=\"panel\">\n    <div class=\"panel-heading\">\n        <h3>Edit @Model.Name<\/h3>\n    <\/div>\n\n    @using (Html.BeginForm(\"Edit\", \"Admin\"))\n    {\n        <div class=\"panel-body\">\n            @Html.HiddenFor(m => m.ProductID)\n            @foreach (var property in ViewData.ModelMetadata.Properties)\n            {\n                if (property.PropertyName != \"ProductID\")\n                {\n                    <div class=\"form-group\">\n                        <label>@(property.DisplayName ?? property.PropertyName)<\/label>\n                        @if(property.PropertyName == \"Description\")\n                        {\n                            @Html.TextArea(property.PropertyName, null, new { @class = \"form-control\", rows = 5})\n                        }\n                        else\n                        {\n                            @Html.TextBox(property.PropertyName, null, new { @class = \"form-control\"})\n                        }\n\n                        @Html.ValidationMessage(property.PropertyName)\n                    <\/div>\n                }\n            }\n        <\/div>\n\n        <div class=\"panel-footer\">\n            <input type=\"submit\" value=\"Save\" class=\"btn btn-primary\" \/>\n            @Html.ActionLink(\"Cancel and erturn to List\", \"Index\", null, new { @class = \"btn btn-default\"})\n        <\/div>\n    }\n<\/div>\n\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"74d657ac996e57e76af891bac6f2c0609393ff65","subject":"14 update","message":"14 update\n","repos":"todorkolev81\/SoftUni","old_file":"Strings and Text Processing - LAB\/1ReverseString\/ReverseString.cs","new_file":"Strings and Text Processing - LAB\/1ReverseString\/ReverseString.cs","new_contents":"","old_contents":"","returncode":0,"stderr":"unknown","license":"mit","lang":"C#"}
{"commit":"a8a4cf7c7ad241bb7b7ff31031f05dc59e2c76a3","subject":"Fixed Merge Errors","message":"Fixed Merge Errors\n","repos":"HenryWConklin\/Blink,dah6ce\/Blink","old_file":"Blink\/Blink\/Classes\/StateGame.cs","new_file":"Blink\/Blink\/Classes\/StateGame.cs","new_contents":"\ufeffusing System;\nusing System.IO;\nusing Blink.GUI;\nusing Blink.Classes;\nusing System.Collections.Generic;\nusing Microsoft.Xna.Framework.Input;\nusing Microsoft.Xna.Framework;\nusing Microsoft.Xna.Framework.Content;\nusing Microsoft.Xna.Framework.Graphics;\n\nnamespace Blink\n{\n    enum PlayerKeys\n    {\n        Player1,\n        Player2,\n        Player3,\n        Player4,\n        allPlayers\n\n    }\n\n\tpublic class StateGame : GameState\n\t{\n\t\tVector2 screenSize;\n        SpearClass spear1;\r\n        SpearClass spear2;\r\n        SpearClass spear3;\r\n        SpearClass spear4;\n\t\tPlayerClass player1;\n\t\tPlayerClass player2;\n\t\tPlayerClass player3;\n\t\tPlayerClass player4;\n        PlayerClass[] players = new PlayerClass[4];\n        SpearClass[] spears = new SpearClass[4];\n\n\t\tPlayerKeys currPlayer;\n\t\tKeyboardState oldState;\n\t\tKeyboardState player1State;\n\t\tKeyboardState player2State;\n\t\tKeyboardState player3State;\n\t\tKeyboardState player4State;\n        string mapName = \"map1\";\n        float roundReset = -1;\n        float timeElapsed;\n        public static GameTime gameTime = new GameTime();\r\n\t\tMap map1;\n\t\tbool[] oldStartState = new bool[4];\n\t\tbool paused;\n\t\tint playerPaused;\n\t\tSpriteFont font;\n        List<Animation> animations;\n\n        public void setMap(string map)\n        {\n            mapName = map;\n        }\n\n\t\tpublic StateGame(Vector2 screenSize)\n\t\t{\n\t\t\tthis.screenSize = screenSize;\n\t\t}\n\n\t\tpublic void Initialize()\n\t\t{\n\t\t\tplayer1 = new PlayerClass();\n\t\t\tplayer2 = new PlayerClass();\n\t\t\tplayer3 = new PlayerClass();\n\t\t\tplayer4 = new PlayerClass();\n\n            animations = new List<Animation>();\n\n            player1.title = \"p1\";\n            player2.title = \"p2\";\n            player3.title = \"p3\";\n            player4.title = \"p4\";\n\n            player1.onPlayerKilled += new PlayerClass.PlayerKilledHandler(playerKilled);\n            player2.onPlayerKilled += new PlayerClass.PlayerKilledHandler(playerKilled);\n            player3.onPlayerKilled += new PlayerClass.PlayerKilledHandler(playerKilled);\n            player4.onPlayerKilled += new PlayerClass.PlayerKilledHandler(playerKilled);\n\n\t\t\tmap1 = new Map();\n\t\t\tcurrPlayer = PlayerKeys.Player1;\n\t\t\tpaused = false;\n\t\t\tplayerPaused = 0;\n\t\t}\n\n\t\tpublic void LoadContent(ContentManager Content)\n\t\t{\n\t\t\tVector2 player1Pos = new Vector2(96, 96);\n\t\t\tVector2 player2Pos = new Vector2(1400, 96);\n\t\t\tVector2 player3Pos = new Vector2(400, 96);\n\t\t\tVector2 player4Pos = new Vector2(1120, 96);\n            \n            players[0] = player1;\n            players[1] = player2;\n            players[2] = player3;\n            players[3] = player4;\n\n\n            Vector2 offset = new Vector2(-4, -4);\n            Texture2D bar = Content.Load<Texture2D>(\"bar\");\n            Texture2D dust = Content.Load<Texture2D>(\"Dust_Trail\");\n\n            player1.Initialize(Content.Load<Texture2D>(\"ROTH-OG-SPEARLESS\"), player1Pos, screenSize, map1, players, offset, bar);\n            player2.Initialize(Content.Load<Texture2D>(\"ROTH-RED-SPEARLESS\"), player2Pos, screenSize, map1, players, offset, bar);\n            player3.Initialize(Content.Load<Texture2D>(\"ROTH-SILVER-SPEARLESS\"), player3Pos, screenSize, map1, players, offset, bar);\n            player4.Initialize(Content.Load<Texture2D>(\"ROTH-BLACK-SPEARLESS\"), player4Pos, screenSize, map1, players, offset, bar);\n\n            player1.deadText = Content.Load<Texture2D>(\"spriteDead\");\n            player2.deadText = Content.Load<Texture2D>(\"spriteDead\");\n            player3.deadText = Content.Load<Texture2D>(\"spriteDead\");\n            player4.deadText = Content.Load<Texture2D>(\"spriteDead\");\n\n            player1.dustEffect = dust;\n            player2.dustEffect = dust;\n            player3.dustEffect = dust;\n            player4.dustEffect = dust;\n\n            player1.aniList = animations;\n            player2.aniList = animations;\n            player3.aniList = animations;\n            player4.aniList = animations;\n\n            spear1 = new SpearClass(player1, Content.Load<Texture2D>(\"spearsprite\"), screenSize, map1, players);\n            spear2 = new SpearClass(player2, Content.Load<Texture2D>(\"spearsprite\"), screenSize, map1, players);\n            spear3 = new SpearClass(player3, Content.Load<Texture2D>(\"spearsprite\"), screenSize, map1, players);\n            spear4 = new SpearClass(player4, Content.Load<Texture2D>(\"spearsprite\"), screenSize, map1, players);\r\n\r\n            spears[0] = spear1;\r\n            spears[1] = spear2;\r\n            spears[2] = spear3;\r\n            spears[3] = spear4;\n\r\n            StreamReader mapData;\n            mapData = File.OpenText(\"Content\/MapData\/\"+mapName+\".map\");\n            map1.Initialize(Content.Load<Texture2D>(\"MapData\/\"+mapName+\"Color\"), mapData.ReadToEnd(), 32, 50, 30, players);\r\n            font = Content.Load<SpriteFont>(\"miramo30\");\r\n        }\n\n\t\tpublic void UnloadContent()\n\t\t{\n\t\t\t\n\t\t}\n\n\t\tpublic void Update(GameTime gameTime)\n\t\t{\n\t\t\tKeyboardState currState = Keyboard.GetState();\n\n            for (int i = 0; i < animations.Count; i++)\r\n            {\r\n                animations[i].Update(gameTime);\r\n            }\n\n\t\t\tif(paused)\n\t\t\t{\n\t\t\t\tif (currState.IsKeyDown(Keys.P) && currState != oldState && playerPaused == (int)currPlayer)\n\t\t\t\t{\n\t\t\t\t\tpaused = false;\n\t\t\t\t\toldState = currState;\n\t\t\t\t}\n\t\t\t\tforeach (PlayerIndex x in Enum.GetValues(typeof(PlayerIndex)))\n\t\t\t\t{\n\t\t\t\t\tif (playerPaused == (int)x && GamePad.GetState(x).IsButtonDown(Buttons.Start) && !oldStartState[(int)x])\n\t\t\t\t\t{\n\t\t\t\t\t\tpaused = false;\n\t\t\t\t\t\toldStartState[(int)x] = GamePad.GetState(x).IsButtonDown(Buttons.Start);\n                    }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!paused)\n\t\t\t{\n\t\t\t\tif (currState.IsKeyDown(Keys.P) && currState != oldState)\n\t\t\t\t{\n\t\t\t\t\tpaused = true;\n\t\t\t\t\toldState = currState;\n\t\t\t\t\tplayerPaused = (int)currPlayer;\n\t\t\t\t}\n\t\t\t\tforeach (PlayerIndex x in Enum.GetValues(typeof(PlayerIndex)))\n\t\t\t\t{\n\t\t\t\t\tif (GamePad.GetState(x).IsButtonDown(Buttons.Start) && !oldStartState[(int)x])\n\t\t\t\t\t{\n\t\t\t\t\t\tpaused = true;\n\t\t\t\t\t\tplayerPaused = (int)x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (paused)\n\t\t\t{\n\t\t\t\toldState = currState;\n\t\t\t\toldStartState[0] = GamePad.GetState(PlayerIndex.One).IsButtonDown(Buttons.Start);\n\t\t\t\toldStartState[1] = GamePad.GetState(PlayerIndex.Two).IsButtonDown(Buttons.Start);\n\t\t\t\toldStartState[2] = GamePad.GetState(PlayerIndex.Three).IsButtonDown(Buttons.Start);\n\t\t\t\toldStartState[3] = GamePad.GetState(PlayerIndex.Four).IsButtonDown(Buttons.Start);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t\/* Press TAB to change player if using keyboard. *** For Testing Purposes Only ***\n                If you hold down a key while pressing TAB, the previous player will continue to do that same action\n                over and over again until you tab to that player again. \n                (It is kinda amusing, but could be useful for collison testing) *\/\n\t\t\tif (currState.IsKeyDown(Keys.Tab) && oldState != currState)\n\t\t\t{\n\t\t\t\tswitch ((int)currPlayer)\n\t\t\t\t{\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tcurrPlayer = PlayerKeys.Player2;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tcurrPlayer = PlayerKeys.Player3;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tcurrPlayer = PlayerKeys.Player4;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tcurrPlayer = PlayerKeys.allPlayers;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tcurrPlayer = PlayerKeys.Player1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\/\/Switches to the next player\n\t\t\t}\n\t\t\tif (currPlayer == PlayerKeys.Player1)\n\t\t\t{\n\t\t\t\tplayer1State = Keyboard.GetState();\n\t\t\t}\n\n\t\t\tif (currPlayer == PlayerKeys.Player2)\n\t\t\t{\n\t\t\t\tplayer2State = Keyboard.GetState();\n\t\t\t}\n\n\t\t\tif (currPlayer == PlayerKeys.Player3)\n\t\t\t{\n\t\t\t\tplayer3State = Keyboard.GetState();\n\t\t\t}\n\t\t\tif (currPlayer == PlayerKeys.Player4)\n\t\t\t{\n\t\t\t\tplayer4State = Keyboard.GetState();\n\t\t\t}\n\n\t\t\tif (currPlayer == PlayerKeys.allPlayers)\n\t\t\t{\n\t\t\t\tplayer1State = Keyboard.GetState();\n\t\t\t\tplayer2State = Keyboard.GetState();\n\t\t\t\tplayer3State = Keyboard.GetState();\n\t\t\t\tplayer4State = Keyboard.GetState();\n\t\t\t}\n\t\t\t\/\/End of TAB code. Can now only control one player at a time using keyboard.\n\t\t\tplayer1.Update(player1State, GamePad.GetState(PlayerIndex.One), gameTime);\r\n            player2.Update(player2State, GamePad.GetState(PlayerIndex.Two), gameTime);\r\n            player3.Update(player3State, GamePad.GetState(PlayerIndex.Three), gameTime);\r\n            player4.Update(player4State, GamePad.GetState(PlayerIndex.Four), gameTime);\r\n            foreach (SpearClass sp in spears)\r\n            {\r\n              \r\n                    if (sp.spearOwner == player1)\r\n                    {\r\n                        sp.Update(player1State, GamePad.GetState(PlayerIndex.One));\r\n                    }\r\n\r\n                    if (sp.spearOwner == player2)\r\n                    {\r\n                        sp.Update(player2State, GamePad.GetState(PlayerIndex.Two));\r\n                    }\r\n                    if (sp.spearOwner == player3)\r\n                    {\r\n                        sp.Update(player3State, GamePad.GetState(PlayerIndex.Three));\r\n                    }\r\n                    if (sp.spearOwner == player4)\r\n                    {\r\n                        sp.Update(player4State, GamePad.GetState(PlayerIndex.Four));\r\n                    }\r\n                    else\r\n                    {\r\n                        KeyboardState fakestate = new KeyboardState();\r\n                        GamePadState faker = new GamePadState();\r\n                        sp.Update(fakestate, faker);\r\n                    }\r\n            }\r\n\t\t\toldState = currState;\r\n\r\n            oldStartState[0] = GamePad.GetState(PlayerIndex.One).IsButtonDown(Buttons.Start);\r\n            oldStartState[1] = GamePad.GetState(PlayerIndex.Two).IsButtonDown(Buttons.Start);\r\n            oldStartState[2] = GamePad.GetState(PlayerIndex.Three).IsButtonDown(Buttons.Start);\r\n            oldStartState[3] = GamePad.GetState(PlayerIndex.Four).IsButtonDown(Buttons.Start);\n            \/\/If a timer is running, decrement here\n\n            timeElapsed = (float)gameTime.ElapsedGameTime.TotalSeconds;\n            if(roundReset > 0)\n            {\n                roundReset -= timeElapsed;\n                if(roundReset < 0)\n                {\n                    resetMap();\r\n\t\t}\n            }\n        }\n\n\t\tpublic void Draw(SpriteBatch sb)\n\t\t{\n\t\t\tmap1.Draw(sb);\n\t\t\tplayer1.Draw(sb);\n\t\t\tplayer2.Draw(sb);\n\t\t\tplayer3.Draw(sb);\n\t\t\tplayer4.Draw(sb);\n            spear1.Draw(sb);\r\n            spear2.Draw(sb);\r\n            spear3.Draw(sb);\r\n            spear4.Draw(sb);\n\n            for (int i = 0; i < animations.Count; i++)\r\n            {\r\n                animations[i].Draw(sb);\r\n            }\n\n\t\t\tif (paused)\n\t\t\t{\n\t\t\t\tsb.DrawString(font, \"P\" + (playerPaused + 1) + \" paused\", new Vector2(screenSize.X \/ 2, screenSize.Y \/ 2), Color.Black);\n\t\t\t}\n\t\t\tif (roundReset > 0)\r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t\tVector2 temp = new Vector2(screenSize.X \/ 2, 300);\r\n\t\t\t\tsb.DrawString(font, \"SCORES\", temp, Color.White);\r\n\r\n\t\t\t\ttemp.Y += 32;\r\n\t\t\t\tfor (int i = 0; i < players.Length; i ++)\r\n\t\t\t\t{\r\n\t\t\t\t\tsb.DrawString(font, \"P\" + (i + 1) + \": \" + players[i].score, temp, Color.White);\r\n\t\t\t\t\ttemp.Y += 32;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\n\n\t\tpublic GameState GetTransition() \n\t\t{\n\t\t\treturn null;\n\t\t}\n\n        private void playerKilled(Object sender, DeathEventArgs args)\n        {\n            \/\/Do things like announce death\/method of death\n\n            detectWinner();\n        }\n\n        public void detectWinner()\n        {\n            Boolean survivor = false;\n            PlayerClass victor = null;\n            foreach (PlayerClass p in players)\n            {\n                if (victor == null && !p.isDead())\n                {\n                    victor = p;\n                    survivor = true;\n                }\n                else if (victor != null && !p.isDead())\n                {\n                    victor = null;\n                    break;\n                }\n            }\n\n            if (victor != null || (victor == null && !survivor))\n            {\n                declareVictor(victor);\n            }\n        }\n\n        private void declareVictor(PlayerClass victor)\n        {\n            victor.winner();\n            roundReset = 3;\n        }\n\n        private void resetMap()\n        {\n            map1.reset();\n            foreach(PlayerClass p in players)\n            {\n                p.reset();\n            }\n\r\n            spear1.reset(players[0]);\r\n            spear2.reset(players[1]);\r\n            spear3.reset(players[2]);\r\n            spear4.reset(players[3]);\n        }\n\t}\n}\n\n","old_contents":"\ufeffusing System;\nusing System.IO;\nusing Blink.GUI;\nusing Blink.Classes;\nusing System.Collections.Generic;\nusing Microsoft.Xna.Framework.Input;\nusing Microsoft.Xna.Framework;\nusing Microsoft.Xna.Framework.Content;\nusing Microsoft.Xna.Framework.Graphics;\n\nnamespace Blink\n{\n    enum PlayerKeys\n    {\n        Player1,\n        Player2,\n        Player3,\n        Player4,\n        allPlayers\n\n    }\n\n\tpublic class StateGame : GameState\n\t{\n\t\tVector2 screenSize;\n        SpearClass spear1;\r\n        SpearClass spear2;\r\n        SpearClass spear3;\r\n        SpearClass spear4;\n\t\tPlayerClass player1;\n\t\tPlayerClass player2;\n\t\tPlayerClass player3;\n\t\tPlayerClass player4;\n        PlayerClass[] players = new PlayerClass[4];\n        SpearClass[] spears = new SpearClass[4];\n\n\t\tPlayerKeys currPlayer;\n\t\tKeyboardState oldState;\n\t\tKeyboardState player1State;\n\t\tKeyboardState player2State;\n\t\tKeyboardState player3State;\n\t\tKeyboardState player4State;\n        string mapName = \"map1\";\n        float roundReset = -1;\n        float timeElapsed;\n        public static GameTime gameTime = new GameTime();\r\n\t\tMap map1;\n\t\tbool[] oldStartState = new bool[4];\n\t\tbool paused;\n\t\tint playerPaused;\n\t\tSpriteFont font;\n        List<Animation> animations;\n\n        public void setMap(string map)\n        {\n            mapName = map;\n        }\n\n\t\tpublic StateGame(Vector2 screenSize)\n\t\t{\n\t\t\tthis.screenSize = screenSize;\n\t\t}\n\n\t\tpublic void Initialize()\n\t\t{\n\t\t\tplayer1 = new PlayerClass();\n\t\t\tplayer2 = new PlayerClass();\n\t\t\tplayer3 = new PlayerClass();\n\t\t\tplayer4 = new PlayerClass();\n\n            animations = new List<Animation>();\n\n            player1.title = \"p1\";\n            player2.title = \"p2\";\n            player3.title = \"p3\";\n            player4.title = \"p4\";\n\n            player1.onPlayerKilled += new PlayerClass.PlayerKilledHandler(playerKilled);\n            player2.onPlayerKilled += new PlayerClass.PlayerKilledHandler(playerKilled);\n            player3.onPlayerKilled += new PlayerClass.PlayerKilledHandler(playerKilled);\n            player4.onPlayerKilled += new PlayerClass.PlayerKilledHandler(playerKilled);\n\n\t\t\tmap1 = new Map();\n\t\t\tcurrPlayer = PlayerKeys.Player1;\n\t\t\tpaused = false;\n\t\t\tplayerPaused = 0;\n\t\t}\n\n\t\tpublic void LoadContent(ContentManager Content)\n\t\t{\n\t\t\tVector2 player1Pos = new Vector2(96, 96);\n\t\t\tVector2 player2Pos = new Vector2(1400, 96);\n\t\t\tVector2 player3Pos = new Vector2(400, 96);\n\t\t\tVector2 player4Pos = new Vector2(1120, 96);\n            \n            players[0] = player1;\n            players[1] = player2;\n            players[2] = player3;\n            players[3] = player4;\n\n\n            Vector2 offset = new Vector2(-4, -4);\n            Texture2D bar = Content.Load<Texture2D>(\"bar\");\n            Texture2D dust = Content.Load<Texture2D>(\"Dust_Trail\");\n\n            player1.Initialize(Content.Load<Texture2D>(\"ROTH-OG-SPEARLESS\"), player1Pos, screenSize, map1, players, offset, bar);\n            player2.Initialize(Content.Load<Texture2D>(\"ROTH-RED-SPEARLESS\"), player2Pos, screenSize, map1, players, offset, bar);\n            player3.Initialize(Content.Load<Texture2D>(\"ROTH-SILVER-SPEARLESS\"), player3Pos, screenSize, map1, players, offset, bar);\n            player4.Initialize(Content.Load<Texture2D>(\"ROTH-BLACK-SPEARLESS\"), player4Pos, screenSize, map1, players, offset, bar);\n\n            player1.deadText = Content.Load<Texture2D>(\"spriteDead\");\n            player2.deadText = Content.Load<Texture2D>(\"spriteDead\");\n            player3.deadText = Content.Load<Texture2D>(\"spriteDead\");\n            player4.deadText = Content.Load<Texture2D>(\"spriteDead\");\n\n            player1.dustEffect = dust;\n            player2.dustEffect = dust;\n            player3.dustEffect = dust;\n            player4.dustEffect = dust;\n\n            player1.aniList = animations;\n            player2.aniList = animations;\n            player3.aniList = animations;\n            player4.aniList = animations;\n\n            spear1 = new SpearClass(player1, Content.Load<Texture2D>(\"spearsprite\"), screenSize, map1, players, spears);\n            spear2 = new SpearClass(player2, Content.Load<Texture2D>(\"spearsprite\"), screenSize, map1, players, spears);\n            spear3 = new SpearClass(player3, Content.Load<Texture2D>(\"spearsprite\"), screenSize, map1, players, spears);\n            spear4 = new SpearClass(player4, Content.Load<Texture2D>(\"spearsprite\"), screenSize, map1, players, spears);\r\n\r\n            spears[0] = spear1;\r\n            spears[1] = spear2;\r\n            spears[2] = spear3;\r\n            spears[3] = spear4;\n\r\n            StreamReader mapData;\n            mapData = File.OpenText(\"Content\/MapData\/\"+mapName+\".map\");\n            map1.Initialize(Content.Load<Texture2D>(\"MapData\/\"+mapName+\"Color\"), mapData.ReadToEnd(), 32, 50, 30, players);\r\n            font = Content.Load<SpriteFont>(\"miramo30\");\r\n        }\n\n\t\tpublic void UnloadContent()\n\t\t{\n\t\t\t\n\t\t}\n\n\t\tpublic void Update(GameTime gameTime)\n\t\t{\n\t\t\tKeyboardState currState = Keyboard.GetState();\n\n            for (int i = 0; i < animations.Count; i++)\r\n            {\r\n                animations[i].Update(gameTime);\r\n            }\n\n\t\t\tif(paused)\n\t\t\t{\n\t\t\t\tif (currState.IsKeyDown(Keys.P) && currState != oldState && playerPaused == (int)currPlayer)\n\t\t\t\t{\n\t\t\t\t\tpaused = false;\n\t\t\t\t\toldState = currState;\n\t\t\t\t}\n\t\t\t\tforeach (PlayerIndex x in Enum.GetValues(typeof(PlayerIndex)))\n\t\t\t\t{\n\t\t\t\t\tif (playerPaused == (int)x && GamePad.GetState(x).IsButtonDown(Buttons.Start) && !oldStartState[(int)x])\n\t\t\t\t\t{\n\t\t\t\t\t\tpaused = false;\n\t\t\t\t\t\toldStartState[(int)x] = GamePad.GetState(x).IsButtonDown(Buttons.Start);\n                    }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!paused)\n\t\t\t{\n\t\t\t\tif (currState.IsKeyDown(Keys.P) && currState != oldState)\n\t\t\t\t{\n\t\t\t\t\tpaused = true;\n\t\t\t\t\toldState = currState;\n\t\t\t\t\tplayerPaused = (int)currPlayer;\n\t\t\t\t}\n\t\t\t\tforeach (PlayerIndex x in Enum.GetValues(typeof(PlayerIndex)))\n\t\t\t\t{\n\t\t\t\t\tif (GamePad.GetState(x).IsButtonDown(Buttons.Start) && !oldStartState[(int)x])\n\t\t\t\t\t{\n\t\t\t\t\t\tpaused = true;\n\t\t\t\t\t\tplayerPaused = (int)x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (paused)\n\t\t\t{\n\t\t\t\toldState = currState;\n\t\t\t\toldStartState[0] = GamePad.GetState(PlayerIndex.One).IsButtonDown(Buttons.Start);\n\t\t\t\toldStartState[1] = GamePad.GetState(PlayerIndex.Two).IsButtonDown(Buttons.Start);\n\t\t\t\toldStartState[2] = GamePad.GetState(PlayerIndex.Three).IsButtonDown(Buttons.Start);\n\t\t\t\toldStartState[3] = GamePad.GetState(PlayerIndex.Four).IsButtonDown(Buttons.Start);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t\/* Press TAB to change player if using keyboard. *** For Testing Purposes Only ***\n                If you hold down a key while pressing TAB, the previous player will continue to do that same action\n                over and over again until you tab to that player again. \n                (It is kinda amusing, but could be useful for collison testing) *\/\n\t\t\tif (currState.IsKeyDown(Keys.Tab) && oldState != currState)\n\t\t\t{\n\t\t\t\tswitch ((int)currPlayer)\n\t\t\t\t{\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tcurrPlayer = PlayerKeys.Player2;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tcurrPlayer = PlayerKeys.Player3;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tcurrPlayer = PlayerKeys.Player4;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tcurrPlayer = PlayerKeys.allPlayers;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tcurrPlayer = PlayerKeys.Player1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\/\/Switches to the next player\n\t\t\t}\n\t\t\tif (currPlayer == PlayerKeys.Player1)\n\t\t\t{\n\t\t\t\tplayer1State = Keyboard.GetState();\n\t\t\t}\n\n\t\t\tif (currPlayer == PlayerKeys.Player2)\n\t\t\t{\n\t\t\t\tplayer2State = Keyboard.GetState();\n\t\t\t}\n\n\t\t\tif (currPlayer == PlayerKeys.Player3)\n\t\t\t{\n\t\t\t\tplayer3State = Keyboard.GetState();\n\t\t\t}\n\t\t\tif (currPlayer == PlayerKeys.Player4)\n\t\t\t{\n\t\t\t\tplayer4State = Keyboard.GetState();\n\t\t\t}\n\n\t\t\tif (currPlayer == PlayerKeys.allPlayers)\n\t\t\t{\n\t\t\t\tplayer1State = Keyboard.GetState();\n\t\t\t\tplayer2State = Keyboard.GetState();\n\t\t\t\tplayer3State = Keyboard.GetState();\n\t\t\t\tplayer4State = Keyboard.GetState();\n\t\t\t}\n\t\t\t\/\/End of TAB code. Can now only control one player at a time using keyboard.\n\t\t\tplayer1.Update(player1State, GamePad.GetState(PlayerIndex.One));\n\t\t\tplayer2.Update(player2State, GamePad.GetState(PlayerIndex.Two));\n\t\t\tplayer3.Update(player3State, GamePad.GetState(PlayerIndex.Three));\n\t\t\tplayer4.Update(player4State, GamePad.GetState(PlayerIndex.Four));\r\n            foreach (SpearClass sp in spears)\r\n            {\r\n              \r\n                    if (sp.spearOwner == player1)\r\n                    {\r\n                        sp.Update(player1State, GamePad.GetState(PlayerIndex.One));\r\n                    }\r\n\r\n                    if (sp.spearOwner == player2)\r\n                    {\r\n                        sp.Update(player2State, GamePad.GetState(PlayerIndex.Two));\r\n                    }\r\n                    if (sp.spearOwner == player3)\r\n                    {\r\n                        sp.Update(player3State, GamePad.GetState(PlayerIndex.Three));\r\n                    }\r\n                    if (sp.spearOwner == player4)\r\n                    {\r\n                        sp.Update(player4State, GamePad.GetState(PlayerIndex.Four));\r\n                    }\r\n                    else\r\n                    {\r\n                        KeyboardState fakestate = new KeyboardState();\r\n                        GamePadState faker = new GamePadState();\r\n                        sp.Update(fakestate, faker);\r\n                    }\r\n            }\r\n\t\t\toldState = currState;\r\n\r\n            oldStartState[0] = GamePad.GetState(PlayerIndex.One).IsButtonDown(Buttons.Start);\r\n            oldStartState[1] = GamePad.GetState(PlayerIndex.Two).IsButtonDown(Buttons.Start);\r\n            oldStartState[2] = GamePad.GetState(PlayerIndex.Three).IsButtonDown(Buttons.Start);\r\n            oldStartState[3] = GamePad.GetState(PlayerIndex.Four).IsButtonDown(Buttons.Start);\n            \/\/If a timer is running, decrement here\n\n            timeElapsed = (float)gameTime.ElapsedGameTime.TotalSeconds;\n            if(roundReset > 0)\n            {\n                roundReset -= timeElapsed;\n                if(roundReset < 0)\n                {\n                    resetMap();\r\n\t\t}\n            }\n        }\n\n\t\tpublic void Draw(SpriteBatch sb)\n\t\t{\n\t\t\tmap1.Draw(sb);\n\t\t\tplayer1.Draw(sb);\n\t\t\tplayer2.Draw(sb);\n\t\t\tplayer3.Draw(sb);\n\t\t\tplayer4.Draw(sb);\n            spear1.Draw(sb);\r\n            spear2.Draw(sb);\r\n            spear3.Draw(sb);\r\n            spear4.Draw(sb);\n\n            for (int i = 0; i < animations.Count; i++)\r\n            {\r\n                animations[i].Draw(sb);\r\n            }\n\n\t\t\tif (paused)\n\t\t\t{\n\t\t\t\tsb.DrawString(font, \"P\" + (playerPaused + 1) + \" paused\", new Vector2(screenSize.X \/ 2, screenSize.Y \/ 2), Color.Black);\n\t\t\t}\n\t\t\tif (roundReset > 0)\r\n\t\t\t{\r\n\t\t\t\t\r\n\t\t\t\tVector2 temp = new Vector2(screenSize.X \/ 2, 300);\r\n\t\t\t\tsb.DrawString(font, \"SCORES\", temp, Color.White);\r\n\r\n\t\t\t\ttemp.Y += 32;\r\n\t\t\t\tfor (int i = 0; i < players.Length; i ++)\r\n\t\t\t\t{\r\n\t\t\t\t\tsb.DrawString(font, \"P\" + (i + 1) + \": \" + players[i].score, temp, Color.White);\r\n\t\t\t\t\ttemp.Y += 32;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\n\n\t\tpublic GameState GetTransition() \n\t\t{\n\t\t\treturn null;\n\t\t}\n\n        private void playerKilled(Object sender, DeathEventArgs args)\n        {\n            \/\/Do things like announce death\/method of death\n\n            detectWinner();\n        }\n\n        public void detectWinner()\n        {\n            Boolean survivor = false;\n            PlayerClass victor = null;\n            foreach (PlayerClass p in players)\n            {\n                if (victor == null && !p.isDead())\n                {\n                    victor = p;\n                    survivor = true;\n                }\n                else if (victor != null && !p.isDead())\n                {\n                    victor = null;\n                    break;\n                }\n            }\n\n            if (victor != null || (victor == null && !survivor))\n            {\n                declareVictor(victor);\n            }\n        }\n\n        private void declareVictor(PlayerClass victor)\n        {\n            victor.winner();\n            roundReset = 3;\n        }\n\n        private void resetMap()\n        {\n            map1.reset();\n            foreach(PlayerClass p in players)\n            {\n                p.reset();\n            }\n\r\n            spear1.reset(players[0]);\r\n            spear2.reset(players[1]);\r\n            spear3.reset(players[2]);\r\n            spear4.reset(players[3]);\n        }\n\t}\n}\n\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"50770b3b2d99cf90e9c06b36e5843a99744f0988","subject":"Fixed issue with inicializing of default culture.","message":"Fixed issue with inicializing of default culture.\n","repos":"snoopydo\/Bonobo-Git-Server,gencer\/Bonobo-Git-Server,lkho\/Bonobo-Git-Server,snoopydo\/Bonobo-Git-Server,Acute-sales-ltd\/Bonobo-Git-Server,snoopydo\/Bonobo-Git-Server,hakim89\/Bonobo-Git-Server,NipponSysits\/IIS.Git-Connector,lkho\/Bonobo-Git-Server,willdean\/Bonobo-Git-Server,jiangzm\/Bonobo-Git-Server,anyeloamt1\/Bonobo-Git-Server,Monepi\/Bonobo-Git-Server,Webmine\/Bonobo-Git-Server,crowar\/Bonobo-Git-Server,snoopydo\/Bonobo-Git-Server,dunderburken\/Bonobo-Git-Server,darioajr\/Bonobo-Git-Server,anyeloamt1\/Bonobo-Git-Server,jiangzm\/Bonobo-Git-Server,YelaSeamless\/Bonobo-Git-Server,Monepi\/Bonobo-Git-Server,larshg\/Bonobo-Git-Server,hakim89\/Bonobo-Git-Server,lkho\/Bonobo-Git-Server,kfarnung\/Bonobo-Git-Server,hakim89\/Bonobo-Git-Server,crowar\/Bonobo-Git-Server,NipponSysits\/IIS.Git-Connector,lkho\/Bonobo-Git-Server,darioajr\/Bonobo-Git-Server,larrynung\/Bonobo-Git-Server,braegelno5\/Bonobo-Git-Server,padremortius\/Bonobo-Git-Server,KiritoStudio\/Bonobo-Git-Server,Webmine\/Bonobo-Git-Server,gencer\/Bonobo-Git-Server,Acute-sales-ltd\/Bonobo-Git-Server,hakim89\/Bonobo-Git-Server,dunderburken\/Bonobo-Git-Server,larrynung\/Bonobo-Git-Server,NipponSysits\/IIS.Git-Connector,PGM-NipponSysits\/IIS.Git-Connector,jiangzm\/Bonobo-Git-Server,YelaSeamless\/Bonobo-Git-Server,Ollienator\/Bonobo-Git-Server,yonglehou\/Bonobo-Git-Server,Monepi\/Bonobo-Git-Server,NipponSysits\/IIS.Git-Connector,larrynung\/Bonobo-Git-Server,yonglehou\/Bonobo-Git-Server,larrynung\/Bonobo-Git-Server,larrynung\/Bonobo-Git-Server,dunderburken\/Bonobo-Git-Server,yonglehou\/Bonobo-Git-Server,dunderburken\/Bonobo-Git-Server,kfarnung\/Bonobo-Git-Server,KiritoStudio\/Bonobo-Git-Server,crowar\/Bonobo-Git-Server,Acute-sales-ltd\/Bonobo-Git-Server,RedX2501\/Bonobo-Git-Server,PGM-NipponSysits\/IIS.Git-Connector,Ollienator\/Bonobo-Git-Server,NipponSysits\/IIS.Git-Connector,PGM-NipponSysits\/IIS.Git-Connector,Monepi\/Bonobo-Git-Server,RedX2501\/Bonobo-Git-Server,KiritoStudio\/Bonobo-Git-Server,jiangzm\/Bonobo-Git-Server,Ollienator\/Bonobo-Git-Server,darioajr\/Bonobo-Git-Server,willdean\/Bonobo-Git-Server,Ollienator\/Bonobo-Git-Server,hakim89\/Bonobo-Git-Server,YelaSeamless\/Bonobo-Git-Server,YelaSeamless\/Bonobo-Git-Server,padremortius\/Bonobo-Git-Server,snoopydo\/Bonobo-Git-Server,KiritoStudio\/Bonobo-Git-Server,Webmine\/Bonobo-Git-Server,padremortius\/Bonobo-Git-Server,Monepi\/Bonobo-Git-Server,Acute-sales-ltd\/Bonobo-Git-Server,igoryok-zp\/Bonobo-Git-Server,NipponSysits\/IIS.Git-Connector,igoryok-zp\/Bonobo-Git-Server,RedX2501\/Bonobo-Git-Server,igoryok-zp\/Bonobo-Git-Server,Monepi\/Bonobo-Git-Server,YelaSeamless\/Bonobo-Git-Server,willdean\/Bonobo-Git-Server,larshg\/Bonobo-Git-Server,crowar\/Bonobo-Git-Server,Webmine\/Bonobo-Git-Server,gencer\/Bonobo-Git-Server,darioajr\/Bonobo-Git-Server,darioajr\/Bonobo-Git-Server,braegelno5\/Bonobo-Git-Server,crowar\/Bonobo-Git-Server,dunderburken\/Bonobo-Git-Server,braegelno5\/Bonobo-Git-Server,forgetz\/Bonobo-Git-Server,larshg\/Bonobo-Git-Server,hakim89\/Bonobo-Git-Server,yonglehou\/Bonobo-Git-Server,yonglehou\/Bonobo-Git-Server,kfarnung\/Bonobo-Git-Server,Webmine\/Bonobo-Git-Server,igoryok-zp\/Bonobo-Git-Server,kfarnung\/Bonobo-Git-Server,forgetz\/Bonobo-Git-Server,PGM-NipponSysits\/IIS.Git-Connector,Acute-sales-ltd\/Bonobo-Git-Server,gencer\/Bonobo-Git-Server,YelaSeamless\/Bonobo-Git-Server,yonglehou\/Bonobo-Git-Server,jiangzm\/Bonobo-Git-Server,Ollienator\/Bonobo-Git-Server,darioajr\/Bonobo-Git-Server,Ollienator\/Bonobo-Git-Server,KiritoStudio\/Bonobo-Git-Server,braegelno5\/Bonobo-Git-Server,forgetz\/Bonobo-Git-Server,larrynung\/Bonobo-Git-Server,snoopydo\/Bonobo-Git-Server,jiangzm\/Bonobo-Git-Server,anyeloamt1\/Bonobo-Git-Server,padremortius\/Bonobo-Git-Server,willdean\/Bonobo-Git-Server,KiritoStudio\/Bonobo-Git-Server,RedX2501\/Bonobo-Git-Server,padremortius\/Bonobo-Git-Server,Acute-sales-ltd\/Bonobo-Git-Server,forgetz\/Bonobo-Git-Server,willdean\/Bonobo-Git-Server,Webmine\/Bonobo-Git-Server,dunderburken\/Bonobo-Git-Server,anyeloamt1\/Bonobo-Git-Server,PGM-NipponSysits\/IIS.Git-Connector,larshg\/Bonobo-Git-Server,Acute-sales-ltd\/Bonobo-Git-Server,PGM-NipponSysits\/IIS.Git-Connector,padremortius\/Bonobo-Git-Server,crowar\/Bonobo-Git-Server","old_file":"Bonobo.Git.Server\/Global.asax.cs","new_file":"Bonobo.Git.Server\/Global.asax.cs","new_contents":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Web;\nusing System.Web.Mvc;\nusing System.Web.Routing;\nusing System.ServiceModel.Activation;\nusing Bonobo.Git.Server.Security;\nusing Microsoft.Practices.Unity;\nusing System.Globalization;\nusing System.Threading;\nusing Bonobo.Git.Server.Data;\nusing Bonobo.Git.Server.Controllers;\nusing System.Diagnostics;\nusing System.Web.Security;\nusing System.Security.Principal;\nusing Bonobo.Git.Server.Configuration;\nusing Bonobo.Git.Server.Data.Update;\n\nnamespace Bonobo.Git.Server\n{\n    public class MvcApplication : System.Web.HttpApplication\n    {\n        public static void RegisterRoutes(RouteCollection routes)\n        {\n            routes.MapRoute(\"SecureInfoRefs\", \"{project}.git\/info\/refs\",\n                            new { controller = \"Git\", action = \"SecureGetInfoRefs\" },\n                            new { method = new HttpMethodConstraint(\"GET\") });\n\n            routes.MapRoute(\"SecureUploadPack\", \"{project}.git\/git-upload-pack\",\n                            new { controller = \"Git\", action = \"SecureUploadPack\" },\n                            new { method = new HttpMethodConstraint(\"POST\") });\n\n            routes.MapRoute(\"SecureReceivePack\", \"{project}.git\/git-receive-pack\",\n                            new { controller = \"Git\", action = \"SecureReceivePack\" },\n                            new { method = new HttpMethodConstraint(\"POST\") });\n\n\n            routes.MapRoute(\"IndexRoute\", \"{controller}\/Index\/\",\n                            new { action = \"Index\" });\n\n            routes.MapRoute(\"CreateRoute\", \"{controller}\/Create\/\",\n                            new { action = \"Create\" });\n\n            routes.MapRoute(\"RepositoryTree\", \"Repository\/{id}\/Tree\/{name}\/{*path}\",\n                            new { controller = \"Repository\", action = \"Tree\" });\n            \n            routes.MapRoute(\"RepositoryBlob\", \"Repository\/{id}\/Blob\/{name}\/{*path}\",\n                            new { controller = \"Repository\", action = \"Blob\" });\n            \n            routes.MapRoute(\"RepositoryRaw\", \"Repository\/{id}\/Raw\/{name}\/{*path}\",\n                            new { controller = \"Repository\", action = \"Raw\" });          \n\n            routes.MapRoute(\"RepositoryCommits\", \"Repository\/{id}\/Commits\/{name}\/\",\n                            new { controller = \"Repository\", action = \"Commits\" });\n\n            routes.MapRoute(\"RepositoryCommit\", \"Repository\/{id}\/Commit\/{commit}\/\",\n                            new { controller = \"Repository\", action = \"Commit\" });\n\n            routes.MapRoute(\"Repository\", \"Repository\/{id}\/{action}\/\",\n                            new { controller = \"Repository\", action = \"Detail\" });\n\n            routes.MapRoute(\"Account\", \"Account\/{id}\/{action}\/\",\n                            new { controller = \"Account\", action = \"Detail\" });\n\n            routes.MapRoute(\"Team\", \"Team\/{id}\/{action}\/\",\n                            new { controller = \"Team\", action = \"Detail\" });\n\n\n            routes.MapRoute(\"Default\", \"{controller}\/{action}\/{id}\",\n                            new { controller = \"Home\", action = \"Index\", id = \"\" });\n\n            routes.IgnoreRoute(\"{*favicon}\", new { favicon = @\"(.*\/)?favicon.ico(\/.*)?\" });\n            routes.IgnoreRoute(\"{resource}.axd\/{*pathInfo}\");\n\n        }\n\n        protected void Application_AcquireRequestState(object sender, EventArgs e)\n        {\n            if (HttpContext.Current.Session != null)\n            {\n                var culture = (CultureInfo)this.Session[\"Culture\"];\n                if (culture == null)\n                {\n                    culture = !String.IsNullOrEmpty(UserConfiguration.Current.DefaultLanguage) ? new CultureInfo(UserConfiguration.Current.DefaultLanguage) : null;\n\n                    if (culture == null)\n                    {\n                        string langName = \"en\";\n\n                        if (HttpContext.Current.Request.UserLanguages != null && HttpContext.Current.Request.UserLanguages.Length != 0)\n                        {\n                            langName = HttpContext.Current.Request.UserLanguages[0].Substring(0, 2);\n                        }\n                        culture = new CultureInfo(langName);\n                        this.Session[\"Culture\"] = culture;\n                    }\n                }\n                Thread.CurrentThread.CurrentUICulture = culture;\n                Thread.CurrentThread.CurrentCulture = CultureInfo.CreateSpecificCulture(culture.Name);\n            }\n        }\n\n        private void RegisterDependencyResolver()\n        {\n            var container = new UnityContainer();\n\n            container.RegisterType<IMembershipService, EFMembershipService>();\n            container.RegisterType<IRepositoryPermissionService, EFRepositoryPermissionService>();\n            container.RegisterType<IFormsAuthenticationService, FormsAuthenticationService>();\n            container.RegisterType<ITeamRepository, EFTeamRepository>();\n            container.RegisterType<IRepositoryRepository, EFRepositoryRepository>();\n\n            DependencyResolver.SetResolver(new UnityDependencyResolver(container));\n\n            var oldProvider = FilterProviders.Providers.Single(f => f is FilterAttributeFilterProvider);\n            FilterProviders.Providers.Remove(oldProvider);\n            var provider = new UnityFilterAttributeFilterProvider(container);\n            FilterProviders.Providers.Add(provider);\n        }\n\n        protected void Application_Start()\n        {\n            AreaRegistration.RegisterAllAreas();\n            RegisterRoutes(RouteTable.Routes);\n            RegisterDependencyResolver();\n                        \n            new AutomaticUpdater().Run();\n            UserConfiguration.Initialize();\n            new RepositorySynchronizer().Run();\n        }\n\n#if !DEBUG\n        protected void Application_Error(object sender, EventArgs e)\n        {\n            Exception exception = Server.GetLastError();\n            if (exception != null)\n            {\n                Response.Clear();\n                HttpException httpException = exception as HttpException;\n\n                RouteData routeData = new RouteData();\n                routeData.Values.Add(\"controller\", \"Home\");\n                if (httpException == null)\n                {\n                    routeData.Values.Add(\"action\", \"Error\");\n                    if (exception != null)\n                    {\n                        Trace.TraceError(\"Error occured and caught in Global.asax - {0}\", exception.ToString());\n                    }\n                }\n                else\n                {\n                    switch (httpException.GetHttpCode())\n                    {\n                        case 404:\n                            routeData.Values.Add(\"action\", \"PageNotFound\");\n                            break;\n                        case 500:\n                            routeData.Values.Add(\"action\", \"ServerError\");\n                            Trace.TraceError(\"Server Error occured and caught in Global.asax - {0}\", exception.ToString());\n                            break;\n                        default:\n                            routeData.Values.Add(\"action\", \"Error\");\n                            Trace.TraceError(\"Error occured and caught in Global.asax - {0}\", exception.ToString());\n                            break;\n                    }\n                }\n                Server.ClearError();\n                Response.TrySkipIisCustomErrors = true;\n                IController errorController = new HomeController();\n                errorController.Execute(new RequestContext(new HttpContextWrapper(Context), routeData));\n            }\n        }\n#endif\n        \n        protected void Application_AuthenticateRequest(object sender, EventArgs e)\n        {\n            if (Context.User == null)\n            {\n                var oldTicket = ExtractTicketFromCookie(Context, FormsAuthentication.FormsCookieName);\n                if (oldTicket != null && !oldTicket.Expired)\n                {\n                    var ticket = oldTicket;\n                    if (FormsAuthentication.SlidingExpiration)\n                    {\n                        ticket = FormsAuthentication.RenewTicketIfOld(oldTicket);\n                        if (ticket == null)\n                        {\n                            return;\n                        }\n                    }\n\n                    Context.User = new GenericPrincipal(new FormsIdentity(ticket), new string[0]);\n                    if (ticket != oldTicket)\n                    {\n                        string cookieValue = FormsAuthentication.Encrypt(ticket);\n                        var cookie = Context.Request.Cookies[FormsAuthentication.FormsCookieName] ?? new HttpCookie(FormsAuthentication.FormsCookieName, cookieValue) { Path = ticket.CookiePath };\n                        if (ticket.IsPersistent)\n                        {\n                            cookie.Expires = ticket.Expiration;\n                        }\n                        cookie.Value = cookieValue;\n                        cookie.Secure = FormsAuthentication.RequireSSL;\n                        cookie.HttpOnly = true;\n                        if (FormsAuthentication.CookieDomain != null)\n                        {\n                            cookie.Domain = FormsAuthentication.CookieDomain;\n                        }\n                        Context.Response.Cookies.Remove(cookie.Name);\n                        Context.Response.Cookies.Add(cookie);\n                    }\n                }\n            }\n        }\n\n        private static FormsAuthenticationTicket ExtractTicketFromCookie(HttpContext context, string name)\n        {\n            FormsAuthenticationTicket ticket = null;\n            string encryptedTicket = null;\n\n            var cookie = context.Request.Cookies[name];\n            if (cookie != null)\n            {\n                encryptedTicket = cookie.Value;\n            }\n\n            if (!string.IsNullOrEmpty(encryptedTicket))\n            {\n                try\n                {\n                    ticket = FormsAuthentication.Decrypt(encryptedTicket);\n                }\n                catch\n                {\n                    context.Request.Cookies.Remove(name);\n                }\n\n                if (ticket != null && !ticket.Expired)\n                {\n                    return ticket;\n                }\n\n                context.Request.Cookies.Remove(name);\n            }\n\n            return null;\n        }\n    }\n}\n","old_contents":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Web;\nusing System.Web.Mvc;\nusing System.Web.Routing;\nusing System.ServiceModel.Activation;\nusing Bonobo.Git.Server.Security;\nusing Microsoft.Practices.Unity;\nusing System.Globalization;\nusing System.Threading;\nusing Bonobo.Git.Server.Data;\nusing Bonobo.Git.Server.Controllers;\nusing System.Diagnostics;\nusing System.Web.Security;\nusing System.Security.Principal;\nusing Bonobo.Git.Server.Configuration;\nusing Bonobo.Git.Server.Data.Update;\n\nnamespace Bonobo.Git.Server\n{\n    public class MvcApplication : System.Web.HttpApplication\n    {\n        public static void RegisterRoutes(RouteCollection routes)\n        {\n            routes.MapRoute(\"SecureInfoRefs\", \"{project}.git\/info\/refs\",\n                            new { controller = \"Git\", action = \"SecureGetInfoRefs\" },\n                            new { method = new HttpMethodConstraint(\"GET\") });\n\n            routes.MapRoute(\"SecureUploadPack\", \"{project}.git\/git-upload-pack\",\n                            new { controller = \"Git\", action = \"SecureUploadPack\" },\n                            new { method = new HttpMethodConstraint(\"POST\") });\n\n            routes.MapRoute(\"SecureReceivePack\", \"{project}.git\/git-receive-pack\",\n                            new { controller = \"Git\", action = \"SecureReceivePack\" },\n                            new { method = new HttpMethodConstraint(\"POST\") });\n\n\n            routes.MapRoute(\"IndexRoute\", \"{controller}\/Index\/\",\n                            new { action = \"Index\" });\n\n            routes.MapRoute(\"CreateRoute\", \"{controller}\/Create\/\",\n                            new { action = \"Create\" });\n\n            routes.MapRoute(\"RepositoryTree\", \"Repository\/{id}\/Tree\/{name}\/{*path}\",\n                            new { controller = \"Repository\", action = \"Tree\" });\n            \n            routes.MapRoute(\"RepositoryBlob\", \"Repository\/{id}\/Blob\/{name}\/{*path}\",\n                            new { controller = \"Repository\", action = \"Blob\" });\n            \n            routes.MapRoute(\"RepositoryRaw\", \"Repository\/{id}\/Raw\/{name}\/{*path}\",\n                            new { controller = \"Repository\", action = \"Raw\" });          \n\n            routes.MapRoute(\"RepositoryCommits\", \"Repository\/{id}\/Commits\/{name}\/\",\n                            new { controller = \"Repository\", action = \"Commits\" });\n\n            routes.MapRoute(\"RepositoryCommit\", \"Repository\/{id}\/Commit\/{commit}\/\",\n                            new { controller = \"Repository\", action = \"Commit\" });\n\n            routes.MapRoute(\"Repository\", \"Repository\/{id}\/{action}\/\",\n                            new { controller = \"Repository\", action = \"Detail\" });\n\n            routes.MapRoute(\"Account\", \"Account\/{id}\/{action}\/\",\n                            new { controller = \"Account\", action = \"Detail\" });\n\n            routes.MapRoute(\"Team\", \"Team\/{id}\/{action}\/\",\n                            new { controller = \"Team\", action = \"Detail\" });\n\n\n            routes.MapRoute(\"Default\", \"{controller}\/{action}\/{id}\",\n                            new { controller = \"Home\", action = \"Index\", id = \"\" });\n\n            routes.IgnoreRoute(\"{*favicon}\", new { favicon = @\"(.*\/)?favicon.ico(\/.*)?\" });\n            routes.IgnoreRoute(\"{resource}.axd\/{*pathInfo}\");\n\n        }\n\n        protected void Application_AcquireRequestState(object sender, EventArgs e)\n        {\n            if (HttpContext.Current.Session != null)\n            {\n                var culture = (CultureInfo)this.Session[\"Culture\"];\n                if (culture == null)\n                {\n                    culture = new CultureInfo(UserConfiguration.Current.DefaultLanguage);\n\n                    if (culture == null)\n                    {\n                        string langName = \"en\";\n\n                        if (HttpContext.Current.Request.UserLanguages != null && HttpContext.Current.Request.UserLanguages.Length != 0)\n                        {\n                            langName = HttpContext.Current.Request.UserLanguages[0].Substring(0, 2);\n                        }\n                        culture = new CultureInfo(langName);\n                        this.Session[\"Culture\"] = culture;\n                    }\n                }\n                Thread.CurrentThread.CurrentUICulture = culture;\n                Thread.CurrentThread.CurrentCulture = CultureInfo.CreateSpecificCulture(culture.Name);\n            }\n        }\n\n        private void RegisterDependencyResolver()\n        {\n            var container = new UnityContainer();\n\n            container.RegisterType<IMembershipService, EFMembershipService>();\n            container.RegisterType<IRepositoryPermissionService, EFRepositoryPermissionService>();\n            container.RegisterType<IFormsAuthenticationService, FormsAuthenticationService>();\n            container.RegisterType<ITeamRepository, EFTeamRepository>();\n            container.RegisterType<IRepositoryRepository, EFRepositoryRepository>();\n\n            DependencyResolver.SetResolver(new UnityDependencyResolver(container));\n\n            var oldProvider = FilterProviders.Providers.Single(f => f is FilterAttributeFilterProvider);\n            FilterProviders.Providers.Remove(oldProvider);\n            var provider = new UnityFilterAttributeFilterProvider(container);\n            FilterProviders.Providers.Add(provider);\n        }\n\n        protected void Application_Start()\n        {\n            AreaRegistration.RegisterAllAreas();\n            RegisterRoutes(RouteTable.Routes);\n            RegisterDependencyResolver();\n                        \n            new AutomaticUpdater().Run();\n            UserConfiguration.Initialize();\n            new RepositorySynchronizer().Run();\n        }\n\n#if !DEBUG\n        protected void Application_Error(object sender, EventArgs e)\n        {\n            Exception exception = Server.GetLastError();\n            if (exception != null)\n            {\n                Response.Clear();\n                HttpException httpException = exception as HttpException;\n\n                RouteData routeData = new RouteData();\n                routeData.Values.Add(\"controller\", \"Home\");\n                if (httpException == null)\n                {\n                    routeData.Values.Add(\"action\", \"Error\");\n                    if (exception != null)\n                    {\n                        Trace.TraceError(\"Error occured and caught in Global.asax - {0}\", exception.ToString());\n                    }\n                }\n                else\n                {\n                    switch (httpException.GetHttpCode())\n                    {\n                        case 404:\n                            routeData.Values.Add(\"action\", \"PageNotFound\");\n                            break;\n                        case 500:\n                            routeData.Values.Add(\"action\", \"ServerError\");\n                            Trace.TraceError(\"Server Error occured and caught in Global.asax - {0}\", exception.ToString());\n                            break;\n                        default:\n                            routeData.Values.Add(\"action\", \"Error\");\n                            Trace.TraceError(\"Error occured and caught in Global.asax - {0}\", exception.ToString());\n                            break;\n                    }\n                }\n                Server.ClearError();\n                Response.TrySkipIisCustomErrors = true;\n                IController errorController = new HomeController();\n                errorController.Execute(new RequestContext(new HttpContextWrapper(Context), routeData));\n            }\n        }\n#endif\n        \n        protected void Application_AuthenticateRequest(object sender, EventArgs e)\n        {\n            if (Context.User == null)\n            {\n                var oldTicket = ExtractTicketFromCookie(Context, FormsAuthentication.FormsCookieName);\n                if (oldTicket != null && !oldTicket.Expired)\n                {\n                    var ticket = oldTicket;\n                    if (FormsAuthentication.SlidingExpiration)\n                    {\n                        ticket = FormsAuthentication.RenewTicketIfOld(oldTicket);\n                        if (ticket == null)\n                        {\n                            return;\n                        }\n                    }\n\n                    Context.User = new GenericPrincipal(new FormsIdentity(ticket), new string[0]);\n                    if (ticket != oldTicket)\n                    {\n                        string cookieValue = FormsAuthentication.Encrypt(ticket);\n                        var cookie = Context.Request.Cookies[FormsAuthentication.FormsCookieName] ?? new HttpCookie(FormsAuthentication.FormsCookieName, cookieValue) { Path = ticket.CookiePath };\n                        if (ticket.IsPersistent)\n                        {\n                            cookie.Expires = ticket.Expiration;\n                        }\n                        cookie.Value = cookieValue;\n                        cookie.Secure = FormsAuthentication.RequireSSL;\n                        cookie.HttpOnly = true;\n                        if (FormsAuthentication.CookieDomain != null)\n                        {\n                            cookie.Domain = FormsAuthentication.CookieDomain;\n                        }\n                        Context.Response.Cookies.Remove(cookie.Name);\n                        Context.Response.Cookies.Add(cookie);\n                    }\n                }\n            }\n        }\n\n        private static FormsAuthenticationTicket ExtractTicketFromCookie(HttpContext context, string name)\n        {\n            FormsAuthenticationTicket ticket = null;\n            string encryptedTicket = null;\n\n            var cookie = context.Request.Cookies[name];\n            if (cookie != null)\n            {\n                encryptedTicket = cookie.Value;\n            }\n\n            if (!string.IsNullOrEmpty(encryptedTicket))\n            {\n                try\n                {\n                    ticket = FormsAuthentication.Decrypt(encryptedTicket);\n                }\n                catch\n                {\n                    context.Request.Cookies.Remove(name);\n                }\n\n                if (ticket != null && !ticket.Expired)\n                {\n                    return ticket;\n                }\n\n                context.Request.Cookies.Remove(name);\n            }\n\n            return null;\n        }\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"b6d258f98a3f3b95a61ebd7fc0d2545184d8ef89","subject":"cleanup","message":"cleanup\n","repos":"ucdavis\/CRP,ucdavis\/CRP,ucdavis\/CRP","old_file":"CRP.Mvc\/Services\/SlothService.cs","new_file":"CRP.Mvc\/Services\/SlothService.cs","new_contents":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing CRP.Core.Domain;\nusing CRP.Mvc.Helpers;\nusing CRP.Mvc.Models.Configuration;\nusing CRP.Mvc.Models.Sloth;\nusing Microsoft.Azure;\nusing Serilog;\n\nnamespace CRP.Mvc.Services\n{\n    public interface ISlothService\n    {\n        Task<Transaction> GetTransactionsByProcessorId(string id);\n\n        Task<IList<Transaction>> GetTransactionsByKfsKey(string kfskey);\n\n        Task<CreateSlothTransactionResponse> CreateTransaction(CreateTransaction transaction);\n\n        Task<Transaction> Test();\n    }\n\n    public class SlothService : ISlothService\n    {\n        private readonly SlothSettings _settings;\n\n        public SlothService()\n        {\n            _settings = new SlothSettings();\n            _settings.BaseUrl = CloudConfigurationManager.GetSetting(\"Sloth.BaseUrl\");\n            _settings.ApiKey = CloudConfigurationManager.GetSetting(\"Sloth.ApiKey\");\n        }\n\n        public async Task<Transaction> GetTransactionsByProcessorId(string id)\n        {\n            \/\/Note: The transaction currently being used is CRP not Sloth so will not work.\n            using (var client = GetHttpClient())\n            {\n                var escapedId = Uri.EscapeUriString(id);\n                var url = $\"transactions\/processor\/{escapedId}\";\n\n                var response = await client.GetAsync(url);\n                var result = await response.GetContentOrNullAsync<Transaction>();\n                return result;\n            }\n        }\n\n        public async Task<IList<Transaction>> GetTransactionsByKfsKey(string kfskey)\n        {\n            \/\/Note: The transaction currently being used is CRP not Sloth so will not work.\n            using (var client = GetHttpClient())\n            {\n                var escapedKey = Uri.EscapeUriString(kfskey);\n                var url = $\"transactions\/kfskey\/{escapedKey}\";\n\n                var response = await client.GetAsync(url);\n                var result = await response.GetContentOrNullAsync<IList<Transaction>>();\n                return result;\n            }\n        }\n\n        public async Task<CreateSlothTransactionResponse> CreateTransaction(CreateTransaction transaction)\n        {\n            using (var client = GetHttpClient())\n            {\n                var url = \"transactions\";\n\n                var response = await client.PostAsJsonAsync(url, transaction);\n                try\n                {\n                    var result = await response.GetContentOrNullAsync<CreateSlothTransactionResponse>();\n                    return result;\n                }\n                catch (Exception e)\n                {\n                    Log.Error(e, \"Exception trying to create transaction in sloth\");\n                    Log.Information($\"DepositNotify - Error info: {await response.GetContentOrEmptyAsync()}\");\n                    throw;\n                }\n                \n                \n            }\n        }\n\n        public async Task<Transaction> Test()\n        {\n            \/\/Note: The transaction currently being used is CRP not Sloth so will not work.\n            using (var client = GetHttpClient())\n            {\n                var url = $\"transactions\";\n\n                var response = await client.GetAsync(url);\n                var result = await response.GetContentOrNullAsync<Transaction>();\n                return result;\n            }\n        }\n\n        private HttpClient GetHttpClient()\n        {\n            var client = new HttpClient()\n            {\n                BaseAddress = new Uri(_settings.BaseUrl),\n            };\n            ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12 | SecurityProtocolType.Tls11 | SecurityProtocolType.Tls;\n            client.DefaultRequestHeaders.Add(\"X-Auth-Token\", _settings.ApiKey);\n\n            return client;\n        }\n    }\n\n    public class CreateSlothTransactionResponse\n    {\n        public string Id { get; set; }\n    }\n}","old_contents":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing CRP.Core.Domain;\nusing CRP.Mvc.Helpers;\nusing CRP.Mvc.Models.Configuration;\nusing CRP.Mvc.Models.Sloth;\nusing Microsoft.Azure;\nusing Serilog;\n\nnamespace CRP.Mvc.Services\n{\n    public interface ISlothService\n    {\n        Task<Transaction> GetTransactionsByProcessorId(string id);\n\n        Task<IList<Transaction>> GetTransactionsByKfsKey(string kfskey);\n\n        Task<CreateSlothTransactionResponse> CreateTransaction(CreateTransaction transaction);\n\n        Task<Transaction> Test();\n    }\n\n    public class SlothService : ISlothService\n    {\n        private readonly SlothSettings _settings;\n\n        public SlothService()\n        {\n            _settings = new SlothSettings();\n            _settings.BaseUrl = CloudConfigurationManager.GetSetting(\"Sloth.BaseUrl\");\n            _settings.ApiKey = CloudConfigurationManager.GetSetting(\"Sloth.ApiKey\");\n        }\n\n        public async Task<Transaction> GetTransactionsByProcessorId(string id)\n        {\n            \/\/Note: The transaction currently being used is CRP not Sloth so will not work.\n            using (var client = GetHttpClient())\n            {\n                var escapedId = Uri.EscapeUriString(id);\n                var url = $\"transactions\/processor\/{escapedId}\";\n\n                var response = await client.GetAsync(url);\n                var result = await response.GetContentOrNullAsync<Transaction>();\n                return result;\n            }\n        }\n\n        public async Task<IList<Transaction>> GetTransactionsByKfsKey(string kfskey)\n        {\n            \/\/Note: The transaction currently being used is CRP not Sloth so will not work.\n            using (var client = GetHttpClient())\n            {\n                var escapedKey = Uri.EscapeUriString(kfskey);\n                var url = $\"transactions\/kfskey\/{escapedKey}\";\n\n                var response = await client.GetAsync(url);\n                var result = await response.GetContentOrNullAsync<IList<Transaction>>();\n                return result;\n            }\n        }\n\n        public async Task<CreateSlothTransactionResponse> CreateTransaction(CreateTransaction transaction)\n        {\n            using (var client = GetHttpClient())\n            {\n                var url = \"transactions\";\n\n                var response = await client.PostAsJsonAsync(url, transaction);\n                try\n                {\n                    var result = await response.GetContentOrNullAsync<CreateSlothTransactionResponse>();\n                    return result;\n                }\n                catch (Exception e)\n                {\n                    Log.Error($\"Exception trying to create transaction in sloth: {e.Message}\");\n                    var info = await response.GetContentOrEmptyAsync();\n                    Log.Information($\"DepositNotify - Error info: {info}\");\n                    throw;\n                }\n                \n                \n            }\n        }\n\n        public async Task<Transaction> Test()\n        {\n            \/\/Note: The transaction currently being used is CRP not Sloth so will not work.\n            using (var client = GetHttpClient())\n            {\n                var url = $\"transactions\";\n\n                var response = await client.GetAsync(url);\n                var result = await response.GetContentOrNullAsync<Transaction>();\n                return result;\n            }\n        }\n\n        private HttpClient GetHttpClient()\n        {\n            var client = new HttpClient()\n            {\n                BaseAddress = new Uri(_settings.BaseUrl),\n            };\n            ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12 | SecurityProtocolType.Tls11 | SecurityProtocolType.Tls;\n            client.DefaultRequestHeaders.Add(\"X-Auth-Token\", _settings.ApiKey);\n\n            return client;\n        }\n    }\n\n    public class CreateSlothTransactionResponse\n    {\n        public string Id { get; set; }\n    }\n}","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"beb0f4f58f5cc3eb2d35d6fd4ebf4584784f8ee0","subject":"Fix for file path reprompts","message":"Fix for file path reprompts\n","repos":"jceipek\/UnityBase","old_file":"UnityBase\/Assets\/Scripts\/CodeGenerators\/Editor\/ConstantsWriter.cs","new_file":"UnityBase\/Assets\/Scripts\/CodeGenerators\/Editor\/ConstantsWriter.cs","new_contents":"\ufeff\/\/ Inspired by Nick Gravelyn's UnityConstantsGenerator\nnamespace ConstantsGenerator {\n    using UnityEngine;\n    using UnityEditor;\n    using System;\n    using System.Text;\n    using System.IO;\n\n    public class ConstantsWriter : IDisposable {\n        StringBuilder _stringBuilder;\n        int _indentLevel;\n        string _filePath;\n        int _spacesPerIndent;\n\n        string ChooseFilePath (string name, string extension) {\n            \/\/ Try to find an existing file in the project called name+\".cs\"\n            string filePath = null;\n            string extensionWildcard = string.Format(\"*{0}\", extension);\n            foreach (var file in Directory.GetFiles(Application.dataPath, extensionWildcard, SearchOption.AllDirectories)) {\n                if (Path.GetFileNameWithoutExtension(file) == name) {\n                    filePath = file;\n                    break;\n                }\n            }\n\n            string nameWithExtension = string.Format(\"{0}{1}\", name, extension);\n            \/\/ If no such file exists yet, use a save window to ask the user for a folder in which to save the file.\n            if (string.IsNullOrEmpty(filePath)) {\n                string prompt = string.Format(\"Choose location for {0}\", nameWithExtension);\n                string directory = EditorUtility.OpenFolderPanel(prompt, Application.dataPath, \"\");\n\n                \/\/ Canceled choose? Do nothing.\n                if (string.IsNullOrEmpty(directory)) {\n                    return null;\n                }\n\n                filePath = Path.Combine(directory, nameWithExtension);\n            }\n            return filePath;\n        }\n\n        public ConstantsWriter (string name, string extension = \".cs\", int spacesPerIndent = 4, string path = null, bool includeHeader = true) {\n            _stringBuilder = new StringBuilder();\n\n            _spacesPerIndent = spacesPerIndent;\n            if (path != null) {\n                path = Path.Combine(path, string.Format(\"{0}{1}\", name, extension));\n            }\n            _filePath = path ?? ChooseFilePath(name, extension);\n            if (_filePath == null) { return; }\n\n            _indentLevel = 0;\n            if (includeHeader) {\n                _stringBuilder.AppendFormat(\"\/* This file ({0}{1}) is auto-generated. Modifications are not saved. *\/\\n\", name, extension);\n                _stringBuilder.AppendLine();\n            }\n\n\n            AssetDatabase.Refresh();\n        }\n\n        public void Dispose () {\n            if (_filePath == null) {\n                Debug.Log(\"Aborting!\");\n                return;\n            }\n\n            if (!TabsOK(_indentLevel, isEnd: true)) {\n                Debug.Log(\"Writing Anyway: \" + _filePath);\n            }\n\n            \/\/ Write out our file\n            using (var writer = new StreamWriter(_filePath)) {\n                writer.Write(_stringBuilder);\n            }\n        }\n\n        public void WriteLine (string value, params object[] args) {\n            AddTabbedFormattedLine(_stringBuilder, _indentLevel, value, args);\n        }\n\n        public void Write (string value) {\n            AddTabbed(_stringBuilder, _indentLevel, value);\n        }\n\n        public void WriteLine (string value) {\n            AddTabbedLine(_stringBuilder, _indentLevel, value);\n        }\n\n        public void WriteLine () {\n            _stringBuilder.AppendLine();\n        }\n\n        private void AddTabbedLine (StringBuilder stringBuilder, int tabCount, string value) {\n            if (!TabsOK(tabCount)) { return; }\n            stringBuilder.Append(' ', tabCount * _spacesPerIndent);\n            stringBuilder.AppendLine(value);\n        }\n\n        private void AddTabbed (StringBuilder stringBuilder, int tabCount, string value) {\n            if (!TabsOK(tabCount)) { return; }\n            stringBuilder.Append(' ', tabCount * _spacesPerIndent);\n            stringBuilder.Append(value);\n        }\n\n        private void AddTabbedFormattedLine (StringBuilder stringBuilder, int tabCount, string value, params object[] args) {\n            if (!TabsOK(tabCount)) { return; }\n            stringBuilder.Append(' ', tabCount * _spacesPerIndent);\n            stringBuilder.AppendFormat(value, args);\n            stringBuilder.Append(\"\\n\");\n        }\n\n        private bool TabsOK (int tabCount, bool isEnd = false) {\n            if (tabCount < 0 || (isEnd && tabCount != 0)) {\n                Debug.LogError(\"Tabs unbalanced! TabLevel: \" + tabCount);\n                return false;\n            }\n            return true;\n        }\n\n        public void Indent () {\n            _indentLevel++;\n        }\n\n        public void UnIndent () {\n            _indentLevel--;\n        }\n\n        \/\/ Takes in a string and makes it safe to use for a C# variable name.\n        \/\/ This just means stripping out spaces\/? and prefixing with a \"_\" character\n        \/\/ if the string starts with a number. It's not the most robust, but should handle most cases just fine.\n        public static string MakeSafeForCode (string str) {\n            str = str.Replace(\" \", \"\");\n            str = str.Replace(\"?\", \"\");\n            if (char.IsDigit(str[0])) {\n                str = \"_\" + str;\n            }\n            return str;\n        }\n    }\n}","old_contents":"\ufeff\/\/ Inspired by Nick Gravelyn's UnityConstantsGenerator\nnamespace ConstantsGenerator {\n    using UnityEngine;\n    using UnityEditor;\n    using System;\n    using System.Text;\n    using System.IO;\n\n    public class ConstantsWriter : IDisposable {\n        StringBuilder _stringBuilder;\n        int _indentLevel;\n        string _filePath;\n        int _spacesPerIndent;\n\n        string ChooseFilePath (string name, string extension) {\n            \/\/ Try to find an existing file in the project called name+\".cs\"\n            string filePath = null;\n            string extensionWildcard = string.Format(\"*{0}\", extension);\n            foreach (var file in Directory.GetFiles(Application.dataPath, extensionWildcard, SearchOption.AllDirectories)) {\n                if (Path.GetFileNameWithoutExtension(file) == name) {\n                    filePath = file;\n                    break;\n                }\n            }\n\n            string nameWithExtension = string.Format(\"{0}{1}\", name, extension);\n            \/\/ If no such file exists yet, use a save window to ask the user for a folder in which to save the file.\n            if (string.IsNullOrEmpty(_filePath)) {\n                string prompt = string.Format(\"Choose location for {0}\", nameWithExtension);\n                string directory = EditorUtility.OpenFolderPanel(prompt, Application.dataPath, \"\");\n\n                \/\/ Canceled choose? Do nothing.\n                if (string.IsNullOrEmpty(directory)) {\n                    return null;\n                }\n\n                filePath = Path.Combine(directory, nameWithExtension);\n            }\n            return filePath;\n        }\n\n        public ConstantsWriter (string name, string extension = \".cs\", int spacesPerIndent = 4, string path = null, bool includeHeader = true) {\n            _stringBuilder = new StringBuilder();\n\n            _spacesPerIndent = spacesPerIndent;\n            if (path != null) {\n                path = Path.Combine(path, string.Format(\"{0}{1}\", name, extension));\n            }\n            _filePath = path ?? ChooseFilePath(name, extension);\n            if (_filePath == null) { return; }\n\n            _indentLevel = 0;\n            if (includeHeader) {\n                _stringBuilder.AppendFormat(\"\/* This file ({0}{1}) is auto-generated. Modifications are not saved. *\/\\n\", name, extension);\n                _stringBuilder.AppendLine();\n            }\n\n\n            AssetDatabase.Refresh();\n        }\n\n        public void Dispose () {\n            if (_filePath == null) {\n                Debug.Log(\"Aborting!\");\n                return;\n            }\n\n            if (!TabsOK(_indentLevel, isEnd: true)) {\n                Debug.Log(\"Writing Anyway: \" + _filePath);\n            }\n\n            \/\/ Write out our file\n            using (var writer = new StreamWriter(_filePath)) {\n                writer.Write(_stringBuilder);\n            }\n        }\n\n        public void WriteLine (string value, params object[] args) {\n            AddTabbedFormattedLine(_stringBuilder, _indentLevel, value, args);\n        }\n\n        public void Write (string value) {\n            AddTabbed(_stringBuilder, _indentLevel, value);\n        }\n\n        public void WriteLine (string value) {\n            AddTabbedLine(_stringBuilder, _indentLevel, value);\n        }\n\n        public void WriteLine () {\n            _stringBuilder.AppendLine();\n        }\n\n        private void AddTabbedLine (StringBuilder stringBuilder, int tabCount, string value) {\n            if (!TabsOK(tabCount)) { return; }\n            stringBuilder.Append(' ', tabCount * _spacesPerIndent);\n            stringBuilder.AppendLine(value);\n        }\n\n        private void AddTabbed (StringBuilder stringBuilder, int tabCount, string value) {\n            if (!TabsOK(tabCount)) { return; }\n            stringBuilder.Append(' ', tabCount * _spacesPerIndent);\n            stringBuilder.Append(value);\n        }\n\n        private void AddTabbedFormattedLine (StringBuilder stringBuilder, int tabCount, string value, params object[] args) {\n            if (!TabsOK(tabCount)) { return; }\n            stringBuilder.Append(' ', tabCount * _spacesPerIndent);\n            stringBuilder.AppendFormat(value, args);\n            stringBuilder.Append(\"\\n\");\n        }\n\n        private bool TabsOK (int tabCount, bool isEnd = false) {\n            if (tabCount < 0 || (isEnd && tabCount != 0)) {\n                Debug.LogError(\"Tabs unbalanced! TabLevel: \" + tabCount);\n                return false;\n            }\n            return true;\n        }\n\n        public void Indent () {\n            _indentLevel++;\n        }\n\n        public void UnIndent () {\n            _indentLevel--;\n        }\n\n        \/\/ Takes in a string and makes it safe to use for a C# variable name.\n        \/\/ This just means stripping out spaces\/? and prefixing with a \"_\" character\n        \/\/ if the string starts with a number. It's not the most robust, but should handle most cases just fine.\n        public static string MakeSafeForCode (string str) {\n            str = str.Replace(\" \", \"\");\n            str = str.Replace(\"?\", \"\");\n            if (char.IsDigit(str[0])) {\n                str = \"_\" + str;\n            }\n            return str;\n        }\n    }\n}","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"a3c5816fb676cb420f786209baf208d02ab015db","subject":"Missed a method...","message":"Missed a method...\n","repos":"gregsdennis\/ThingFilter","old_file":"ThingFilter\/IFilter.cs","new_file":"ThingFilter\/IFilter.cs","new_contents":"\ufeffusing System;\nusing System.Collections.Generic;\n\nnamespace ThingFilter\n{\n\tpublic interface IFilter<T>\n\t{\n\t\tIFilter<T> MatchOn<TProp>(Func<T, TProp> valueFunc, string tag = null, bool requireTag = false);\n\t\tIFilter<T> CaseSensitive();\n\t\tIFilter<T> SortByRelevance();\n\t\tIEnumerable<T> Apply(IEnumerable<T> collection, string query);\n\t}\n}\n","old_contents":"\ufeffusing System;\n\nnamespace ThingFilter\n{\n\tpublic interface IFilter<T>\n\t{\n\t\tIFilter<T> MatchOn<TProp>(Func<T, TProp> valueFunc, string tag = null, bool requireTag = false);\n\t\tIFilter<T> CaseSensitive();\n\t\tIFilter<T> SortByRelevance();\n\t}\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"5783f7702757a9bffa47cf6d5b7eeb6ad43d4d2e","subject":"\u6587\u5b57\u5217\u306e\u30d1\u30fc\u30b9\u306b\u3088\u308b\u30c6\u30b9\u30c8\uff0e","message":"\u6587\u5b57\u5217\u306e\u30d1\u30fc\u30b9\u306b\u3088\u308b\u30c6\u30b9\u30c8\uff0e\n\nNUnit\u306e\u62e1\u5f35\u6a5f\u80fd\u306e\u7df4\u7fd2\u3082\u517c\u306d\u305f\uff0e\n","repos":"betchx\/Abaqus_cs","old_file":"UnitTest\/ParserTest.cs","new_file":"UnitTest\/ParserTest.cs","new_contents":"\ufeffusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing NUnit.Framework;\r\nusing Abaqus;\r\nusing System.IO;\r\n\r\nnamespace UnitTest.ParserTests\r\n{\r\n    [TestFixture]\r\n    public class ParserTest\r\n    {\r\n        [Test]\r\n        public void DummyTest()\r\n        {\r\n            Assert.True(true);\r\n        }\r\n\r\n        Parser parser;\r\n        string file;\r\n\r\n        [SetUp]\r\n        public void setup()\r\n        {\r\n            parser = new Parser();\r\n            file = Path.GetTempFileName();\r\n        }\r\n\r\n        [TearDown]\r\n        public void teardown()\r\n        {\r\n            File.Delete(file);\r\n        }\r\n\r\n\r\n\r\n        public IEnumerable<string> SingleNode1\r\n        {\r\n            get\r\n            {\r\n                yield return \"*NODE\\n1, 3.0, 0.0, 0.0\";\r\n                yield return \"*NODE\\n1, 3.0, 0.0\";\r\n                yield return \"*NODE\\n1, 3.0\";\r\n            }\r\n        }\r\n\r\n        public enum Pos { X, Y, Z}\r\n\r\n        public IEnumerable<Tuple<Pos, double>> Node1Positions\r\n        {\r\n            get\r\n            {\r\n                yield return new Tuple<Pos, double>(Pos.X, 3.0);\r\n                yield return new Tuple<Pos, double>(Pos.Y, 0.0);\r\n                yield return new Tuple<Pos, double>(Pos.Z, 0.0);\r\n            }\r\n        }\r\n\r\n        [Test,Combinatorial]\r\n        public void SingleNodeTest(\r\n            [ValueSource(\"SingleNode1\")] string definition,\r\n            [ValueSource(\"Node1Positions\")] Tuple<Pos, double> res)\r\n        {\r\n            var model = parser.parse_string(definition);\r\n            var node = model.nodes[1u];\r\n            switch (res.Item1)\r\n            {\r\n                case Pos.X:\r\n                    Assert.AreEqual(res.Item2, node.X, 0.001);\r\n                    break;\r\n                case Pos.Y:\r\n                    Assert.AreEqual(res.Item2, node.Y, 0.001);\r\n                    break;\r\n                case Pos.Z:\r\n                    Assert.AreEqual(res.Item2, node.Z, 0.001);\r\n                    break;\r\n                default:\r\n                    Assert.Fail();\r\n                    break;\r\n            }\r\n        }\r\n\r\n        [Test]\r\n        public void ParseElementTest()\r\n        {\r\n            using (var f = new StreamWriter(file))\r\n            {\r\n                f.WriteLine(\"*ELEMENT, type=S4\");\r\n                f.WriteLine(\"1, 1, 2, 3, 4\");\r\n                f.WriteLine(\"4, 4, 5, 6, 7\");\r\n            }\r\n            var model = parser.parse_file(file);\r\n            var elements = model.elements;\r\n            var all = model.all_elements;\r\n\r\n            Assert.AreEqual(2, elements.Count, \"Number of elements\");\r\n\r\n            Assert.Contains(1u, elements.Keys);\r\n            var e1 = elements[1u];\r\n            Assert.AreEqual(1u, e1.id);\r\n            var n1 = new uint[] { 1u, 2u, 3u, 4u };\r\n            for (uint i = 0; i < 4u; i++)\r\n            {\r\n                Assert.AreEqual(n1[i], e1[i]);\r\n            }\r\n            Assert.Contains(4u, elements.Keys);\r\n            var e4 = elements[4u];\r\n            Assert.AreEqual(4u, e4.id);\r\n            var n4 = new uint[] { 4u, 5u, 6u, 7u };\r\n            for (uint i = 0; i < 4u; i++)\r\n            {\r\n                Assert.AreEqual(n4[i], e4[i]);\r\n            }\r\n        }\r\n\r\n\r\n        [Test]\r\n        public void ParseNodeTest()\r\n        {\r\n            Assert.NotNull(file);\r\n            using (var f = new StreamWriter(file))\r\n            {\r\n                f.WriteLine(\"*NODE\");\r\n                f.WriteLine(\"1, 1.0, 2.0, 3.0\");\r\n                f.WriteLine(\"2, 1.0, 2.0\");\r\n                f.WriteLine(\"3, 1.0\");\r\n                f.WriteLine(\"4, 4., 5., 6.\");\r\n            }\r\n            parser.parse_file(file);\r\n            var model = parser.model;\r\n            var nodes = model.nodes;\r\n            var all = model.all_nodes;\r\n\r\n\r\n            for (uint i = 1u; i < 5u; i++)\r\n            {\r\n                Assert.True(nodes.ContainsKey(i),\"nodes\");\r\n                Assert.True(all.ContainsKey(new Address(i)), \"all_nodes\");\r\n                Assert.AreSame(nodes[i], all[new Address(i)], \"all\");\r\n                Assert.NotNull(nodes[i].parent);\r\n                Assert.AreSame(model, nodes[i].model,\"Model\");\r\n            }\r\n\r\n            const double d = 0.001; \/\/ delta\r\n \r\n            var n1 = nodes[1u];\r\n            Assert.AreEqual(1u, n1.id, \"n1.ID\");\r\n            Assert.AreEqual(1.0, n1.X, d, \"n1.X\");\r\n            Assert.AreEqual(2.0, n1.Y, d, \"n1.Y\");\r\n            Assert.AreEqual(3.0, n1.Z, d, \"n1.Z\");\r\n\r\n            var n2 = nodes[2u];\r\n            Assert.AreEqual(2u, n2.id, \"n2.ID\");\r\n            Assert.AreEqual(1.0, n2.X, d, \"n2.X\");\r\n            Assert.AreEqual(2.0, n2.Y, d, \"n2.Y\");\r\n            Assert.AreEqual(0.0, n2.Z, d, \"n2.Z\");\r\n\r\n            var n3 = nodes[3u];\r\n            Assert.AreEqual(3u, n3.id, \"n3.ID\");\r\n            Assert.AreEqual(1.0, n3.X, d, \"n3.X\");\r\n            Assert.AreEqual(0.0, n3.Y, d, \"n3.Y\");\r\n            Assert.AreEqual(0.0, n3.Z, d, \"n3.Z\");\r\n\r\n            var n4 = nodes[4u];\r\n            Assert.AreEqual(4u, n4.id, \"n4.ID\");\r\n            Assert.AreEqual(4.0, n4.X, d, \"n4.X\");\r\n            Assert.AreEqual(5.0, n4.Y, d, \"n4.Y\");\r\n            Assert.AreEqual(6.0, n4.Z, d, \"n4.Z\");\r\n\r\n        }\r\n\r\n\r\n        [Test]\r\n        public void inputParseTestNode()\r\n        {\r\n            var m = parser.parse_string(LexTest.input);\r\n\r\n            Assert.AreEqual(3, m.nodes.Count);\r\n            CollectionAssert.AreEquivalent(new uint[] { 1u, 2u, 3u }, m.nodes.Keys);\r\n        }\r\n\r\n\r\n        [Test]\r\n        public void inputParseTestSets()\r\n        {\r\n            var m = parser.parse_string(LexTest.input);\r\n            Assert.AreEqual(2, m.nsets.Count);\r\n            Assert.AreEqual(1, m.elsets.Count);\r\n\r\n            Assert.Contains(\"ENDS\", m.nsets.Keys);\r\n            Assert.Contains(\"MID\", m.nsets.Keys);\r\n\r\n            Assert.Contains(\"BAR\", m.elsets.Keys);\r\n        }\r\n\r\n\r\n        [Combinatorial]\r\n        [TestCase(\"*NSET, NSET=FOO\\n1,2,3\", Result = \"FOO\")]\r\n        [TestCase(\"*NSET, NSET=bar\\n1,2,3\", Result = \"BAR\")]\r\n        [TestCase(\"*NSET, nset=baz\\n1,2,3\", Result = \"BAZ\")]\r\n        public string NsetNameTest(string data)\r\n        {\r\n            parser.parse_string(data);\r\n            return parser.model.nsets.First().Value.name;\r\n        }\r\n\r\n    }\r\n\r\n\r\n}\r\n","old_contents":"\ufeffusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing NUnit.Framework;\r\nusing Abaqus;\r\nusing System.IO;\r\n\r\nnamespace UnitTest.ParserTests\r\n{\r\n    [TestFixture]\r\n    public class ParserTest\r\n    {\r\n        [Test]\r\n        public void DummyTest()\r\n        {\r\n            Assert.True(true);\r\n        }\r\n\r\n        Parser parser;\r\n        string file;\r\n\r\n        [SetUp]\r\n        public void setup()\r\n        {\r\n            parser = new Parser();\r\n            file = Path.GetTempFileName();\r\n        }\r\n\r\n        [TearDown]\r\n        public void teardown()\r\n        {\r\n            File.Delete(file);\r\n        }\r\n\r\n        [Test]\r\n        public void ParseElementTest()\r\n        {\r\n            using (var f = new StreamWriter(file))\r\n            {\r\n                f.WriteLine(\"*ELEMENT, type=S4\");\r\n                f.WriteLine(\"1, 1, 2, 3, 4\");\r\n                f.WriteLine(\"4, 4, 5, 6, 7\");\r\n            }\r\n            var model = parser.parse_file(file);\r\n            var elements = model.elements;\r\n            var all = model.all_elements;\r\n\r\n            Assert.AreEqual(2, elements.Count, \"Number of elements\");\r\n\r\n            Assert.Contains(1u, elements.Keys);\r\n            var e1 = elements[1u];\r\n            Assert.AreEqual(1u, e1.id);\r\n            var n1 = new uint[] { 1u, 2u, 3u, 4u };\r\n            for (uint i = 0; i < 4u; i++)\r\n            {\r\n                Assert.AreEqual(n1[i], e1[i]);\r\n            }\r\n            Assert.Contains(4u, elements.Keys);\r\n            var e4 = elements[4u];\r\n            Assert.AreEqual(4u, e4.id);\r\n            var n4 = new uint[] { 4u, 5u, 6u, 7u };\r\n            for (uint i = 0; i < 4u; i++)\r\n            {\r\n                Assert.AreEqual(n4[i], e4[i]);\r\n            }\r\n        }\r\n\r\n\r\n        [Test]\r\n        public void ParseNodeTest()\r\n        {\r\n            Assert.NotNull(file);\r\n            using (var f = new StreamWriter(file))\r\n            {\r\n                f.WriteLine(\"*NODE\");\r\n                f.WriteLine(\"1, 1.0, 2.0, 3.0\");\r\n                f.WriteLine(\"2, 1.0, 2.0\");\r\n                f.WriteLine(\"3, 1.0\");\r\n                f.WriteLine(\"4, 4., 5., 6.\");\r\n            }\r\n            parser.parse_file(file);\r\n            var model = parser.model;\r\n            var nodes = model.nodes;\r\n            var all = model.all_nodes;\r\n\r\n\r\n            for (uint i = 1u; i < 5u; i++)\r\n            {\r\n                Assert.True(nodes.ContainsKey(i),\"nodes\");\r\n                Assert.True(all.ContainsKey(new Address(i)), \"all_nodes\");\r\n                Assert.AreSame(nodes[i], all[new Address(i)], \"all\");\r\n                Assert.NotNull(nodes[i].parent);\r\n                Assert.AreSame(model, nodes[i].model,\"Model\");\r\n            }\r\n\r\n            const double d = 0.001; \/\/ delta\r\n \r\n            var n1 = nodes[1u];\r\n            Assert.AreEqual(1u, n1.id, \"n1.ID\");\r\n            Assert.AreEqual(1.0, n1.X, d, \"n1.X\");\r\n            Assert.AreEqual(2.0, n1.Y, d, \"n1.Y\");\r\n            Assert.AreEqual(3.0, n1.Z, d, \"n1.Z\");\r\n\r\n            var n2 = nodes[2u];\r\n            Assert.AreEqual(2u, n2.id, \"n2.ID\");\r\n            Assert.AreEqual(1.0, n2.X, d, \"n2.X\");\r\n            Assert.AreEqual(2.0, n2.Y, d, \"n2.Y\");\r\n            Assert.AreEqual(0.0, n2.Z, d, \"n2.Z\");\r\n\r\n            var n3 = nodes[3u];\r\n            Assert.AreEqual(3u, n3.id, \"n3.ID\");\r\n            Assert.AreEqual(1.0, n3.X, d, \"n3.X\");\r\n            Assert.AreEqual(0.0, n3.Y, d, \"n3.Y\");\r\n            Assert.AreEqual(0.0, n3.Z, d, \"n3.Z\");\r\n\r\n            var n4 = nodes[4u];\r\n            Assert.AreEqual(4u, n4.id, \"n4.ID\");\r\n            Assert.AreEqual(4.0, n4.X, d, \"n4.X\");\r\n            Assert.AreEqual(5.0, n4.Y, d, \"n4.Y\");\r\n            Assert.AreEqual(6.0, n4.Z, d, \"n4.Z\");\r\n\r\n        }\r\n\r\n\r\n        [Test]\r\n        public void inputParseTestNode()\r\n        {\r\n            var m = parser.parse_string(LexTest.input);\r\n\r\n            Assert.AreEqual(3, m.nodes.Count);\r\n            CollectionAssert.AreEquivalent(new uint[] { 1u, 2u, 3u }, m.nodes.Keys);\r\n        }\r\n\r\n\r\n        [Test]\r\n        public void inputParseTestSets()\r\n        {\r\n            var m = parser.parse_string(LexTest.input);\r\n            Assert.AreEqual(2, m.nsets.Count);\r\n            Assert.AreEqual(1, m.elsets.Count);\r\n\r\n            Assert.Contains(\"ENDS\", m.nsets.Keys);\r\n            Assert.Contains(\"MID\", m.nsets.Keys);\r\n\r\n            Assert.Contains(\"BAR\", m.elsets.Keys);\r\n        }\r\n\r\n\r\n        [Combinatorial]\r\n        [TestCase(\"*NSET, NSET=FOO\\n1,2,3\", Result = \"FOO\")]\r\n        [TestCase(\"*NSET, NSET=bar\\n1,2,3\", Result = \"BAR\")]\r\n        [TestCase(\"*NSET, nset=baz\\n1,2,3\", Result = \"BAZ\")]\r\n        public string NsetNameTest(string data)\r\n        {\r\n            parser.parse_string(data);\r\n            return parser.model.nsets.First().Value.name;\r\n        }\r\n\r\n    }\r\n\r\n\r\n}\r\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"733b86eeb93ac7fdb2506318739919e8bba75cc2","subject":"Implement non-abstract socket support","message":"Implement non-abstract socket support\n","repos":"tmds\/Tmds.DBus","old_file":"UnixNativeTransport.cs","new_file":"UnixNativeTransport.cs","new_contents":"\/\/ Copyright 2006 Alp Toker <alp@atoker.com>\n\/\/ This software is made available under the MIT License\n\/\/ See COPYING for details\n\nusing System;\nusing System.IO;\nusing System.Net;\nusing System.Net.Sockets;\n\nusing System.Runtime.InteropServices;\n\nusing Mono.Unix;\nusing Mono.Unix.Native;\n\nnamespace NDesk.DBus\n{\n\tpublic class UnixSocket\n\t{\n\t\t\/\/TODO: verify these\n\t\t[DllImport (\"libc\")]\n\t\t\tprotected static extern int socket (int domain, int type, int protocol);\n\n\t\t[DllImport (\"libc\")]\n\t\t\tprotected static extern int connect (int sockfd, byte[] serv_addr, uint addrlen);\n\n\t\tpublic int Handle;\n\n\t\tpublic UnixSocket ()\n\t\t{\n\t\t\t\/\/AddressFamily family, SocketType type, ProtocolType proto\n\t\t\t\/\/Handle = socket ((int)AddressFamily.Unix, (int)SocketType.Stream, 0);\n\t\t\tHandle = socket (1, (int)SocketType.Stream, 0);\n\n\t\t}\n\n\t\t\/\/TODO: consider memory management\n\t\tpublic void Connect (byte[] remote_end)\n\t\t{\n\t\t\tint ret = connect (Handle, remote_end, (uint)remote_end.Length);\n\t\t\t\/\/Console.Error.WriteLine (\"connect ret: \" + ret);\n\t\t\t\/\/FIXME: we need to get the errno or it will screw things up later?\n\t\t}\n\t}\n\n\tpublic class UnixNativeTransport : Transport, IAuthenticator\n\t{\n\t\tprotected UnixSocket socket;\n\n\t\tpublic UnixNativeTransport (string path, bool @abstract)\n\t\t{\n\t\t\tif (@abstract)\n\t\t\t\tsocket = OpenAbstractUnix (path);\n\t\t\telse\n\t\t\t\tsocket = OpenUnix (path);\n\n\t\t\t\/\/socket.Blocking = true;\n\t\t\tSocketHandle = (long)socket.Handle;\n\t\t\tStream = new UnixStream ((int)socket.Handle);\n\t\t}\n\n\t\tpublic override string AuthString ()\n\t\t{\n\t\t\tlong uid = UnixUserInfo.GetRealUserId ();\n\n\t\t\treturn uid.ToString ();\n\t\t}\n\n\t\tprotected UnixSocket OpenAbstractUnix (string path)\n\t\t{\n\t\t\tbyte[] p = System.Text.Encoding.Default.GetBytes (path);\n\n\t\t\tbyte[] sa = new byte[2 + 1 + p.Length];\n\n\t\t\t\/\/sa[0] = (byte)AddressFamily.Unix;\n\t\t\tsa[0] = 1;\n\t\t\tsa[1] = 0;\n\n\t\t\tsa[2] = 0; \/\/null prefix for abstract sockets, see unix(7)\n\t\t\tfor (int i = 0 ; i != p.Length ; i++)\n\t\t\t\tsa[i+3] = p[i];\n\n\t\t\tUnixSocket client = new UnixSocket ();\n\t\t\tclient.Connect (sa);\n\t\t\t\/\/Console.Error.WriteLine (\"client Handle: \" + client.Handle);\n\n\t\t\treturn client;\n\t\t}\n\n\t\tpublic UnixSocket OpenUnix (string path)\n\t\t{\n\t\t\tbyte[] p = System.Text.Encoding.Default.GetBytes (path);\n\n\t\t\tbyte[] sa = new byte[2 + p.Length + 1];\n\n\t\t\t\/\/sa[0] = (byte)AddressFamily.Unix;\n\t\t\tsa[0] = 1;\n\t\t\tsa[1] = 0;\n\n\t\t\tfor (int i = 0 ; i != p.Length ; i++)\n\t\t\t\tsa[i+2] = p[i];\n\t\t\tsa[2 + p.Length] = 0; \/\/null suffix for sockets, see unix(7)\n\n\t\t\tUnixSocket client = new UnixSocket ();\n\t\t\tclient.Connect (sa);\n\t\t\t\/\/Console.Error.WriteLine (\"client Handle: \" + client.Handle);\n\n\t\t\treturn client;\n\t\t}\n\t}\n}\n","old_contents":"\/\/ Copyright 2006 Alp Toker <alp@atoker.com>\n\/\/ This software is made available under the MIT License\n\/\/ See COPYING for details\n\nusing System;\nusing System.IO;\nusing System.Net;\nusing System.Net.Sockets;\n\nusing System.Runtime.InteropServices;\n\nusing Mono.Unix;\nusing Mono.Unix.Native;\n\nnamespace NDesk.DBus\n{\n\tpublic class UnixSocket\n\t{\n\t\t\/\/TODO: verify these\n\t\t[DllImport (\"libc\")]\n\t\t\tprotected static extern int socket (int domain, int type, int protocol);\n\n\t\t[DllImport (\"libc\")]\n\t\t\tprotected static extern int connect (int sockfd, byte[] serv_addr, uint addrlen);\n\n\t\tpublic int Handle;\n\n\t\tpublic UnixSocket ()\n\t\t{\n\t\t\t\/\/AddressFamily family, SocketType type, ProtocolType proto\n\t\t\t\/\/Handle = socket ((int)AddressFamily.Unix, (int)SocketType.Stream, 0);\n\t\t\tHandle = socket (1, (int)SocketType.Stream, 0);\n\n\t\t}\n\n\t\t\/\/TODO: consider memory management\n\t\tpublic void Connect (byte[] remote_end)\n\t\t{\n\t\t\tint ret = connect (Handle, remote_end, (uint)remote_end.Length);\n\t\t\t\/\/Console.Error.WriteLine (\"connect ret: \" + ret);\n\t\t\t\/\/FIXME: we need to get the errno or it will screw things up later?\n\t\t}\n\t}\n\n\tpublic class UnixNativeTransport : Transport, IAuthenticator\n\t{\n\t\tprotected UnixSocket socket;\n\n\t\tpublic UnixNativeTransport (string path, bool @abstract)\n\t\t{\n\t\t\tif (@abstract)\n\t\t\t\tsocket = OpenAbstractUnix (path);\n\t\t\telse\n\t\t\t\tsocket = OpenUnix (path);\n\n\t\t\t\/\/socket.Blocking = true;\n\t\t\tSocketHandle = (long)socket.Handle;\n\t\t\tStream = new UnixStream ((int)socket.Handle);\n\t\t}\n\n\t\tpublic override string AuthString ()\n\t\t{\n\t\t\tlong uid = UnixUserInfo.GetRealUserId ();\n\n\t\t\treturn uid.ToString ();\n\t\t}\n\n\t\tprotected UnixSocket OpenAbstractUnix (string path)\n\t\t{\n\t\t\tbyte[] p = System.Text.Encoding.Default.GetBytes (path);\n\n\t\t\tbyte[] sa = new byte[2 + 1 + p.Length];\n\n\t\t\t\/\/sa[0] = (byte)AddressFamily.Unix;\n\t\t\tsa[0] = 1;\n\t\t\tsa[1] = 0;\n\n\t\t\tsa[2] = 0; \/\/null prefix for abstract sockets, see unix(7)\n\t\t\tfor (int i = 0 ; i != p.Length ; i++)\n\t\t\t\tsa[i+3] = p[i];\n\n\t\t\tUnixSocket client = new UnixSocket ();\n\t\t\tclient.Connect (sa);\n\t\t\t\/\/Console.Error.WriteLine (\"client Handle: \" + client.Handle);\n\n\t\t\treturn client;\n\t\t}\n\n\t\tpublic UnixSocket OpenUnix (string path)\n\t\t{\n\t\t\t\/\/TODO\n\t\t\tthrow new Exception (\"Not implemented yet\");\n\t\t}\n\t}\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"c41bb3130f5f080d70f3eb6445ca31951d863cc0","subject":"debug save language at application exit","message":"debug save language at application exit\n","repos":"fredatgithub\/WaitingLog","old_file":"WaitingLog\/FormMain.cs","new_file":"WaitingLog\/FormMain.cs","new_contents":"\ufeff\/*\nThe MIT License(MIT)\nCopyright(c) 2015 Freddy Juhel\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*\/\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing System.Windows.Forms;\nusing System.Xml.Linq;\nusing WaitingLog.Properties;\n\nnamespace WaitingLog\n{\n  public partial class FormMain : Form\n  {\n    public FormMain()\n    {\n      InitializeComponent();\n    }\n\n    readonly Dictionary<string, string> languageDicoEn = new Dictionary<string, string>();\n    readonly Dictionary<string, string> languageDicoFr = new Dictionary<string, string>();\n\n    private void QuitToolStripMenuItem_Click(object sender, EventArgs e)\n    {\n      SaveWindowValue();\n      Application.Exit();\n    }\n\n    private void AboutToolStripMenuItem_Click(object sender, EventArgs e)\n    {\n      AboutBoxApplication aboutBoxApplication = new AboutBoxApplication();\n      aboutBoxApplication.ShowDialog();\n    }\n\n    private void DisplayTitle()\n    {\n      Assembly assembly = Assembly.GetExecutingAssembly();\n      FileVersionInfo fvi = FileVersionInfo.GetVersionInfo(assembly.Location);\n      Text += string.Format(\" V{0}.{1}.{2}.{3}\", fvi.FileMajorPart, fvi.FileMinorPart, fvi.FileBuildPart, fvi.FilePrivatePart);\n    }\n\n    private void FormMain_Load(object sender, EventArgs e)\n    {\n      DisplayTitle();\n      GetWindowValue();\n      LoadLanguages();\n      SetLanguage(Settings.Default.LastLanguageUsed);\n    }\n\n    private void LoadLanguages()\n    {\n      if (!File.Exists(Settings.Default.LanguageFileName))\n      {\n        CreateLanguageFile();\n      }\n\n      \/\/ read the translation file and feed the language\n      XDocument xDoc = XDocument.Load(Settings.Default.LanguageFileName);\n      var result = from node in xDoc.Descendants(\"term\")\n                   where node.HasElements\n                   select new\n                   {\n                     name = node.Element(\"name\").Value,\n                     englishValue = node.Element(\"englishValue\").Value,\n                     frenchValue = node.Element(\"frenchValue\").Value\n                   };\n      foreach (var i in result)\n      {\n        languageDicoEn.Add(i.name, i.englishValue);\n        languageDicoFr.Add(i.name, i.frenchValue);\n      }\n    }\n\n    private void CreateLanguageFile()\n    {\n      List<string> minimumVersion = new List<string>\n      {\n        \"<?xml version=\\\"1.0\\\" encoding=\\\"utf - 8\\\" ?>\",\n        \"<Document>\",\n        \"<DocumentVersion>\",\n        \"<version> 1.0 <\/version>\",\n        \"<\/DocumentVersion>\",\n        \"<terms>\",\n        \" <term>\",\n        \"<name> WindowHeight <\/name>\",\n        \"<value> 200 <\/value>\",\n        \" <\/term>\",\n        \" <term>\",\n        \"<name> WindowWidth <\/name>\",\n        \"<value> 200 <\/value>\",\n        \"<\/term>\",\n        \" <term>\",\n        \"<name> WindowTop <\/name>\",\n        \"<value> 0 <\/value>\",\n        \"<\/term>\",\n        \"<term>\",\n        \"<name> WindowLeft <\/name>\",\n        \"<value> 0 <\/value>\",\n        \"<\/term>\",\n        \"  <\/terms>\",\n        \"<\/Document>\"\n      };\n      StreamWriter sw = new StreamWriter(Settings.Default.LanguageFileName);\n      foreach (string item in minimumVersion)\n      {\n        sw.WriteLine(item);\n      }\n\n      sw.Close();\n    }\n\n    private void GetWindowValue()\n    {\n      Width = Settings.Default.WindowWidth;\n      Height = Settings.Default.WindowHeight;\n      Top = Settings.Default.WindowTop < 0 ? 0 : Settings.Default.WindowTop;\n      Left = Settings.Default.WindowLeft < 0 ? 0 : Settings.Default.WindowLeft;\n    }\n\n    private void SaveWindowValue()\n    {\n      Settings.Default.WindowHeight = Height;\n      Settings.Default.WindowWidth = Width;\n      Settings.Default.WindowLeft = Left;\n      Settings.Default.WindowTop = Top;\n      Settings.Default.LastLanguageUsed = ReturnLanguageInUse();\n      Settings.Default.Save();\n    }\n\n    private string ReturnLanguageInUse()\n    {\n      string result = \"English\"; \/\/ default value\n      if (frenchToolStripMenuItem.Checked)\n      {\n        result = \"French\";\n      }\n      \/\/ add any other languages here\n      return result;\n    }\n\n    private void FormMainFormClosing(object sender, FormClosingEventArgs e)\n    {\n      SaveWindowValue();\n    }\n\n    private void buttonStartStop_Click(object sender, EventArgs e)\n    {\n\n    }\n\n    private void frenchToolStripMenuItem_Click(object sender, EventArgs e)\n    {\n      SetLanguage(Language.French.ToString());\n    }\n\n    private void englishToolStripMenuItem_Click(object sender, EventArgs e)\n    {\n      SetLanguage(Language.English.ToString());\n    }\n\n    private void SetLanguage(string myLanguage)\n    {\n      switch (myLanguage)\n      {\n        case \"English\":\n          frenchToolStripMenuItem.Checked = false;\n          englishToolStripMenuItem.Checked = true;\n          fileToolStripMenuItem.Text = languageDicoEn[\"MenuFile\"];\n          newToolStripMenuItem.Text = languageDicoEn[\"MenuFileNew\"];\n          openToolStripMenuItem.Text = languageDicoEn[\"MenuFileOpen\"];\n          saveToolStripMenuItem.Text = languageDicoEn[\"MenuFileSave\"];\n          saveasToolStripMenuItem.Text = languageDicoEn[\"MenuFileSaveAs\"];\n          printPreviewToolStripMenuItem.Text = languageDicoEn[\"MenuFilePrint\"];\n          printPreviewToolStripMenuItem.Text = languageDicoEn[\"MenufilePageSetup\"];\n          quitToolStripMenuItem.Text = languageDicoEn[\"MenufileQuit\"];\n          editToolStripMenuItem.Text = languageDicoEn[\"MenuEdit\"];\n          cancelToolStripMenuItem.Text = languageDicoEn[\"MenuEditCancel\"];\n          redoToolStripMenuItem.Text = languageDicoEn[\"MenuEditRedo\"];\n          cutToolStripMenuItem.Text = languageDicoEn[\"MenuEditCut\"];\n          copyToolStripMenuItem.Text = languageDicoEn[\"MenuEditCopy\"];\n          pasteToolStripMenuItem.Text = languageDicoEn[\"MenuEditPaste\"];\n          selectAllToolStripMenuItem.Text = languageDicoEn[\"MenuEditSelectAll\"];\n          toolsToolStripMenuItem.Text = languageDicoEn[\"MenuTools\"];\n          personalizeToolStripMenuItem.Text = languageDicoEn[\"MenuToolsCustomize\"];\n          optionsToolStripMenuItem.Text = languageDicoEn[\"MenuToolsOptions\"];\n          languagetoolStripMenuItem.Text = languageDicoEn[\"MenuLanguage\"];\n          englishToolStripMenuItem.Text = languageDicoEn[\"MenuLanguageEnglish\"];\n          frenchToolStripMenuItem.Text = languageDicoEn[\"MenuLanguageFrench\"];\n          helpToolStripMenuItem.Text = languageDicoEn[\"MenuHelp\"];\n          summaryToolStripMenuItem.Text = languageDicoEn[\"MenuHelpSummary\"];\n          indexToolStripMenuItem.Text = languageDicoEn[\"MenuHelpIndex\"];\n          searchToolStripMenuItem.Text = languageDicoEn[\"MenuHelpSearch\"];\n          aboutToolStripMenuItem.Text = languageDicoEn[\"MenuHelpAbout\"];\n\n          break;\n        case \"French\":\n          frenchToolStripMenuItem.Checked = true;\n          englishToolStripMenuItem.Checked = false;\n          fileToolStripMenuItem.Text = languageDicoFr[\"MenuFile\"];\n          newToolStripMenuItem.Text = languageDicoFr[\"MenuFileNew\"];\n          openToolStripMenuItem.Text = languageDicoFr[\"MenuFileOpen\"];\n          saveToolStripMenuItem.Text = languageDicoFr[\"MenuFileSave\"];\n          saveasToolStripMenuItem.Text = languageDicoFr[\"MenuFileSaveAs\"];\n          printPreviewToolStripMenuItem.Text = languageDicoFr[\"MenuFilePrint\"];\n          printPreviewToolStripMenuItem.Text = languageDicoFr[\"MenufilePageSetup\"];\n          quitToolStripMenuItem.Text = languageDicoFr[\"MenufileQuit\"];\n          editToolStripMenuItem.Text = languageDicoFr[\"MenuEdit\"];\n          cancelToolStripMenuItem.Text = languageDicoFr[\"MenuEditCancel\"];\n          redoToolStripMenuItem.Text = languageDicoFr[\"MenuEditRedo\"];\n          cutToolStripMenuItem.Text = languageDicoFr[\"MenuEditCut\"];\n          copyToolStripMenuItem.Text = languageDicoFr[\"MenuEditCopy\"];\n          pasteToolStripMenuItem.Text = languageDicoFr[\"MenuEditPaste\"];\n          selectAllToolStripMenuItem.Text = languageDicoFr[\"MenuEditSelectAll\"];\n          toolsToolStripMenuItem.Text = languageDicoFr[\"MenuTools\"];\n          personalizeToolStripMenuItem.Text = languageDicoFr[\"MenuToolsCustomize\"];\n          optionsToolStripMenuItem.Text = languageDicoFr[\"MenuToolsOptions\"];\n          languagetoolStripMenuItem.Text = languageDicoFr[\"MenuLanguage\"];\n          englishToolStripMenuItem.Text = languageDicoFr[\"MenuLanguageEnglish\"];\n          frenchToolStripMenuItem.Text = languageDicoFr[\"MenuLanguageFrench\"];\n          helpToolStripMenuItem.Text = languageDicoFr[\"MenuHelp\"];\n          summaryToolStripMenuItem.Text = languageDicoFr[\"MenuHelpSummary\"];\n          indexToolStripMenuItem.Text = languageDicoFr[\"MenuHelpIndex\"];\n          searchToolStripMenuItem.Text = languageDicoFr[\"MenuHelpSearch\"];\n          aboutToolStripMenuItem.Text = languageDicoFr[\"MenuHelpAbout\"];\n\n          break;\n\n      }\n    }\n  }\n}","old_contents":"\ufeff\/*\nThe MIT License(MIT)\nCopyright(c) 2015 Freddy Juhel\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*\/\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\nusing System.Windows.Forms;\nusing System.Xml.Linq;\nusing WaitingLog.Properties;\n\nnamespace WaitingLog\n{\n  public partial class FormMain : Form\n  {\n    public FormMain()\n    {\n      InitializeComponent();\n    }\n\n    readonly Dictionary<string, string> languageDicoEn = new Dictionary<string, string>();\n    readonly Dictionary<string, string> languageDicoFr = new Dictionary<string, string>();\n\n    private void QuitToolStripMenuItem_Click(object sender, EventArgs e)\n    {\n      SaveWindowValue();\n      Application.Exit();\n    }\n\n    private void AboutToolStripMenuItem_Click(object sender, EventArgs e)\n    {\n      AboutBoxApplication aboutBoxApplication = new AboutBoxApplication();\n      aboutBoxApplication.ShowDialog();\n    }\n\n    private void DisplayTitle()\n    {\n      Assembly assembly = Assembly.GetExecutingAssembly();\n      FileVersionInfo fvi = FileVersionInfo.GetVersionInfo(assembly.Location);\n      Text += string.Format(\" V{0}.{1}.{2}.{3}\", fvi.FileMajorPart, fvi.FileMinorPart, fvi.FileBuildPart, fvi.FilePrivatePart);\n    }\n\n    private void FormMain_Load(object sender, EventArgs e)\n    {\n      DisplayTitle();\n      GetWindowValue();\n      LoadLanguages();\n      SetLanguage(Settings.Default.LastLanguageUsed);\n    }\n\n    private void LoadLanguages()\n    {\n      if (!File.Exists(Settings.Default.LanguageFileName))\n      {\n        CreateLanguageFile();\n      }\n\n      \/\/ read the translation file and feed the language\n      XDocument xDoc = XDocument.Load(Settings.Default.LanguageFileName);\n      var result = from node in xDoc.Descendants(\"term\")\n                   where node.HasElements\n                   select new\n                   {\n                     name = node.Element(\"name\").Value,\n                     englishValue = node.Element(\"englishValue\").Value,\n                     frenchValue = node.Element(\"frenchValue\").Value\n                   };\n      foreach (var i in result)\n      {\n        languageDicoEn.Add(i.name, i.englishValue);\n        languageDicoFr.Add(i.name, i.frenchValue);\n      }\n    }\n\n    private void CreateLanguageFile()\n    {\n      List<string> minimumVersion = new List<string>\n      {\n        \"<?xml version=\\\"1.0\\\" encoding=\\\"utf - 8\\\" ?>\",\n        \"<Document>\",\n        \"<DocumentVersion>\",\n        \"<version> 1.0 <\/version>\",\n        \"<\/DocumentVersion>\",\n        \"<terms>\",\n        \" <term>\",\n        \"<name> WindowHeight <\/name>\",\n        \"<value> 200 <\/value>\",\n        \" <\/term>\",\n        \" <term>\",\n        \"<name> WindowWidth <\/name>\",\n        \"<value> 200 <\/value>\",\n        \"<\/term>\",\n        \" <term>\",\n        \"<name> WindowTop <\/name>\",\n        \"<value> 0 <\/value>\",\n        \"<\/term>\",\n        \"<term>\",\n        \"<name> WindowLeft <\/name>\",\n        \"<value> 0 <\/value>\",\n        \"<\/term>\",\n        \"  <\/terms>\",\n        \"<\/Document>\"\n      };\n      StreamWriter sw = new StreamWriter(Settings.Default.LanguageFileName);\n      foreach (string item in minimumVersion)\n      {\n        sw.WriteLine(item);\n      }\n\n      sw.Close();\n    }\n\n    private void GetWindowValue()\n    {\n      Width = Settings.Default.WindowWidth;\n      Height = Settings.Default.WindowHeight;\n      Top = Settings.Default.WindowTop < 0 ? 0 : Settings.Default.WindowTop;\n      Left = Settings.Default.WindowLeft < 0 ? 0 : Settings.Default.WindowLeft;\n    }\n\n    private void SaveWindowValue()\n    {\n      Settings.Default.WindowHeight = Height;\n      Settings.Default.WindowWidth = Width;\n      Settings.Default.WindowLeft = Left;\n      Settings.Default.WindowTop = Top;\n      Settings.Default.Save();\n    }\n\n    private void FormMainFormClosing(object sender, FormClosingEventArgs e)\n    {\n      SaveWindowValue();\n    }\n\n    private void buttonStartStop_Click(object sender, EventArgs e)\n    {\n\n    }\n\n    private void frenchToolStripMenuItem_Click(object sender, EventArgs e)\n    {\n      SetLanguage(Language.French.ToString());\n    }\n\n    private void englishToolStripMenuItem_Click(object sender, EventArgs e)\n    {\n      SetLanguage(Language.English.ToString());\n    }\n\n    private void SetLanguage(string myLanguage)\n    {\n      switch (myLanguage)\n      {\n        case \"English\":\n          frenchToolStripMenuItem.Checked = false;\n          englishToolStripMenuItem.Checked = true;\n          fileToolStripMenuItem.Text = languageDicoEn[\"MenuFile\"];\n          newToolStripMenuItem.Text = languageDicoEn[\"MenuFileNew\"];\n          openToolStripMenuItem.Text = languageDicoEn[\"MenuFileOpen\"];\n          saveToolStripMenuItem.Text = languageDicoEn[\"MenuFileSave\"];\n          saveasToolStripMenuItem.Text = languageDicoEn[\"MenuFileSaveAs\"];\n          printPreviewToolStripMenuItem.Text = languageDicoEn[\"MenuFilePrint\"];\n          printPreviewToolStripMenuItem.Text = languageDicoEn[\"MenufilePageSetup\"];\n          quitToolStripMenuItem.Text = languageDicoEn[\"MenufileQuit\"];\n          editToolStripMenuItem.Text = languageDicoEn[\"MenuEdit\"];\n          cancelToolStripMenuItem.Text = languageDicoEn[\"MenuEditCancel\"];\n          redoToolStripMenuItem.Text = languageDicoEn[\"MenuEditRedo\"];\n          cutToolStripMenuItem.Text = languageDicoEn[\"MenuEditCut\"];\n          copyToolStripMenuItem.Text = languageDicoEn[\"MenuEditCopy\"];\n          pasteToolStripMenuItem.Text = languageDicoEn[\"MenuEditPaste\"];\n          selectAllToolStripMenuItem.Text = languageDicoEn[\"MenuEditSelectAll\"];\n          toolsToolStripMenuItem.Text = languageDicoEn[\"MenuTools\"];\n          personalizeToolStripMenuItem.Text = languageDicoEn[\"MenuToolsCustomize\"];\n          optionsToolStripMenuItem.Text = languageDicoEn[\"MenuToolsOptions\"];\n          languagetoolStripMenuItem.Text = languageDicoEn[\"MenuLanguage\"];\n          englishToolStripMenuItem.Text = languageDicoEn[\"MenuLanguageEnglish\"];\n          frenchToolStripMenuItem.Text = languageDicoEn[\"MenuLanguageFrench\"];\n          helpToolStripMenuItem.Text = languageDicoEn[\"MenuHelp\"];\n          summaryToolStripMenuItem.Text = languageDicoEn[\"MenuHelpSummary\"];\n          indexToolStripMenuItem.Text = languageDicoEn[\"MenuHelpIndex\"];\n          searchToolStripMenuItem.Text = languageDicoEn[\"MenuHelpSearch\"];\n          aboutToolStripMenuItem.Text = languageDicoEn[\"MenuHelpAbout\"];\n\n          break;\n        case \"French\":\n          frenchToolStripMenuItem.Checked = true;\n          englishToolStripMenuItem.Checked = false;\n          fileToolStripMenuItem.Text = languageDicoFr[\"MenuFile\"];\n          newToolStripMenuItem.Text = languageDicoFr[\"MenuFileNew\"];\n          openToolStripMenuItem.Text = languageDicoFr[\"MenuFileOpen\"];\n          saveToolStripMenuItem.Text = languageDicoFr[\"MenuFileSave\"];\n          saveasToolStripMenuItem.Text = languageDicoFr[\"MenuFileSaveAs\"];\n          printPreviewToolStripMenuItem.Text = languageDicoFr[\"MenuFilePrint\"];\n          printPreviewToolStripMenuItem.Text = languageDicoFr[\"MenufilePageSetup\"];\n          quitToolStripMenuItem.Text = languageDicoFr[\"MenufileQuit\"];\n          editToolStripMenuItem.Text = languageDicoFr[\"MenuEdit\"];\n          cancelToolStripMenuItem.Text = languageDicoFr[\"MenuEditCancel\"];\n          redoToolStripMenuItem.Text = languageDicoFr[\"MenuEditRedo\"];\n          cutToolStripMenuItem.Text = languageDicoFr[\"MenuEditCut\"];\n          copyToolStripMenuItem.Text = languageDicoFr[\"MenuEditCopy\"];\n          pasteToolStripMenuItem.Text = languageDicoFr[\"MenuEditPaste\"];\n          selectAllToolStripMenuItem.Text = languageDicoFr[\"MenuEditSelectAll\"];\n          toolsToolStripMenuItem.Text = languageDicoFr[\"MenuTools\"];\n          personalizeToolStripMenuItem.Text = languageDicoFr[\"MenuToolsCustomize\"];\n          optionsToolStripMenuItem.Text = languageDicoFr[\"MenuToolsOptions\"];\n          languagetoolStripMenuItem.Text = languageDicoFr[\"MenuLanguage\"];\n          englishToolStripMenuItem.Text = languageDicoFr[\"MenuLanguageEnglish\"];\n          frenchToolStripMenuItem.Text = languageDicoFr[\"MenuLanguageFrench\"];\n          helpToolStripMenuItem.Text = languageDicoFr[\"MenuHelp\"];\n          summaryToolStripMenuItem.Text = languageDicoFr[\"MenuHelpSummary\"];\n          indexToolStripMenuItem.Text = languageDicoFr[\"MenuHelpIndex\"];\n          searchToolStripMenuItem.Text = languageDicoFr[\"MenuHelpSearch\"];\n          aboutToolStripMenuItem.Text = languageDicoFr[\"MenuHelpAbout\"];\n\n          break;\n\n      }\n    }\n  }\n}","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"c145e32625bbf30702f8d5850ed72d77cad69db9","subject":"C#: Tests for multiline alert suppression comments","message":"C#: Tests for multiline alert suppression comments\n","repos":"github\/codeql,github\/codeql,github\/codeql,github\/codeql,github\/codeql,github\/codeql,github\/codeql,github\/codeql,github\/codeql,github\/codeql,github\/codeql,github\/codeql,github\/codeql,github\/codeql,github\/codeql","old_file":"csharp\/ql\/test\/query-tests\/AlertSuppression\/AlertSuppressionWindows.cs","new_file":"csharp\/ql\/test\/query-tests\/AlertSuppression\/AlertSuppressionWindows.cs","new_contents":"class Dead2 { } \/\/ lgtm\n\/\/ lgtm[cs\/unused-reftype]\n\/\/ lgtm[cs\/unused-reftype, cs\/unused-field]\n\/\/ lgtm[@tag:nullness]\n\/\/ lgtm[@tag:useless-code,cs\/unused-reftype]\n\/\/ lgtm[@expires:2017-06-11]\n\/\/ lgtm[cs\/unused-reftype] because I know better than lgtm\n\/\/ lgtm: blah blah\n\/\/ lgtm blah blah #falsepositive\n\/\/lgtm  [cs\/unused-reftype]\n\/* lgtm *\/\n\/\/ lgtm[]\n\/\/ lgtmfoo\n\/\/lgtm\n\/\/  lgtm\n\/\/ lgtm [cs\/unused-reftype]\n\/\/ foolgtm[cs\/unused-reftype]\n\/\/ foolgtm\n\/\/ foo; lgtm\n\/\/ foo; lgtm[cs\/unused-reftype]\n\/\/ foo lgtm\n\/\/ foo lgtm[cs\/unused-reftype]\n\/\/ foo lgtm bar\n\/\/ foo lgtm[cs\/unused-reftype] bar\n\/\/ LGTM!\n\/\/ LGTM[cs\/unused-reftype]\n\/\/ lgtm[cs\/unused-reftype] and lgtm[cs\/unused-field]\n\/\/ lgtm[cs\/unused-reftype]; lgtm\n\/* lgtm[] *\/\n\/* lgtm[cs\/unused-reftype] *\/\n\/* lgtm\n*\/\n\/* lgtm\n*\/\n\/* lgtm[@tag:nullness,cs\/unused-reftype] *\/\n\/* lgtm[@tag:nullness] *\/\n","old_contents":"class Dead2 { } \/\/ lgtm\n\/\/ lgtm[cs\/unused-reftype]\n\/\/ lgtm[cs\/unused-reftype, cs\/unused-field]\n\/\/ lgtm[@tag:nullness]\n\/\/ lgtm[@tag:useless-code,cs\/unused-reftype]\n\/\/ lgtm[@expires:2017-06-11]\n\/\/ lgtm[cs\/unused-reftype] because I know better than lgtm\n\/\/ lgtm: blah blah\n\/\/ lgtm blah blah #falsepositive\n\/\/lgtm  [cs\/unused-reftype]\n\/* lgtm *\/\n\/\/ lgtm[]\n\/\/ lgtmfoo\n\/\/lgtm\n\/\/  lgtm\n\/\/ lgtm [cs\/unused-reftype]\n\/\/ foolgtm[cs\/unused-reftype]\n\/\/ foolgtm\n\/\/ foo; lgtm\n\/\/ foo; lgtm[cs\/unused-reftype]\n\/\/ foo lgtm\n\/\/ foo lgtm[cs\/unused-reftype]\n\/\/ foo lgtm bar\n\/\/ foo lgtm[cs\/unused-reftype] bar\n\/\/ LGTM!\n\/\/ LGTM[cs\/unused-reftype]\n\/\/ lgtm[cs\/unused-reftype] and lgtm[cs\/unused-field]\n\/\/ lgtm[cs\/unused-reftype]; lgtm\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"2485fca03f8c2d0caf52b0a18d5edbf6b369b8d1","subject":"turned origin and region into internal methods","message":"turned origin and region into internal methods\n","repos":"inputfalken\/Sharpy","old_file":"DataGen\/Types\/Name\/NameFilter.cs","new_file":"DataGen\/Types\/Name\/NameFilter.cs","new_contents":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing DataGen.Types.String;\n\nnamespace DataGen.Types.Name {\n    public sealed class NameFilter : Filter<Name>, IStringFilter<NameFilter> {\n        public NameFilter(IEnumerable<Name> enumerable) : base(enumerable) {\n        }\n\n\n        \/\/Todo change from params string to country params\n        internal NameFilter ByCountry(params Country[] args)\n            => new NameFilter(this.Where(name => args.Contains(name.Country)));\n\n\n        \/\/Todo change from params string to country params\n        internal NameFilter ByRegion(params Region[] args)\n            => new NameFilter(this.Where(name => args.Contains(name.Region)));\n\n\n        internal NameFilter ByType(NameType nameType) {\n            switch (nameType) {\n                case NameType.FemaleFirst:\n                    return new NameFilter(this.Where(name => name.Type == 1));\n                case NameType.MaleFirst:\n                    return new NameFilter(this.Where(name => name.Type == 2));\n                case NameType.LastNames:\n                    return new NameFilter(this.Where(name => name.Type == 3));\n                case NameType.MixedFirstNames:\n                    return new NameFilter(this.Where(name => name.Type == 1 | name.Type == 2));\n                default:\n                    throw new ArgumentOutOfRangeException(nameof(nameType), nameType, null);\n            }\n        }\n\n        public NameFilter DoesNotStartWith(string arg) => new NameFilter(this.Where(s => IndexOf(s.Data, arg) != 0));\n\n        public NameFilter DoesNotContain(string arg) => new NameFilter(this.Where(s => !s.Data.Contains(arg)));\n\n        public NameFilter StartsWith(params string[] args)\n            => args.Length == 1\n                ? new NameFilter(this.Where(s => IndexOf(s.Data, args[0]) == 0))\n                : new NameFilter(this.Where(s => args.Any(arg => IndexOf(s.Data, arg) == 0)));\n\n\n        public NameFilter Contains(params string[] args)\n            => args.Length == 1\n                ? new NameFilter(this.Where(s => s.Data.Contains(args[0])))\n                : new NameFilter(this.Where(s => args.Any(s.Data.Contains)));\n\n        public NameFilter ByLength(int length) {\n            if (length < 1) throw new ArgumentOutOfRangeException($\"{nameof(length)} is below 1\");\n            return new NameFilter(this.Where(s => s.Data.Length == length));\n        }\n    }\n\n    public enum NameType {\n        FemaleFirst,\n        MaleFirst,\n        LastNames,\n        MixedFirstNames\n    }\n}","old_contents":"using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing DataGen.Types.String;\n\nnamespace DataGen.Types.Name {\n    public sealed class NameFilter : Filter<Name>, IStringFilter<NameFilter> {\n        public NameFilter(IEnumerable<Name> enumerable) : base(enumerable) {\n        }\n\n\n        \/\/Todo change from params string to country params\n        public NameFilter ByCountry(params Country[] args)\n            => new NameFilter(this.Where(name => args.Contains(name.Country)));\n\n\n        \/\/Todo change from params string to country params\n        public NameFilter ByRegion(params Region[] args)\n            => new NameFilter(this.Where(name => args.Contains(name.Region)));\n\n\n        internal NameFilter ByType(NameType nameType) {\n            switch (nameType) {\n                case NameType.FemaleFirst:\n                    return new NameFilter(this.Where(name => name.Type == 1));\n                case NameType.MaleFirst:\n                    return new NameFilter(this.Where(name => name.Type == 2));\n                case NameType.LastNames:\n                    return new NameFilter(this.Where(name => name.Type == 3));\n                case NameType.MixedFirstNames:\n                    return new NameFilter(this.Where(name => name.Type == 1 | name.Type == 2));\n                default:\n                    throw new ArgumentOutOfRangeException(nameof(nameType), nameType, null);\n            }\n        }\n\n        public NameFilter DoesNotStartWith(string arg) => new NameFilter(this.Where(s => IndexOf(s.Data, arg) != 0));\n\n        public NameFilter DoesNotContain(string arg) => new NameFilter(this.Where(s => !s.Data.Contains(arg)));\n\n        public NameFilter StartsWith(params string[] args)\n            => args.Length == 1\n                ? new NameFilter(this.Where(s => IndexOf(s.Data, args[0]) == 0))\n                : new NameFilter(this.Where(s => args.Any(arg => IndexOf(s.Data, arg) == 0)));\n\n\n        public NameFilter Contains(params string[] args)\n            => args.Length == 1\n                ? new NameFilter(this.Where(s => s.Data.Contains(args[0])))\n                : new NameFilter(this.Where(s => args.Any(s.Data.Contains)));\n\n        public NameFilter ByLength(int length) {\n            if (length < 1) throw new ArgumentOutOfRangeException($\"{nameof(length)} is below 1\");\n            return new NameFilter(this.Where(s => s.Data.Length == length));\n        }\n    }\n\n    public enum NameType {\n        FemaleFirst,\n        MaleFirst,\n        LastNames,\n        MixedFirstNames\n    }\n}","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"a1dfb2bcae168c6c1d45772e3bccd46f61ac2ffb","subject":"Added test to identify #161","message":"Added test to identify #161\n","repos":"AngleSharp\/AngleSharp,FlorianRappl\/AngleSharp,AngleSharp\/AngleSharp,AngleSharp\/AngleSharp,zedr0n\/AngleSharp.Local,FlorianRappl\/AngleSharp,FlorianRappl\/AngleSharp,zedr0n\/AngleSharp.Local,zedr0n\/AngleSharp.Local,AngleSharp\/AngleSharp,FlorianRappl\/AngleSharp,AngleSharp\/AngleSharp","old_file":"AngleSharp.Core.Tests\/Html\/UserJsUnsafe.cs","new_file":"AngleSharp.Core.Tests\/Html\/UserJsUnsafe.cs","new_contents":"\ufeffnamespace AngleSharp.Core.Tests\n{\n    using AngleSharp.Dom;\n    using AngleSharp.Extensions;\n    using AngleSharp.Html;\n    using NUnit.Framework;\n    using System;\n\n    \/\/\/ <summary>\n    \/\/\/ Tests from https:\/\/github.com\/html5lib\/html5lib-tests:\n    \/\/\/ tree-construction\/domjs-unsafe.dat\n    \/\/\/ <\/summary>\n    [TestFixture]\n    public class UserJsUnsafeTests\n    {\n        static IDocument Html(String code)\n        {\n            return code.ToHtmlDocument();\n        }\n\n        [Test]\n        public void Html5LibSvgCdata()\n        {\n            var doc = Html(@\"<svg><![CDATA[foo\nbar]]>\");\n            var html = doc.ChildNodes[0] as Element;\n            Assert.AreEqual(2, html.ChildNodes.Length);\n            Assert.AreEqual(0, html.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, html.NodeType);\n\n            var htmlhead = html.ChildNodes[0] as Element;\n            Assert.AreEqual(0, htmlhead.ChildNodes.Length);\n            Assert.AreEqual(0, htmlhead.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, htmlhead.NodeType);\n\n            var htmlbody = html.ChildNodes[1] as Element;\n            Assert.AreEqual(1, htmlbody.ChildNodes.Length);\n            Assert.AreEqual(0, htmlbody.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, htmlbody.NodeType);\n\n            var htmlbodysvg = htmlbody.ChildNodes[0] as Element;\n            Assert.IsTrue(htmlbodysvg.Flags.HasFlag(NodeFlags.SvgMember));\n            Assert.AreEqual(Namespaces.SvgUri, htmlbodysvg.NamespaceUri);\n            Assert.AreEqual(1, htmlbodysvg.ChildNodes.Length);\n            Assert.AreEqual(0, htmlbodysvg.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, htmlbodysvg.NodeType);\n\n            var text = htmlbodysvg.ChildNodes[0];\n            Assert.AreEqual(NodeType.Text, text.NodeType);\n            Assert.AreEqual(\"foo\\nbar\", text.TextContent);\n        }\n\n        [Test]\n        public void Html5LibScriptDataCommentStarted()\n        {\n            var doc = Html(@\"<script type=\"\"data\"\"><!--foo\" + Symbols.Null.ToString() + \"<\/script>\");\n\n            var dochtml = doc.ChildNodes[0] as Element;\n            Assert.AreEqual(2, dochtml.ChildNodes.Length);\n            Assert.AreEqual(0, dochtml.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtml.NodeType);\n\n            var dochtmlhead = dochtml.ChildNodes[0] as Element;\n            Assert.AreEqual(1, dochtmlhead.ChildNodes.Length);\n            Assert.AreEqual(0, dochtmlhead.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlhead.NodeType);\n\n            var dochtmlheadscript = dochtmlhead.ChildNodes[0] as Element;\n            Assert.AreEqual(1, dochtmlheadscript.ChildNodes.Length);\n            Assert.AreEqual(1, dochtmlheadscript.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlheadscript.NodeType);\n            Assert.AreEqual(\"data\", dochtmlheadscript.Attributes.GetNamedItem(\"type\").Value);\n\n            var text = dochtmlheadscript.ChildNodes[0];\n            Assert.AreEqual(NodeType.Text, text.NodeType);\n            Assert.AreEqual(@\"<!--foo\" + Symbols.Replacement.ToString(), text.TextContent);\n\n            var dochtmlbody = dochtml.ChildNodes[1] as Element;\n            Assert.AreEqual(0, dochtmlbody.ChildNodes.Length);\n            Assert.AreEqual(0, dochtmlbody.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlbody.NodeType);\n        }\n\n        [Test]\n        public void Html5LibScriptDataCommentFinishing()\n        {\n            var doc = Html(@\"<script type=\"\"data\"\"><!-- foo--\" + Symbols.Null.ToString() + \"<\/script>\");\n\n            var dochtml = doc.ChildNodes[0] as Element;\n            Assert.AreEqual(2, dochtml.ChildNodes.Length);\n            Assert.AreEqual(0, dochtml.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtml.NodeType);\n\n            var dochtmlhead = dochtml.ChildNodes[0] as Element;\n            Assert.AreEqual(1, dochtmlhead.ChildNodes.Length);\n            Assert.AreEqual(0, dochtmlhead.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlhead.NodeType);\n\n            var dochtmlheadscript = dochtmlhead.ChildNodes[0] as Element;\n            Assert.AreEqual(1, dochtmlheadscript.ChildNodes.Length);\n            Assert.AreEqual(1, dochtmlheadscript.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlheadscript.NodeType);\n            Assert.AreEqual(\"data\", dochtmlheadscript.Attributes.GetNamedItem(\"type\").Value);\n\n            var text = dochtmlheadscript.ChildNodes[0];\n            Assert.AreEqual(NodeType.Text, text.NodeType);\n            Assert.AreEqual(@\"<!-- foo--\" + Symbols.Replacement.ToString(), text.TextContent);\n\n            var dochtmlbody = dochtml.ChildNodes[1] as Element;\n            Assert.AreEqual(0, dochtmlbody.ChildNodes.Length);\n            Assert.AreEqual(0, dochtmlbody.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlbody.NodeType);\n        }\n\n        [Test]\n        public void Html5LibScriptDataEnding()\n        {\n            var doc = Html(@\"<script type=\"\"data\"\"><!-- foo-<<\/script>\");\n\n            var dochtml = doc.ChildNodes[0] as Element;\n            Assert.AreEqual(2, dochtml.ChildNodes.Length);\n            Assert.AreEqual(0, dochtml.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtml.NodeType);\n\n            var dochtmlhead = dochtml.ChildNodes[0] as Element;\n            Assert.AreEqual(1, dochtmlhead.ChildNodes.Length);\n            Assert.AreEqual(0, dochtmlhead.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlhead.NodeType);\n\n            var dochtmlheadscript = dochtmlhead.ChildNodes[0] as Element;\n            Assert.AreEqual(1, dochtmlheadscript.ChildNodes.Length);\n            Assert.AreEqual(1, dochtmlheadscript.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlheadscript.NodeType);\n            Assert.AreEqual(\"data\", dochtmlheadscript.Attributes.GetNamedItem(\"type\").Value);\n\n            var text = dochtmlheadscript.ChildNodes[0];\n            Assert.AreEqual(NodeType.Text, text.NodeType);\n            Assert.AreEqual(@\"<!-- foo-<\", text.TextContent);\n\n            var dochtmlbody = dochtml.ChildNodes[1] as Element;\n            Assert.AreEqual(0, dochtmlbody.ChildNodes.Length);\n            Assert.AreEqual(0, dochtmlbody.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlbody.NodeType);\n        }\n\n        [Test]\n        public void Html5LibScriptDataParagraph()\n        {\n            var doc = Html(@\"<script type=\"\"data\"\"><!--<p><\/script>\");\n\n            var dochtml = doc.ChildNodes[0] as Element;\n            Assert.AreEqual(2, dochtml.ChildNodes.Length);\n            Assert.AreEqual(0, dochtml.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtml.NodeType);\n\n            var dochtmlhead = dochtml.ChildNodes[0] as Element;\n            Assert.AreEqual(1, dochtmlhead.ChildNodes.Length);\n            Assert.AreEqual(0, dochtmlhead.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlhead.NodeType);\n\n            var dochtmlheadscript = dochtmlhead.ChildNodes[0] as Element;\n            Assert.AreEqual(1, dochtmlheadscript.ChildNodes.Length);\n            Assert.AreEqual(1, dochtmlheadscript.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlheadscript.NodeType);\n            Assert.AreEqual(\"data\", dochtmlheadscript.Attributes.GetNamedItem(\"type\").Value);\n\n            var text = dochtmlheadscript.ChildNodes[0];\n            Assert.AreEqual(NodeType.Text, text.NodeType);\n            Assert.AreEqual(@\"<!--<p>\", text.TextContent);\n                        \n            var dochtmlbody = dochtml.ChildNodes[1] as Element;\n            Assert.AreEqual(0, dochtmlbody.ChildNodes.Length);\n            Assert.AreEqual(0, dochtmlbody.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlbody.NodeType);\n        }\n\n        [Test]\n        public void Html5LibDoctypeInHeadImplicit()\n        {\n            var doc = Html(@\"<html><!DOCTYPE html>\");\n\n            var dochtml = doc.ChildNodes[0] as Element;\n            Assert.AreEqual(2, dochtml.ChildNodes.Length);\n            Assert.AreEqual(0, dochtml.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtml.NodeType);\n\n            var dochtmlhead = dochtml.ChildNodes[0] as Element;\n            Assert.AreEqual(0, dochtmlhead.ChildNodes.Length);\n            Assert.AreEqual(0, dochtmlhead.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlhead.NodeType);\n\n            var dochtmlbody = dochtml.ChildNodes[1] as Element;\n            Assert.AreEqual(0, dochtmlbody.ChildNodes.Length);\n            Assert.AreEqual(0, dochtmlbody.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlbody.NodeType);\n        }\n\n        [Test]\n        public void Html5LibDoctypeInBodyImplicit()\n        {\n            var doc = Html(@\"<html><head><\/head><!DOCTYPE html>\");\n\n            var dochtml = doc.ChildNodes[0] as Element;\n            Assert.AreEqual(2, dochtml.ChildNodes.Length);\n            Assert.AreEqual(0, dochtml.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtml.NodeType);\n\n            var dochtmlhead = dochtml.ChildNodes[0] as Element;\n            Assert.AreEqual(0, dochtmlhead.ChildNodes.Length);\n            Assert.AreEqual(0, dochtmlhead.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlhead.NodeType);\n\n            var dochtmlbody = dochtml.ChildNodes[1] as Element;\n            Assert.AreEqual(0, dochtmlbody.ChildNodes.Length);\n            Assert.AreEqual(0, dochtmlbody.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlbody.NodeType);\n\n        }\n\n        [Test]\n        public void HtmlParseSvgElementWithEmptyStyleShouldRemoveAttribute()\n        {\n            var doc = Html(@\"<!DOCTYPE html><html><body><svg xmlns=\"\"http:\/\/www.w3.org\/2000\/svg\"\" xmlns:xlink=\"\"http:\/\/www.w3.org\/1999\/xlink\"\" version=\"\"1.1\"\" focusable=\"\"false\"\" baseProfile=\"\"tiny\"\" id=\"\"Layer_1\"\" x=\"\"0px\"\" y=\"\"0px\"\" viewBox=\"\"0 0 8.5 4.9\"\" xml:space=\"\"preserve\"\">\n<polyline fill-rule=\"\"evenodd\"\" fill=\"\"#747474\"\" points=\"\"8.5,0.6 7.9,0 4.3,3.6 0.6,0 0,0.6 4.3,4.9 \"\" style=\"\"\"\"\/>\n<\/svg><\/body><\/html>\");\n            var polyline = doc.QuerySelector(\"polyline\");\n            Assert.IsNull(polyline.GetAttribute(\"style\"));\n            Assert.AreEqual(3, polyline.Attributes.Length);\n        }\n    }\n}\n","old_contents":"\ufeffnamespace AngleSharp.Core.Tests\n{\n    using AngleSharp.Dom;\n    using AngleSharp.Extensions;\n    using AngleSharp.Html;\n    using NUnit.Framework;\n    using System;\n\n    \/\/\/ <summary>\n    \/\/\/ Tests from https:\/\/github.com\/html5lib\/html5lib-tests:\n    \/\/\/ tree-construction\/domjs-unsafe.dat\n    \/\/\/ <\/summary>\n    [TestFixture]\n    public class UserJsUnsafeTests\n    {\n        static IDocument Html(String code)\n        {\n            return code.ToHtmlDocument();\n        }\n\n        [Test]\n        public void Html5LibSvgCdata()\n        {\n            var doc = Html(@\"<svg><![CDATA[foo\nbar]]>\");\n            var html = doc.ChildNodes[0] as Element;\n            Assert.AreEqual(2, html.ChildNodes.Length);\n            Assert.AreEqual(0, html.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, html.NodeType);\n\n            var htmlhead = html.ChildNodes[0] as Element;\n            Assert.AreEqual(0, htmlhead.ChildNodes.Length);\n            Assert.AreEqual(0, htmlhead.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, htmlhead.NodeType);\n\n            var htmlbody = html.ChildNodes[1] as Element;\n            Assert.AreEqual(1, htmlbody.ChildNodes.Length);\n            Assert.AreEqual(0, htmlbody.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, htmlbody.NodeType);\n\n            var htmlbodysvg = htmlbody.ChildNodes[0] as Element;\n            Assert.IsTrue(htmlbodysvg.Flags.HasFlag(NodeFlags.SvgMember));\n            Assert.AreEqual(Namespaces.SvgUri, htmlbodysvg.NamespaceUri);\n            Assert.AreEqual(1, htmlbodysvg.ChildNodes.Length);\n            Assert.AreEqual(0, htmlbodysvg.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, htmlbodysvg.NodeType);\n\n            var text = htmlbodysvg.ChildNodes[0];\n            Assert.AreEqual(NodeType.Text, text.NodeType);\n            Assert.AreEqual(\"foo\\nbar\", text.TextContent);\n        }\n\n        [Test]\n        public void Html5LibScriptDataCommentStarted()\n        {\n            var doc = Html(@\"<script type=\"\"data\"\"><!--foo\" + Symbols.Null.ToString() + \"<\/script>\");\n\n            var dochtml = doc.ChildNodes[0] as Element;\n            Assert.AreEqual(2, dochtml.ChildNodes.Length);\n            Assert.AreEqual(0, dochtml.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtml.NodeType);\n\n            var dochtmlhead = dochtml.ChildNodes[0] as Element;\n            Assert.AreEqual(1, dochtmlhead.ChildNodes.Length);\n            Assert.AreEqual(0, dochtmlhead.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlhead.NodeType);\n\n            var dochtmlheadscript = dochtmlhead.ChildNodes[0] as Element;\n            Assert.AreEqual(1, dochtmlheadscript.ChildNodes.Length);\n            Assert.AreEqual(1, dochtmlheadscript.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlheadscript.NodeType);\n            Assert.AreEqual(\"data\", dochtmlheadscript.Attributes.GetNamedItem(\"type\").Value);\n\n            var text = dochtmlheadscript.ChildNodes[0];\n            Assert.AreEqual(NodeType.Text, text.NodeType);\n            Assert.AreEqual(@\"<!--foo\" + Symbols.Replacement.ToString(), text.TextContent);\n\n            var dochtmlbody = dochtml.ChildNodes[1] as Element;\n            Assert.AreEqual(0, dochtmlbody.ChildNodes.Length);\n            Assert.AreEqual(0, dochtmlbody.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlbody.NodeType);\n        }\n\n        [Test]\n        public void Html5LibScriptDataCommentFinishing()\n        {\n            var doc = Html(@\"<script type=\"\"data\"\"><!-- foo--\" + Symbols.Null.ToString() + \"<\/script>\");\n\n            var dochtml = doc.ChildNodes[0] as Element;\n            Assert.AreEqual(2, dochtml.ChildNodes.Length);\n            Assert.AreEqual(0, dochtml.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtml.NodeType);\n\n            var dochtmlhead = dochtml.ChildNodes[0] as Element;\n            Assert.AreEqual(1, dochtmlhead.ChildNodes.Length);\n            Assert.AreEqual(0, dochtmlhead.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlhead.NodeType);\n\n            var dochtmlheadscript = dochtmlhead.ChildNodes[0] as Element;\n            Assert.AreEqual(1, dochtmlheadscript.ChildNodes.Length);\n            Assert.AreEqual(1, dochtmlheadscript.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlheadscript.NodeType);\n            Assert.AreEqual(\"data\", dochtmlheadscript.Attributes.GetNamedItem(\"type\").Value);\n\n            var text = dochtmlheadscript.ChildNodes[0];\n            Assert.AreEqual(NodeType.Text, text.NodeType);\n            Assert.AreEqual(@\"<!-- foo--\" + Symbols.Replacement.ToString(), text.TextContent);\n\n            var dochtmlbody = dochtml.ChildNodes[1] as Element;\n            Assert.AreEqual(0, dochtmlbody.ChildNodes.Length);\n            Assert.AreEqual(0, dochtmlbody.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlbody.NodeType);\n        }\n\n        [Test]\n        public void Html5LibScriptDataEnding()\n        {\n            var doc = Html(@\"<script type=\"\"data\"\"><!-- foo-<<\/script>\");\n\n            var dochtml = doc.ChildNodes[0] as Element;\n            Assert.AreEqual(2, dochtml.ChildNodes.Length);\n            Assert.AreEqual(0, dochtml.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtml.NodeType);\n\n            var dochtmlhead = dochtml.ChildNodes[0] as Element;\n            Assert.AreEqual(1, dochtmlhead.ChildNodes.Length);\n            Assert.AreEqual(0, dochtmlhead.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlhead.NodeType);\n\n            var dochtmlheadscript = dochtmlhead.ChildNodes[0] as Element;\n            Assert.AreEqual(1, dochtmlheadscript.ChildNodes.Length);\n            Assert.AreEqual(1, dochtmlheadscript.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlheadscript.NodeType);\n            Assert.AreEqual(\"data\", dochtmlheadscript.Attributes.GetNamedItem(\"type\").Value);\n\n            var text = dochtmlheadscript.ChildNodes[0];\n            Assert.AreEqual(NodeType.Text, text.NodeType);\n            Assert.AreEqual(@\"<!-- foo-<\", text.TextContent);\n\n            var dochtmlbody = dochtml.ChildNodes[1] as Element;\n            Assert.AreEqual(0, dochtmlbody.ChildNodes.Length);\n            Assert.AreEqual(0, dochtmlbody.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlbody.NodeType);\n        }\n\n        [Test]\n        public void Html5LibScriptDataParagraph()\n        {\n            var doc = Html(@\"<script type=\"\"data\"\"><!--<p><\/script>\");\n\n            var dochtml = doc.ChildNodes[0] as Element;\n            Assert.AreEqual(2, dochtml.ChildNodes.Length);\n            Assert.AreEqual(0, dochtml.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtml.NodeType);\n\n            var dochtmlhead = dochtml.ChildNodes[0] as Element;\n            Assert.AreEqual(1, dochtmlhead.ChildNodes.Length);\n            Assert.AreEqual(0, dochtmlhead.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlhead.NodeType);\n\n            var dochtmlheadscript = dochtmlhead.ChildNodes[0] as Element;\n            Assert.AreEqual(1, dochtmlheadscript.ChildNodes.Length);\n            Assert.AreEqual(1, dochtmlheadscript.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlheadscript.NodeType);\n            Assert.AreEqual(\"data\", dochtmlheadscript.Attributes.GetNamedItem(\"type\").Value);\n\n            var text = dochtmlheadscript.ChildNodes[0];\n            Assert.AreEqual(NodeType.Text, text.NodeType);\n            Assert.AreEqual(@\"<!--<p>\", text.TextContent);\n                        \n            var dochtmlbody = dochtml.ChildNodes[1] as Element;\n            Assert.AreEqual(0, dochtmlbody.ChildNodes.Length);\n            Assert.AreEqual(0, dochtmlbody.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlbody.NodeType);\n        }\n\n        [Test]\n        public void Html5LibDoctypeInHeadImplicit()\n        {\n            var doc = Html(@\"<html><!DOCTYPE html>\");\n\n            var dochtml = doc.ChildNodes[0] as Element;\n            Assert.AreEqual(2, dochtml.ChildNodes.Length);\n            Assert.AreEqual(0, dochtml.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtml.NodeType);\n\n            var dochtmlhead = dochtml.ChildNodes[0] as Element;\n            Assert.AreEqual(0, dochtmlhead.ChildNodes.Length);\n            Assert.AreEqual(0, dochtmlhead.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlhead.NodeType);\n\n            var dochtmlbody = dochtml.ChildNodes[1] as Element;\n            Assert.AreEqual(0, dochtmlbody.ChildNodes.Length);\n            Assert.AreEqual(0, dochtmlbody.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlbody.NodeType);\n        }\n\n        [Test]\n        public void Html5LibDoctypeInBodyImplicit()\n        {\n            var doc = Html(@\"<html><head><\/head><!DOCTYPE html>\");\n\n            var dochtml = doc.ChildNodes[0] as Element;\n            Assert.AreEqual(2, dochtml.ChildNodes.Length);\n            Assert.AreEqual(0, dochtml.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtml.NodeType);\n\n            var dochtmlhead = dochtml.ChildNodes[0] as Element;\n            Assert.AreEqual(0, dochtmlhead.ChildNodes.Length);\n            Assert.AreEqual(0, dochtmlhead.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlhead.NodeType);\n\n            var dochtmlbody = dochtml.ChildNodes[1] as Element;\n            Assert.AreEqual(0, dochtmlbody.ChildNodes.Length);\n            Assert.AreEqual(0, dochtmlbody.Attributes.Length);\n            Assert.AreEqual(NodeType.Element, dochtmlbody.NodeType);\n\n        }\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"599362a921347cd1e61a95e3d0b34fe265947091","subject":"The remote cursor does not display","message":"The remote cursor does not display\n\nThe remote cursor does not display default until the remote mouse event\noccurs.\n","repos":"geesugar\/DoubleMouseCursor,geesugar\/DoubleMouseCursor","old_file":"DoubleCursor\/DoubleCursor\/IPC.cs","new_file":"DoubleCursor\/DoubleCursor\/IPC.cs","new_contents":"\ufeffusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nusing System.Threading;\r\nusing System.Net;\r\nusing System.Net.Sockets;\r\nusing Newtonsoft.Json.Linq;\r\nusing MouseEvent;\r\nusing System.Runtime.InteropServices;\r\nusing System.IO;\r\nusing System.Windows.Media;\r\nusing System.Windows.Controls;\r\nusing System.Windows.Interop;\r\nusing System.Windows;\r\n\r\nnamespace DoubleCursor\r\n{\r\n    class IPC\r\n    {\r\n        LocalIndicator localIndicator;\r\n        RemoteIndicator remoteIndicator;\r\n        LocalCursor localCursor;\r\n        RemoteCursor remoteCursor;\r\n\r\n        #region PInvoke\r\n\r\n        [DllImport(\"user32.dll\", EntryPoint = \"mouse_event\")]\r\n        private static extern void mouse_event(int dwFlags, int dx, int dy, int dwData, int dwExtraInfo);\r\n\r\n        [DllImport(\"user32.dll\", CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]\r\n        public static extern bool SetWindowPos(IntPtr hWnd, int hWndInsertAfter, int X, int Y, int cx, int cy, int uFlags);\r\n\r\n        [DllImport(\"user32.dll\")]\r\n        private static extern bool GetCursorPos(ref MouseEvent.Hook.POINT point);\r\n\r\n        private int MOUSEEVENTF_ABSOLUTE = 0x8000;\r\n        private int MOUSEEVENTF_MOVE = 0x0001;\r\n\r\n        #endregion\r\n\r\n        private int port { set; get; }\r\n        private bool isRuning = true;\r\n        private static Hook mouseHook;\r\n\r\n        public IPC(int port)\r\n        {\r\n            this.port = port;\r\n\r\n            mouseHook = new Hook(\"Mouse hook.\");\r\n            mouseHook.mouseOwnChange += MouseOwnChange;\r\n            mouseHook.mouseMoveEvent += MouseMoveEvent;\r\n\r\n            localIndicator = new LocalIndicator();\r\n            remoteIndicator = new RemoteIndicator();\r\n            localIndicator.Show();\r\n            remoteIndicator.Hide();\r\n          \r\n            localCursor = new LocalCursor();\r\n            MemoryStream localImagMemory = new MemoryStream();\r\n            var localCursorImg = DoubleCursor.Properties.Resources.localCursor;\r\n            localCursorImg.Save(localImagMemory, System.Drawing.Imaging.ImageFormat.Png);\r\n            ImageSourceConverter converter = new ImageSourceConverter();\r\n            ImageSource source = (ImageSource)converter.ConvertFrom(localImagMemory);\r\n            Grid gd = localCursor.Content as Grid;\r\n            Image localImg = gd.Children[0] as Image;\r\n            localImg.Source = source;\r\n            localCursor.Hide();\r\n\r\n            remoteCursor = new RemoteCursor();\r\n            MemoryStream remoteImgMemory = new MemoryStream();\r\n            var remoteCursorImg = DoubleCursor.Properties.Resources.remoteCursor;\r\n            remoteCursorImg.Save(remoteImgMemory, System.Drawing.Imaging.ImageFormat.Png);\r\n            source = (ImageSource)converter.ConvertFrom(remoteImgMemory);\r\n            gd = remoteCursor.Content as Grid;\r\n            Image remoteImg = gd.Children[0] as Image;\r\n            remoteImg.Source = source;\r\n            remoteCursor.Hide();\r\n        }\r\n\r\n        public void start()\r\n        {\r\n            MouseEvent.Hook.POINT mousePos = new MouseEvent.Hook.POINT(0, 0);\r\n            GetCursorPos(ref mousePos); \r\n            var hLocalCursor = new WindowInteropHelper(localCursor);\r\n            var hLocalIndicator = new WindowInteropHelper(localIndicator);\r\n            var hRemoteCursor = new WindowInteropHelper(remoteCursor);\r\n            var hRemoteIndicator = new WindowInteropHelper(remoteIndicator);\r\n            SetWindowPos(hLocalCursor.Handle, -1, mousePos.X, mousePos.Y, 0, 0, 0x0040 | 0x0001);\r\n            SetWindowPos(hLocalIndicator.Handle, -1, mousePos.X, mousePos.Y, 0, 0, 0x0040 | 0x0001);\r\n            SetWindowPos(hRemoteCursor.Handle, -1, mousePos.X, mousePos.Y, 0, 0, 0x0040 | 0x0001);\r\n            SetWindowPos(hRemoteIndicator.Handle, -1, mousePos.X, mousePos.Y, 0, 0, 0x0040 | 0x0001);\r\n        }\r\n\r\n        public void exitProcess()\r\n        {\r\n            System.Diagnostics.Process.GetCurrentProcess().Kill();\r\n        }\r\n\r\n        private void MouseMoveEvent(bool isLocal, MouseEvent.Hook.POINT pt)\r\n        {\r\n            \/\/Console.WriteLine(\"MouseMoveEvent  isLocal:{0} x:{1} y:{2}\", isLocal, pt.X, pt.Y);\r\n            if (isLocal)\r\n            {\r\n                var hLocalCursor = new WindowInteropHelper(localCursor);\r\n                var hLocalIndicator = new WindowInteropHelper(localIndicator);\r\n                SetWindowPos(hLocalCursor.Handle, -1, pt.X, pt.Y, 0, 0, 0x0040 | 0x0001);\r\n                SetWindowPos(hLocalIndicator.Handle, -1, pt.X, pt.Y, 0, 0, 0x0040 | 0x0001);\r\n            }\r\n            else\r\n            {\r\n                if (!remoteActive)\r\n                {\r\n                    remoteActive = true;\r\n                    remoteCursor.Show();\r\n                    remoteIndicator.Show();\r\n                }\r\n                var hRemoteCursor = new WindowInteropHelper(remoteCursor);\r\n                var hRemoteIndicator = new WindowInteropHelper(remoteIndicator);\r\n                SetWindowPos(hRemoteCursor.Handle, -1, pt.X, pt.Y, 0, 0, 0x0040 | 0x0001);\r\n                SetWindowPos(hRemoteIndicator.Handle, -1, pt.X, pt.Y, 0, 0, 0x0040 | 0x0001);\r\n            }\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Change cursor own status\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <param name=\"isLocal\">true: remote->local; false: local->remote<\/param>\r\n        \/\/\/ <param name=\"pt\">move cursor to the position<\/param>\r\n        private void MouseOwnChange(bool isLocal, MouseEvent.Hook.POINT pt){\r\n            \/\/move cursor to pt\r\n            Console.WriteLine(\"move cursor to x:{0} y:{1}\", pt.X, pt.Y);\r\n            int x = (int)(pt.X * 65535 \/ SystemParameters.PrimaryScreenWidth);\r\n            int y = (int)(pt.Y * 65535 \/ SystemParameters.PrimaryScreenHeight);\r\n            mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE, x, y, 0, 0);\r\n\r\n            if (isLocal)\r\n            {\r\n                localCursor.Hide();\r\n                remoteCursor.Show();\r\n            }\r\n            else\r\n            {\r\n                localCursor.Show();\r\n                remoteCursor.Hide();\r\n            }\r\n        }\r\n    }\r\n}\r\n","old_contents":"\ufeffusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nusing System.Threading;\r\nusing System.Net;\r\nusing System.Net.Sockets;\r\nusing Newtonsoft.Json.Linq;\r\nusing MouseEvent;\r\nusing System.Runtime.InteropServices;\r\nusing System.IO;\r\nusing System.Windows.Media;\r\nusing System.Windows.Controls;\r\nusing System.Windows.Interop;\r\nusing System.Windows;\r\n\r\nnamespace DoubleCursor\r\n{\r\n    class IPC\r\n    {\r\n        LocalIndicator localIndicator;\r\n        RemoteIndicator remoteIndicator;\r\n        LocalCursor localCursor;\r\n        RemoteCursor remoteCursor;\r\n\r\n        #region PInvoke\r\n\r\n        [DllImport(\"user32.dll\", EntryPoint = \"mouse_event\")]\r\n        private static extern void mouse_event(int dwFlags, int dx, int dy, int dwData, int dwExtraInfo);\r\n\r\n        [DllImport(\"user32.dll\", CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]\r\n        public static extern bool SetWindowPos(IntPtr hWnd, int hWndInsertAfter, int X, int Y, int cx, int cy, int uFlags);\r\n\r\n        [DllImport(\"user32.dll\")]\r\n        private static extern bool GetCursorPos(ref MouseEvent.Hook.POINT point);\r\n\r\n        private int MOUSEEVENTF_ABSOLUTE = 0x8000;\r\n        private int MOUSEEVENTF_MOVE = 0x0001;\r\n\r\n        #endregion\r\n\r\n        private int port { set; get; }\r\n        private bool isRuning = true;\r\n        private static Hook mouseHook;\r\n\r\n        public IPC(int port)\r\n        {\r\n            this.port = port;\r\n\r\n            mouseHook = new Hook(\"Mouse hook.\");\r\n            mouseHook.mouseOwnChange += MouseOwnChange;\r\n            mouseHook.mouseMoveEvent += MouseMoveEvent;\r\n\r\n            localIndicator = new LocalIndicator();\r\n            remoteIndicator = new RemoteIndicator();\r\n            localIndicator.Show();\r\n            remoteIndicator.Show();\r\n          \r\n            localCursor = new LocalCursor();\r\n            MemoryStream localImagMemory = new MemoryStream();\r\n            var localCursorImg = DoubleCursor.Properties.Resources.localCursor;\r\n            localCursorImg.Save(localImagMemory, System.Drawing.Imaging.ImageFormat.Png);\r\n            ImageSourceConverter converter = new ImageSourceConverter();\r\n            ImageSource source = (ImageSource)converter.ConvertFrom(localImagMemory);\r\n            Grid gd = localCursor.Content as Grid;\r\n            Image localImg = gd.Children[0] as Image;\r\n            localImg.Source = source;\r\n            localCursor.Hide();\r\n\r\n            remoteCursor = new RemoteCursor();\r\n            MemoryStream remoteImgMemory = new MemoryStream();\r\n            var remoteCursorImg = DoubleCursor.Properties.Resources.remoteCursor;\r\n            remoteCursorImg.Save(remoteImgMemory, System.Drawing.Imaging.ImageFormat.Png);\r\n            source = (ImageSource)converter.ConvertFrom(remoteImgMemory);\r\n            gd = remoteCursor.Content as Grid;\r\n            Image remoteImg = gd.Children[0] as Image;\r\n            remoteImg.Source = source;\r\n            remoteCursor.Show();\r\n        }\r\n\r\n        public void start()\r\n        {\r\n            MouseEvent.Hook.POINT mousePos = new MouseEvent.Hook.POINT(0, 0);\r\n            GetCursorPos(ref mousePos); \r\n            var hLocalCursor = new WindowInteropHelper(localCursor);\r\n            var hLocalIndicator = new WindowInteropHelper(localIndicator);\r\n            var hRemoteCursor = new WindowInteropHelper(remoteCursor);\r\n            var hRemoteIndicator = new WindowInteropHelper(remoteIndicator);\r\n            SetWindowPos(hLocalCursor.Handle, -1, mousePos.X, mousePos.Y, 0, 0, 0x0040 | 0x0001);\r\n            SetWindowPos(hLocalIndicator.Handle, -1, mousePos.X, mousePos.Y, 0, 0, 0x0040 | 0x0001);\r\n            SetWindowPos(hRemoteCursor.Handle, -1, mousePos.X, mousePos.Y, 0, 0, 0x0040 | 0x0001);\r\n            SetWindowPos(hRemoteIndicator.Handle, -1, mousePos.X, mousePos.Y, 0, 0, 0x0040 | 0x0001);\r\n        }\r\n\r\n        public void exitProcess()\r\n        {\r\n            System.Diagnostics.Process.GetCurrentProcess().Kill();\r\n        }\r\n\r\n        private void MouseMoveEvent(bool isLocal, MouseEvent.Hook.POINT pt)\r\n        {\r\n            \/\/Console.WriteLine(\"MouseMoveEvent  isLocal:{0} x:{1} y:{2}\", isLocal, pt.X, pt.Y);\r\n            if (isLocal)\r\n            {\r\n                var hLocalCursor = new WindowInteropHelper(localCursor);\r\n                var hLocalIndicator = new WindowInteropHelper(localIndicator);\r\n                SetWindowPos(hLocalCursor.Handle, -1, pt.X, pt.Y, 0, 0, 0x0040 | 0x0001);\r\n                SetWindowPos(hLocalIndicator.Handle, -1, pt.X, pt.Y, 0, 0, 0x0040 | 0x0001);\r\n            }\r\n            else\r\n            {\r\n                var hRemoteCursor = new WindowInteropHelper(remoteCursor);\r\n                var hRemoteIndicator = new WindowInteropHelper(remoteIndicator);\r\n                SetWindowPos(hRemoteCursor.Handle, -1, pt.X, pt.Y, 0, 0, 0x0040 | 0x0001);\r\n                SetWindowPos(hRemoteIndicator.Handle, -1, pt.X, pt.Y, 0, 0, 0x0040 | 0x0001);\r\n            }\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Change cursor own status\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <param name=\"isLocal\">true: remote->local; false: local->remote<\/param>\r\n        \/\/\/ <param name=\"pt\">move cursor to the position<\/param>\r\n        private void MouseOwnChange(bool isLocal, MouseEvent.Hook.POINT pt){\r\n            \/\/move cursor to pt\r\n            Console.WriteLine(\"move cursor to x:{0} y:{1}\", pt.X, pt.Y);\r\n            int x = (int)(pt.X * 65535 \/ SystemParameters.PrimaryScreenWidth);\r\n            int y = (int)(pt.Y * 65535 \/ SystemParameters.PrimaryScreenHeight);\r\n            mouse_event(MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE, x, y, 0, 0);\r\n\r\n            if (isLocal)\r\n            {\r\n                localCursor.Hide();\r\n                remoteCursor.Show();\r\n            }\r\n            else\r\n            {\r\n                localCursor.Show();\r\n                remoteCursor.Hide();\r\n            }\r\n        }\r\n    }\r\n}\r\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"5b264cf65cba866b04a34b4571b96f1e2d5630b6","subject":"remove unused using","message":"remove unused using\n","repos":"Microsoft\/vscode-mono-debug,Microsoft\/vscode-mono-debug","old_file":"src\/sdb\/CommandLine.cs","new_file":"src\/sdb\/CommandLine.cs","new_contents":"\ufeff\/\/\n\/\/ The MIT License (MIT)\n\/\/\n\/\/ Copyright (c) 2014 Alex R\u00f8nne Petersen\n\/\/\n\/\/ Permission is hereby granted, free of charge, to any person obtaining a copy\n\/\/ of this software and associated documentation files (the \"Software\"), to deal\n\/\/ in the Software without restriction, including without limitation the rights\n\/\/ to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\n\/\/ copies of the Software, and to permit persons to whom the Software is\n\/\/ furnished to do so, subject to the following conditions:\n\/\/\n\/\/ The above copyright notice and this permission notice shall be included in\n\/\/ all copies or substantial portions of the Software.\n\/\/\n\/\/ THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\/\/ IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\/\/ FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\/\/ AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\/\/ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\/\/ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\/\/ THE SOFTWARE.\n\/\/\n\nusing System.Threading;\n\nnamespace Mono.Debugger.Client\n{\n    public static class CommandLine\n\t{\n\t\tinternal static AutoResetEvent ResumeEvent { get; private set; }\n\n\t\tinternal static bool InferiorExecuting { get; set; }\n\n\t\tstatic CommandLine()\n\t\t{\n\t\t\tResumeEvent = new AutoResetEvent(false);\n\t\t}\n\n\t\tinternal static void SetControlCHandler()\n\t\t{\n\t\t}\n\n\t\tinternal static void UnsetControlCHandler()\n\t\t{\n\t\t}\n\n\t\tpublic static void WaitForSuspend() {\n\t\t\tif (InferiorExecuting)\n\t\t\t{\n\t\t\t\tResumeEvent.WaitOne();\n\t\t\t\tInferiorExecuting = false;\n\t\t\t}\n\t\t}\n\t}\n}\n","old_contents":"\ufeff\/\/\n\/\/ The MIT License (MIT)\n\/\/\n\/\/ Copyright (c) 2014 Alex R\u00f8nne Petersen\n\/\/\n\/\/ Permission is hereby granted, free of charge, to any person obtaining a copy\n\/\/ of this software and associated documentation files (the \"Software\"), to deal\n\/\/ in the Software without restriction, including without limitation the rights\n\/\/ to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\n\/\/ copies of the Software, and to permit persons to whom the Software is\n\/\/ furnished to do so, subject to the following conditions:\n\/\/\n\/\/ The above copyright notice and this permission notice shall be included in\n\/\/ all copies or substantial portions of the Software.\n\/\/\n\/\/ THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\/\/ IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\/\/ FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\/\/ AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\/\/ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\/\/ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\/\/ THE SOFTWARE.\n\/\/\n\nusing System;\nusing System.Threading;\n\nnamespace Mono.Debugger.Client\n{\n\tpublic static class CommandLine\n\t{\n\t\tinternal static AutoResetEvent ResumeEvent { get; private set; }\n\n\t\tinternal static bool InferiorExecuting { get; set; }\n\n\t\tstatic CommandLine()\n\t\t{\n\t\t\tResumeEvent = new AutoResetEvent(false);\n\t\t}\n\n\t\tinternal static void SetControlCHandler()\n\t\t{\n\t\t}\n\n\t\tinternal static void UnsetControlCHandler()\n\t\t{\n\t\t}\n\n\t\tpublic static void WaitForSuspend() {\n\t\t\tif (InferiorExecuting)\n\t\t\t{\n\t\t\t\tResumeEvent.WaitOne();\n\t\t\t\tInferiorExecuting = false;\n\t\t\t}\n\t\t}\n\t}\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"ba9b17f36e0abd10413622976f339f0e37baf81f","subject":"Dispose everything as early as possibl","message":"Dispose everything as early as possibl\n","repos":"flagbug\/Espera.Network","old_file":"Espera.Network\/NetworkHelpers.cs","new_file":"Espera.Network\/NetworkHelpers.cs","new_contents":"\ufeffusing Newtonsoft.Json;\nusing Newtonsoft.Json.Bson;\nusing Newtonsoft.Json.Linq;\nusing System;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Linq;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Espera.Network\n{\n    public static class NetworkHelpers\n    {\n        public static async Task<byte[]> PackFileTransferMessageAsync(FileTransferMessage message)\n        {\n            byte[] serialized;\n\n            using (var ms = new MemoryStream())\n            {\n                var serializer = new JsonSerializer();\n\n                using (var writer = new BsonWriter(ms))\n                {\n                    await Task.Run(() => serializer.Serialize(writer, message));\n\n                    serialized = ms.ToArray();\n                }\n            }\n\n            byte[] length = BitConverter.GetBytes(serialized.Length); \/\/ We have a fixed size of 4 bytes\n\n            var returnData = new byte[length.Length + serialized.Length];\n\n            \/\/ We could simply call .ToArray() everywhere, but with Buffer.BlockCopy, we are\n            \/\/ reducing memory pressure and CPU time on mobile devices by an order of magnitude\n            Buffer.BlockCopy(length, 0, returnData, 0, length.Length);\n            Buffer.BlockCopy(serialized, 0, returnData, length.Length, serialized.Length);\n\n            return returnData;\n        }\n\n        public static async Task<byte[]> PackMessageAsync(NetworkMessage message)\n        {\n            string serialized = JsonConvert.SerializeObject(message, Formatting.None);\n            byte[] contentBytes = Encoding.UTF8.GetBytes(serialized);\n\n            contentBytes = await CompressDataAsync(contentBytes);\n\n            byte[] length = BitConverter.GetBytes(contentBytes.Length); \/\/ We have a fixed size of 4 bytes\n\n            return length.Concat(contentBytes).ToArray();\n        }\n\n        public static async Task<FileTransferMessage> ReadNextFileTransferMessageAsync(this TcpClient client)\n        {\n            byte[] messageLength = await client.ReadAsync(4);\n\n            if (messageLength.Length == 0)\n            {\n                return null;\n            }\n\n            int realMessageLength = BitConverter.ToInt32(messageLength, 0);\n\n            byte[] messageContent = await client.ReadAsync(realMessageLength);\n\n            if (messageContent.Length == 0)\n            {\n                return null;\n            }\n\n            using (var stream = new MemoryStream(messageContent))\n            {\n                await stream.WriteAsync(messageContent, 0, messageContent.Length);\n\n                var deserializer = new JsonSerializer();\n\n                using (var reader = new BsonReader(stream))\n                {\n                    return deserializer.Deserialize<FileTransferMessage>(reader);\n                }\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Reads the next message for the Espera protocol from the TCP client.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>\n        \/\/\/ The uncompressed, deserialized message in JSON, or null, if the underlying client has\n        \/\/\/ closed the connection.\n        \/\/\/ <\/returns>\n        public static async Task<NetworkMessage> ReadNextMessageAsync(this TcpClient client)\n        {\n            byte[] messageLength = await client.ReadAsync(4);\n\n            if (messageLength.Length == 0)\n            {\n                return null;\n            }\n\n            int realMessageLength = BitConverter.ToInt32(messageLength, 0);\n\n            byte[] messageContent = await client.ReadAsync(realMessageLength);\n\n            if (messageContent.Length == 0)\n            {\n                return null;\n            }\n\n            byte[] decompressed = await DecompressDataAsync(messageContent);\n            string decoded = Encoding.UTF8.GetString(decompressed);\n\n            var message = JObject.Parse(decoded).ToObject<NetworkMessage>();\n\n            return message;\n        }\n\n        private static async Task<byte[]> CompressDataAsync(byte[] data)\n        {\n            using (var targetStream = new MemoryStream())\n            {\n                using (var stream = new GZipStream(targetStream, CompressionMode.Compress))\n                {\n                    await stream.WriteAsync(data, 0, data.Length);\n                }\n\n                return targetStream.ToArray();\n            }\n        }\n\n        private static async Task<byte[]> DecompressDataAsync(byte[] data)\n        {\n            using (var sourceStream = new MemoryStream(data))\n            {\n                using (var stream = new GZipStream(sourceStream, CompressionMode.Decompress))\n                {\n                    using (var targetStream = new MemoryStream())\n                    {\n                        await stream.CopyToAsync(targetStream);\n                        return targetStream.ToArray();\n                    }\n                }\n            }\n        }\n\n        private static async Task<byte[]> ReadAsync(this TcpClient client, int length)\n        {\n            if (length <= 0)\n                throw new ArgumentOutOfRangeException(\"length\", \"Length must be greater than 0\");\n\n            int count = 0;\n            var buffer = new byte[length];\n\n            do\n            {\n                int read = await client.GetStream().ReadAsync(buffer, count, length - count);\n                count += read;\n\n                \/\/ The client has closed the connection\n                if (read == 0)\n                    return new byte[0];\n            }\n            while (count < length);\n\n            return buffer;\n        }\n    }\n}","old_contents":"\ufeffusing Newtonsoft.Json;\nusing Newtonsoft.Json.Bson;\nusing Newtonsoft.Json.Linq;\nusing System;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Linq;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Espera.Network\n{\n    public static class NetworkHelpers\n    {\n        public static async Task<byte[]> PackFileTransferMessageAsync(FileTransferMessage message)\n        {\n            using (var ms = new MemoryStream())\n            {\n                var serializer = new JsonSerializer();\n\n                using (var writer = new BsonWriter(ms))\n                {\n                    await Task.Run(() => serializer.Serialize(writer, message));\n\n                    byte[] length = BitConverter.GetBytes((int)ms.Length); \/\/ We have a fixed size of 4 bytes\n\n                    var returnData = new byte[length.Length + ms.Length];\n\n                    \/\/ We could simply call .ToArray() everywhere, but with Buffer.BlockCopy, we are\n                    \/\/ reducing memory pressure and CPU time on mobile devices by an order of magnitude\n                    Buffer.BlockCopy(length, 0, returnData, 0, length.Length);\n                    Buffer.BlockCopy(ms.ToArray(), 0, returnData, length.Length, (int)ms.Length);\n\n                    return returnData;\n                }\n            }\n        }\n\n        public static async Task<byte[]> PackMessageAsync(NetworkMessage message)\n        {\n            string serialized = JsonConvert.SerializeObject(message, Formatting.None);\n            byte[] contentBytes = Encoding.UTF8.GetBytes(serialized);\n\n            contentBytes = await CompressDataAsync(contentBytes);\n\n            byte[] length = BitConverter.GetBytes(contentBytes.Length); \/\/ We have a fixed size of 4 bytes\n\n            return length.Concat(contentBytes).ToArray();\n        }\n\n        public static async Task<FileTransferMessage> ReadNextFileTransferMessageAsync(this TcpClient client)\n        {\n            byte[] messageLength = await client.ReadAsync(4);\n\n            if (messageLength.Length == 0)\n            {\n                return null;\n            }\n\n            int realMessageLength = BitConverter.ToInt32(messageLength, 0);\n\n            byte[] messageContent = await client.ReadAsync(realMessageLength);\n\n            if (messageContent.Length == 0)\n            {\n                return null;\n            }\n\n            using (var stream = new MemoryStream(messageContent))\n            {\n                await stream.WriteAsync(messageContent, 0, messageContent.Length);\n\n                var deserializer = new JsonSerializer();\n\n                using (var reader = new BsonReader(stream))\n                {\n                    return deserializer.Deserialize<FileTransferMessage>(reader);\n                }\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Reads the next message for the Espera protocol from the TCP client.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns>\n        \/\/\/ The uncompressed, deserialized message in JSON, or null, if the underlying client has\n        \/\/\/ closed the connection.\n        \/\/\/ <\/returns>\n        public static async Task<NetworkMessage> ReadNextMessageAsync(this TcpClient client)\n        {\n            byte[] messageLength = await client.ReadAsync(4);\n\n            if (messageLength.Length == 0)\n            {\n                return null;\n            }\n\n            int realMessageLength = BitConverter.ToInt32(messageLength, 0);\n\n            byte[] messageContent = await client.ReadAsync(realMessageLength);\n\n            if (messageContent.Length == 0)\n            {\n                return null;\n            }\n\n            byte[] decompressed = await DecompressDataAsync(messageContent);\n            string decoded = Encoding.UTF8.GetString(decompressed);\n\n            var message = JObject.Parse(decoded).ToObject<NetworkMessage>();\n\n            return message;\n        }\n\n        private static async Task<byte[]> CompressDataAsync(byte[] data)\n        {\n            using (var targetStream = new MemoryStream())\n            {\n                using (var stream = new GZipStream(targetStream, CompressionMode.Compress))\n                {\n                    await stream.WriteAsync(data, 0, data.Length);\n                }\n\n                return targetStream.ToArray();\n            }\n        }\n\n        private static async Task<byte[]> DecompressDataAsync(byte[] data)\n        {\n            using (var sourceStream = new MemoryStream(data))\n            {\n                using (var stream = new GZipStream(sourceStream, CompressionMode.Decompress))\n                {\n                    using (var targetStream = new MemoryStream())\n                    {\n                        await stream.CopyToAsync(targetStream);\n                        return targetStream.ToArray();\n                    }\n                }\n            }\n        }\n\n        private static async Task<byte[]> ReadAsync(this TcpClient client, int length)\n        {\n            if (length <= 0)\n                throw new ArgumentOutOfRangeException(\"length\", \"Length must be greater than 0\");\n\n            int count = 0;\n            var buffer = new byte[length];\n\n            do\n            {\n                int read = await client.GetStream().ReadAsync(buffer, count, length - count);\n                count += read;\n\n                \/\/ The client has closed the connection\n                if (read == 0)\n                    return new byte[0];\n            }\n            while (count < length);\n\n            return buffer;\n        }\n    }\n}","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"078bb3dd83662d65aa782cc477c5ab0a26f81023","subject":"the profile picture is now smaller","message":"the profile picture is now smaller\n","repos":"oliverguhr\/Flurfunk,oliverguhr\/Flurfunk","old_file":"Flurfunk\/Views\/Home\/Index.cshtml","new_file":"Flurfunk\/Views\/Home\/Index.cshtml","new_contents":"\ufeff@model Flurfunk.Data.Model.User\n@using Flurfunk.Helper\n@{\n    ViewBag.Title = \"\";\n}\n@section featured {\n    @* <section class=\"featured\">\n        <div class=\"content-wrapper\">\n            <hgroup class=\"title\">\n                <h1>@ViewBag.Title<\/h1>\n                <h2>@ViewBag.Message<\/h2>\n            <\/hgroup>\n            <p>\n                To learn more about ASP.NET MVC visit\n                <a href=\"http:\/\/asp.net\/mvc\" title=\"ASP.NET MVC Website\">http:\/\/asp.net\/mvc<\/a>.\n                The page features <mark>videos, tutorials, and samples<\/mark> to help you get the most from ASP.NET MVC.\n                If you have any questions about ASP.NET MVC visit\n                <a href=\"http:\/\/forums.asp.net\/1146.aspx\/1?MVC\" title=\"ASP.NET MVC Forum\">our forums<\/a>.\n            <\/p>\n        <\/div>\n    <\/section>*@\n}\n<div class=\"row\">\n    <div class=\"span3 sidebar\">\n        <h3>\n            <img src=\"@Url.ProfilePicture(Model)\" style=\"height: 55px\" \/>@Model.Name\n        <\/h3>\n        <div ng-controller=\"sendMessageController\">\n            <form class=\"form\" ng-submit=\"sendMessage()\">\n                <div class=\"control-group\">\n                    <div class=\"controls\">\n                        <textarea ng-model=\"message\" ng-change=\"messageUpdate()\" placeholder=\"Teile es mit allen\u2026\" class=\"span3\" id=\"textarea\" rows=\"3\"><\/textarea>\n                    <\/div>\n\n                    <button type=\"submit\" class=\"btn btn-{{messageButtonClass}}\">Senden<\/button>\n                    <h3 style=\"float: right\">{{140 - message.length}}<\/h3>\n\n                <\/div>\n            <\/form>\n        <\/div>\n\n        <div ng-controller='filterController'>\n            <h2>Filter<\/h2>\n            <div class=\"input-append\">\n       \n                    <input class=\"span3\" ng-model=\"filterKeyword\" ng-change=\"filterUpdate()\" placeholder=\"nach Schlagwort filtern\" size=\"16\" type=\"text\">\n                    <button ng-click=\"addFilter()\" class=\"btn {{addButtonClass}}\" type=\"button\">+<\/button>\n  \n            <\/div>\n            <ul class=\"nav nav-pills nav-stacked filters\" >\n               @* <li class=\"active\"><a href=\"#\">alle Nachrichten<\/a><\/li>*@\n                <li ng-repeat='filter in filters' id=\"filter-{{$index}}\"><a href=\"#\" ng-click=\"selectFilter($index)\" ><span class=\"keyword\">{{filter}}<\/span><button ng-click=\"removeFilter(filter)\" eat-click class=\"close\">&times;<\/button> <\/a><\/li>                \n            <\/ul>\n        <\/div>\n\n        <h2>Gruppen<\/h2>\n        <div class=\"input-append\">\n            <input class=\"span3\" id=\"appendedInputButton\" placeholder=\"neue Gruppe erstellen\" size=\"16\" type=\"text\">\n            <button class=\"btn\" type=\"button\">+<\/button>\n        <\/div>\n        <ul class=\"nav nav-pills nav-stacked\">\n            <li><a href=\"#\">Projekt A<button class=\"close\">&times;<\/button><\/a><\/li>\n            <li><a href=\"#\">Mittagessen Gruppe<button class=\"close\">&times;<\/button><\/a><\/li>\n            <li><a href=\"#\">Abteilung B<button class=\"close\">&times;<\/button><\/a> <\/li>\n        <\/ul>\n    <\/div>\n\n    <div ng-controller='loadMessageController'>\n        <div infinite-scroll='nextPage()' infinite-scroll-disabled='busy'>\n            <div class=\"row span9\" style=\"float: right\" ng-repeat='item in items'>\n                <div id=\"{{item._id}}\" class=\"span8 textmessage\">\n                    <span class=\"messageImage\" >\n                        <img src=\"{{getUserImageUrl(item.Creator.ProviderId)}}\"\/>\n                    <\/span>\n                    <p class=\"span6\">{{item.Text}}<\/p>\n                    <small class=\"span4\">von {{item.Creator.Name}} am {{getTimeString(item.Created)}}<\/small>\n                <\/div>\n            <\/div>\n            @*  <div ng-show='busy'>Loading data...<\/div>*@\n        <\/div>\n    <\/div>\n<\/div>\n","old_contents":"\ufeff@model Flurfunk.Data.Model.User\n@using Flurfunk.Helper\n@{\n    ViewBag.Title = \"\";\n}\n@section featured {\n    @* <section class=\"featured\">\n        <div class=\"content-wrapper\">\n            <hgroup class=\"title\">\n                <h1>@ViewBag.Title<\/h1>\n                <h2>@ViewBag.Message<\/h2>\n            <\/hgroup>\n            <p>\n                To learn more about ASP.NET MVC visit\n                <a href=\"http:\/\/asp.net\/mvc\" title=\"ASP.NET MVC Website\">http:\/\/asp.net\/mvc<\/a>.\n                The page features <mark>videos, tutorials, and samples<\/mark> to help you get the most from ASP.NET MVC.\n                If you have any questions about ASP.NET MVC visit\n                <a href=\"http:\/\/forums.asp.net\/1146.aspx\/1?MVC\" title=\"ASP.NET MVC Forum\">our forums<\/a>.\n            <\/p>\n        <\/div>\n    <\/section>*@\n}\n<div class=\"row\">\n    <div class=\"span3 sidebar\">\n        <h3>\n            <img src=\"@Url.ProfilePicture(Model)\" style=\"height: 100px\" \/>@Model.Name\n        <\/h3>\n        <div ng-controller=\"sendMessageController\">\n            <form class=\"form\" ng-submit=\"sendMessage()\">\n                <div class=\"control-group\">\n                    <div class=\"controls\">\n                        <textarea ng-model=\"message\" ng-change=\"messageUpdate()\" placeholder=\"Teile es mit allen\u2026\" class=\"span3\" id=\"textarea\" rows=\"3\"><\/textarea>\n                    <\/div>\n\n                    <button type=\"submit\" class=\"btn btn-{{messageButtonClass}}\">Senden<\/button>\n                    <h3 style=\"float: right\">{{140 - message.length}}<\/h3>\n\n                <\/div>\n            <\/form>\n        <\/div>\n\n        <div ng-controller='filterController'>\n            <h2>Filter<\/h2>\n            <div class=\"input-append\">\n       \n                    <input class=\"span3\" ng-model=\"filterKeyword\" ng-change=\"filterUpdate()\" placeholder=\"nach Schlagwort filtern\" size=\"16\" type=\"text\">\n                    <button ng-click=\"addFilter()\" class=\"btn {{addButtonClass}}\" type=\"button\">+<\/button>\n  \n            <\/div>\n            <ul class=\"nav nav-pills nav-stacked filters\" >\n               @* <li class=\"active\"><a href=\"#\">alle Nachrichten<\/a><\/li>*@\n                <li ng-repeat='filter in filters' id=\"filter-{{$index}}\"><a href=\"#\" ng-click=\"selectFilter($index)\" ><span class=\"keyword\">{{filter}}<\/span><button ng-click=\"removeFilter(filter)\" eat-click class=\"close\">&times;<\/button> <\/a><\/li>                \n            <\/ul>\n        <\/div>\n\n        <h2>Gruppen<\/h2>\n        <div class=\"input-append\">\n            <input class=\"span3\" id=\"appendedInputButton\" placeholder=\"neue Gruppe erstellen\" size=\"16\" type=\"text\">\n            <button class=\"btn\" type=\"button\">+<\/button>\n        <\/div>\n        <ul class=\"nav nav-pills nav-stacked\">\n            <li><a href=\"#\">Projekt A<button class=\"close\">&times;<\/button><\/a><\/li>\n            <li><a href=\"#\">Mittagessen Gruppe<button class=\"close\">&times;<\/button><\/a><\/li>\n            <li><a href=\"#\">Abteilung B<button class=\"close\">&times;<\/button><\/a> <\/li>\n        <\/ul>\n    <\/div>\n\n    <div ng-controller='loadMessageController'>\n        <div infinite-scroll='nextPage()' infinite-scroll-disabled='busy'>\n            <div class=\"row span9\" style=\"float: right\" ng-repeat='item in items'>\n                <div id=\"{{item._id}}\" class=\"span8 textmessage\">\n                    <span class=\"messageImage\" >\n                        <img src=\"{{getUserImageUrl(item.Creator.ProviderId)}}\"\/>\n                    <\/span>\n                    <p class=\"span6\">{{item.Text}}<\/p>\n                    <small class=\"span4\">von {{item.Creator.Name}} am {{getTimeString(item.Created)}}<\/small>\n                <\/div>\n            <\/div>\n            @*  <div ng-show='busy'>Loading data...<\/div>*@\n        <\/div>\n    <\/div>\n<\/div>\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"3e818dc21746dd99161e3db6bdd7c6c2c3b11a6b","subject":"Fix joystick input ignored after first disabled and then enabled","message":"Fix joystick input ignored after first disabled and then enabled\n","repos":"ppy\/osu-framework,ppy\/osu-framework,EVAST9919\/osu-framework,smoogipooo\/osu-framework,EVAST9919\/osu-framework,DrabWeb\/osu-framework,ZLima12\/osu-framework,Tom94\/osu-framework,peppy\/osu-framework,smoogipooo\/osu-framework,DrabWeb\/osu-framework,EVAST9919\/osu-framework,ZLima12\/osu-framework,EVAST9919\/osu-framework,peppy\/osu-framework,DrabWeb\/osu-framework,ppy\/osu-framework,peppy\/osu-framework,Tom94\/osu-framework","old_file":"osu.Framework\/Input\/Handlers\/Joystick\/OpenTKJoystickHandler.cs","new_file":"osu.Framework\/Input\/Handlers\/Joystick\/OpenTKJoystickHandler.cs","new_contents":"\ufeff\/\/ Copyright (c) 2007-2018 ppy Pty Ltd <contact@ppy.sh>.\n\/\/ Licensed under the MIT Licence - https:\/\/raw.githubusercontent.com\/ppy\/osu-framework\/master\/LICENCE\n\nusing System;\nusing System.Collections.Generic;\nusing osu.Framework.Logging;\nusing osu.Framework.MathUtils;\nusing osu.Framework.Platform;\nusing osu.Framework.Statistics;\nusing osu.Framework.Threading;\nusing OpenTK.Input;\n\nnamespace osu.Framework.Input.Handlers.Joystick\n{\n    public class OpenTKJoystickHandler : InputHandler\n    {\n        private ScheduledDelegate scheduled;\n\n        private int mostSeenDevices;\n        private List<JoystickDevice> devices = new List<JoystickDevice>();\n\n        public override bool Initialize(GameHost host)\n        {\n            Enabled.ValueChanged += enabled =>\n            {\n                if (enabled)\n                {\n                    host.InputThread.Scheduler.Add(scheduled = new ScheduledDelegate(delegate\n                    {\n                        refreshDevices();\n\n                        foreach (var device in devices)\n                        {\n                            if (device.RawState.Equals(device.LastRawState))\n                                continue;\n\n                            var newState = new OpenTKJoystickState(device);\n                            handleState(device, newState);\n                            FrameStatistics.Increment(StatisticsCounterType.JoystickEvents);\n                        }\n                    }, 0, 0));\n                }\n                else\n                {\n                    scheduled?.Cancel();\n                    foreach (var device in devices)\n                    {\n                        if (device.LastState != null)\n                            handleState(device, new JoystickState());\n                    }\n\n                    devices.Clear();\n                    mostSeenDevices = 0;\n                }\n            };\n\n            Enabled.TriggerChange();\n\n            return true;\n        }\n\n        private void handleState(JoystickDevice device, JoystickState newState)\n        {\n            PendingInputs.Enqueue(new JoystickButtonInput(newState.Buttons, device.LastState?.Buttons));\n\n            device.LastState = newState;\n        }\n\n        private void refreshDevices()\n        {\n            var newDevices = new List<JoystickDevice>();\n\n            \/\/ Update devices and add them to newDevices if still connected\n            foreach (var dev in devices)\n            {\n                dev.Refresh();\n\n                if (dev.RawState.IsConnected)\n                {\n                    newDevices.Add(dev);\n                }\n                else\n                {\n                    mostSeenDevices--;\n                    if (dev.LastState != null)\n                        handleState(dev, new JoystickState());\n                }\n            }\n\n            \/\/ Find any newly-connected devices\n            while (true)\n            {\n                var newDevice = new JoystickDevice(mostSeenDevices);\n                if (!newDevice.Capabilities.IsConnected)\n                    break;\n\n                Logger.Log($\"Connected joystick device: {newDevice.Guid}\");\n\n                newDevices.Add(newDevice);\n                mostSeenDevices++;\n            }\n\n            devices = newDevices;\n        }\n\n        public override bool IsActive => true;\n        public override int Priority => 0;\n\n        private class OpenTKJoystickState : JoystickState\n        {\n            public OpenTKJoystickState(JoystickDevice device)\n            {\n                \/\/ Populate axes\n                var axes = new List<JoystickAxis>();\n                for (int i = 0; i < JoystickDevice.MAX_AXES; i++)\n                {\n                    var value = device.RawState.GetAxis(i);\n                    if (!Precision.AlmostEquals(value, 0, device.DefaultDeadzones?[i] ?? Precision.FLOAT_EPSILON))\n                        axes.Add(new JoystickAxis(i, value));\n                }\n\n                Axes = axes;\n\n                \/\/ Populate normal buttons\n                for (int i = 0; i < JoystickDevice.MAX_BUTTONS; i++)\n                {\n                    if (device.RawState.GetButton(i) == ButtonState.Pressed)\n                        Buttons.SetPressed(JoystickButton.FirstButton + i, true);\n                }\n\n                \/\/ Populate hat buttons\n                for (int i = 0; i < JoystickDevice.MAX_HATS; i++)\n                {\n                    foreach (var hatButton in getHatButtons(device, i))\n                        Buttons.SetPressed(hatButton, true);\n                }\n\n                \/\/ Populate axis buttons (each axis has two buttons)\n                foreach (var axis in Axes)\n                    Buttons.SetPressed((axis.Value < 0 ? JoystickButton.FirstAxisNegative : JoystickButton.FirstAxisPositive) + axis.Axis, true);\n            }\n\n            private IEnumerable<JoystickButton> getHatButtons(JoystickDevice device, int hat)\n            {\n                var state = device.RawState.GetHat(JoystickHat.Hat0 + hat);\n\n                if (state.IsUp)\n                    yield return JoystickButton.FirstHatUp + hat;\n                else if (state.IsDown)\n                    yield return JoystickButton.FirstHatDown + hat;\n\n                if (state.IsLeft)\n                    yield return JoystickButton.FirstHatLeft + hat;\n                else if (state.IsRight)\n                    yield return JoystickButton.FirstHatRight + hat;\n            }\n        }\n\n        private class JoystickDevice\n        {\n            \/\/\/ <summary>\n            \/\/\/ Amount of axes supported by OpenTK.\n            \/\/\/ <\/summary>\n            public const int MAX_AXES = 64;\n\n            \/\/\/ <summary>\n            \/\/\/ Amount of buttons supported by OpenTK.\n            \/\/\/ <\/summary>\n            public const int MAX_BUTTONS = 64;\n\n            \/\/\/ <summary>\n            \/\/\/ Amount of hats supported by OpenTK.\n            \/\/\/ <\/summary>\n            public const int MAX_HATS = 4;\n\n            \/\/\/ <summary>\n            \/\/\/ Amount of movement around the \"centre\" of the axis that counts as moving within the deadzone.\n            \/\/\/ <\/summary>\n            private const float deadzone_threshold = 0.05f;\n\n            \/\/\/ <summary>\n            \/\/\/ The last state of this <see cref=\"JoystickDevice\"\/>.\n            \/\/\/ This is updated with ever invocation of <see cref=\"Refresh\"\/>.\n            \/\/\/ <\/summary>\n            public OpenTK.Input.JoystickState? LastRawState { get; private set; }\n\n            public JoystickState LastState { get; set; }\n\n            \/\/\/ <summary>\n            \/\/\/ The current state of this <see cref=\"JoystickDevice\"\/>.\n            \/\/\/ Use <see cref=\"Refresh\"\/> to update the state.\n            \/\/\/ <\/summary>\n            public OpenTK.Input.JoystickState RawState { get; private set; }\n\n            private readonly Lazy<float[]> defaultDeadZones = new Lazy<float[]>(() => new float[MAX_AXES]);\n\n            \/\/\/ <summary>\n            \/\/\/ Default deadzones for each axis. Can be null if deadzones have not been found.\n            \/\/\/ <\/summary>\n            public float[] DefaultDeadzones => defaultDeadZones.IsValueCreated ? defaultDeadZones.Value : null;\n\n            \/\/\/ <summary>\n            \/\/\/ The capabilities for this joystick device.\n            \/\/\/ This is only queried once when <see cref=\"JoystickDevice\"\/> is constructed.\n            \/\/\/ <\/summary>\n            public readonly JoystickCapabilities Capabilities;\n\n            \/\/\/ <summary>\n            \/\/\/ The <see cref=\"Guid\"\/> for this <see cref=\"JoystickDevice\"\/>.\n            \/\/\/ <\/summary>\n            public readonly Guid Guid;\n\n            private readonly int deviceIndex;\n\n            public JoystickDevice(int deviceIndex)\n            {\n                this.deviceIndex = deviceIndex;\n\n                Capabilities = OpenTK.Input.Joystick.GetCapabilities(deviceIndex);\n                Guid = OpenTK.Input.Joystick.GetGuid(deviceIndex);\n\n                Refresh();\n            }\n\n            \/\/\/ <summary>\n            \/\/\/ Refreshes the state of this <see cref=\"JoystickDevice\"\/>.\n            \/\/\/ <\/summary>\n            public void Refresh()\n            {\n                LastRawState = RawState;\n                RawState = OpenTK.Input.Joystick.GetState(deviceIndex);\n\n                if (!defaultDeadZones.IsValueCreated)\n                {\n                    for (int i = 0; i < MAX_AXES; i++)\n                    {\n                        var axisValue = Math.Abs(RawState.GetAxis(i));\n                        if (Precision.AlmostEquals(0, axisValue))\n                            continue;\n\n                        defaultDeadZones.Value[i] = axisValue + deadzone_threshold;\n                    }\n                }\n            }\n        }\n    }\n}\n","old_contents":"\ufeff\/\/ Copyright (c) 2007-2018 ppy Pty Ltd <contact@ppy.sh>.\n\/\/ Licensed under the MIT Licence - https:\/\/raw.githubusercontent.com\/ppy\/osu-framework\/master\/LICENCE\n\nusing System;\nusing System.Collections.Generic;\nusing osu.Framework.Logging;\nusing osu.Framework.MathUtils;\nusing osu.Framework.Platform;\nusing osu.Framework.Statistics;\nusing osu.Framework.Threading;\nusing OpenTK.Input;\n\nnamespace osu.Framework.Input.Handlers.Joystick\n{\n    public class OpenTKJoystickHandler : InputHandler\n    {\n        private ScheduledDelegate scheduled;\n\n        private int mostSeenDevices;\n        private List<JoystickDevice> devices = new List<JoystickDevice>();\n\n        public override bool Initialize(GameHost host)\n        {\n            Enabled.ValueChanged += enabled =>\n            {\n                if (enabled)\n                {\n                    host.InputThread.Scheduler.Add(scheduled = new ScheduledDelegate(delegate\n                    {\n                        refreshDevices();\n\n                        foreach (var device in devices)\n                        {\n                            if (device.RawState.Equals(device.LastRawState))\n                                continue;\n\n                            var newState = new OpenTKJoystickState(device);\n                            handleState(device, newState);\n                            FrameStatistics.Increment(StatisticsCounterType.JoystickEvents);\n                        }\n                    }, 0, 0));\n                }\n                else\n                {\n                    scheduled?.Cancel();\n                    foreach (var device in devices)\n                    {\n                        if (device.LastState != null)\n                            handleState(device, new JoystickState());\n                    }\n\n                    devices.Clear();\n                }\n            };\n\n            Enabled.TriggerChange();\n\n            return true;\n        }\n\n        private void handleState(JoystickDevice device, JoystickState newState)\n        {\n            PendingInputs.Enqueue(new JoystickButtonInput(newState.Buttons, device.LastState?.Buttons));\n\n            device.LastState = newState;\n        }\n\n        private void refreshDevices()\n        {\n            var newDevices = new List<JoystickDevice>();\n\n            \/\/ Update devices and add them to newDevices if still connected\n            foreach (var dev in devices)\n            {\n                dev.Refresh();\n\n                if (dev.RawState.IsConnected)\n                {\n                    newDevices.Add(dev);\n                }\n                else\n                {\n                    mostSeenDevices--;\n                    if (dev.LastState != null)\n                        handleState(dev, new JoystickState());\n                }\n            }\n\n            \/\/ Find any newly-connected devices\n            while (true)\n            {\n                var newDevice = new JoystickDevice(mostSeenDevices);\n                if (!newDevice.Capabilities.IsConnected)\n                    break;\n\n                Logger.Log($\"Connected joystick device: {newDevice.Guid}\");\n\n                newDevices.Add(newDevice);\n                mostSeenDevices++;\n            }\n\n            devices = newDevices;\n        }\n\n        public override bool IsActive => true;\n        public override int Priority => 0;\n\n        private class OpenTKJoystickState : JoystickState\n        {\n            public OpenTKJoystickState(JoystickDevice device)\n            {\n                \/\/ Populate axes\n                var axes = new List<JoystickAxis>();\n                for (int i = 0; i < JoystickDevice.MAX_AXES; i++)\n                {\n                    var value = device.RawState.GetAxis(i);\n                    if (!Precision.AlmostEquals(value, 0, device.DefaultDeadzones?[i] ?? Precision.FLOAT_EPSILON))\n                        axes.Add(new JoystickAxis(i, value));\n                }\n\n                Axes = axes;\n\n                \/\/ Populate normal buttons\n                for (int i = 0; i < JoystickDevice.MAX_BUTTONS; i++)\n                {\n                    if (device.RawState.GetButton(i) == ButtonState.Pressed)\n                        Buttons.SetPressed(JoystickButton.FirstButton + i, true);\n                }\n\n                \/\/ Populate hat buttons\n                for (int i = 0; i < JoystickDevice.MAX_HATS; i++)\n                {\n                    foreach (var hatButton in getHatButtons(device, i))\n                        Buttons.SetPressed(hatButton, true);\n                }\n\n                \/\/ Populate axis buttons (each axis has two buttons)\n                foreach (var axis in Axes)\n                    Buttons.SetPressed((axis.Value < 0 ? JoystickButton.FirstAxisNegative : JoystickButton.FirstAxisPositive) + axis.Axis, true);\n            }\n\n            private IEnumerable<JoystickButton> getHatButtons(JoystickDevice device, int hat)\n            {\n                var state = device.RawState.GetHat(JoystickHat.Hat0 + hat);\n\n                if (state.IsUp)\n                    yield return JoystickButton.FirstHatUp + hat;\n                else if (state.IsDown)\n                    yield return JoystickButton.FirstHatDown + hat;\n\n                if (state.IsLeft)\n                    yield return JoystickButton.FirstHatLeft + hat;\n                else if (state.IsRight)\n                    yield return JoystickButton.FirstHatRight + hat;\n            }\n        }\n\n        private class JoystickDevice\n        {\n            \/\/\/ <summary>\n            \/\/\/ Amount of axes supported by OpenTK.\n            \/\/\/ <\/summary>\n            public const int MAX_AXES = 64;\n\n            \/\/\/ <summary>\n            \/\/\/ Amount of buttons supported by OpenTK.\n            \/\/\/ <\/summary>\n            public const int MAX_BUTTONS = 64;\n\n            \/\/\/ <summary>\n            \/\/\/ Amount of hats supported by OpenTK.\n            \/\/\/ <\/summary>\n            public const int MAX_HATS = 4;\n\n            \/\/\/ <summary>\n            \/\/\/ Amount of movement around the \"centre\" of the axis that counts as moving within the deadzone.\n            \/\/\/ <\/summary>\n            private const float deadzone_threshold = 0.05f;\n\n            \/\/\/ <summary>\n            \/\/\/ The last state of this <see cref=\"JoystickDevice\"\/>.\n            \/\/\/ This is updated with ever invocation of <see cref=\"Refresh\"\/>.\n            \/\/\/ <\/summary>\n            public OpenTK.Input.JoystickState? LastRawState { get; private set; }\n\n            public JoystickState LastState { get; set; }\n\n            \/\/\/ <summary>\n            \/\/\/ The current state of this <see cref=\"JoystickDevice\"\/>.\n            \/\/\/ Use <see cref=\"Refresh\"\/> to update the state.\n            \/\/\/ <\/summary>\n            public OpenTK.Input.JoystickState RawState { get; private set; }\n\n            private readonly Lazy<float[]> defaultDeadZones = new Lazy<float[]>(() => new float[MAX_AXES]);\n\n            \/\/\/ <summary>\n            \/\/\/ Default deadzones for each axis. Can be null if deadzones have not been found.\n            \/\/\/ <\/summary>\n            public float[] DefaultDeadzones => defaultDeadZones.IsValueCreated ? defaultDeadZones.Value : null;\n\n            \/\/\/ <summary>\n            \/\/\/ The capabilities for this joystick device.\n            \/\/\/ This is only queried once when <see cref=\"JoystickDevice\"\/> is constructed.\n            \/\/\/ <\/summary>\n            public readonly JoystickCapabilities Capabilities;\n\n            \/\/\/ <summary>\n            \/\/\/ The <see cref=\"Guid\"\/> for this <see cref=\"JoystickDevice\"\/>.\n            \/\/\/ <\/summary>\n            public readonly Guid Guid;\n\n            private readonly int deviceIndex;\n\n            public JoystickDevice(int deviceIndex)\n            {\n                this.deviceIndex = deviceIndex;\n\n                Capabilities = OpenTK.Input.Joystick.GetCapabilities(deviceIndex);\n                Guid = OpenTK.Input.Joystick.GetGuid(deviceIndex);\n\n                Refresh();\n            }\n\n            \/\/\/ <summary>\n            \/\/\/ Refreshes the state of this <see cref=\"JoystickDevice\"\/>.\n            \/\/\/ <\/summary>\n            public void Refresh()\n            {\n                LastRawState = RawState;\n                RawState = OpenTK.Input.Joystick.GetState(deviceIndex);\n\n                if (!defaultDeadZones.IsValueCreated)\n                {\n                    for (int i = 0; i < MAX_AXES; i++)\n                    {\n                        var axisValue = Math.Abs(RawState.GetAxis(i));\n                        if (Precision.AlmostEquals(0, axisValue))\n                            continue;\n\n                        defaultDeadZones.Value[i] = axisValue + deadzone_threshold;\n                    }\n                }\n            }\n        }\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"9a0a1ba0df10b87baa552e9d5869892d4cbfe3d9","subject":"correct logic of hasKeyTexture determination","message":"correct logic of hasKeyTexture determination\n","repos":"UselessToucan\/osu,smoogipoo\/osu,UselessToucan\/osu,peppy\/osu,ppy\/osu,UselessToucan\/osu,NeoAdonis\/osu,peppy\/osu-new,smoogipoo\/osu,ppy\/osu,peppy\/osu,ppy\/osu,smoogipooo\/osu,NeoAdonis\/osu,NeoAdonis\/osu,peppy\/osu,smoogipoo\/osu","old_file":"osu.Game.Rulesets.Mania\/Skinning\/ManiaLegacySkinTransformer.cs","new_file":"osu.Game.Rulesets.Mania\/Skinning\/ManiaLegacySkinTransformer.cs","new_contents":"\/\/ Copyright (c) ppy Pty Ltd <contact@ppy.sh>. Licensed under the MIT Licence.\n\/\/ See the LICENCE file in the repository root for full licence text.\n\nusing System;\nusing osu.Framework.Graphics;\nusing osu.Framework.Graphics.Textures;\nusing osu.Framework.Audio.Sample;\nusing osu.Framework.Bindables;\nusing osu.Game.Rulesets.Scoring;\nusing osu.Game.Audio;\nusing osu.Game.Beatmaps;\nusing osu.Game.Rulesets.Mania.Beatmaps;\nusing osu.Game.Skinning;\nusing System.Collections.Generic;\n\nnamespace osu.Game.Rulesets.Mania.Skinning\n{\n    public class ManiaLegacySkinTransformer : ISkin\n    {\n        private readonly ISkin source;\n        private readonly ManiaBeatmap beatmap;\n\n        \/\/\/ <summary>\n        \/\/\/ Mapping of <see cref=\"HitResult\"\/> to their corresponding\n        \/\/\/ <see cref=\"LegacyManiaSkinConfigurationLookups\"\/> value.\n        \/\/\/ <\/summary>\n        private static readonly IReadOnlyDictionary<HitResult, LegacyManiaSkinConfigurationLookups> hitresult_mapping\n            = new Dictionary<HitResult, LegacyManiaSkinConfigurationLookups>\n            {\n                { HitResult.Perfect, LegacyManiaSkinConfigurationLookups.Hit300g },\n                { HitResult.Great, LegacyManiaSkinConfigurationLookups.Hit300 },\n                { HitResult.Good, LegacyManiaSkinConfigurationLookups.Hit200 },\n                { HitResult.Ok, LegacyManiaSkinConfigurationLookups.Hit100 },\n                { HitResult.Meh, LegacyManiaSkinConfigurationLookups.Hit50 },\n                { HitResult.Miss, LegacyManiaSkinConfigurationLookups.Hit0 }\n            };\n\n        \/\/\/ <summary>\n        \/\/\/ Mapping of <see cref=\"HitResult\"\/> to their corresponding\n        \/\/\/ default filenames.\n        \/\/\/ <\/summary>\n        private static readonly IReadOnlyDictionary<HitResult, string> default_hitresult_skin_filenames\n            = new Dictionary<HitResult, string>\n            {\n                { HitResult.Perfect, \"mania-hit300g\" },\n                { HitResult.Great, \"mania-hit300\" },\n                { HitResult.Good, \"mania-hit200\" },\n                { HitResult.Ok, \"mania-hit100\" },\n                { HitResult.Meh, \"mania-hit50\" },\n                { HitResult.Miss, \"mania-hit0\" }\n            };\n\n        private Lazy<bool> isLegacySkin;\n\n        \/\/\/ <summary>\n        \/\/\/ Whether texture for the keys exists.\n        \/\/\/ Used to determine if the mania ruleset is skinned.\n        \/\/\/ <\/summary>\n        private Lazy<bool> hasKeyTexture;\n\n        public ManiaLegacySkinTransformer(ISkinSource source, IBeatmap beatmap)\n        {\n            this.source = source;\n            this.beatmap = (ManiaBeatmap)beatmap;\n\n            source.SourceChanged += sourceChanged;\n            sourceChanged();\n        }\n\n        private void sourceChanged()\n        {\n            isLegacySkin = new Lazy<bool>(() => source.GetConfig<LegacySkinConfiguration.LegacySetting, decimal>(LegacySkinConfiguration.LegacySetting.Version) != null);\n            hasKeyTexture = new Lazy<bool>(() => source.GetAnimation(\n                this.GetManiaSkinConfig<string>(LegacyManiaSkinConfigurationLookups.KeyImage, 0)?.Value\n                ?? \"mania-key1\", true, true) != null);\n        }\n\n        public Drawable GetDrawableComponent(ISkinComponent component)\n        {\n            switch (component)\n            {\n                case GameplaySkinComponent<HitResult> resultComponent:\n                    return getResult(resultComponent.Component);\n\n                case ManiaSkinComponent maniaComponent:\n                    if (!isLegacySkin.Value || !hasKeyTexture.Value)\n                        return null;\n\n                    switch (maniaComponent.Component)\n                    {\n                        case ManiaSkinComponents.ColumnBackground:\n                            return new LegacyColumnBackground(maniaComponent.TargetColumn == beatmap.TotalColumns - 1);\n\n                        case ManiaSkinComponents.HitTarget:\n                            return new LegacyHitTarget();\n\n                        case ManiaSkinComponents.KeyArea:\n                            return new LegacyKeyArea();\n\n                        case ManiaSkinComponents.Note:\n                            return new LegacyNotePiece();\n\n                        case ManiaSkinComponents.HoldNoteHead:\n                            return new LegacyHoldNoteHeadPiece();\n\n                        case ManiaSkinComponents.HoldNoteTail:\n                            return new LegacyHoldNoteTailPiece();\n\n                        case ManiaSkinComponents.HoldNoteBody:\n                            return new LegacyBodyPiece();\n\n                        case ManiaSkinComponents.HitExplosion:\n                            return new LegacyHitExplosion();\n\n                        case ManiaSkinComponents.StageBackground:\n                            return new LegacyStageBackground();\n\n                        case ManiaSkinComponents.StageForeground:\n                            return new LegacyStageForeground();\n                    }\n\n                    break;\n            }\n\n            return null;\n        }\n\n        private Drawable getResult(HitResult result)\n        {\n            string filename = this.GetManiaSkinConfig<string>(hitresult_mapping[result])?.Value\n                ?? default_hitresult_skin_filenames[result];\n\n            return this.GetAnimation(filename, true, true);\n        }\n\n        public Texture GetTexture(string componentName) => source.GetTexture(componentName);\n\n        public SampleChannel GetSample(ISampleInfo sample) => source.GetSample(sample);\n\n        public IBindable<TValue> GetConfig<TLookup, TValue>(TLookup lookup)\n        {\n            if (lookup is ManiaSkinConfigurationLookup maniaLookup)\n                return source.GetConfig<LegacyManiaSkinConfigurationLookup, TValue>(new LegacyManiaSkinConfigurationLookup(beatmap.TotalColumns, maniaLookup.Lookup, maniaLookup.TargetColumn));\n\n            return source.GetConfig<TLookup, TValue>(lookup);\n        }\n    }\n}\n","old_contents":"\/\/ Copyright (c) ppy Pty Ltd <contact@ppy.sh>. Licensed under the MIT Licence.\n\/\/ See the LICENCE file in the repository root for full licence text.\n\nusing System;\nusing osu.Framework.Graphics;\nusing osu.Framework.Graphics.Textures;\nusing osu.Framework.Audio.Sample;\nusing osu.Framework.Bindables;\nusing osu.Game.Rulesets.Scoring;\nusing osu.Game.Audio;\nusing osu.Game.Beatmaps;\nusing osu.Game.Rulesets.Mania.Beatmaps;\nusing osu.Game.Skinning;\nusing System.Collections.Generic;\n\nnamespace osu.Game.Rulesets.Mania.Skinning\n{\n    public class ManiaLegacySkinTransformer : ISkin\n    {\n        private readonly ISkin source;\n        private readonly ManiaBeatmap beatmap;\n\n        \/\/\/ <summary>\n        \/\/\/ Mapping of <see cref=\"HitResult\"\/> to their corresponding\n        \/\/\/ <see cref=\"LegacyManiaSkinConfigurationLookups\"\/> value.\n        \/\/\/ <\/summary>\n        private static readonly IReadOnlyDictionary<HitResult, LegacyManiaSkinConfigurationLookups> hitresult_mapping\n            = new Dictionary<HitResult, LegacyManiaSkinConfigurationLookups>\n            {\n                { HitResult.Perfect, LegacyManiaSkinConfigurationLookups.Hit300g },\n                { HitResult.Great, LegacyManiaSkinConfigurationLookups.Hit300 },\n                { HitResult.Good, LegacyManiaSkinConfigurationLookups.Hit200 },\n                { HitResult.Ok, LegacyManiaSkinConfigurationLookups.Hit100 },\n                { HitResult.Meh, LegacyManiaSkinConfigurationLookups.Hit50 },\n                { HitResult.Miss, LegacyManiaSkinConfigurationLookups.Hit0 }\n            };\n\n        \/\/\/ <summary>\n        \/\/\/ Mapping of <see cref=\"HitResult\"\/> to their corresponding\n        \/\/\/ default filenames.\n        \/\/\/ <\/summary>\n        private static readonly IReadOnlyDictionary<HitResult, string> default_hitresult_skin_filenames\n            = new Dictionary<HitResult, string>\n            {\n                { HitResult.Perfect, \"mania-hit300g\" },\n                { HitResult.Great, \"mania-hit300\" },\n                { HitResult.Good, \"mania-hit200\" },\n                { HitResult.Ok, \"mania-hit100\" },\n                { HitResult.Meh, \"mania-hit50\" },\n                { HitResult.Miss, \"mania-hit0\" }\n            };\n\n        private Lazy<bool> isLegacySkin;\n\n        \/\/\/ <summary>\n        \/\/\/ Whether texture for the keys exists.\n        \/\/\/ Used to determine if the mania ruleset is skinned.\n        \/\/\/ <\/summary>\n        private Lazy<bool> hasKeyTexture;\n\n        public ManiaLegacySkinTransformer(ISkinSource source, IBeatmap beatmap)\n        {\n            this.source = source;\n            this.beatmap = (ManiaBeatmap)beatmap;\n\n            source.SourceChanged += sourceChanged;\n            sourceChanged();\n        }\n\n        private void sourceChanged()\n        {\n            isLegacySkin = new Lazy<bool>(() => source.GetConfig<LegacySkinConfiguration.LegacySetting, decimal>(LegacySkinConfiguration.LegacySetting.Version) != null);\n            hasKeyTexture = new Lazy<bool>(() => source.GetAnimation(\n                this.GetManiaSkinConfig<string>(LegacyManiaSkinConfigurationLookups.KeyImage)?.Value\n                ?? \"mania-key1\", true, true) != null);\n        }\n\n        public Drawable GetDrawableComponent(ISkinComponent component)\n        {\n            switch (component)\n            {\n                case GameplaySkinComponent<HitResult> resultComponent:\n                    return getResult(resultComponent.Component);\n\n                case ManiaSkinComponent maniaComponent:\n                    if (!isLegacySkin.Value || !hasKeyTexture.Value)\n                        return null;\n\n                    switch (maniaComponent.Component)\n                    {\n                        case ManiaSkinComponents.ColumnBackground:\n                            return new LegacyColumnBackground(maniaComponent.TargetColumn == beatmap.TotalColumns - 1);\n\n                        case ManiaSkinComponents.HitTarget:\n                            return new LegacyHitTarget();\n\n                        case ManiaSkinComponents.KeyArea:\n                            return new LegacyKeyArea();\n\n                        case ManiaSkinComponents.Note:\n                            return new LegacyNotePiece();\n\n                        case ManiaSkinComponents.HoldNoteHead:\n                            return new LegacyHoldNoteHeadPiece();\n\n                        case ManiaSkinComponents.HoldNoteTail:\n                            return new LegacyHoldNoteTailPiece();\n\n                        case ManiaSkinComponents.HoldNoteBody:\n                            return new LegacyBodyPiece();\n\n                        case ManiaSkinComponents.HitExplosion:\n                            return new LegacyHitExplosion();\n\n                        case ManiaSkinComponents.StageBackground:\n                            return new LegacyStageBackground();\n\n                        case ManiaSkinComponents.StageForeground:\n                            return new LegacyStageForeground();\n                    }\n\n                    break;\n            }\n\n            return null;\n        }\n\n        private Drawable getResult(HitResult result)\n        {\n            string filename = this.GetManiaSkinConfig<string>(hitresult_mapping[result])?.Value\n                ?? default_hitresult_skin_filenames[result];\n\n            return this.GetAnimation(filename, true, true);\n        }\n\n        public Texture GetTexture(string componentName) => source.GetTexture(componentName);\n\n        public SampleChannel GetSample(ISampleInfo sample) => source.GetSample(sample);\n\n        public IBindable<TValue> GetConfig<TLookup, TValue>(TLookup lookup)\n        {\n            if (lookup is ManiaSkinConfigurationLookup maniaLookup)\n                return source.GetConfig<LegacyManiaSkinConfigurationLookup, TValue>(new LegacyManiaSkinConfigurationLookup(beatmap.TotalColumns, maniaLookup.Lookup, maniaLookup.TargetColumn));\n\n            return source.GetConfig<TLookup, TValue>(lookup);\n        }\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"e7c563fb671f8c2eee44de363e6c04971dad6cd3","subject":"simplify `CreateTextFlow` in quote block","message":"simplify `CreateTextFlow` in quote block\n","repos":"NeoAdonis\/osu,UselessToucan\/osu,smoogipooo\/osu,NeoAdonis\/osu,ppy\/osu,peppy\/osu,UselessToucan\/osu,peppy\/osu-new,smoogipoo\/osu,ppy\/osu,NeoAdonis\/osu,peppy\/osu,ppy\/osu,smoogipoo\/osu,peppy\/osu,UselessToucan\/osu,smoogipoo\/osu","old_file":"osu.Game\/Graphics\/Containers\/Markdown\/OsuMarkdownQuoteBlock.cs","new_file":"osu.Game\/Graphics\/Containers\/Markdown\/OsuMarkdownQuoteBlock.cs","new_contents":"\/\/ Copyright (c) ppy Pty Ltd <contact@ppy.sh>. Licensed under the MIT Licence.\n\/\/ See the LICENCE file in the repository root for full licence text.\n\nusing Markdig.Syntax;\nusing osu.Framework.Allocation;\nusing osu.Framework.Graphics;\nusing osu.Framework.Graphics.Containers.Markdown;\nusing osu.Game.Overlays;\n\nnamespace osu.Game.Graphics.Containers.Markdown\n{\n    public class OsuMarkdownQuoteBlock : MarkdownQuoteBlock\n    {\n        private Drawable background;\n\n        public OsuMarkdownQuoteBlock(QuoteBlock quoteBlock)\n            : base(quoteBlock)\n        {\n        }\n\n        [BackgroundDependencyLoader]\n        private void load(OverlayColourProvider colourProvider)\n        {\n            background.Colour = colourProvider.Content2;\n        }\n\n        protected override Drawable CreateBackground()\n        {\n            background = base.CreateBackground();\n            background.Width = 2;\n            return background;\n        }\n\n        public override MarkdownTextFlowContainer CreateTextFlow()\n        {\n            return base.CreateTextFlow().With(f => f.Margin = new MarginPadding\n            {\n                Vertical = 10,\n                Horizontal = 20,\n            });\n        }\n    }\n}\n","old_contents":"\/\/ Copyright (c) ppy Pty Ltd <contact@ppy.sh>. Licensed under the MIT Licence.\n\/\/ See the LICENCE file in the repository root for full licence text.\n\nusing Markdig.Syntax;\nusing osu.Framework.Allocation;\nusing osu.Framework.Graphics;\nusing osu.Framework.Graphics.Containers.Markdown;\nusing osu.Game.Overlays;\n\nnamespace osu.Game.Graphics.Containers.Markdown\n{\n    public class OsuMarkdownQuoteBlock : MarkdownQuoteBlock\n    {\n        private Drawable background;\n\n        public OsuMarkdownQuoteBlock(QuoteBlock quoteBlock)\n            : base(quoteBlock)\n        {\n        }\n\n        [BackgroundDependencyLoader]\n        private void load(OverlayColourProvider colourProvider)\n        {\n            background.Colour = colourProvider.Content2;\n        }\n\n        protected override Drawable CreateBackground()\n        {\n            background = base.CreateBackground();\n            background.Width = 2;\n            return background;\n        }\n\n        public override MarkdownTextFlowContainer CreateTextFlow()\n        {\n            var textFlow = base.CreateTextFlow();\n            textFlow.Margin = new MarginPadding\n            {\n                Vertical = 10,\n                Horizontal = 20,\n            };\n            return textFlow;\n        }\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"c2eb2da2caec1c0f7d4e19c0cff1e95b71c27ac7","subject":"Reset cookies on initial request.","message":"Reset cookies on initial request.\n","repos":"FastSpring\/FsprgEmbeddedStoreWin","old_file":"FsprgEmbeddedStore\/Controller.cs","new_file":"FsprgEmbeddedStore\/Controller.cs","new_contents":"\ufeffusing System;\r\nusing System.ComponentModel;\r\nusing System.IO;\r\nusing System.Runtime.InteropServices;\r\nusing System.Windows.Controls;\r\nusing System.Windows.Navigation;\r\nusing FsprgEmbeddedStore.Model;\r\nusing MSHTML;\r\nusing System.Windows;\r\n\r\nnamespace FsprgEmbeddedStore\r\n{\r\n    public class Controller : INotifyPropertyChanged\r\n    {\r\n        private bool _isInitialLoad;\r\n\r\n        private WebBrowser _webView;\r\n        \/\/\/ <summary>\r\n        \/\/\/ Attach <see cref=\"WebBrowser\"\/> instance to this controller.\r\n        \/\/\/ <\/summary>\r\n        public WebBrowser WebView { \r\n            set {\r\n                if (_webView != null)\r\n                {\r\n                    _webView.LoadCompleted -= LoadCompleted;\r\n                }\r\n                _webView = value;\r\n                _webView.Navigating += Navigating;\r\n                _webView.LoadCompleted += LoadCompleted;\r\n                _webView.SizeChanged += WebBrowserSizeChanged;\r\n            }\r\n            get { return _webView; }\r\n        }\r\n        \/\/\/ <summary>\r\n        \/\/\/ Occurs when the store has been loaded for the first time.\r\n        \/\/\/ <\/summary>\r\n        public event EventHandler DidLoadStore;\r\n        \/\/\/ <summary>\r\n        \/\/\/ Occurs when the order has been received.\r\n        \/\/\/ <\/summary>\r\n        public event DidReceiveOrderEventHandler DidReceiveOrder;\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Loads the store.\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <param name=\"parameters\">Parameters to load the store with.<\/param>\r\n        public void LoadWithParameters(StoreParameters parameters) {\r\n            _isInitialLoad = true;\r\n            IsLoading = true;\r\n\r\n            ChangeUserAgent(\"FSEmbeddedStore\/1.0\");\r\n            ResetCookies();\r\n\r\n            WebView.Navigate(parameters.ToURL);\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Loads content from a file with an .xml suffix and shows the order confirmation.\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <param name=\"path\">Path to the file.<\/param>\r\n        public void LoadWithContentsOfFile(string path) {\r\n            _isInitialLoad = true;\r\n            IsLoading = true;\r\n\r\n            StreamReader reader = new StreamReader(path);\r\n            string plistXml = reader.ReadToEnd();\r\n            reader.Close();\r\n\r\n            Uri url = new Uri(\"file:\/\/\" + path);\r\n            WebView.Navigate(url);\r\n        }\r\n\r\n        private bool _isLoading;\r\n        \/\/\/ <summary>\r\n        \/\/\/ <code>true<\/code> if store is loading. Useful to show a progress indicator.\r\n        \/\/\/ <\/summary>\r\n        public bool IsLoading { \r\n            get { return _isLoading; }\r\n            internal set {\r\n                _isLoading = value;\r\n                if (PropertyChanged != null) {\r\n                    PropertyChanged(this, new PropertyChangedEventArgs(\"IsLoading\"));\r\n                }\r\n            }\r\n        }\r\n        \/\/\/ <summary>\r\n        \/\/\/ <code>true<\/code> if communication is secure.\r\n        \/\/\/ <\/summary>\r\n        public bool IsSecure {\r\n            get {\r\n                return \"Https\".Equals(_webView.Source.Scheme);\r\n            }\r\n        }\r\n\r\n        public event PropertyChangedEventHandler PropertyChanged;\r\n        protected void IsSecureChanged()\r\n        {\r\n            if (PropertyChanged != null) {\r\n                PropertyChanged(this, new PropertyChangedEventArgs(\"IsSecure\"));\r\n            }\r\n        }\r\n        \r\n        private void WebBrowserSizeChanged(object sender, SizeChangedEventArgs args) {\r\n            AdjustResizableContent((int)Math.Round(args.NewSize.Height));\r\n        }\r\n\r\n        private void Navigating(object sender, NavigatingCancelEventArgs args)\r\n        {\r\n            IsLoading = true;\r\n        }\r\n\r\n        private void LoadCompleted(object sender, NavigationEventArgs args)\r\n        {\r\n            IsLoading = false;\r\n            IsSecureChanged();\r\n\r\n            if (_isInitialLoad) {\r\n                _isInitialLoad = false;\r\n                DidLoadStore(this, EventArgs.Empty);\r\n            }\r\n\r\n            try\r\n            {\r\n                AdjustResizableContent((int)Math.Round(_webView.ActualHeight));\r\n\r\n                var aMimetype = ((HTMLDocument)_webView.Document).mimeType;\r\n                if (aMimetype.ToLower().IndexOf(\"xml\") > -1)\r\n                {\r\n                    string data = ((HTMLDocument)_webView.Document).documentElement.innerText;\r\n\r\n                    data = data.Replace(\"<!DOCTYPE plist (View Source for full doctype...)>\", \"\");\r\n                    data = data.Replace(\"\\r\\n-\", \"\");\r\n                    data = data.Substring(data.IndexOf(\"<?xml version=\"));\r\n\r\n                    Order order = Order.Parse(data);\r\n                    DidReceiveOrder(this, new DidReceiveOrderEventArgs(order));\r\n                }\r\n            }\r\n            catch (Exception e)\r\n            {\r\n                var errorWriter = new StreamWriter(\"c:\/temp\/error.txt\");\r\n                errorWriter.WriteLine(e.Message);\r\n                errorWriter.Write(e.StackTrace);\r\n                errorWriter.Close();\r\n            }\r\n        }\r\n\r\n        [DllImport(\"urlmon.dll\", CharSet = CharSet.Ansi)]\r\n        private static extern int UrlMkSetSessionOption(int dwOption, string pBuffer, int dwBufferLength, int dwReserved);\r\n        const int URLMON_OPTION_USERAGENT = 0x10000001;\r\n        private void ChangeUserAgent(string Agent)\r\n        {\r\n            UrlMkSetSessionOption(URLMON_OPTION_USERAGENT, Agent, Agent.Length, 0);\r\n        }\r\n\r\n        private void ResetCookies() {\r\n            HTMLDocument document = (HTMLDocument)WebView.Document;\r\n            if (document == null) {\r\n                return;\r\n            }\r\n            if (document.cookie == null) {\r\n                return;\r\n            }\r\n\r\n            string[] cookies = document.cookie.Split(new string[] { \"; \" }, StringSplitOptions.None);\r\n            foreach (string cookie in cookies) {\r\n                string domain = document.location.host;\r\n\r\n                while (domain.Length > 0) {\r\n                    string path = document.location.pathname;\r\n                    while (path.Length > 0) {\r\n                        document.cookie = string.Format(\"{0}; domain={1}; path={2}; expires=Thu, 2 Aug 2001 20:47:11 UTC\", cookie, domain, path);\r\n\r\n                        int slashIdx = path.LastIndexOf('\/');\r\n                        path = slashIdx == -1 ? \"\" : path.Substring(0, slashIdx);\r\n                    }\r\n\r\n                    int dothIdx = domain.IndexOf('.');\r\n                    domain = dothIdx == -1 ? \"\" : domain.Substring(dothIdx + 1);\r\n                }\r\n            }\r\n        }\r\n\r\n        private void AdjustResizableContent(int browserWindowHeightPx) {\r\n            if (_webView.Document == null) {\r\n                return;\r\n            }\r\n\r\n            IHTMLElement resizableContentE = ((HTMLDocument)_webView.Document).getElementById(\"FsprgResizableContent\");\r\n            if (resizableContentE == null) {\r\n                return;\r\n            }\r\n\r\n            IHTMLElement storePageNavigationE = null;\r\n            IHTMLElementCollection divEs = ((HTMLDocument)_webView.Document).getElementsByTagName(\"div\");\r\n            foreach (IHTMLElement divE in divEs) {\r\n                if (\"store-page-navigation\".Equals(divE.className)) {\r\n                    storePageNavigationE = divE;\r\n                    break;\r\n                }\r\n            }\r\n            if (storePageNavigationE == null) {\r\n                return;\r\n            }\r\n\r\n            dynamic resizableContentEStyle = resizableContentE.getAttribute(\"currentStyle\"); \/\/ see http:\/\/blog.stchur.com\/2006\/06\/21\/css-computed-style\/\r\n            string paddingTopStr = resizableContentEStyle.paddingTop;\r\n            int paddingTopPx = int.Parse(paddingTopStr.TrimEnd(new char[] { 'p', 'x' }));\r\n            string paddingBottomStr = resizableContentEStyle.paddingBottom;\r\n            int paddingBottomPx = int.Parse(paddingBottomStr.TrimEnd(new char[] { 'p', 'x' }));\r\n\r\n            int storePageNavigationHeightPx = storePageNavigationE.getAttribute(\"clientHeight\");\r\n\r\n            int newHeight = browserWindowHeightPx - paddingTopPx - paddingBottomPx - storePageNavigationHeightPx;\r\n            if (newHeight < 0) {\r\n                newHeight = 0;\r\n            }\r\n            resizableContentE.style.height = newHeight + \"px\";\r\n        }\r\n    }\r\n\r\n    public delegate void DidReceiveOrderEventHandler(object sender, DidReceiveOrderEventArgs e);\r\n    public class DidReceiveOrderEventArgs : EventArgs\r\n    {\r\n        public DidReceiveOrderEventArgs(Order order)\r\n        {\r\n            Order = order;\r\n        }\r\n        public Order Order { get; internal set; }\r\n    }\r\n\r\n}\r\n","old_contents":"\ufeffusing System;\r\nusing System.ComponentModel;\r\nusing System.IO;\r\nusing System.Runtime.InteropServices;\r\nusing System.Windows.Controls;\r\nusing System.Windows.Navigation;\r\nusing FsprgEmbeddedStore.Model;\r\nusing MSHTML;\r\nusing System.Windows;\r\nusing System.Windows.Media;\r\n\r\nnamespace FsprgEmbeddedStore\r\n{\r\n    public class Controller : INotifyPropertyChanged\r\n    {\r\n        private bool _isInitialLoad;\r\n\r\n        private WebBrowser _webView;\r\n        \/\/\/ <summary>\r\n        \/\/\/ Attach <see cref=\"WebBrowser\"\/> instance to this controller.\r\n        \/\/\/ <\/summary>\r\n        public WebBrowser WebView { \r\n            set {\r\n                if (_webView != null)\r\n                {\r\n                    _webView.LoadCompleted -= LoadCompleted;\r\n                }\r\n                _webView = value;\r\n                _webView.Navigating += Navigating;\r\n                _webView.LoadCompleted += LoadCompleted;\r\n                _webView.SizeChanged += WebBrowserSizeChanged;\r\n            }\r\n            get { return _webView; }\r\n        }\r\n        \/\/\/ <summary>\r\n        \/\/\/ Occurs when the store has been loaded for the first time.\r\n        \/\/\/ <\/summary>\r\n        public event EventHandler DidLoadStore;\r\n        \/\/\/ <summary>\r\n        \/\/\/ Occurs when the order has been received.\r\n        \/\/\/ <\/summary>\r\n        public event DidReceiveOrderEventHandler DidReceiveOrder;\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Loads the store.\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <param name=\"parameters\">Parameters to load the store with.<\/param>\r\n        public void LoadWithParameters(StoreParameters parameters) {\r\n            _isInitialLoad = true;\r\n            IsLoading = true;\r\n            ChangeUserAgent(\"FSEmbeddedStore\/1.0\");\r\n\r\n            \/*\r\n            StringBuilder resetCookiesJs = new StringBuilder();\r\n            resetCookiesJs.Append(\"javascript:void((function(){\");\r\n            resetCookiesJs.Append(\"  alert('test');var a,b,c,e,f;\");\r\n            resetCookiesJs.Append(\"  f=0;alert(document.cookie)\");\r\n            resetCookiesJs.Append(\"  a=document.cookie.split('; ');\");\r\n            resetCookiesJs.Append(\"  for(e=0;e<a.length&&a[e];e++){\");\r\n            resetCookiesJs.Append(\"    f++;\");\r\n            resetCookiesJs.Append(\"    for(b='.'+location.host;b;b=b.replace(\/^(?:%5C.|[^%5C.]+)\/,'')){\");\r\n            resetCookiesJs.Append(\"      for(c=location.pathname;c;c=c.replace(\/.$\/,'')){\");\r\n            resetCookiesJs.Append(\"        document.cookie=(a[e]+'; domain='+b+'; path='+c+'; expires='+new Date((new Date()).getTime()-1e11).toGMTString());\");\r\n            resetCookiesJs.Append(\"      }\");\r\n            resetCookiesJs.Append(\"    }\");\r\n            resetCookiesJs.Append(\"  }\");\r\n            resetCookiesJs.Append(\"})())\");\r\n            WebView.Navigate(resetCookiesJs.ToString());\r\n            *\/\r\n\r\n            WebView.Navigate(parameters.ToURL);\r\n        }\r\n\r\n        \/\/\/ <summary>\r\n        \/\/\/ Loads content from a file with an .xml suffix and shows the order confirmation.\r\n        \/\/\/ <\/summary>\r\n        \/\/\/ <param name=\"path\">Path to the file.<\/param>\r\n        public void LoadWithContentsOfFile(string path) {\r\n            _isInitialLoad = true;\r\n            IsLoading = true;\r\n\r\n            StreamReader reader = new StreamReader(path);\r\n            string plistXml = reader.ReadToEnd();\r\n            reader.Close();\r\n\r\n            Uri url = new Uri(\"file:\/\/\" + path);\r\n            WebView.Navigate(url);\r\n        }\r\n\r\n        private bool _isLoading;\r\n        \/\/\/ <summary>\r\n        \/\/\/ <code>true<\/code> if store is loading. Useful to show a progress indicator.\r\n        \/\/\/ <\/summary>\r\n        public bool IsLoading { \r\n            get { return _isLoading; }\r\n            internal set {\r\n                _isLoading = value;\r\n                if (PropertyChanged != null) {\r\n                    PropertyChanged(this, new PropertyChangedEventArgs(\"IsLoading\"));\r\n                }\r\n            }\r\n        }\r\n        \/\/\/ <summary>\r\n        \/\/\/ <code>true<\/code> if communication is secure.\r\n        \/\/\/ <\/summary>\r\n        public bool IsSecure {\r\n            get {\r\n                return \"Https\".Equals(_webView.Source.Scheme);\r\n            }\r\n        }\r\n\r\n        public event PropertyChangedEventHandler PropertyChanged;\r\n        protected void IsSecureChanged()\r\n        {\r\n            if (PropertyChanged != null) {\r\n                PropertyChanged(this, new PropertyChangedEventArgs(\"IsSecure\"));\r\n            }\r\n        }\r\n        \r\n        private void WebBrowserSizeChanged(object sender, SizeChangedEventArgs args) {\r\n            AdjustResizableContent((int)Math.Round(args.NewSize.Height));\r\n        }\r\n\r\n        private void Navigating(object sender, NavigatingCancelEventArgs args)\r\n        {\r\n            IsLoading = true;\r\n        }\r\n\r\n        private void LoadCompleted(object sender, NavigationEventArgs args)\r\n        {\r\n            IsLoading = false;\r\n            IsSecureChanged();\r\n\r\n            if (_isInitialLoad) {\r\n                _isInitialLoad = false;\r\n                DidLoadStore(this, EventArgs.Empty);\r\n            }\r\n\r\n            try\r\n            {\r\n                AdjustResizableContent((int)Math.Round(_webView.ActualHeight));\r\n\r\n                var aMimetype = ((HTMLDocument)_webView.Document).mimeType;\r\n                if (aMimetype.ToLower().IndexOf(\"xml\") > -1)\r\n                {\r\n                    string data = ((HTMLDocument)_webView.Document).documentElement.innerText;\r\n\r\n                    data = data.Replace(\"<!DOCTYPE plist (View Source for full doctype...)>\", \"\");\r\n                    data = data.Replace(\"\\r\\n-\", \"\");\r\n                    data = data.Substring(data.IndexOf(\"<?xml version=\"));\r\n\r\n                    Order order = Order.Parse(data);\r\n                    DidReceiveOrder(this, new DidReceiveOrderEventArgs(order));\r\n                }\r\n            }\r\n            catch (Exception e)\r\n            {\r\n                var errorWriter = new StreamWriter(\"c:\/temp\/error.txt\");\r\n                errorWriter.WriteLine(e.Message);\r\n                errorWriter.Write(e.StackTrace);\r\n                errorWriter.Close();\r\n            }\r\n        }\r\n\r\n        [DllImport(\"urlmon.dll\", CharSet = CharSet.Ansi)]\r\n        private static extern int UrlMkSetSessionOption(int dwOption, string pBuffer, int dwBufferLength, int dwReserved);\r\n        const int URLMON_OPTION_USERAGENT = 0x10000001;\r\n        private void ChangeUserAgent(string Agent)\r\n        {\r\n            UrlMkSetSessionOption(URLMON_OPTION_USERAGENT, Agent, Agent.Length, 0);\r\n        }\r\n\r\n        private void AdjustResizableContent(int browserWindowHeightPx) {\r\n            if (_webView.Document == null) {\r\n                return;\r\n            }\r\n\r\n            IHTMLElement resizableContentE = ((HTMLDocument)_webView.Document).getElementById(\"FsprgResizableContent\");\r\n            if (resizableContentE == null) {\r\n                return;\r\n            }\r\n\r\n            IHTMLElement storePageNavigationE = null;\r\n            IHTMLElementCollection divEs = ((HTMLDocument)_webView.Document).getElementsByTagName(\"div\");\r\n            foreach (IHTMLElement divE in divEs) {\r\n                if (\"store-page-navigation\".Equals(divE.className)) {\r\n                    storePageNavigationE = divE;\r\n                    break;\r\n                }\r\n            }\r\n            if (storePageNavigationE == null) {\r\n                return;\r\n            }\r\n\r\n            dynamic resizableContentEStyle = resizableContentE.getAttribute(\"currentStyle\"); \/\/ see http:\/\/blog.stchur.com\/2006\/06\/21\/css-computed-style\/\r\n            string paddingTopStr = resizableContentEStyle.paddingTop;\r\n            int paddingTopPx = int.Parse(paddingTopStr.TrimEnd(new char[] { 'p', 'x' }));\r\n            string paddingBottomStr = resizableContentEStyle.paddingBottom;\r\n            int paddingBottomPx = int.Parse(paddingBottomStr.TrimEnd(new char[] { 'p', 'x' }));\r\n\r\n            int storePageNavigationHeightPx = storePageNavigationE.getAttribute(\"clientHeight\");\r\n\r\n            int newHeight = browserWindowHeightPx - paddingTopPx - paddingBottomPx - storePageNavigationHeightPx;\r\n            if (newHeight < 0) {\r\n                newHeight = 0;\r\n            }\r\n            resizableContentE.style.height = newHeight + \"px\";\r\n        }\r\n    }\r\n\r\n    public delegate void DidReceiveOrderEventHandler(object sender, DidReceiveOrderEventArgs e);\r\n    public class DidReceiveOrderEventArgs : EventArgs\r\n    {\r\n        public DidReceiveOrderEventArgs(Order order)\r\n        {\r\n            Order = order;\r\n        }\r\n        public Order Order { get; internal set; }\r\n    }\r\n\r\n}\r\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"6097a7a0f28ec0977d49c208d075bc3e63770ee8","subject":"Incomplete: added assertion that home page works, and working on fixing how test servers are stood up","message":"Incomplete: added assertion that home page works, and working on fixing how test servers are stood up\n","repos":"matthew-a-thomas\/gps-logger,matthew-a-thomas\/gps-logger","old_file":"GPSLogger.Integration\/Program.cs","new_file":"GPSLogger.Integration\/Program.cs","new_contents":"using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Net.Http;\nusing System.Security.Cryptography;\nusing System.Threading.Tasks;\nusing Common.Extensions;\nusing Common.Extensions.Security;\nusing Common.Security;\nusing Common.Security.Signing;\nusing Microsoft.AspNetCore.TestHost;\nusing Newtonsoft.Json;\nusing System.Linq;\nusing System.Reflection;\nusing System.Text.RegularExpressions;\nusing Common.Messages;\nusing GPSLogger.Models;\nusing Microsoft.AspNetCore.Hosting;\n\nnamespace GPSLogger.Integration\n{\n    \/\/ ReSharper disable once UnusedMember.Global\n    \/\/ ReSharper disable once ArrangeTypeModifiers\n    class Program\n    {\n        \/\/ ReSharper disable once UnusedMember.Local\n        \/\/ ReSharper disable once ArrangeTypeMemberModifiers\n        \/\/ ReSharper disable once SuggestBaseTypeForParameter\n        \/\/ ReSharper disable once UnusedParameter.Local\n        static void Main(string[] args)\n        {\n            RunTests().Wait();\n            Debug.WriteLine(\"All tests executed successfully\");\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Asynchronously spins up a test server.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns><\/returns>\n        \/\/\/ <remarks>\n        \/\/\/ The test server's content root will be located within a randomly-created directory under GPSLogger\/tests\n        \/\/\/ <\/remarks>\n        private static async Task<TestServer> CreateServerAsync()\n        {\n            \/\/ Figure out where the GPS Logger directory is\n            var startingLocation = new DirectoryInfo(Path.GetDirectoryName(typeof(Program).GetTypeInfo().Assembly.Location));\n            var baseDirectory = Path.Combine(startingLocation.Parent.Parent.Parent.Parent.FullName, typeof(Startup).Namespace);\n\n            \/\/ Create a temp directory for this server to run from\n            var temp = DateTime.Now.ToString(\"yyyy-MM-dd HH-mm-ss\") + \" - \" + Guid.NewGuid();\n            var contentRoot = Path.Combine(baseDirectory, \"tests\", temp);\n            var contentRootDirectory = Directory.CreateDirectory(contentRoot);\n\n            \/\/ Assert that the newly created folder name matches what we expect\n            var pattern = new Regex(@\"^[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}-[0-9]{2}-[0-9]{2} - [a-f0-9\\-]+$\");\n            if (!pattern.IsMatch(contentRootDirectory.Name))\n                throw new Exception();\n\n            return await Task.Run(() =>\n            {\n                \/\/ Copy over needed files\n                foreach (var file in new[]\n                {\n                    \"appsettings.json\",\n                    \"Views\",\n                    \"wwwroot\"\n                })\n                {\n                    var source = Path.Combine(baseDirectory, file);\n                    var destination\n                    if (Directory.Exists(source))\n                    {\n                        Directory.CreateDirectory();\n                        foreach (var directory in Directory.GetDirectories())\n                    }\n                    else if (File.Exists(source))\n                    {\n                        File.Copy(source, Path.Combine(contentRoot, file));\n                    }\n                }\n\n                \/\/ Spin up the server\n                Debug.WriteLine($\"Starting test server under {contentRoot}\");\n                return new TestServer(\n                    new WebHostBuilder()\n                        .UseContentRoot(contentRoot)\n                        .UseStartup<Startup>()\n                );\n            });\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Does the given action with a newly-created client which is connected to the given server\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"server\"><\/param>\n        \/\/\/ <param name=\"action\"><\/param>\n        \/\/\/ <returns><\/returns>\n        private static async Task DoWithClientAsync(TestServer server, Func<HttpClient, Task> action)\n        {\n            using (var client = server.CreateClient())\n            {\n                await action(client);\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Asynchronously retrieves a credential from the server\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"server\"><\/param>\n        \/\/\/ <returns><\/returns>\n        private static async Task<Credential<string>> GetCredentialAsync(TestServer server)\n        {\n            var result = default(Credential<string>);\n            await DoWithClientAsync(server, async client =>\n            {\n                var response = await client.GetAsync(\"\/api\/credential\");\n                response.EnsureSuccessStatusCode();\n                var content = await response.Content.ReadAsStringAsync();\n                var deserialized = JsonConvert.DeserializeObject<SignedMessage<Credential<string>>>(content);\n                result = deserialized.Message.Contents;\n            });\n            return result;\n        }\n\n        private static async Task RunTests()\n        {\n            using (var server = await CreateServerAsync())\n            {\n                \/\/ Assert that the time returned from the time controller is within a second of now\n                await DoWithClientAsync(server, async client =>\n                {\n                    var response = await client.GetAsync<SignedMessage<long>>(\"\/api\/time\");\n                    if (response == null)\n                        throw new Exception(\"The time controller returned a null response instead of giving us the current time\");\n                    if (response.Message == null)\n                        throw new Exception(\"The contents of the time controller's response is null instead of containing the current time\");\n                    var difference = Math.Abs(response.Message.Contents - DateTimeOffset.Now.ToUnixTimeSeconds());\n                    if (difference > 1)\n                        throw new Exception($\"The time controller returned a time that is {difference} seconds different than the current time. This test only tolerates a difference of up to one second\");\n                });\n\n                \/\/ Assert that no HMAC has been set yet\n                await DoWithClientAsync(server, async client =>\n                {\n                    var hmacIsSet = await client.GetAsync<bool>(\"\/api\/hmackey\");\n                    if (hmacIsSet)\n                        throw new Exception(\"An HMAC key has already been set, even though we just started this server\");\n                });\n\n                \/\/ Set an HMAC key\n                await DoWithClientAsync(server, async client =>\n                {\n                    string newKey;\n                    using (var rng = RandomNumberGenerator.Create())\n                    {\n                        var buffer = new byte[100];\n                        rng.GetBytes(buffer);\n                        newKey = buffer.ToHexString();\n                    }\n                    var response = await client.PostAsync(\"\/api\/hmackey\", new { newKey });\n                    if (!string.IsNullOrWhiteSpace(response))\n                        throw new Exception(\"The HMAC key controller responded with something after we told it to set the key\");\n                });\n\n                \/\/ Assert that the HMAC has now been set\n                await DoWithClientAsync(server, async client =>\n                {\n                    var hmacIsSet = await client.GetAsync<bool>(\"\/api\/hmackey\");\n                    if (!hmacIsSet)\n                        throw new Exception(\"An HMAC key has not been set, even though we just told the HMAC controller to set it\");\n                });\n\n                \/\/ Get a credential\n                var credential = await GetCredentialAsync(server);\n                if (credential == null)\n                    throw new Exception(\"Credential is null\");\n                if (string.IsNullOrWhiteSpace(credential.ID))\n                    throw new Exception(\"Credential ID is null or whitespace\");\n                if (string.IsNullOrWhiteSpace(credential.Secret))\n                    throw new Exception(\"Credential secret is null or whitespace\");\n\n                \/\/ Convert it into a credential of bytes\n                var credentialBytes = await credential.ConvertAsync(async x => await ByteArrayExtensions.FromHexStringAsync(x));\n                if (credentialBytes == null)\n                    throw new Exception(\"Converted credential is null\");\n                if (credentialBytes.ID == null)\n                    throw new Exception(\"Converted credential's ID is null\");\n                if (credentialBytes.Secret == null)\n                    throw new Exception(\"Converted credential's secret is null\");\n\n                \/\/ Get another credential, signing the request with this credential\n                var newCredentialResponse = default(SignedMessage<Credential<string>>);\n                await DoWithClientAsync(server, async client =>\n                {\n                    var salt = BitConverter.GetBytes(DateTime.Now.Ticks);\n                    var signedRequest = new SignedMessage<bool>\n                    {\n                        Message = new Message<bool>\n                        {\n                            Contents = true,\n                            ID = credentialBytes.ID.ToHexString(),\n                            Salt = salt.ToHexString(),\n                            UnixTime = DateTimeOffset.Now.ToUnixTimeSeconds()\n                        }\n                    };\n                    await SignAsync(signedRequest, credentialBytes, x => Task.Run(() => BitConverter.GetBytes(x)));\n\n                    var queryString = $\"\/api\/credential?contents={signedRequest.Message.Contents}&id={signedRequest.Message.ID}&hmac={signedRequest.HMAC}&salt={signedRequest.Message.Salt}&unixTime={signedRequest.Message.UnixTime}\";\n                    var response = await client.GetAsync<SignedMessage<Credential<string>>>(queryString);\n                    newCredentialResponse = response;\n                });\n                if (newCredentialResponse == null)\n                    throw new Exception(\"New credential was null\");\n                if (string.IsNullOrWhiteSpace(newCredentialResponse.HMAC))\n                    throw new Exception(\"New credential's response wasn't signed\");\n                \/\/ Verify the new credential's response\n                var hmacBefore = newCredentialResponse.HMAC;\n                await SignAsync(newCredentialResponse, credentialBytes, async contents =>\n                {\n                    var id = await ByteArrayExtensions.FromHexStringAsync(contents.ID);\n                    var secret = await ByteArrayExtensions.FromHexStringAsync(contents.Secret);\n                    return new[]\n                        {\n                            id,\n                            secret\n                        }.SelectMany(_ => _)\n                        .ToArray();\n                });\n                if (!hmacBefore.Equals(newCredentialResponse.HMAC, StringComparison.CurrentCultureIgnoreCase))\n                    throw new Exception(\"The server didn't sign the response using our secret\");\n\n                \/\/ Get all the locations for the first credential\n                var locations = default(IEnumerable<Common.RemoteStorage.Models.Location>);\n                await DoWithClientAsync(server, async client =>\n                {\n                    locations = await client.GetAsync<IEnumerable<Common.RemoteStorage.Models.Location>>($\"\/api\/location\/?id={credential.ID}\");\n                });\n                if (locations == null)\n                    throw new Exception(\"Locations is null\");\n                if (locations.Any())\n                    throw new Exception(\"Returned some locations, even though the credential is supposed to be new\");\n\n                \/\/ Post a location using the first credential\n                var postResponse = default(SignedMessage<bool>);\n                var postedLocation = new Location\n                {\n                    Latitude = -1000,\n                    Longitude = 2000\n                };\n                await DoWithClientAsync(server, async client =>\n                {\n                    var request = new SignedMessage<Location>\n                    {\n                        Message = new Message<Location>\n                        {\n                            ID = credential.ID,\n                            Salt = BitConverter.GetBytes(DateTimeOffset.Now.Ticks).ToHexString(),\n                            UnixTime = DateTimeOffset.Now.ToUnixTimeSeconds(),\n                            Contents = postedLocation\n                        }\n                    };\n                    await SignAsync(\n                        request,\n                        credentialBytes,\n                        location => Task.FromResult(new[] { location.Latitude, location.Longitude }.Select(BitConverter.GetBytes).SelectMany(_ => _).ToArray())\n                        );\n                    var response = await client.PostAsync($\"\/api\/location\", request);\n                    postResponse = JsonConvert.DeserializeObject<SignedMessage<bool>>(response);\n                });\n                if (postResponse == null)\n                    throw new Exception(\"Didn't receive a valid response after posting a location\");\n                if (string.IsNullOrWhiteSpace(postResponse.HMAC))\n                    throw new Exception(\"The response from posting a location was not signed\");\n                if (postResponse.Message == null)\n                    throw new Exception(\"The message within the signed response is null instead of having something\");\n                if (!postResponse.Message.Contents)\n                    throw new Exception(\"The server indicated the post wasn't successful\");\n\n                \/\/ Get all the locations for the first credential again\n                locations = default(IEnumerable<Common.RemoteStorage.Models.Location>);\n                await DoWithClientAsync(server, async client =>\n                {\n                    locations = await client.GetAsync<IEnumerable<Common.RemoteStorage.Models.Location>>($\"\/api\/location\/?id={credential.ID}\");\n                });\n                \/\/ Make sure we got back the location we just posted\n                if (locations == null)\n                    throw new Exception(\"Locations is null\");\n                var locationsArray = locations.ToArray();\n                if (locationsArray.Length > 1)\n                    throw new Exception(\"Got back more than one location, even though we only posted one\");\n                var firstLocation = locationsArray.FirstOrDefault();\n                if (ReferenceEquals(firstLocation, null))\n                    throw new Exception(\"Didn't return any locations, even though we just posted one\");\n                const double tolerance = 0.0000001;\n                if (Math.Abs(firstLocation.Latitude - postedLocation.Latitude) > tolerance)\n                    throw new Exception($\"The returned latitude is more than {tolerance} off\");\n                if (Math.Abs(firstLocation.Longitude - postedLocation.Longitude) > tolerance)\n                    throw new Exception($\"The returned longitude is more than {tolerance} off\");\n                var timeDifference = Math.Abs(firstLocation.UnixTime - DateTimeOffset.Now.ToUnixTimeSeconds());\n                const long allowedDifference = 10;\n                if (timeDifference > allowedDifference)\n                    throw new Exception($\"The returned time is more than {allowedDifference} seconds off\");\n\n                \/\/ Sign a request to get the current time\n                await DoWithClientAsync(server, async client =>\n                {\n                    var request = new SignedMessage<bool>\n                    {\n                        Message = new Message<bool>\n                        {\n                            Contents = true,\n                            ID = credential.ID,\n                            Salt = Guid.NewGuid().ToByteArray().ToHexString(),\n                            UnixTime = DateTimeOffset.Now.ToUnixTimeSeconds()\n                        }\n                    };\n                    await SignAsync(request, credentialBytes, x => Task.FromResult(BitConverter.GetBytes(x)));\n                    var response = await client.GetAsync<SignedMessage<long>>($\"\/api\/time\/?hmac={request.HMAC}&id={request.Message.ID}&salt={request.Message.Salt}&unixTime={request.Message.UnixTime}&contents={request.Message.Contents}\");\n                    if (response == null)\n                        throw new Exception(\"The time controller returned a null response\");\n                    if (string.IsNullOrWhiteSpace(response.HMAC))\n                        throw new Exception(\"The HMAC of the time controller's response was null or whitespace\");\n                    if (response.Message == null)\n                        throw new Exception(\"The message within the time controller's response was null\");\n                    var difference = Math.Abs(response.Message.Contents - DateTimeOffset.Now.ToUnixTimeSeconds());\n                    if (difference > 1)\n                        throw new Exception(\"The time reported by the time controller in response to a signed request was more than one second off\");\n                });\n\n                \/\/ Now make sure an exception comes back from the exception controller\n                await DoWithClientAsync(server, async client =>\n                {\n                    var message = Guid.NewGuid().ToString();\n                    var response = await client.GetAsync($\"\/api\/exception?message={message}\");\n                    if (response.IsSuccessStatusCode)\n                        throw new Exception(\"The exception controller returned a success status code\");\n                    var contents = await response.Content.ReadAsStringAsync();\n                    if (string.IsNullOrWhiteSpace(contents))\n                        throw new Exception(\"The exception controller returned an empty response\");\n                    if (contents.Contains(message))\n                        throw new Exception(\"The exception controller isn't hiding internal exceptions\");\n                    try\n                    {\n                        JsonConvert.DeserializeObject<string>(contents);\n                    }\n                    catch\n                    {\n                        throw new Exception(\"The exception handler isn't returning a plain string\");\n                    }\n                });\n\n                \/\/ See if we can get an \"Access-Control-Allow-Origin\" header back\n                await DoWithClientAsync(server, async client =>\n                {\n                    client.DefaultRequestHeaders.Add(\"Origin\", $\"https:\/\/{Guid.NewGuid().ToString()}.com\");\n                    var response = await client.GetAsync(\"\/api\/time\");\n                    response.EnsureSuccessStatusCode();\n                    var gotHeader = response.Headers.TryGetValues(\"Access-Control-Allow-Origin\", out var values);\n                    var first = values.FirstOrDefault();\n                    if (!gotHeader || string.IsNullOrWhiteSpace(first))\n                        throw new Exception(\"The server didn't respons with a Access-Control-Allow-Origin header\");\n                    if (first != \"*\")\n                        throw new Exception(\"The server responded with a Access-Control-Allow-Origin header, but didn't set it to * as expected\");\n                });\n\n                \/\/ See if we can access the home page\n                await DoWithClientAsync(server, async client =>\n                {\n                    var homePage = await client.GetAsync<string>(\"\");\n                });\n            }\n        }\n\n        private static async Task SignAsync<T>(SignedMessage<T> signedRequest, Credential<byte[]> credential, Func<T, Task<byte[]>> conversion)\n        {\n            var serialized = new[]\n                {\n                    await conversion(signedRequest.Message.Contents),\n                    await ByteArrayExtensions.FromHexStringAsync(signedRequest.Message.ID),\n                    await ByteArrayExtensions.FromHexStringAsync(signedRequest.Message.Salt),\n                    BitConverter.GetBytes(signedRequest.Message.UnixTime)\n                }.SelectMany(_ => _)\n                .ToArray();\n            using (var hmac = new HMACSHA256(credential.Secret))\n            {\n                var hash = hmac.ComputeHash(serialized);\n                signedRequest.HMAC = hash.ToHexString();\n            }\n        }\n    }\n}","old_contents":"using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Net.Http;\nusing System.Security.Cryptography;\nusing System.Threading.Tasks;\nusing Common.Extensions;\nusing Common.Extensions.Security;\nusing Common.Security;\nusing Common.Security.Signing;\nusing Microsoft.AspNetCore.TestHost;\nusing Newtonsoft.Json;\nusing System.Linq;\nusing System.Reflection;\nusing System.Text.RegularExpressions;\nusing Common.Messages;\nusing GPSLogger.Models;\nusing Microsoft.AspNetCore.Hosting;\n\nnamespace GPSLogger.Integration\n{\n    \/\/ ReSharper disable once UnusedMember.Global\n    \/\/ ReSharper disable once ArrangeTypeModifiers\n    class Program\n    {\n        \/\/ ReSharper disable once UnusedMember.Local\n        \/\/ ReSharper disable once ArrangeTypeMemberModifiers\n        \/\/ ReSharper disable once SuggestBaseTypeForParameter\n        \/\/ ReSharper disable once UnusedParameter.Local\n        static void Main(string[] args)\n        {\n            RunTests().Wait();\n            Debug.WriteLine(\"All tests executed successfully\");\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Asynchronously spins up a test server.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns><\/returns>\n        \/\/\/ <remarks>\n        \/\/\/ The test server's content root will be located within a randomly-created directory under GPSLogger\/tests\n        \/\/\/ <\/remarks>\n        private static async Task<TestServer> CreateServerAsync()\n        {\n            \/\/ Figure out where the GPS Logger directory is\n            var startingLocation = new DirectoryInfo(Path.GetDirectoryName(typeof(Program).GetTypeInfo().Assembly.Location));\n            var baseDirectory = Path.Combine(startingLocation.Parent.Parent.Parent.Parent.FullName, typeof(Startup).Namespace);\n\n            \/\/ Create a temp directory for this server to run from\n            var temp = DateTime.Now.ToString(\"yyyy-MM-dd HH-mm-ss\") + \" - \" + Guid.NewGuid();\n            var contentRoot = Path.Combine(baseDirectory, \"tests\", temp);\n            var contentRootDirectory = Directory.CreateDirectory(contentRoot);\n\n            \/\/ Assert that the newly created folder name matches what we expect\n            var pattern = new Regex(@\"^[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}-[0-9]{2}-[0-9]{2} - [a-f0-9\\-]+$\");\n            if (!pattern.IsMatch(contentRootDirectory.Name))\n                throw new Exception();\n\n            return await Task.Run(() =>\n            {\n                \/\/ Copy over needed files\n                foreach (var file in new[]\n                {\n                    \"appsettings.json\"\n                })\n                    File.Copy(Path.Combine(baseDirectory, file), Path.Combine(contentRoot, file));\n\n                \/\/ Spin up the server\n                Debug.WriteLine($\"Starting test server under {contentRoot}\");\n                return new TestServer(\n                    new WebHostBuilder()\n                        .UseContentRoot(contentRoot)\n                        .UseStartup<Startup>()\n                );\n            });\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Does the given action with a newly-created client which is connected to the given server\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"server\"><\/param>\n        \/\/\/ <param name=\"action\"><\/param>\n        \/\/\/ <returns><\/returns>\n        private static async Task DoWithClientAsync(TestServer server, Func<HttpClient, Task> action)\n        {\n            using (var client = server.CreateClient())\n            {\n                await action(client);\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Asynchronously retrieves a credential from the server\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"server\"><\/param>\n        \/\/\/ <returns><\/returns>\n        private static async Task<Credential<string>> GetCredentialAsync(TestServer server)\n        {\n            var result = default(Credential<string>);\n            await DoWithClientAsync(server, async client =>\n            {\n                var response = await client.GetAsync(\"\/api\/credential\");\n                response.EnsureSuccessStatusCode();\n                var content = await response.Content.ReadAsStringAsync();\n                var deserialized = JsonConvert.DeserializeObject<SignedMessage<Credential<string>>>(content);\n                result = deserialized.Message.Contents;\n            });\n            return result;\n        }\n\n        private static async Task RunTests()\n        {\n            using (var server = await CreateServerAsync())\n            {\n                \/\/ Assert that the time returned from the time controller is within a second of now\n                await DoWithClientAsync(server, async client =>\n                {\n                    var response = await client.GetAsync<SignedMessage<long>>(\"\/api\/time\");\n                    if (response == null)\n                        throw new Exception(\"The time controller returned a null response instead of giving us the current time\");\n                    if (response.Message == null)\n                        throw new Exception(\"The contents of the time controller's response is null instead of containing the current time\");\n                    var difference = Math.Abs(response.Message.Contents - DateTimeOffset.Now.ToUnixTimeSeconds());\n                    if (difference > 1)\n                        throw new Exception($\"The time controller returned a time that is {difference} seconds different than the current time. This test only tolerates a difference of up to one second\");\n                });\n\n                \/\/ Assert that no HMAC has been set yet\n                await DoWithClientAsync(server, async client =>\n                {\n                    var hmacIsSet = await client.GetAsync<bool>(\"\/api\/hmackey\");\n                    if (hmacIsSet)\n                        throw new Exception(\"An HMAC key has already been set, even though we just started this server\");\n                });\n\n                \/\/ Set an HMAC key\n                await DoWithClientAsync(server, async client =>\n                {\n                    string newKey;\n                    using (var rng = RandomNumberGenerator.Create())\n                    {\n                        var buffer = new byte[100];\n                        rng.GetBytes(buffer);\n                        newKey = buffer.ToHexString();\n                    }\n                    var response = await client.PostAsync(\"\/api\/hmackey\", new { newKey });\n                    if (!string.IsNullOrWhiteSpace(response))\n                        throw new Exception(\"The HMAC key controller responded with something after we told it to set the key\");\n                });\n\n                \/\/ Assert that the HMAC has now been set\n                await DoWithClientAsync(server, async client =>\n                {\n                    var hmacIsSet = await client.GetAsync<bool>(\"\/api\/hmackey\");\n                    if (!hmacIsSet)\n                        throw new Exception(\"An HMAC key has not been set, even though we just told the HMAC controller to set it\");\n                });\n\n                \/\/ Get a credential\n                var credential = await GetCredentialAsync(server);\n                if (credential == null)\n                    throw new Exception(\"Credential is null\");\n                if (string.IsNullOrWhiteSpace(credential.ID))\n                    throw new Exception(\"Credential ID is null or whitespace\");\n                if (string.IsNullOrWhiteSpace(credential.Secret))\n                    throw new Exception(\"Credential secret is null or whitespace\");\n\n                \/\/ Convert it into a credential of bytes\n                var credentialBytes = await credential.ConvertAsync(async x => await ByteArrayExtensions.FromHexStringAsync(x));\n                if (credentialBytes == null)\n                    throw new Exception(\"Converted credential is null\");\n                if (credentialBytes.ID == null)\n                    throw new Exception(\"Converted credential's ID is null\");\n                if (credentialBytes.Secret == null)\n                    throw new Exception(\"Converted credential's secret is null\");\n\n                \/\/ Get another credential, signing the request with this credential\n                var newCredentialResponse = default(SignedMessage<Credential<string>>);\n                await DoWithClientAsync(server, async client =>\n                {\n                    var salt = BitConverter.GetBytes(DateTime.Now.Ticks);\n                    var signedRequest = new SignedMessage<bool>\n                    {\n                        Message = new Message<bool>\n                        {\n                            Contents = true,\n                            ID = credentialBytes.ID.ToHexString(),\n                            Salt = salt.ToHexString(),\n                            UnixTime = DateTimeOffset.Now.ToUnixTimeSeconds()\n                        }\n                    };\n                    await SignAsync(signedRequest, credentialBytes, x => Task.Run(() => BitConverter.GetBytes(x)));\n\n                    var queryString = $\"\/api\/credential?contents={signedRequest.Message.Contents}&id={signedRequest.Message.ID}&hmac={signedRequest.HMAC}&salt={signedRequest.Message.Salt}&unixTime={signedRequest.Message.UnixTime}\";\n                    var response = await client.GetAsync<SignedMessage<Credential<string>>>(queryString);\n                    newCredentialResponse = response;\n                });\n                if (newCredentialResponse == null)\n                    throw new Exception(\"New credential was null\");\n                if (string.IsNullOrWhiteSpace(newCredentialResponse.HMAC))\n                    throw new Exception(\"New credential's response wasn't signed\");\n                \/\/ Verify the new credential's response\n                var hmacBefore = newCredentialResponse.HMAC;\n                await SignAsync(newCredentialResponse, credentialBytes, async contents =>\n                {\n                    var id = await ByteArrayExtensions.FromHexStringAsync(contents.ID);\n                    var secret = await ByteArrayExtensions.FromHexStringAsync(contents.Secret);\n                    return new[]\n                        {\n                            id,\n                            secret\n                        }.SelectMany(_ => _)\n                        .ToArray();\n                });\n                if (!hmacBefore.Equals(newCredentialResponse.HMAC, StringComparison.CurrentCultureIgnoreCase))\n                    throw new Exception(\"The server didn't sign the response using our secret\");\n\n                \/\/ Get all the locations for the first credential\n                var locations = default(IEnumerable<Common.RemoteStorage.Models.Location>);\n                await DoWithClientAsync(server, async client =>\n                {\n                    locations = await client.GetAsync<IEnumerable<Common.RemoteStorage.Models.Location>>($\"\/api\/location\/?id={credential.ID}\");\n                });\n                if (locations == null)\n                    throw new Exception(\"Locations is null\");\n                if (locations.Any())\n                    throw new Exception(\"Returned some locations, even though the credential is supposed to be new\");\n\n                \/\/ Post a location using the first credential\n                var postResponse = default(SignedMessage<bool>);\n                var postedLocation = new Location\n                {\n                    Latitude = -1000,\n                    Longitude = 2000\n                };\n                await DoWithClientAsync(server, async client =>\n                {\n                    var request = new SignedMessage<Location>\n                    {\n                        Message = new Message<Location>\n                        {\n                            ID = credential.ID,\n                            Salt = BitConverter.GetBytes(DateTimeOffset.Now.Ticks).ToHexString(),\n                            UnixTime = DateTimeOffset.Now.ToUnixTimeSeconds(),\n                            Contents = postedLocation\n                        }\n                    };\n                    await SignAsync(\n                        request,\n                        credentialBytes,\n                        location => Task.FromResult(new[] { location.Latitude, location.Longitude }.Select(BitConverter.GetBytes).SelectMany(_ => _).ToArray())\n                        );\n                    var response = await client.PostAsync($\"\/api\/location\", request);\n                    postResponse = JsonConvert.DeserializeObject<SignedMessage<bool>>(response);\n                });\n                if (postResponse == null)\n                    throw new Exception(\"Didn't receive a valid response after posting a location\");\n                if (string.IsNullOrWhiteSpace(postResponse.HMAC))\n                    throw new Exception(\"The response from posting a location was not signed\");\n                if (postResponse.Message == null)\n                    throw new Exception(\"The message within the signed response is null instead of having something\");\n                if (!postResponse.Message.Contents)\n                    throw new Exception(\"The server indicated the post wasn't successful\");\n\n                \/\/ Get all the locations for the first credential again\n                locations = default(IEnumerable<Common.RemoteStorage.Models.Location>);\n                await DoWithClientAsync(server, async client =>\n                {\n                    locations = await client.GetAsync<IEnumerable<Common.RemoteStorage.Models.Location>>($\"\/api\/location\/?id={credential.ID}\");\n                });\n                \/\/ Make sure we got back the location we just posted\n                if (locations == null)\n                    throw new Exception(\"Locations is null\");\n                var locationsArray = locations.ToArray();\n                if (locationsArray.Length > 1)\n                    throw new Exception(\"Got back more than one location, even though we only posted one\");\n                var firstLocation = locationsArray.FirstOrDefault();\n                if (ReferenceEquals(firstLocation, null))\n                    throw new Exception(\"Didn't return any locations, even though we just posted one\");\n                const double tolerance = 0.0000001;\n                if (Math.Abs(firstLocation.Latitude - postedLocation.Latitude) > tolerance)\n                    throw new Exception($\"The returned latitude is more than {tolerance} off\");\n                if (Math.Abs(firstLocation.Longitude - postedLocation.Longitude) > tolerance)\n                    throw new Exception($\"The returned longitude is more than {tolerance} off\");\n                var timeDifference = Math.Abs(firstLocation.UnixTime - DateTimeOffset.Now.ToUnixTimeSeconds());\n                const long allowedDifference = 10;\n                if (timeDifference > allowedDifference)\n                    throw new Exception($\"The returned time is more than {allowedDifference} seconds off\");\n\n                \/\/ Sign a request to get the current time\n                await DoWithClientAsync(server, async client =>\n                {\n                    var request = new SignedMessage<bool>\n                    {\n                        Message = new Message<bool>\n                        {\n                            Contents = true,\n                            ID = credential.ID,\n                            Salt = Guid.NewGuid().ToByteArray().ToHexString(),\n                            UnixTime = DateTimeOffset.Now.ToUnixTimeSeconds()\n                        }\n                    };\n                    await SignAsync(request, credentialBytes, x => Task.FromResult(BitConverter.GetBytes(x)));\n                    var response = await client.GetAsync<SignedMessage<long>>($\"\/api\/time\/?hmac={request.HMAC}&id={request.Message.ID}&salt={request.Message.Salt}&unixTime={request.Message.UnixTime}&contents={request.Message.Contents}\");\n                    if (response == null)\n                        throw new Exception(\"The time controller returned a null response\");\n                    if (string.IsNullOrWhiteSpace(response.HMAC))\n                        throw new Exception(\"The HMAC of the time controller's response was null or whitespace\");\n                    if (response.Message == null)\n                        throw new Exception(\"The message within the time controller's response was null\");\n                    var difference = Math.Abs(response.Message.Contents - DateTimeOffset.Now.ToUnixTimeSeconds());\n                    if (difference > 1)\n                        throw new Exception(\"The time reported by the time controller in response to a signed request was more than one second off\");\n                });\n\n                \/\/ Now make sure an exception comes back from the exception controller\n                await DoWithClientAsync(server, async client =>\n                {\n                    var message = Guid.NewGuid().ToString();\n                    var response = await client.GetAsync($\"\/api\/exception?message={message}\");\n                    if (response.IsSuccessStatusCode)\n                        throw new Exception(\"The exception controller returned a success status code\");\n                    var contents = await response.Content.ReadAsStringAsync();\n                    if (string.IsNullOrWhiteSpace(contents))\n                        throw new Exception(\"The exception controller returned an empty response\");\n                    if (contents.Contains(message))\n                        throw new Exception(\"The exception controller isn't hiding internal exceptions\");\n                    try\n                    {\n                        JsonConvert.DeserializeObject<string>(contents);\n                    }\n                    catch\n                    {\n                        throw new Exception(\"The exception handler isn't returning a plain string\");\n                    }\n                });\n\n                \/\/ See if we can get an \"Access-Control-Allow-Origin\" header back\n                await DoWithClientAsync(server, async client =>\n                {\n                    client.DefaultRequestHeaders.Add(\"Origin\", $\"https:\/\/{Guid.NewGuid().ToString()}.com\");\n                    var response = await client.GetAsync(\"\/api\/time\");\n                    response.EnsureSuccessStatusCode();\n                    var gotHeader = response.Headers.TryGetValues(\"Access-Control-Allow-Origin\", out var values);\n                    var first = values.FirstOrDefault();\n                    if (!gotHeader || string.IsNullOrWhiteSpace(first))\n                        throw new Exception(\"The server didn't respons with a Access-Control-Allow-Origin header\");\n                    if (first != \"*\")\n                        throw new Exception(\"The server responded with a Access-Control-Allow-Origin header, but didn't set it to * as expected\");\n                });\n            }\n        }\n\n        private static async Task SignAsync<T>(SignedMessage<T> signedRequest, Credential<byte[]> credential, Func<T, Task<byte[]>> conversion)\n        {\n            var serialized = new[]\n                {\n                    await conversion(signedRequest.Message.Contents),\n                    await ByteArrayExtensions.FromHexStringAsync(signedRequest.Message.ID),\n                    await ByteArrayExtensions.FromHexStringAsync(signedRequest.Message.Salt),\n                    BitConverter.GetBytes(signedRequest.Message.UnixTime)\n                }.SelectMany(_ => _)\n                .ToArray();\n            using (var hmac = new HMACSHA256(credential.Secret))\n            {\n                var hash = hmac.ComputeHash(serialized);\n                signedRequest.HMAC = hash.ToHexString();\n            }\n        }\n    }\n}","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"7a37820a7d6423da9a0c94c35e5aad4d260af4e7","subject":"Fixed bug when result is called outside of a method.","message":"Fixed bug when result is called outside of a method.\n","repos":"hvanbakel\/Asyncify-CSharp","old_file":"Asyncify\/Asyncify\/VariableAccessChecker.cs","new_file":"Asyncify\/Asyncify\/VariableAccessChecker.cs","new_contents":"using System.Threading.Tasks;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\n\nnamespace Asyncify\n{\n    internal class VariableAccessChecker\n    { \n        private readonly SemanticModel semanticModel;\n\n        public VariableAccessChecker(SemanticModel semanticModel)\n        {\n            this.semanticModel = semanticModel;\n        }\n\n        public bool ShouldUseTap(MemberAccessExpressionSyntax memberAccessExpression)\n        {\n            if (memberAccessExpression.IsWrappedInAwaitExpression() || memberAccessExpression.IsWrappedInLock())\n            {\n                return false;\n            }\n\n            var identifierName = memberAccessExpression.Name as IdentifierNameSyntax;\n            if (identifierName?.Identifier.ValueText != nameof(Task<int>.Result))\n            {\n                return false;\n            }\n\n            var lambdaExpression = memberAccessExpression.FirstAncestorOrSelf<LambdaExpressionSyntax>();\n            if (lambdaExpression == null)\n            {\n                var methodDeclaration = memberAccessExpression.FirstAncestorOrSelf<MethodDeclarationSyntax>();\n                if (methodDeclaration == null || methodDeclaration.HasOutOrRefParameters())\n                {\n                    return false;\n                }\n            }\n\n            var symbol = FindSymbol(memberAccessExpression.Expression);\n            if (symbol == null)\n            {\n                return false;\n            }\n            var taskSymbol = semanticModel.Compilation.GetTypeByMetadataName(typeof(Task).FullName);\n            var taskOfTSymbol = semanticModel.Compilation.GetTypeByMetadataName(typeof(Task).FullName + \"`1\");\n\n            return symbol.IsGenericType ?\n                symbol.ConstructedFrom.Equals(taskOfTSymbol) :\n                symbol.Equals(taskSymbol);\n        }\n\n        private INamedTypeSymbol FindSymbol(ExpressionSyntax expression)\n        {\n            while (true)\n            {\n                var parenthesizedExpression = expression as ParenthesizedExpressionSyntax;\n                if (parenthesizedExpression != null)\n                {\n                    expression = parenthesizedExpression.Expression;\n                    continue;\n                }\n\n                var castExpression = expression as CastExpressionSyntax;\n                if (castExpression != null)\n                {\n                    return semanticModel.GetTypeInfo(castExpression.Type).Type as INamedTypeSymbol;\n                }\n\n                if (expression is InvocationExpressionSyntax)\/\/Handled by invocationanalzyer\n                {\n                    return null;\n                }\n\n                var localSymbol = semanticModel.GetSymbolInfo(expression).Symbol as ILocalSymbol;\n                return localSymbol?.Type as INamedTypeSymbol;\n            }\n        }\n    }\n}","old_contents":"using System.Threading.Tasks;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\n\nnamespace Asyncify\n{\n    internal class VariableAccessChecker\n    { \n        private readonly SemanticModel semanticModel;\n\n        public VariableAccessChecker(SemanticModel semanticModel)\n        {\n            this.semanticModel = semanticModel;\n        }\n\n        public bool ShouldUseTap(MemberAccessExpressionSyntax memberAccessExpression)\n        {\n            if (memberAccessExpression.IsWrappedInAwaitExpression() || memberAccessExpression.IsWrappedInLock())\n            {\n                return false;\n            }\n\n            var identifierName = memberAccessExpression.Name as IdentifierNameSyntax;\n            if (identifierName?.Identifier.ValueText != nameof(Task<int>.Result))\n            {\n                return false;\n            }\n\n            var lambdaExpression = memberAccessExpression.FirstAncestorOrSelf<LambdaExpressionSyntax>();\n            if (lambdaExpression == null)\n            {\n                var methodDeclaration = memberAccessExpression.FirstAncestorOrSelf<MethodDeclarationSyntax>();\n                if (methodDeclaration.HasOutOrRefParameters())\n                {\n                    return false;\n                }\n            }\n\n            var symbol = FindSymbol(memberAccessExpression.Expression);\n            if (symbol == null)\n            {\n                return false;\n            }\n            var taskSymbol = semanticModel.Compilation.GetTypeByMetadataName(typeof(Task).FullName);\n            var taskOfTSymbol = semanticModel.Compilation.GetTypeByMetadataName(typeof(Task).FullName + \"`1\");\n\n            return symbol.IsGenericType ?\n                symbol.ConstructedFrom.Equals(taskOfTSymbol) :\n                symbol.Equals(taskSymbol);\n        }\n\n        private INamedTypeSymbol FindSymbol(ExpressionSyntax expression)\n        {\n            while (true)\n            {\n                var parenthesizedExpression = expression as ParenthesizedExpressionSyntax;\n                if (parenthesizedExpression != null)\n                {\n                    expression = parenthesizedExpression.Expression;\n                    continue;\n                }\n\n                var castExpression = expression as CastExpressionSyntax;\n                if (castExpression != null)\n                {\n                    return semanticModel.GetTypeInfo(castExpression.Type).Type as INamedTypeSymbol;\n                }\n\n                if (expression is InvocationExpressionSyntax)\/\/Handled by invocationanalzyer\n                {\n                    return null;\n                }\n\n                var localSymbol = semanticModel.GetSymbolInfo(expression).Symbol as ILocalSymbol;\n                return localSymbol?.Type as INamedTypeSymbol;\n            }\n        }\n    }\n}","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"43d34d5d35fc40c3dd8398ac85edd4b2d6259f47","subject":"Now requiring Authorization on AppsController","message":"Now requiring Authorization on AppsController\n","repos":"btcpayserver\/btcpayserver,btcpayserver\/btcpayserver,btcpayserver\/btcpayserver,btcpayserver\/btcpayserver","old_file":"BTCPayServer\/Controllers\/AppsController.cs","new_file":"BTCPayServer\/Controllers\/AppsController.cs","new_contents":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing BTCPayServer.Data;\nusing BTCPayServer.Models;\nusing BTCPayServer.Models.AppViewModels;\nusing BTCPayServer.Security;\nusing BTCPayServer.Services.Apps;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Identity;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing NBitcoin;\nusing NBitcoin.DataEncoders;\n\nnamespace BTCPayServer.Controllers\n{\n    [Authorize(AuthenticationSchemes = Policies.CookieAuthentication)]\n    [AutoValidateAntiforgeryToken]\n    [Route(\"apps\")]\n    public partial class AppsController : Controller\n    {\n        public AppsController(\n            UserManager<ApplicationUser> userManager,\n            ApplicationDbContextFactory contextFactory,\n            BTCPayNetworkProvider networkProvider,\n            AppsHelper appsHelper)\n        {\n            _UserManager = userManager;\n            _ContextFactory = contextFactory;\n            _NetworkProvider = networkProvider;\n            _AppsHelper = appsHelper;\n        }\n\n        private UserManager<ApplicationUser> _UserManager;\n        private ApplicationDbContextFactory _ContextFactory;\n        private BTCPayNetworkProvider _NetworkProvider;\n        private AppsHelper _AppsHelper;\n\n        [TempData]\n        public string StatusMessage { get; set; }\n\n        public async Task<IActionResult> ListApps()\n        {\n            var apps = await GetAllApps();\n            return View(new ListAppsViewModel()\n            {\n                Apps = apps\n            });\n        }\n\n        [HttpPost]\n        [Route(\"{appId}\/delete\")]\n        public async Task<IActionResult> DeleteAppPost(string appId)\n        {\n            var appData = await GetOwnedApp(appId);\n            if (appData == null)\n                return NotFound();\n            if (await DeleteApp(appData))\n                StatusMessage = \"App removed successfully\";\n            return RedirectToAction(nameof(ListApps));\n        }\n\n        [HttpGet]\n        [Route(\"create\")]\n        public async Task<IActionResult> CreateApp()\n        {\n            var stores = await GetOwnedStores();\n            if (stores.Length == 0)\n            {\n                StatusMessage = \"Error: You must have created at least one store\";\n                return RedirectToAction(nameof(ListApps));\n            }\n            var vm = new CreateAppViewModel();\n            vm.SetStores(stores);\n            return View(vm);\n        }\n\n        [HttpPost]\n        [Route(\"create\")]\n        public async Task<IActionResult> CreateApp(CreateAppViewModel vm)\n        {\n            var stores = await GetOwnedStores();\n            if (stores.Length == 0)\n            {\n                StatusMessage = \"Error: You must own at least one store\";\n                return RedirectToAction(nameof(ListApps));\n            }\n            var selectedStore = vm.SelectedStore;\n            vm.SetStores(stores);\n            vm.SelectedStore = selectedStore;\n\n            if (!Enum.TryParse<AppType>(vm.SelectedAppType, out AppType appType))\n                ModelState.AddModelError(nameof(vm.SelectedAppType), \"Invalid App Type\");\n\n            if (!ModelState.IsValid)\n            {\n                return View(vm);\n            }\n\n            if (!stores.Any(s => s.Id == selectedStore))\n            {\n                StatusMessage = \"Error: You are not owner of this store\";\n                return RedirectToAction(nameof(ListApps));\n            }\n            var id = Encoders.Base58.EncodeData(RandomUtils.GetBytes(32));\n            using (var ctx = _ContextFactory.CreateContext())\n            {\n                var appData = new AppData() { Id = id };\n                appData.StoreDataId = selectedStore;\n                appData.Name = vm.Name;\n                appData.AppType = appType.ToString();\n                ctx.Apps.Add(appData);\n                await ctx.SaveChangesAsync();\n            }\n            StatusMessage = \"App successfully created\";\n\n            if (appType == AppType.PointOfSale)\n                return RedirectToAction(nameof(UpdatePointOfSale), new { appId = id });\n            return RedirectToAction(nameof(ListApps));\n        }\n\n        [HttpGet]\n        [Route(\"{appId}\/delete\")]\n        public async Task<IActionResult> DeleteApp(string appId)\n        {\n            var appData = await GetOwnedApp(appId);\n            if (appData == null)\n                return NotFound();\n            return View(\"Confirm\", new ConfirmModel()\n            {\n                Title = $\"Delete app {appData.Name} ({appData.AppType})\",\n                Description = \"This app will be removed from this store\",\n                Action = \"Delete\"\n            });\n        }\n\n        private async Task<AppData> GetOwnedApp(string appId, AppType? type = null)\n        {\n            var userId = GetUserId();\n            using (var ctx = _ContextFactory.CreateContext())\n            {\n                var app = await ctx.UserStore\n                                .Where(us => us.ApplicationUserId == userId && us.Role == StoreRoles.Owner)\n                                .SelectMany(us => us.StoreData.Apps.Where(a => a.Id == appId))\n                   .FirstOrDefaultAsync();\n                if (app == null)\n                    return null;\n                if (type != null && type.Value.ToString() != app.AppType)\n                    return null;\n                return app;\n            }\n        }\n\n        private async Task<StoreData[]> GetOwnedStores()\n        {\n            var userId = GetUserId();\n            using (var ctx = _ContextFactory.CreateContext())\n            {\n                return await ctx.UserStore\n                    .Where(us => us.ApplicationUserId == userId && us.Role == StoreRoles.Owner)\n                    .Select(u => u.StoreData)\n                    .ToArrayAsync();\n            }\n        }\n\n        private async Task<bool> DeleteApp(AppData appData)\n        {\n            using (var ctx = _ContextFactory.CreateContext())\n            {\n                ctx.Apps.Add(appData);\n                ctx.Entry<AppData>(appData).State = EntityState.Deleted;\n                return await ctx.SaveChangesAsync() == 1;\n            }\n        }\n\n        private async Task<ListAppsViewModel.ListAppViewModel[]> GetAllApps()\n        {\n            var userId = GetUserId();\n            using (var ctx = _ContextFactory.CreateContext())\n            {\n                return await ctx.UserStore\n                    .Where(us => us.ApplicationUserId == userId)\n                    .Join(ctx.Apps, us => us.StoreDataId, app => app.StoreDataId,\n                    (us, app) =>\n                    new ListAppsViewModel.ListAppViewModel()\n                    {\n                        IsOwner = us.Role == StoreRoles.Owner,\n                        StoreId = us.StoreDataId,\n                        StoreName = us.StoreData.StoreName,\n                        AppName = app.Name,\n                        AppType = app.AppType,\n                        Id = app.Id\n                    })\n                    .ToArrayAsync();\n            }\n        }\n\n        private string GetUserId()\n        {\n            return _UserManager.GetUserId(User);\n        }\n    }\n}\n","old_contents":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing BTCPayServer.Data;\nusing BTCPayServer.Models;\nusing BTCPayServer.Models.AppViewModels;\nusing BTCPayServer.Security;\nusing BTCPayServer.Services.Apps;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Identity;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing NBitcoin;\nusing NBitcoin.DataEncoders;\n\nnamespace BTCPayServer.Controllers\n{\n    [AutoValidateAntiforgeryToken]\n    [Route(\"apps\")]\n    public partial class AppsController : Controller\n    {\n        public AppsController(\n            UserManager<ApplicationUser> userManager,\n            ApplicationDbContextFactory contextFactory,\n            BTCPayNetworkProvider networkProvider,\n            AppsHelper appsHelper)\n        {\n            _UserManager = userManager;\n            _ContextFactory = contextFactory;\n            _NetworkProvider = networkProvider;\n            _AppsHelper = appsHelper;\n        }\n\n        private UserManager<ApplicationUser> _UserManager;\n        private ApplicationDbContextFactory _ContextFactory;\n        private BTCPayNetworkProvider _NetworkProvider;\n        private AppsHelper _AppsHelper;\n\n        [TempData]\n        public string StatusMessage { get; set; }\n\n        public async Task<IActionResult> ListApps()\n        {\n            var apps = await GetAllApps();\n            return View(new ListAppsViewModel()\n            {\n                Apps = apps\n            });\n        }\n\n        [HttpPost]\n        [Route(\"{appId}\/delete\")]\n        public async Task<IActionResult> DeleteAppPost(string appId)\n        {\n            var appData = await GetOwnedApp(appId);\n            if (appData == null)\n                return NotFound();\n            if (await DeleteApp(appData))\n                StatusMessage = \"App removed successfully\";\n            return RedirectToAction(nameof(ListApps));\n        }\n\n        [HttpGet]\n        [Route(\"create\")]\n        public async Task<IActionResult> CreateApp()\n        {\n            var stores = await GetOwnedStores();\n            if (stores.Length == 0)\n            {\n                StatusMessage = \"Error: You must have created at least one store\";\n                return RedirectToAction(nameof(ListApps));\n            }\n            var vm = new CreateAppViewModel();\n            vm.SetStores(stores);\n            return View(vm);\n        }\n\n        [HttpPost]\n        [Route(\"create\")]\n        public async Task<IActionResult> CreateApp(CreateAppViewModel vm)\n        {\n            var stores = await GetOwnedStores();\n            if (stores.Length == 0)\n            {\n                StatusMessage = \"Error: You must own at least one store\";\n                return RedirectToAction(nameof(ListApps));\n            }\n            var selectedStore = vm.SelectedStore;\n            vm.SetStores(stores);\n            vm.SelectedStore = selectedStore;\n\n            if (!Enum.TryParse<AppType>(vm.SelectedAppType, out AppType appType))\n                ModelState.AddModelError(nameof(vm.SelectedAppType), \"Invalid App Type\");\n\n            if (!ModelState.IsValid)\n            {\n                return View(vm);\n            }\n\n            if (!stores.Any(s => s.Id == selectedStore))\n            {\n                StatusMessage = \"Error: You are not owner of this store\";\n                return RedirectToAction(nameof(ListApps));\n            }\n            var id = Encoders.Base58.EncodeData(RandomUtils.GetBytes(32));\n            using (var ctx = _ContextFactory.CreateContext())\n            {\n                var appData = new AppData() { Id = id };\n                appData.StoreDataId = selectedStore;\n                appData.Name = vm.Name;\n                appData.AppType = appType.ToString();\n                ctx.Apps.Add(appData);\n                await ctx.SaveChangesAsync();\n            }\n            StatusMessage = \"App successfully created\";\n\n            if (appType == AppType.PointOfSale)\n                return RedirectToAction(nameof(UpdatePointOfSale), new { appId = id });\n            return RedirectToAction(nameof(ListApps));\n        }\n\n        [HttpGet]\n        [Route(\"{appId}\/delete\")]\n        public async Task<IActionResult> DeleteApp(string appId)\n        {\n            var appData = await GetOwnedApp(appId);\n            if (appData == null)\n                return NotFound();\n            return View(\"Confirm\", new ConfirmModel()\n            {\n                Title = $\"Delete app {appData.Name} ({appData.AppType})\",\n                Description = \"This app will be removed from this store\",\n                Action = \"Delete\"\n            });\n        }\n\n        private async Task<AppData> GetOwnedApp(string appId, AppType? type = null)\n        {\n            var userId = GetUserId();\n            using (var ctx = _ContextFactory.CreateContext())\n            {\n                var app = await ctx.UserStore\n                                .Where(us => us.ApplicationUserId == userId && us.Role == StoreRoles.Owner)\n                                .SelectMany(us => us.StoreData.Apps.Where(a => a.Id == appId))\n                   .FirstOrDefaultAsync();\n                if (app == null)\n                    return null;\n                if (type != null && type.Value.ToString() != app.AppType)\n                    return null;\n                return app;\n            }\n        }\n\n        private async Task<StoreData[]> GetOwnedStores()\n        {\n            var userId = GetUserId();\n            using (var ctx = _ContextFactory.CreateContext())\n            {\n                return await ctx.UserStore\n                    .Where(us => us.ApplicationUserId == userId && us.Role == StoreRoles.Owner)\n                    .Select(u => u.StoreData)\n                    .ToArrayAsync();\n            }\n        }\n\n        private async Task<bool> DeleteApp(AppData appData)\n        {\n            using (var ctx = _ContextFactory.CreateContext())\n            {\n                ctx.Apps.Add(appData);\n                ctx.Entry<AppData>(appData).State = EntityState.Deleted;\n                return await ctx.SaveChangesAsync() == 1;\n            }\n        }\n\n        private async Task<ListAppsViewModel.ListAppViewModel[]> GetAllApps()\n        {\n            var userId = GetUserId();\n            using (var ctx = _ContextFactory.CreateContext())\n            {\n                return await ctx.UserStore\n                    .Where(us => us.ApplicationUserId == userId)\n                    .Join(ctx.Apps, us => us.StoreDataId, app => app.StoreDataId,\n                    (us, app) =>\n                    new ListAppsViewModel.ListAppViewModel()\n                    {\n                        IsOwner = us.Role == StoreRoles.Owner,\n                        StoreId = us.StoreDataId,\n                        StoreName = us.StoreData.StoreName,\n                        AppName = app.Name,\n                        AppType = app.AppType,\n                        Id = app.Id\n                    })\n                    .ToArrayAsync();\n            }\n        }\n\n        private string GetUserId()\n        {\n            return _UserManager.GetUserId(User);\n        }\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"33b5ade2b1923c7db5a7bf9bf50fd69994bafb97","subject":"padding","message":"padding\n","repos":"btcpayserver\/btcpayserver,btcpayserver\/btcpayserver,btcpayserver\/btcpayserver,btcpayserver\/btcpayserver","old_file":"BTCPayServer\/Views\/Manage\/AddApiKey.cshtml","new_file":"BTCPayServer\/Views\/Manage\/AddApiKey.cshtml","new_contents":"@using BTCPayServer.Client\n@using BTCPayServer.Controllers\n@using BTCPayServer.Security.GreenField\n@model ManageController.AddApiKeyViewModel\n\n@{\n    ViewData.SetActivePageAndTitle(ManageNavPages.APIKeys, \"Generate API Key\");\n}\n\n@section PageHeadContent {\n    <style>\n        .remove-btn { font-size: 1.5rem; border-radius: 0; }\n        .remove-btn:hover { background-color: #CCCCCC; }\n    <\/style>\n}\n\n@section PageFootContent {\n    <partial name=\"_ValidationScriptsPartial\"\/>\n    <script>\n        delegate('click', `form button[value*=':']`, function (e) {\n            const { form, value } = e.target\n            const [action] = form.getAttribute('action').split('#')\n            const anchor = value.replace(\/:.*\/, '')\n            form.setAttribute('action', `${action}#${anchor}`)\n        })\n    <\/script>\n}\n\n<h2 class=\"mb-3\">@ViewData[\"PageTitle\"]<\/h2>\n\n<p>Generate a new api key to use BTCPay through its API.<\/p>\n\n<form method=\"post\" asp-action=\"AddApiKey\">\n    <div asp-validation-summary=\"All\" class=\"text-danger\"><\/div>\n\n    <div class=\"form-group\">\n        <label asp-for=\"Label\" class=\"form-label\"><\/label>\n        <input asp-for=\"Label\" class=\"form-control\"\/>\n        <span asp-validation-for=\"Label\" class=\"text-danger\"><\/span>\n    <\/div>\n\n    <h5 class=\"mt-4 mb-3\">Permissions<\/h5>\n    <div class=\"list-group mb-4\">\n        @for (int i = 0; i < Model.PermissionValues.Count; i++)\n        {\n            @if (Model.PermissionValues[i].Forbidden)\n            {\n                <input type=\"hidden\" asp-for=\"PermissionValues[i].Value\" value=\"false\" \/>\n            }\n            else\n            {\n                <div class=\"list-group-item py-3\">\n                    <input type=\"hidden\" asp-for=\"PermissionValues[i].Permission\" \/>\n                    @if (Policies.IsStorePolicy(Model.PermissionValues[i].Permission))\n                    {\n                        <input type=\"hidden\" asp-for=\"PermissionValues[i].StoreMode\" value=\"@Model.PermissionValues[i].StoreMode\" \/>\n                        @if (Model.PermissionValues[i].StoreMode == ManageController.AddApiKeyViewModel.ApiKeyStoreMode.AllStores)\n                        {\n                            <div class=\"form-check\">\n                                <input id=\"@Model.PermissionValues[i].Permission\" type=\"checkbox\" asp-for=\"PermissionValues[i].Value\" class=\"form-check-input ms-n4\"\/>\n                                <label for=\"@Model.PermissionValues[i].Permission\" class=\"h5 form-check-label me-2 mb-1\">\n                                    <span class=\"me-lg-1\">@Model.PermissionValues[i].Title<\/span>\n                                    <small class=\"text-muted text-break d-block my-2 d-lg-inline-block my-lg-0\">@Model.PermissionValues[i].Permission<\/small>\n                                <\/label>\n                                <div>\n                                    <span asp-validation-for=\"PermissionValues[i].Value\" class=\"text-danger\"><\/span>\n                                    <div class=\"text-muted\">@Model.PermissionValues[i].Description<\/div>\n                                    @if (Model.Stores.Any())\n                                    {\n                                        <button type=\"submit\" class=\"btn btn-link p-0\" name=\"command\" value=\"@($\"{Model.PermissionValues[i].Permission}:change-store-mode\")\">Select specific stores<\/button>\n                                    }\n                                <\/div>\n                            <\/div>\n                        }\n                        else\n                        {\n                            <h5 class=\"mb-1\" id=\"@Model.PermissionValues[i].Permission\">\n                                <span class=\"me-lg-1\">@Model.PermissionValues[i].Title<\/span>\n                                <small class=\"text-muted text-break d-block my-2 d-lg-inline-block my-lg-0\">@Model.PermissionValues[i].Permission<\/small>\n                            <\/h5>\n                            <div class=\"text-muted\">@Model.PermissionValues[i].Description<\/div>\n                            <button type=\"submit\" class=\"btn btn-link p-0\" name=\"command\" value=\"@($\"{Model.PermissionValues[i].Permission}:change-store-mode\")\">Give permission to all stores instead<\/button>\n\n                            @if (!Model.Stores.Any())\n                            {\n                                <p class=\"text-warning mt-2 mb-0\">\n                                    You currently have no stores configured.\n                                <\/p>\n                            }\n                            @for (var index = 0; index < Model.PermissionValues[i].SpecificStores.Count; index++)\n                            {\n                                <div class=\"input-group my-3\">\n                                    @if (Model.PermissionValues[i].SpecificStores[index] == null)\n                                    {\n                                        <select asp-for=\"PermissionValues[i].SpecificStores[index]\" class=\"form-select w-auto flex-grow-0\" asp-items=\"@(new SelectList(Model.Stores.Where(data => !Model.PermissionValues[i].SpecificStores.Contains(data.Id)), nameof(StoreData.Id), nameof(StoreData.StoreName)))\"><\/select>\n                                    }\n                                    else\n                                    {\n                                        var store = Model.Stores.SingleOrDefault(data => data.Id == Model.PermissionValues[i].SpecificStores[index]);\n                                        <select asp-for=\"PermissionValues[i].SpecificStores[index]\" class=\"form-select w-auto flex-grow-0\" asp-items=\"@(new SelectList(new[] {store}, nameof(StoreData.Id), nameof(StoreData.StoreName), store.Id))\"><\/select>\n                                    }\n                                    <span asp-validation-for=\"PermissionValues[i].SpecificStores[index]\" class=\"text-danger\"><\/span>\n                                    <button type=\"submit\" title=\"Remove Store Permission\" name=\"command\" value=\"@($\"{Model.PermissionValues[i].Permission}:remove-store:{index}\")\" class=\"btn btn-danger\">\n                                        Remove\n                                    <\/button>\n                                <\/div>\n                            }\n                            @if (Model.PermissionValues[i].SpecificStores.Count < Model.Stores.Length)\n                            {\n                                <div class=\"mt-3 mb-2\">\n                                    <button type=\"submit\" name=\"command\" value=\"@($\"{Model.PermissionValues[i].Permission}:add-store\")\" class=\"btn btn-secondary\">Add another store<\/button>\n                                <\/div>\n                            }\n                        }\n                    }\n                    else\n                    {\n                        <div class=\"form-check\">\n                            <input id=\"@Model.PermissionValues[i].Permission\" type=\"checkbox\" asp-for=\"PermissionValues[i].Value\" class=\"form-check-input ms-n4\" \/>\n                            <label for=\"@Model.PermissionValues[i].Permission\" class=\"h5 form-check-label me-2 mb-1\">\n                                <span class=\"me-lg-1\">@Model.PermissionValues[i].Title<\/span>\n                                <small class=\"text-muted text-break d-block my-2 d-lg-inline-block my-lg-0\">@Model.PermissionValues[i].Permission<\/small>\n                            <\/label>\n                            <div>\n                                <span asp-validation-for=\"PermissionValues[i].Value\" class=\"text-danger\"><\/span>\n                                <span class=\"text-muted\">@Model.PermissionValues[i].Description<\/span>\n                            <\/div>\n                        <\/div>  \n                    }\n                <\/div>\n            }\n        }\n    <\/div>\n\n    <button type=\"submit\" class=\"btn btn-primary\" id=\"Generate\">Generate API Key<\/button>\n<\/form>\n","old_contents":"@using BTCPayServer.Client\n@using BTCPayServer.Controllers\n@using BTCPayServer.Security.GreenField\n@model ManageController.AddApiKeyViewModel\n\n@{\n    ViewData.SetActivePageAndTitle(ManageNavPages.APIKeys, \"Generate API Key\");\n}\n\n@section PageHeadContent {\n    <style>\n        .remove-btn { font-size: 1.5rem; border-radius: 0; }\n        .remove-btn:hover { background-color: #CCCCCC; }\n    <\/style>\n}\n\n@section PageFootContent {\n    <partial name=\"_ValidationScriptsPartial\"\/>\n    <script>\n        delegate('click', `form button[value*=':']`, function (e) {\n            const { form, value } = e.target\n            const [action] = form.getAttribute('action').split('#')\n            const anchor = value.replace(\/:.*\/, '')\n            form.setAttribute('action', `${action}#${anchor}`)\n        })\n    <\/script>\n}\n\n<h2 class=\"mb-3\">@ViewData[\"PageTitle\"]<\/h2>\n\n<p>Generate a new api key to use BTCPay through its API.<\/p>\n\n<form method=\"post\" asp-action=\"AddApiKey\">\n    <div asp-validation-summary=\"All\" class=\"text-danger\"><\/div>\n\n    <div class=\"form-group\">\n        <label asp-for=\"Label\" class=\"form-label\"><\/label>\n        <input asp-for=\"Label\" class=\"form-control\"\/>\n        <span asp-validation-for=\"Label\" class=\"text-danger\"><\/span>\n    <\/div>\n\n    <h5 class=\"mt-5 mb-3\">Permissions<\/h5>\n    <div class=\"list-group mb-4\">\n        @for (int i = 0; i < Model.PermissionValues.Count; i++)\n        {\n            @if (Model.PermissionValues[i].Forbidden)\n            {\n                <input type=\"hidden\" asp-for=\"PermissionValues[i].Value\" value=\"false\" \/>\n            }\n            else\n            {\n                <div class=\"list-group-item py-3\">\n                    <input type=\"hidden\" asp-for=\"PermissionValues[i].Permission\" \/>\n                    @if (Policies.IsStorePolicy(Model.PermissionValues[i].Permission))\n                    {\n                        <input type=\"hidden\" asp-for=\"PermissionValues[i].StoreMode\" value=\"@Model.PermissionValues[i].StoreMode\" \/>\n                        @if (Model.PermissionValues[i].StoreMode == ManageController.AddApiKeyViewModel.ApiKeyStoreMode.AllStores)\n                        {\n                            <div class=\"form-check\">\n                                <input id=\"@Model.PermissionValues[i].Permission\" type=\"checkbox\" asp-for=\"PermissionValues[i].Value\" class=\"form-check-input ms-n4\"\/>\n                                <label for=\"@Model.PermissionValues[i].Permission\" class=\"h5 form-check-label me-2 mb-1\">\n                                    <span class=\"me-lg-1\">@Model.PermissionValues[i].Title<\/span>\n                                    <small class=\"text-muted text-break d-block my-2 d-lg-inline-block my-lg-0\">@Model.PermissionValues[i].Permission<\/small>\n                                <\/label>\n                                <div>\n                                    <span asp-validation-for=\"PermissionValues[i].Value\" class=\"text-danger\"><\/span>\n                                    <div class=\"text-muted\">@Model.PermissionValues[i].Description<\/div>\n                                    @if (Model.Stores.Any())\n                                    {\n                                        <button type=\"submit\" class=\"btn btn-link p-0\" name=\"command\" value=\"@($\"{Model.PermissionValues[i].Permission}:change-store-mode\")\">Select specific stores<\/button>\n                                    }\n                                <\/div>\n                            <\/div>\n                        }\n                        else\n                        {\n                            <h5 class=\"mb-1\" id=\"@Model.PermissionValues[i].Permission\">\n                                <span class=\"me-lg-1\">@Model.PermissionValues[i].Title<\/span>\n                                <small class=\"text-muted text-break d-block my-2 d-lg-inline-block my-lg-0\">@Model.PermissionValues[i].Permission<\/small>\n                            <\/h5>\n                            <div class=\"text-muted\">@Model.PermissionValues[i].Description<\/div>\n                            <button type=\"submit\" class=\"btn btn-link p-0\" name=\"command\" value=\"@($\"{Model.PermissionValues[i].Permission}:change-store-mode\")\">Give permission to all stores instead<\/button>\n\n                            @if (!Model.Stores.Any())\n                            {\n                                <p class=\"text-warning mt-2 mb-0\">\n                                    You currently have no stores configured.\n                                <\/p>\n                            }\n                            @for (var index = 0; index < Model.PermissionValues[i].SpecificStores.Count; index++)\n                            {\n                                <div class=\"input-group my-3\">\n                                    @if (Model.PermissionValues[i].SpecificStores[index] == null)\n                                    {\n                                        <select asp-for=\"PermissionValues[i].SpecificStores[index]\" class=\"form-select w-auto flex-grow-0\" asp-items=\"@(new SelectList(Model.Stores.Where(data => !Model.PermissionValues[i].SpecificStores.Contains(data.Id)), nameof(StoreData.Id), nameof(StoreData.StoreName)))\"><\/select>\n                                    }\n                                    else\n                                    {\n                                        var store = Model.Stores.SingleOrDefault(data => data.Id == Model.PermissionValues[i].SpecificStores[index]);\n                                        <select asp-for=\"PermissionValues[i].SpecificStores[index]\" class=\"form-select w-auto flex-grow-0\" asp-items=\"@(new SelectList(new[] {store}, nameof(StoreData.Id), nameof(StoreData.StoreName), store.Id))\"><\/select>\n                                    }\n                                    <span asp-validation-for=\"PermissionValues[i].SpecificStores[index]\" class=\"text-danger\"><\/span>\n                                    <button type=\"submit\" title=\"Remove Store Permission\" name=\"command\" value=\"@($\"{Model.PermissionValues[i].Permission}:remove-store:{index}\")\" class=\"btn btn-danger\">\n                                        Remove\n                                    <\/button>\n                                <\/div>\n                            }\n                            @if (Model.PermissionValues[i].SpecificStores.Count < Model.Stores.Length)\n                            {\n                                <div class=\"mt-3 mb-2\">\n                                    <button type=\"submit\" name=\"command\" value=\"@($\"{Model.PermissionValues[i].Permission}:add-store\")\" class=\"btn btn-secondary\">Add another store<\/button>\n                                <\/div>\n                            }\n                        }\n                    }\n                    else\n                    {\n                        <div class=\"form-check\">\n                            <input id=\"@Model.PermissionValues[i].Permission\" type=\"checkbox\" asp-for=\"PermissionValues[i].Value\" class=\"form-check-input ms-n4\" \/>\n                            <label for=\"@Model.PermissionValues[i].Permission\" class=\"h5 form-check-label me-2 mb-1\">\n                                <span class=\"me-lg-1\">@Model.PermissionValues[i].Title<\/span>\n                                <small class=\"text-muted text-break d-block my-2 d-lg-inline-block my-lg-0\">@Model.PermissionValues[i].Permission<\/small>\n                            <\/label>\n                            <div>\n                                <span asp-validation-for=\"PermissionValues[i].Value\" class=\"text-danger\"><\/span>\n                                <span class=\"text-muted\">@Model.PermissionValues[i].Description<\/span>\n                            <\/div>\n                        <\/div>  \n                    }\n                <\/div>\n            }\n        }\n    <\/div>\n\n    <button type=\"submit\" class=\"btn btn-primary\" id=\"Generate\">Generate API Key<\/button>\n<\/form>\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"c6c222e4bb77ddb0503b6da2eab0c7f4004d799e","subject":"Commnet","message":"Commnet\n","repos":"jefking\/King.Azure.Imaging,jefking\/King.Azure.Imaging,jefking\/King.Azure.Imaging","old_file":"King.Azure.Imaging\/Interfaces.cs","new_file":"King.Azure.Imaging\/Interfaces.cs","new_contents":"\ufeffnamespace King.Azure.Imaging\n{\n    using System.Collections.Generic;\n    using System.IO;\n    using System.Threading.Tasks;\n\n    #region IImagePreprocessor\n    \/\/\/ <summary>\n    \/\/\/ Image Preprocessor Interface\n    \/\/\/ <\/summary>\n    public interface IImagePreprocessor\n    {\n        #region Methods\n        \/\/\/ <summary>\n        \/\/\/ Preprocess uploaded image\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"content\">Content<\/param>\n        \/\/\/ <param name=\"contentType\">Content Type<\/param>\n        \/\/\/ <param name=\"fileName\">File Name<\/param>\n        \/\/\/ <returns>Task<\/returns>\n        Task Process(byte[] content, string contentType, string fileName);\n        #endregion\n    }\n    #endregion\n\n    #region IStorageElements\n    \/\/\/ <summary>\n    \/\/\/ Storage Elements Interface\n    \/\/\/ <\/summary>\n    public interface IStorageElements\n    {\n        #region Properties\n        \/\/\/ <summary>\n        \/\/\/ Container to store images\n        \/\/\/ <\/summary>\n        string Container\n        {\n            get;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Queue to save tasks to\n        \/\/\/ <\/summary>\n        string Queue\n        {\n            get;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Table for storing image meta-data\n        \/\/\/ <\/summary>\n        string Table\n        {\n            get;\n        }\n        #endregion\n    }\n    #endregion\n\n    #region IVersions\n    public interface IVersions\n    {\n        #region Methods\n        IDictionary<string, IImageVersion> Images\n        {\n            get;\n        }\n        #endregion\n    }\n    #endregion\n\n    #region IImageStreamer\n    public interface IImageStreamer\n    {\n        Task<Stream> Get(string file);\n\n        string ContentType\n        {\n            get;\n        }\n    }\n    #endregion\n\n    #region IImageVersion\n    \/\/\/ <summary>\n    \/\/\/ Image Version to be generated automatically\n    \/\/\/ <\/summary>\n    \/\/\/ <remarks>\n    \/\/\/ Specify either Width or Height you don't need to have both.\n    \/\/\/ <\/remarks>\n    public interface IImageVersion\n    {\n        #region Properties\n        \/\/\/ <summary>\n        \/\/\/ Image Width\n        \/\/\/ <\/summary>\n        int Width\n        {\n            get;\n            set;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Image Height\n        \/\/\/ <\/summary>\n        int Height\n        {\n            get;\n            set;\n        }\n        #endregion\n    }\n    #endregion\n}","old_contents":"\ufeffnamespace King.Azure.Imaging\n{\n    using System.Collections.Generic;\n    using System.IO;\n    using System.Threading.Tasks;\n\n    #region IImagePreprocessor\n    \/\/\/ <summary>\n    \/\/\/ Image Preprocessor Interface\n    \/\/\/ <\/summary>\n    public interface IImagePreprocessor\n    {\n        #region Methods\n        \/\/\/ <summary>\n        \/\/\/ Preprocess uploaded image\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"content\">Content<\/param>\n        \/\/\/ <param name=\"contentType\">Content Type<\/param>\n        \/\/\/ <param name=\"fileName\">File Name<\/param>\n        \/\/\/ <returns>Task<\/returns>\n        Task Process(byte[] content, string contentType, string fileName);\n        #endregion\n    }\n    #endregion\n\n    #region IStorageElements\n    \/\/\/ <summary>\n    \/\/\/ Storage Elements Interface\n    \/\/\/ <\/summary>\n    public interface IStorageElements\n    {\n        #region Properties\n        \/\/\/ <summary>\n        \/\/\/ Container to store images\n        \/\/\/ <\/summary>\n        string Container\n        {\n            get;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Queue to save tasks to\n        \/\/\/ <\/summary>\n        string Queue\n        {\n            get;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Table for storing image meta-data\n        \/\/\/ <\/summary>\n        string Table\n        {\n            get;\n        }\n        #endregion\n    }\n    #endregion\n\n    #region IVersions\n    public interface IVersions\n    {\n        #region Methods\n        IDictionary<string, IImageVersion> Images\n        {\n            get;\n        }\n        #endregion\n    }\n    #endregion\n\n    #region IImageStreamer\n    public interface IImageStreamer\n    {\n        Task<Stream> Get(string file);\n\n        string ContentType\n        {\n            get;\n        }\n    }\n    #endregion\n\n    #region IImageVersion\n    public interface IImageVersion\n    {\n        #region Properties\n        \/\/\/ <summary>\n        \/\/\/ Image Width\n        \/\/\/ <\/summary>\n        int Width\n        {\n            get;\n            set;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Image Height\n        \/\/\/ <\/summary>\n        int Height\n        {\n            get;\n            set;\n        }\n        #endregion\n    }\n    #endregion\n}","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"fb12b26e11f2206508a3634e664f176569767ea4","subject":"Even if we don't use it yet, we still want a name for it","message":"Even if we don't use it yet, we still want a name for it\n","repos":"KraXarN\/KraxbotOSS","old_file":"KraxbotOSS\/FormLogin.Designer.cs","new_file":"KraxbotOSS\/FormLogin.Designer.cs","new_contents":"\ufeffnamespace KraxbotOSS\n{\n    partial class FormLogin\n    {\n        \/\/\/ <summary>\n        \/\/\/ Required designer variable.\n        \/\/\/ <\/summary>\n        private System.ComponentModel.IContainer components = null;\n\n        \/\/\/ <summary>\n        \/\/\/ Clean up any resources being used.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"disposing\">true if managed resources should be disposed; otherwise, false.<\/param>\n        protected override void Dispose(bool disposing)\n        {\n            if (disposing && (components != null))\n            {\n                components.Dispose();\n            }\n            base.Dispose(disposing);\n        }\n\n        #region Windows Form Designer generated code\n\n        \/\/\/ <summary>\n        \/\/\/ Required method for Designer support - do not modify\n        \/\/\/ the contents of this method with the code editor.\n        \/\/\/ <\/summary>\n        private void InitializeComponent()\n        {\n            this.groupBox1 = new System.Windows.Forms.GroupBox();\n            this.tbUsername = new System.Windows.Forms.TextBox();\n            this.groupBox2 = new System.Windows.Forms.GroupBox();\n            this.tbPassword = new System.Windows.Forms.TextBox();\n            this.btnLogin = new System.Windows.Forms.Button();\n            this.cbSaveLogin = new System.Windows.Forms.CheckBox();\n            this.groupBox1.SuspendLayout();\n            this.groupBox2.SuspendLayout();\n            this.SuspendLayout();\n            \/\/ \n            \/\/ groupBox1\n            \/\/ \n            this.groupBox1.Controls.Add(this.tbUsername);\n            this.groupBox1.Location = new System.Drawing.Point(12, 12);\n            this.groupBox1.Name = \"groupBox1\";\n            this.groupBox1.Size = new System.Drawing.Size(165, 50);\n            this.groupBox1.TabIndex = 0;\n            this.groupBox1.TabStop = false;\n            this.groupBox1.Text = \"Username\";\n            \/\/ \n            \/\/ tbUsername\n            \/\/ \n            this.tbUsername.Location = new System.Drawing.Point(7, 20);\n            this.tbUsername.Name = \"tbUsername\";\n            this.tbUsername.Size = new System.Drawing.Size(150, 20);\n            this.tbUsername.TabIndex = 0;\n            \/\/ \n            \/\/ groupBox2\n            \/\/ \n            this.groupBox2.Controls.Add(this.tbPassword);\n            this.groupBox2.Location = new System.Drawing.Point(12, 68);\n            this.groupBox2.Name = \"groupBox2\";\n            this.groupBox2.Size = new System.Drawing.Size(165, 50);\n            this.groupBox2.TabIndex = 1;\n            this.groupBox2.TabStop = false;\n            this.groupBox2.Text = \"Password\";\n            \/\/ \n            \/\/ tbPassword\n            \/\/ \n            this.tbPassword.Location = new System.Drawing.Point(7, 20);\n            this.tbPassword.Name = \"tbPassword\";\n            this.tbPassword.Size = new System.Drawing.Size(150, 20);\n            this.tbPassword.TabIndex = 0;\n            this.tbPassword.UseSystemPasswordChar = true;\n            \/\/ \n            \/\/ btnLogin\n            \/\/ \n            this.btnLogin.Location = new System.Drawing.Point(12, 148);\n            this.btnLogin.Name = \"btnLogin\";\n            this.btnLogin.Size = new System.Drawing.Size(165, 23);\n            this.btnLogin.TabIndex = 2;\n            this.btnLogin.Text = \"Login\";\n            this.btnLogin.UseVisualStyleBackColor = true;\n            this.btnLogin.Click += new System.EventHandler(this.btnLogin_Click);\n            \/\/ \n            \/\/ cbSaveLogin\n            \/\/ \n            this.cbSaveLogin.AutoSize = true;\n            this.cbSaveLogin.Location = new System.Drawing.Point(12, 125);\n            this.cbSaveLogin.Name = \"cbSaveLogin\";\n            this.cbSaveLogin.Size = new System.Drawing.Size(98, 17);\n            this.cbSaveLogin.TabIndex = 3;\n            this.cbSaveLogin.Text = \"Remember Me\";\n            this.cbSaveLogin.UseVisualStyleBackColor = true;\n            \/\/ \n            \/\/ FormLogin\n            \/\/ \n            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);\n            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;\n            this.ClientSize = new System.Drawing.Size(187, 180);\n            this.Controls.Add(this.cbSaveLogin);\n            this.Controls.Add(this.btnLogin);\n            this.Controls.Add(this.groupBox2);\n            this.Controls.Add(this.groupBox1);\n            this.MaximizeBox = false;\n            this.MinimizeBox = false;\n            this.Name = \"FormLogin\";\n            this.ShowIcon = false;\n            this.ShowInTaskbar = false;\n            this.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide;\n            this.Text = \"Login\";\n            this.TopMost = true;\n            this.groupBox1.ResumeLayout(false);\n            this.groupBox1.PerformLayout();\n            this.groupBox2.ResumeLayout(false);\n            this.groupBox2.PerformLayout();\n            this.ResumeLayout(false);\n            this.PerformLayout();\n\n        }\n\n        #endregion\n\n        private System.Windows.Forms.GroupBox groupBox1;\n        private System.Windows.Forms.TextBox tbUsername;\n        private System.Windows.Forms.GroupBox groupBox2;\n        private System.Windows.Forms.TextBox tbPassword;\n        private System.Windows.Forms.Button btnLogin;\n        private System.Windows.Forms.CheckBox cbSaveLogin;\n    }\n}","old_contents":"\ufeffnamespace KraxbotOSS\n{\n    partial class FormLogin\n    {\n        \/\/\/ <summary>\n        \/\/\/ Required designer variable.\n        \/\/\/ <\/summary>\n        private System.ComponentModel.IContainer components = null;\n\n        \/\/\/ <summary>\n        \/\/\/ Clean up any resources being used.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"disposing\">true if managed resources should be disposed; otherwise, false.<\/param>\n        protected override void Dispose(bool disposing)\n        {\n            if (disposing && (components != null))\n            {\n                components.Dispose();\n            }\n            base.Dispose(disposing);\n        }\n\n        #region Windows Form Designer generated code\n\n        \/\/\/ <summary>\n        \/\/\/ Required method for Designer support - do not modify\n        \/\/\/ the contents of this method with the code editor.\n        \/\/\/ <\/summary>\n        private void InitializeComponent()\n        {\n            this.groupBox1 = new System.Windows.Forms.GroupBox();\n            this.tbUsername = new System.Windows.Forms.TextBox();\n            this.groupBox2 = new System.Windows.Forms.GroupBox();\n            this.tbPassword = new System.Windows.Forms.TextBox();\n            this.btnLogin = new System.Windows.Forms.Button();\n            this.checkBox1 = new System.Windows.Forms.CheckBox();\n            this.groupBox1.SuspendLayout();\n            this.groupBox2.SuspendLayout();\n            this.SuspendLayout();\n            \/\/ \n            \/\/ groupBox1\n            \/\/ \n            this.groupBox1.Controls.Add(this.tbUsername);\n            this.groupBox1.Location = new System.Drawing.Point(12, 12);\n            this.groupBox1.Name = \"groupBox1\";\n            this.groupBox1.Size = new System.Drawing.Size(165, 50);\n            this.groupBox1.TabIndex = 0;\n            this.groupBox1.TabStop = false;\n            this.groupBox1.Text = \"Username\";\n            \/\/ \n            \/\/ tbUsername\n            \/\/ \n            this.tbUsername.Location = new System.Drawing.Point(7, 20);\n            this.tbUsername.Name = \"tbUsername\";\n            this.tbUsername.Size = new System.Drawing.Size(150, 20);\n            this.tbUsername.TabIndex = 0;\n            \/\/ \n            \/\/ groupBox2\n            \/\/ \n            this.groupBox2.Controls.Add(this.tbPassword);\n            this.groupBox2.Location = new System.Drawing.Point(12, 68);\n            this.groupBox2.Name = \"groupBox2\";\n            this.groupBox2.Size = new System.Drawing.Size(165, 50);\n            this.groupBox2.TabIndex = 1;\n            this.groupBox2.TabStop = false;\n            this.groupBox2.Text = \"Password\";\n            \/\/ \n            \/\/ tbPassword\n            \/\/ \n            this.tbPassword.Location = new System.Drawing.Point(7, 20);\n            this.tbPassword.Name = \"tbPassword\";\n            this.tbPassword.Size = new System.Drawing.Size(150, 20);\n            this.tbPassword.TabIndex = 0;\n            this.tbPassword.UseSystemPasswordChar = true;\n            \/\/ \n            \/\/ btnLogin\n            \/\/ \n            this.btnLogin.Location = new System.Drawing.Point(12, 148);\n            this.btnLogin.Name = \"btnLogin\";\n            this.btnLogin.Size = new System.Drawing.Size(165, 23);\n            this.btnLogin.TabIndex = 2;\n            this.btnLogin.Text = \"Login\";\n            this.btnLogin.UseVisualStyleBackColor = true;\n            this.btnLogin.Click += new System.EventHandler(this.btnLogin_Click);\n            \/\/ \n            \/\/ checkBox1\n            \/\/ \n            this.checkBox1.AutoSize = true;\n            this.checkBox1.Location = new System.Drawing.Point(12, 125);\n            this.checkBox1.Name = \"checkBox1\";\n            this.checkBox1.Size = new System.Drawing.Size(98, 17);\n            this.checkBox1.TabIndex = 3;\n            this.checkBox1.Text = \"Remember Me\";\n            this.checkBox1.UseVisualStyleBackColor = true;\n            \/\/ \n            \/\/ FormLogin\n            \/\/ \n            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);\n            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;\n            this.ClientSize = new System.Drawing.Size(187, 180);\n            this.Controls.Add(this.checkBox1);\n            this.Controls.Add(this.btnLogin);\n            this.Controls.Add(this.groupBox2);\n            this.Controls.Add(this.groupBox1);\n            this.MaximizeBox = false;\n            this.MinimizeBox = false;\n            this.Name = \"FormLogin\";\n            this.ShowIcon = false;\n            this.ShowInTaskbar = false;\n            this.SizeGripStyle = System.Windows.Forms.SizeGripStyle.Hide;\n            this.Text = \"Login\";\n            this.TopMost = true;\n            this.groupBox1.ResumeLayout(false);\n            this.groupBox1.PerformLayout();\n            this.groupBox2.ResumeLayout(false);\n            this.groupBox2.PerformLayout();\n            this.ResumeLayout(false);\n            this.PerformLayout();\n\n        }\n\n        #endregion\n\n        private System.Windows.Forms.GroupBox groupBox1;\n        private System.Windows.Forms.TextBox tbUsername;\n        private System.Windows.Forms.GroupBox groupBox2;\n        private System.Windows.Forms.TextBox tbPassword;\n        private System.Windows.Forms.Button btnLogin;\n        private System.Windows.Forms.CheckBox checkBox1;\n    }\n}","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"b5ce26dd2987f813cf1f5f1e2c11ac1c0b460ab5","subject":"add docs to commitcollection","message":"add docs to commitcollection\n","repos":"shana\/libgit2sharp,AMSadek\/libgit2sharp,nulltoken\/libgit2sharp,jorgeamado\/libgit2sharp,jamill\/libgit2sharp,Zoxive\/libgit2sharp,carlosmn\/libgit2sharp,whoisj\/libgit2sharp,vivekpradhanC\/libgit2sharp,shana\/libgit2sharp,mono\/libgit2sharp,Skybladev2\/libgit2sharp,vorou\/libgit2sharp,ethomson\/libgit2sharp,GeertvanHorrik\/libgit2sharp,libgit2\/libgit2sharp,github\/libgit2sharp,rcorre\/libgit2sharp,Zoxive\/libgit2sharp,AMSadek\/libgit2sharp,github\/libgit2sharp,OidaTiftla\/libgit2sharp,mono\/libgit2sharp,vivekpradhanC\/libgit2sharp,paulcbetts\/libgit2sharp,psawey\/libgit2sharp,jeffhostetler\/public_libgit2sharp,sushihangover\/libgit2sharp,yishaigalatzer\/LibGit2SharpCheckOutTests,jamill\/libgit2sharp,PKRoma\/libgit2sharp,red-gate\/libgit2sharp,red-gate\/libgit2sharp,paulcbetts\/libgit2sharp,psawey\/libgit2sharp,oliver-feng\/libgit2sharp,dlsteuer\/libgit2sharp,oliver-feng\/libgit2sharp,OidaTiftla\/libgit2sharp,whoisj\/libgit2sharp,dlsteuer\/libgit2sharp,vorou\/libgit2sharp,Skybladev2\/libgit2sharp,rcorre\/libgit2sharp,jorgeamado\/libgit2sharp,nulltoken\/libgit2sharp,AArnott\/libgit2sharp,xoofx\/libgit2sharp,yishaigalatzer\/LibGit2SharpCheckOutTests,GeertvanHorrik\/libgit2sharp,ethomson\/libgit2sharp,xoofx\/libgit2sharp,carlosmn\/libgit2sharp,AArnott\/libgit2sharp,jeffhostetler\/public_libgit2sharp,sushihangover\/libgit2sharp","old_file":"LibGit2Sharp\/CommitCollection.cs","new_file":"LibGit2Sharp\/CommitCollection.cs","new_contents":"\ufeff#region  Copyright (c) 2011 LibGit2Sharp committers\n\n\/\/  The MIT License\n\/\/  \n\/\/  Copyright (c) 2011 LibGit2Sharp committers\n\/\/  \n\/\/  Permission is hereby granted, free of charge, to any person obtaining a copy\n\/\/  of this software and associated documentation files (the \"Software\"), to deal\n\/\/  in the Software without restriction, including without limitation the rights\n\/\/  to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\n\/\/  copies of the Software, and to permit persons to whom the Software is\n\/\/  furnished to do so, subject to the following conditions:\n\/\/  \n\/\/  The above copyright notice and this permission notice shall be included in\n\/\/  all copies or substantial portions of the Software.\n\/\/  \n\/\/  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\/\/  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\/\/  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\/\/  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\/\/  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\/\/  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\/\/  THE SOFTWARE.\n\n#endregion\n\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\n\nnamespace LibGit2Sharp\n{\n    \/\/\/ <summary>\n    \/\/\/   A collection of commits in a <see cref = \"Repository\" \/>\n    \/\/\/ <\/summary>\n    public class CommitCollection : IEnumerable<Commit>\n    {\n        private readonly Repository repo;\n        private CommitEnumerator enumerator;\n        private string pushedSha;\n        private GitSortOptions sortOptions = GitSortOptions.None;\n\n        \/\/\/ <summary>\n        \/\/\/   Initializes a new instance of the <see cref = \"CommitCollection\" \/> class.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name = \"repo\">The repo.<\/param>\n        public CommitCollection(Repository repo)\n        {\n            this.repo = repo;\n        }\n\n        private CommitEnumerator Enumerator\n        {\n            get { return enumerator ?? (enumerator = new CommitEnumerator(repo)); }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/   Gets the <see cref = \"LibGit2Sharp.Commit\" \/> with the specified sha. (This is identical to calling Lookup\/<Commit \/>(sha) on the repo)\n        \/\/\/ <\/summary>\n        public Commit this[string sha]\n        {\n            get { return repo.Lookup<Commit>(sha); }\n        }\n\n        #region IEnumerable<Commit> Members\n\n        public IEnumerator<Commit> GetEnumerator()\n        {\n            Enumerator.Sort(sortOptions);\n            if (string.IsNullOrEmpty(pushedSha))\n            {\n                throw new NotImplementedException();\n            }\n\n            Enumerator.Push(pushedSha);\n            return Enumerator;\n        }\n\n        IEnumerator IEnumerable.GetEnumerator()\n        {\n            return GetEnumerator();\n        }\n\n        #endregion\n\n        \/\/\/ <summary>\n        \/\/\/   Sorts <see cref = \"CommitCollection\" \/> with the specified options.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name = \"options\">The options.<\/param>\n        \/\/\/ <returns><\/returns>\n        public CommitCollection SortBy(GitSortOptions options)\n        {\n            sortOptions = options;\n            return this;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/   Starts enumeratoring the <see cref = \"CommitCollection\" \/> at the specified branch.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name = \"branch\">The branch.<\/param>\n        \/\/\/ <returns><\/returns>\n        public CommitCollection StartingAt(Branch branch)\n        {\n            Ensure.ArgumentNotNull(branch, \"branch\");\n\n            pushedSha = branch.Reference.Target.Sha;\n            return this;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/   Starts enumeratoring the <see cref = \"CommitCollection\" \/> at the specified reference.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name = \"reference\">The reference.<\/param>\n        \/\/\/ <returns><\/returns>\n        public CommitCollection StartingAt(Reference reference)\n        {\n            Ensure.ArgumentNotNull(reference, \"reference\");\n\n            var directReference = reference.ResolveToDirectReference();\n            pushedSha = directReference.Target.Sha;\n            return this;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/   Starts enumeratoring the <see cref = \"CommitCollection\" \/> at the specified sha.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name = \"sha\">The sha.<\/param>\n        \/\/\/ <returns><\/returns>\n        public CommitCollection StartingAt(string sha)\n        {\n            Ensure.ArgumentNotNullOrEmptyString(sha, \"sha\");\n\n            pushedSha = sha;\n            return this;\n        }\n\n        #region Nested type: CommitEnumerator\n\n        public class CommitEnumerator : IEnumerator<Commit>\n        {\n            private readonly Repository repo;\n            private readonly IntPtr walker = IntPtr.Zero;\n            private bool disposed;\n\n            public CommitEnumerator(Repository repo)\n            {\n                this.repo = repo;\n                int res = NativeMethods.git_revwalk_new(out walker, repo.RepoPtr);\n                Ensure.Success(res);\n            }\n\n            #region IEnumerator<Commit> Members\n\n            public Commit Current { get; private set; }\n\n            public void Dispose()\n            {\n                Dispose(true);\n                GC.SuppressFinalize(this);\n            }\n\n            object IEnumerator.Current\n            {\n                get { return Current; }\n            }\n\n            public bool MoveNext()\n            {\n                GitOid oid;\n                var res = NativeMethods.git_revwalk_next(out oid, walker);\n                if (res == (int) GitErrorCode.GIT_EREVWALKOVER) return false;\n\n                Current = repo.Lookup<Commit>(oid);\n\n                return true;\n            }\n\n            public void Reset()\n            {\n                NativeMethods.git_revwalk_reset(walker);\n            }\n\n            #endregion\n\n            private void Dispose(bool disposing)\n            {\n                \/\/ Check to see if Dispose has already been called.\n                if (!disposed)\n                {\n                    \/\/ If disposing equals true, dispose all managed\n                    \/\/ and unmanaged resources.\n                    if (disposing)\n                    {\n                        \/\/ Dispose managed resources.\n                    }\n\n                    \/\/ Call the appropriate methods to clean up\n                    \/\/ unmanaged resources here.\n                    NativeMethods.git_revwalk_free(walker);\n\n                    \/\/ Note disposing has been done.\n                    disposed = true;\n                }\n            }\n\n            ~CommitEnumerator()\n            {\n                \/\/ Do not re-create Dispose clean-up code here.\n                \/\/ Calling Dispose(false) is optimal in terms of\n                \/\/ readability and maintainability.\n                Dispose(false);\n            }\n\n            public void Push(string sha)\n            {\n                var oid = GitOid.FromSha(sha);\n                int res = NativeMethods.git_revwalk_push(walker, ref oid);\n                Ensure.Success(res);\n            }\n\n            public void Sort(GitSortOptions options)\n            {\n                NativeMethods.git_revwalk_sorting(walker, options);\n            }\n        }\n\n        #endregion\n    }\n}","old_contents":"\ufeff#region  Copyright (c) 2011 LibGit2Sharp committers\n\n\/\/  The MIT License\n\/\/  \n\/\/  Copyright (c) 2011 LibGit2Sharp committers\n\/\/  \n\/\/  Permission is hereby granted, free of charge, to any person obtaining a copy\n\/\/  of this software and associated documentation files (the \"Software\"), to deal\n\/\/  in the Software without restriction, including without limitation the rights\n\/\/  to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\n\/\/  copies of the Software, and to permit persons to whom the Software is\n\/\/  furnished to do so, subject to the following conditions:\n\/\/  \n\/\/  The above copyright notice and this permission notice shall be included in\n\/\/  all copies or substantial portions of the Software.\n\/\/  \n\/\/  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\/\/  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\/\/  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\/\/  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\/\/  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\/\/  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\/\/  THE SOFTWARE.\n\n#endregion\n\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\n\nnamespace LibGit2Sharp\n{\n    public class CommitCollection : IEnumerable<Commit>\n    {\n        private readonly Repository repo;\n        private CommitEnumerator enumerator;\n        private string pushedSha;\n        private GitSortOptions sortOptions = GitSortOptions.None;\n\n        public CommitCollection(Repository repo)\n        {\n            this.repo = repo;\n        }\n\n        private CommitEnumerator Enumerator\n        {\n            get { return enumerator ?? (enumerator = new CommitEnumerator(repo)); }\n        }\n\n        public Commit this[string sha]\n        {\n            get { return repo.Lookup<Commit>(sha); }\n        }\n\n        #region IEnumerable<Commit> Members\n\n        public IEnumerator<Commit> GetEnumerator()\n        {\n            Enumerator.Sort(sortOptions);\n            if (string.IsNullOrEmpty(pushedSha))\n            {\n                throw new NotImplementedException();\n            }\n\n            Enumerator.Push(pushedSha);\n            return Enumerator;\n        }\n\n        IEnumerator IEnumerable.GetEnumerator()\n        {\n            return GetEnumerator();\n        }\n\n        #endregion\n\n        public CommitCollection SortBy(GitSortOptions options)\n        {\n            sortOptions = options;\n            return this;\n        }\n\n        public CommitCollection StartingAt(Branch branch)\n        {\n            Ensure.ArgumentNotNull(branch, \"branch\");\n\n            pushedSha = branch.Reference.Target.Sha;\n            return this;\n        }\n\n        public CommitCollection StartingAt(Reference reference)\n        {\n            Ensure.ArgumentNotNull(reference, \"reference\");\n\n            var directReference = reference.ResolveToDirectReference();\n            pushedSha = directReference.Target.Sha;\n            return this;\n        }\n\n        public CommitCollection StartingAt(string sha)\n        {\n            Ensure.ArgumentNotNullOrEmptyString(sha, \"sha\");\n\n            pushedSha = sha;\n            return this;\n        }\n\n        #region Nested type: CommitEnumerator\n\n        public class CommitEnumerator : IEnumerator<Commit>\n        {\n            private readonly Repository repo;\n            private readonly IntPtr walker = IntPtr.Zero;\n            private bool disposed;\n\n            public CommitEnumerator(Repository repo)\n            {\n                this.repo = repo;\n                int res = NativeMethods.git_revwalk_new(out walker, repo.RepoPtr);\n                Ensure.Success(res);\n            }\n\n            #region IEnumerator<Commit> Members\n\n            public Commit Current { get; private set; }\n\n            public void Dispose()\n            {\n                Dispose(true);\n                GC.SuppressFinalize(this);\n            }\n\n            object IEnumerator.Current\n            {\n                get { return Current; }\n            }\n\n            public bool MoveNext()\n            {\n                GitOid oid;\n                var res = NativeMethods.git_revwalk_next(out oid, walker);\n                if (res == (int) GitErrorCode.GIT_EREVWALKOVER) return false;\n\n                Current = repo.Lookup<Commit>(oid);\n\n                return true;\n            }\n\n            public void Reset()\n            {\n                NativeMethods.git_revwalk_reset(walker);\n            }\n\n            #endregion\n\n            private void Dispose(bool disposing)\n            {\n                \/\/ Check to see if Dispose has already been called.\n                if (!disposed)\n                {\n                    \/\/ If disposing equals true, dispose all managed\n                    \/\/ and unmanaged resources.\n                    if (disposing)\n                    {\n                        \/\/ Dispose managed resources.\n                    }\n\n                    \/\/ Call the appropriate methods to clean up\n                    \/\/ unmanaged resources here.\n                    NativeMethods.git_revwalk_free(walker);\n\n                    \/\/ Note disposing has been done.\n                    disposed = true;\n                }\n            }\n\n            ~CommitEnumerator()\n            {\n                \/\/ Do not re-create Dispose clean-up code here.\n                \/\/ Calling Dispose(false) is optimal in terms of\n                \/\/ readability and maintainability.\n                Dispose(false);\n            }\n\n            public void Push(string sha)\n            {\n                var oid = GitOid.FromSha(sha);\n                int res = NativeMethods.git_revwalk_push(walker, ref oid);\n                Ensure.Success(res);\n            }\n\n            public void Sort(GitSortOptions options)\n            {\n                NativeMethods.git_revwalk_sorting(walker, options);\n            }\n        }\n\n        #endregion\n    }\n}","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"966a8d576a89680360f059adcb7d746002802c0d","subject":"Make TryGetValue_decimal_Good2 test environment-independent","message":"Make TryGetValue_decimal_Good2 test environment-independent\n","repos":"ClosedXML\/ClosedXML,igitur\/ClosedXML","old_file":"ClosedXML_Tests\/Excel\/Cells\/XLCellTests.cs","new_file":"ClosedXML_Tests\/Excel\/Cells\/XLCellTests.cs","new_contents":"using ClosedXML.Excel;\nusing NUnit.Framework;\nusing System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Threading;\n\nnamespace ClosedXML_Tests\n{\n    [TestFixture]\n    public class XLCellTests\n    {\n        [Test]\n        public void CellsUsed()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            ws.Cell(1, 1);\n            ws.Cell(2, 2);\n            int count = ws.Range(\"A1:B2\").CellsUsed().Count();\n            Assert.AreEqual(0, count);\n        }\n\n        [Test]\n        public void CellsUsedIncludeStyles1()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            ws.Row(3).Style.Fill.BackgroundColor = XLColor.Red;\n            ws.Column(3).Style.Fill.BackgroundColor = XLColor.Red;\n            ws.Cell(2, 2).Value = \"ASDF\";\n            var range = ws.RangeUsed(XLCellsUsedOptions.All).RangeAddress.ToString();\n            Assert.AreEqual(\"B2:C3\", range);\n        }\n\n        [Test]\n        public void CellsUsedIncludeStyles2()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            ws.Row(2).Style.Fill.BackgroundColor = XLColor.Red;\n            ws.Column(2).Style.Fill.BackgroundColor = XLColor.Red;\n            ws.Cell(3, 3).Value = \"ASDF\";\n            var range = ws.RangeUsed(XLCellsUsedOptions.All).RangeAddress.ToString();\n            Assert.AreEqual(\"B2:C3\", range);\n        }\n\n        [Test]\n        public void CellsUsedIncludeStyles3()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            var range = ws.RangeUsed(XLCellsUsedOptions.All);\n            Assert.AreEqual(null, range);\n        }\n\n        [Test]\n        public void Double_Infinity_is_a_string()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(\"A1\");\n            var doubleList = new List<Double> { 1.0 \/ 0.0 };\n\n            cell.Value = 5;\n            cell.Value = doubleList;\n            Assert.AreEqual(XLDataType.Text, cell.DataType);\n            Assert.AreEqual(CultureInfo.CurrentCulture.NumberFormat.PositiveInfinitySymbol, cell.Value);\n\n            cell.Value = 5;\n            Assert.Throws<ArgumentException>(() => cell.SetValue(doubleList));\n        }\n\n        [Test]\n        public void Double_NaN_is_a_string()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(\"A1\");\n            var doubleList = new List<Double> { 0.0 \/ 0.0 };\n\n            cell.Value = 5;\n            cell.Value = doubleList;\n            Assert.AreEqual(XLDataType.Text, cell.DataType);\n            Assert.AreEqual(CultureInfo.CurrentCulture.NumberFormat.NaNSymbol, cell.Value);\n\n            cell.Value = 5;\n            Assert.Throws<ArgumentException>(() => cell.SetValue(doubleList));\n        }\n\n        [Test]\n        public void InsertData1()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLRange range = ws.Cell(2, 2).InsertData(new[] { \"a\", \"b\", \"c\" });\n            Assert.AreEqual(\"Sheet1!B2:B4\", range.ToString());\n        }\n\n        [Test]\n        public void InsertData2()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLRange range = ws.Cell(2, 2).InsertData(new[] { \"a\", \"b\", \"c\" }, false);\n            Assert.AreEqual(\"Sheet1!B2:B4\", range.ToString());\n        }\n\n        [Test]\n        public void InsertData3()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLRange range = ws.Cell(2, 2).InsertData(new[] { \"a\", \"b\", \"c\" }, true);\n            Assert.AreEqual(\"Sheet1!B2:D2\", range.ToString());\n        }\n\n        [Test]\n        public void InsertData_with_Guids()\n        {\n            var ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            ws.FirstCell().InsertData(Enumerable.Range(1, 20).Select(i => new { Guid = Guid.NewGuid() }));\n\n            Assert.AreEqual(XLDataType.Text, ws.FirstCell().DataType);\n            Assert.AreEqual(Guid.NewGuid().ToString().Length, ws.FirstCell().GetString().Length);\n        }\n\n        [Test]\n        public void IsEmpty1()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(1, 1);\n            bool actual = cell.IsEmpty();\n            bool expected = true;\n            Assert.AreEqual(expected, actual);\n        }\n\n        [Test]\n        public void IsEmpty2()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(1, 1);\n            bool actual = cell.IsEmpty(XLCellsUsedOptions.All);\n            bool expected = true;\n            Assert.AreEqual(expected, actual);\n        }\n\n        [Test]\n        public void IsEmpty3()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(1, 1);\n            cell.Style.Fill.BackgroundColor = XLColor.Red;\n            bool actual = cell.IsEmpty();\n            bool expected = true;\n            Assert.AreEqual(expected, actual);\n        }\n\n        [Test]\n        public void IsEmpty4()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(1, 1);\n            cell.Style.Fill.BackgroundColor = XLColor.Red;\n            bool actual = cell.IsEmpty(XLCellsUsedOptions.AllContents);\n            bool expected = true;\n            Assert.AreEqual(expected, actual);\n        }\n\n        [Test]\n        public void IsEmpty5()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(1, 1);\n            cell.Style.Fill.BackgroundColor = XLColor.Red;\n            bool actual = cell.IsEmpty(XLCellsUsedOptions.All);\n            bool expected = false;\n            Assert.AreEqual(expected, actual);\n        }\n\n        [Test]\n        public void IsEmpty6()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(1, 1);\n            cell.Value = \"X\";\n            bool actual = cell.IsEmpty();\n            bool expected = false;\n            Assert.AreEqual(expected, actual);\n        }\n\n        [Test]\n        public void NaN_is_not_a_number()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(\"A1\");\n            cell.Value = \"NaN\";\n\n            Assert.AreNotEqual(XLDataType.Number, cell.DataType);\n        }\n\n        [Test]\n        public void Nan_is_not_a_number()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(\"A1\");\n            cell.Value = \"Nan\";\n\n            Assert.AreNotEqual(XLDataType.Number, cell.DataType);\n        }\n\n        [Test]\n        public void TryGetValue_Boolean_Bad()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(\"A1\").SetValue(\"ABC\");\n            bool success = cell.TryGetValue(out bool outValue);\n            Assert.IsFalse(success);\n        }\n\n        [Test]\n        public void TryGetValue_Boolean_False()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(\"A1\").SetValue(false);\n            bool success = cell.TryGetValue(out bool outValue);\n            Assert.IsTrue(success);\n            Assert.IsFalse(outValue);\n        }\n\n        [Test]\n        public void TryGetValue_Boolean_Good()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(\"A1\").SetValue(\"True\");\n            bool success = cell.TryGetValue(out bool outValue);\n            Assert.IsTrue(success);\n            Assert.IsTrue(outValue);\n        }\n\n        [Test]\n        public void TryGetValue_Boolean_True()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(\"A1\").SetValue(true);\n            bool success = cell.TryGetValue(out bool outValue);\n            Assert.IsTrue(success);\n            Assert.IsTrue(outValue);\n        }\n\n        [Test]\n        public void TryGetValue_DateTime_Good()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            var date = \"2018-01-01\";\n            bool success = ws.Cell(\"A1\").SetValue(date).TryGetValue(out DateTime outValue);\n            Assert.IsTrue(success);\n            Assert.AreEqual(new DateTime(2018, 1, 1), outValue);\n        }\n\n        [Test]\n        public void TryGetValue_DateTime_BadString()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            var date = \"ABC\";\n            bool success = ws.Cell(\"A1\").SetValue(date).TryGetValue(out DateTime outValue);\n            Assert.IsFalse(success);\n        }\n\n        [Test]\n        public void TryGetValue_DateTime_BadString2()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            var date = 5545454;\n            ws.FirstCell().SetValue(date).DataType = XLDataType.DateTime;\n            bool success = ws.FirstCell().TryGetValue(out DateTime outValue);\n            Assert.IsFalse(success);\n        }\n\n        [Test]\n        public void TryGetValue_RichText_Bad()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(\"A1\").SetValue(\"Anything\");\n            bool success = cell.TryGetValue(out IXLRichText outValue);\n            Assert.IsTrue(success);\n            Assert.AreEqual(cell.RichText, outValue);\n            Assert.AreEqual(\"Anything\", outValue.ToString());\n        }\n\n        [Test]\n        public void TryGetValue_RichText_Good()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(\"A1\");\n            cell.RichText.AddText(\"Anything\");\n            bool success = cell.TryGetValue(out IXLRichText outValue);\n            Assert.IsTrue(success);\n            Assert.AreEqual(cell.RichText, outValue);\n        }\n\n        [Test]\n        public void TryGetValue_TimeSpan_BadString()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            string timeSpan = \"ABC\";\n            bool success = ws.Cell(\"A1\").SetValue(timeSpan).TryGetValue(out TimeSpan outValue);\n            Assert.IsFalse(success);\n        }\n\n        [Test]\n        public void TryGetValue_TimeSpan_Good()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            var timeSpan = new TimeSpan(1, 1, 1);\n            bool success = ws.Cell(\"A1\").SetValue(timeSpan).TryGetValue(out TimeSpan outValue);\n            Assert.IsTrue(success);\n            Assert.AreEqual(timeSpan, outValue);\n        }\n\n        [Test]\n        public void TryGetValue_TimeSpan_GoodString()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            var timeSpan = new TimeSpan(1, 1, 1);\n            bool success = ws.Cell(\"A1\").SetValue(timeSpan.ToString()).TryGetValue(out TimeSpan outValue);\n            Assert.IsTrue(success);\n            Assert.AreEqual(timeSpan, outValue);\n        }\n\n        [Test]\n        public void TryGetValue_sbyte_Bad()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(\"A1\").SetValue(255);\n            bool success = cell.TryGetValue(out sbyte outValue);\n            Assert.IsFalse(success);\n        }\n\n        [Test]\n        public void TryGetValue_sbyte_Bad2()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(\"A1\").SetValue(\"255\");\n            bool success = cell.TryGetValue(out sbyte outValue);\n            Assert.IsFalse(success);\n        }\n\n        [Test]\n        public void TryGetValue_sbyte_Good()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(\"A1\").SetValue(5);\n            bool success = cell.TryGetValue(out sbyte outValue);\n            Assert.IsTrue(success);\n            Assert.AreEqual(5, outValue);\n        }\n\n        [Test]\n        public void TryGetValue_sbyte_Good2()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(\"A1\").SetValue(\"5\");\n            bool success = cell.TryGetValue(out sbyte outValue);\n            Assert.IsTrue(success);\n            Assert.AreEqual(5, outValue);\n        }\n\n        [Test]\n        public void TryGetValue_decimal_Good()\n        {\n            var ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            var cell = ws.Cell(\"A1\").SetValue(\"5\");\n            bool success = cell.TryGetValue(out decimal outValue);\n            Assert.IsTrue(success);\n            Assert.AreEqual(5, outValue);\n        }\n\n        [Test]\n        public void TryGetValue_decimal_Good2()\n        {\n            Thread.CurrentThread.CurrentCulture = CultureInfo.CreateSpecificCulture(\"en-US\");\n\n            var ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            var cell = ws.Cell(\"A1\").SetValue(\"1.60000001869776E-06\");\n            bool success = cell.TryGetValue(out decimal outValue);\n            Assert.IsTrue(success);\n            Assert.AreEqual(1.60000001869776E-06, outValue);\n        }\n\n        [Test]\n        public void TryGetValue_Hyperlink()\n        {\n            using (var wb = new XLWorkbook())\n            {\n                var ws1 = wb.Worksheets.Add(\"Sheet1\");\n                var ws2 = wb.Worksheets.Add(\"Sheet2\");\n\n                var targetCell = ws2.Cell(\"A1\");\n\n                var linkCell1 = ws1.Cell(\"A1\");\n                linkCell1.Value = \"Link to IXLCell\";\n                linkCell1.Hyperlink = new XLHyperlink(targetCell);\n\n                var success = linkCell1.TryGetValue(out XLHyperlink hyperlink);\n                Assert.IsTrue(success);\n                Assert.AreEqual(\"Sheet2!A1\", hyperlink.InternalAddress);\n            }\n        }\n\n        [Test]\n        public void TryGetValue_Unicode_String()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n\n            Boolean success;\n            String outValue;\n\n            success = ws.Cell(\"A1\")\n                .SetValue(\"Site_x0020_Column_x0020_Test\")\n                .TryGetValue(out outValue);\n            Assert.IsTrue(success);\n            Assert.AreEqual(\"Site Column Test\", outValue);\n\n            success = ws.Cell(\"A1\")\n                .SetValue(\"Site_x005F_x0020_Column_x005F_x0020_Test\")\n                .TryGetValue(out outValue);\n\n            Assert.IsTrue(success);\n            Assert.AreEqual(\"Site_x005F_x0020_Column_x005F_x0020_Test\", outValue);\n        }\n\n\n        [Test]\n        public void SetCellValueToGuid()\n        {\n            var ws = new XLWorkbook().AddWorksheet(\"Sheet1\");\n            var guid = Guid.NewGuid();\n            ws.FirstCell().Value = guid;\n            Assert.AreEqual(XLDataType.Text, ws.FirstCell().DataType);\n            Assert.AreEqual(guid.ToString(), ws.FirstCell().Value);\n            Assert.AreEqual(guid.ToString(), ws.FirstCell().GetString());\n\n            guid = Guid.NewGuid();\n            ws.FirstCell().SetValue(guid);\n            Assert.AreEqual(XLDataType.Text, ws.FirstCell().DataType);\n            Assert.AreEqual(guid.ToString(), ws.FirstCell().Value);\n            Assert.AreEqual(guid.ToString(), ws.FirstCell().GetString());\n        }\n\n        [Test]\n        public void SetCellValueToEnum()\n        {\n            var ws = new XLWorkbook().AddWorksheet(\"Sheet1\");\n            var dataType = XLDataType.Number;\n            ws.FirstCell().Value = dataType;\n            Assert.AreEqual(XLDataType.Text, ws.FirstCell().DataType);\n            Assert.AreEqual(dataType.ToString(), ws.FirstCell().Value);\n            Assert.AreEqual(dataType.ToString(), ws.FirstCell().GetString());\n\n            dataType = XLDataType.TimeSpan;\n            ws.FirstCell().SetValue(dataType);\n            Assert.AreEqual(XLDataType.Text, ws.FirstCell().DataType);\n            Assert.AreEqual(dataType.ToString(), ws.FirstCell().Value);\n            Assert.AreEqual(dataType.ToString(), ws.FirstCell().GetString());\n        }\n        [Test]\n        public void SetCellValueToRange()\n        {\n            var ws = new XLWorkbook().AddWorksheet(\"Sheet1\");\n\n            ws.Cell(\"A1\").SetValue(2)\n                .CellRight().SetValue(3)\n                .CellRight().SetValue(5)\n                .CellRight().SetValue(7);\n\n            var range = ws.Range(\"1:1\");\n\n            ws.Cell(\"B2\").Value = range;\n\n            Assert.AreEqual(2, ws.Cell(\"B2\").Value);\n            Assert.AreEqual(3, ws.Cell(\"C2\").Value);\n            Assert.AreEqual(5, ws.Cell(\"D2\").Value);\n            Assert.AreEqual(7, ws.Cell(\"E2\").Value);\n        }\n\n        [Test]\n        public void ValueSetToEmptyString()\n        {\n            string expected = String.Empty;\n\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(1, 1);\n            cell.Value = new DateTime(2000, 1, 2);\n            cell.Value = String.Empty;\n            Assert.AreEqual(expected, cell.GetString());\n            Assert.AreEqual(expected, cell.Value);\n\n            cell.Value = new DateTime(2000, 1, 2);\n            cell.SetValue(string.Empty);\n            Assert.AreEqual(expected, cell.GetString());\n            Assert.AreEqual(expected, cell.Value);\n        }\n\n        [Test]\n        public void ValueSetToNull()\n        {\n            string expected = String.Empty;\n\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(1, 1);\n            cell.Value = new DateTime(2000, 1, 2);\n            cell.Value = null;\n            Assert.AreEqual(expected, cell.GetString());\n            Assert.AreEqual(expected, cell.Value);\n\n            cell.Value = new DateTime(2000, 1, 2);\n            cell.SetValue(null as string);\n            Assert.AreEqual(expected, cell.GetString());\n            Assert.AreEqual(expected, cell.Value);\n        }\n\n        [Test]\n        public void ValueSetDateWithShortUserDateFormat()\n        {\n            \/\/ For this test to make sense, user's local date format should be dd\/MM\/yy (note without the 2 century digits)\n            \/\/ What happened previously was that the century digits got lost in .ToString() conversion and wrong century was sometimes returned.\n            var ci = new CultureInfo(CultureInfo.InvariantCulture.LCID);\n            ci.DateTimeFormat.ShortDatePattern = \"dd\/MM\/yy\";\n            Thread.CurrentThread.CurrentCulture = ci;\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(1, 1);\n            var expected = DateTime.Today.AddYears(20);\n            cell.Value = expected;\n            var actual = (DateTime)cell.Value;\n            Assert.AreEqual(expected, actual);\n        }\n\n        [Test]\n        public void SetStringCellValues()\n        {\n            using (var wb = new XLWorkbook())\n            {\n                var ws = wb.AddWorksheet(\"Sheet1\");\n                var cell = ws.FirstCell();\n\n                object expected;\n\n                var date = new DateTime(2018, 4, 18);\n                expected = date.ToString();\n                cell.Value = expected;\n                Assert.AreEqual(XLDataType.DateTime, cell.DataType);\n                Assert.AreEqual(date, cell.Value);\n\n                var b = true;\n                expected = b.ToString();\n                cell.Value = expected;\n                Assert.AreEqual(XLDataType.Boolean, cell.DataType);\n                Assert.AreEqual(b, cell.Value);\n\n                var ts = new TimeSpan(8, 12, 4);\n                expected = ts.ToString();\n                cell.Value = expected;\n                Assert.AreEqual(XLDataType.TimeSpan, cell.DataType);\n                Assert.AreEqual(ts, cell.Value);\n            }\n        }\n\n        [Test]\n        public void SetStringValueTooLong()\n        {\n            using (var wb = new XLWorkbook())\n            {\n                var ws = wb.AddWorksheet(\"Sheet1\");\n\n                ws.FirstCell().Value = new DateTime(2018, 5, 15);\n\n                ws.FirstCell().SetValue(new String('A', 32767));\n\n                Assert.Throws<ArgumentOutOfRangeException>(() => ws.FirstCell().Value = new String('A', 32768));\n                Assert.Throws<ArgumentOutOfRangeException>(() => ws.FirstCell().SetValue(new String('A', 32768)));\n            }\n        }\n\n        [Test]\n        public void SetDateOutOfRange()\n        {\n            Thread.CurrentThread.CurrentCulture = CultureInfo.GetCultureInfo(\"en-ZA\");\n\n            using (var wb = new XLWorkbook())\n            {\n                var ws = wb.AddWorksheet(\"Sheet1\");\n\n                ws.FirstCell().Value = 5;\n\n                var date = XLCell.BaseDate.AddDays(-1);\n                ws.FirstCell().Value = date;\n\n                \/\/ Should default to string representation using current culture's date format\n                Assert.AreEqual(XLDataType.Text, ws.FirstCell().DataType);\n                Assert.AreEqual(date.ToString(), ws.FirstCell().Value);\n\n                Assert.Throws<ArgumentException>(() => ws.FirstCell().SetValue(XLCell.BaseDate.AddDays(-1)));\n            }\n        }\n\n        [Test]\n        public void SetCellValueWipesFormulas()\n        {\n            using (var wb = new XLWorkbook())\n            {\n                var ws = wb.AddWorksheet(\"Sheet1\");\n\n                ws.FirstCell().FormulaA1 = \"=TODAY()\";\n                ws.FirstCell().Value = \"hello world\";\n                Assert.IsFalse(ws.FirstCell().HasFormula);\n\n                ws.FirstCell().FormulaA1 = \"=TODAY()\";\n                ws.FirstCell().SetValue(\"hello world\");\n                Assert.IsFalse(ws.FirstCell().HasFormula);\n            }\n        }\n\n        [Test]\n        public void CellValueLineWrapping()\n        {\n            using (var wb = new XLWorkbook())\n            {\n                var ws = wb.AddWorksheet(\"Sheet1\");\n\n                ws.FirstCell().Value = \"hello world\";\n                Assert.IsFalse(ws.FirstCell().Style.Alignment.WrapText);\n\n                ws.FirstCell().Value = \"hello\\r\\nworld\";\n                Assert.IsTrue(ws.FirstCell().Style.Alignment.WrapText);\n\n                ws.FirstCell().Style.Alignment.WrapText = false;\n\n                ws.FirstCell().SetValue(\"hello world\");\n                Assert.IsFalse(ws.FirstCell().Style.Alignment.WrapText);\n\n                ws.FirstCell().SetValue(\"hello\\r\\nworld\");\n                Assert.IsTrue(ws.FirstCell().Style.Alignment.WrapText);\n            }\n        }\n\n        [Test]\n        public void TestInvalidXmlCharacters()\n        {\n            byte[] data;\n\n            using (var stream = new MemoryStream())\n            {\n                var wb = new XLWorkbook();\n                wb.AddWorksheet(\"Sheet1\").FirstCell().SetValue(\"\\u0018\");\n                wb.SaveAs(stream);\n                data = stream.ToArray();\n            }\n\n            using (var stream = new MemoryStream(data))\n            {\n                var wb = new XLWorkbook(stream);\n                Assert.AreEqual(\"\\u0018\", wb.Worksheets.First().FirstCell().Value);\n            }\n        }\n\n        [Test]\n        public void CanClearCellValueBySettingNullValue()\n        {\n            using (var wb = new XLWorkbook())\n            {\n                var ws = wb.AddWorksheet(\"Sheet1\");\n                var cell = ws.FirstCell();\n\n                cell.Value = \"Test\";\n                Assert.AreEqual(\"Test\", cell.Value);\n                Assert.AreEqual(XLDataType.Text, cell.DataType);\n\n                string s = null;\n                cell.SetValue(s);\n                Assert.AreEqual(string.Empty, cell.Value);\n\n                cell.Value = \"Test\";\n                cell.Value = null;\n                Assert.AreEqual(string.Empty, cell.Value);\n            }\n        }\n\n        [Test]\n        public void CanClearDateTimeCellValue()\n        {\n            using (var ms = new MemoryStream())\n            {\n                using (var wb = new XLWorkbook())\n                {\n                    var ws = wb.AddWorksheet(\"Sheet1\");\n                    var c = ws.FirstCell();\n                    c.SetValue(new DateTime(2017, 10, 08));\n                    Assert.AreEqual(XLDataType.DateTime, c.DataType);\n                    Assert.AreEqual(new DateTime(2017, 10, 08), c.Value);\n\n                    wb.SaveAs(ms);\n                }\n\n                using (var wb = new XLWorkbook(ms))\n                {\n                    var ws = wb.Worksheets.First();\n                    var c = ws.FirstCell();\n                    Assert.AreEqual(XLDataType.DateTime, c.DataType);\n                    Assert.AreEqual(new DateTime(2017, 10, 08), c.Value);\n\n                    c.Clear();\n                    wb.Save();\n                }\n\n                using (var wb = new XLWorkbook(ms))\n                {\n                    var ws = wb.Worksheets.First();\n                    var c = ws.FirstCell();\n                    Assert.AreEqual(XLDataType.Text, c.DataType);\n                    Assert.True(c.IsEmpty());\n                }\n            }\n        }\n\n        [Test]\n        public void CurrentRegion()\n        {\n            \/\/ Partially based on sample in https:\/\/github.com\/ClosedXML\/ClosedXML\/issues\/120\n            using (var wb = new XLWorkbook())\n            {\n                var ws = wb.AddWorksheet(\"Sheet1\");\n\n                ws.Cell(\"B1\").SetValue(\"x\")\n                    .CellBelow().SetValue(\"x\")\n                    .CellBelow().SetValue(\"x\");\n\n                ws.Cell(\"C1\").SetValue(\"x\")\n                    .CellBelow().SetValue(\"x\")\n                    .CellBelow().SetValue(\"x\");\n\n                \/\/Deliberately D2\n                ws.Cell(\"D2\").SetValue(\"x\")\n                    .CellBelow().SetValue(\"x\");\n\n                ws.Cell(\"G1\").SetValue(\"x\")\n                    .CellBelow() \/\/ skip a cell\n                    .CellBelow().SetValue(\"x\")\n                    .CellBelow().SetValue(\"x\");\n\n                \/\/ Deliberately H2\n                ws.Cell(\"H2\").SetValue(\"x\")\n                    .CellBelow().SetValue(\"x\")\n                    .CellBelow().SetValue(\"x\");\n\n                \/\/ A diagonal\n                ws.Cell(\"E8\").SetValue(\"x\")\n                    .CellBelow().CellRight().SetValue(\"x\")\n                    .CellBelow().CellRight().SetValue(\"x\")\n                    .CellBelow().CellRight().SetValue(\"x\")\n                    .CellBelow().CellRight().SetValue(\"x\");\n\n                Assert.AreEqual(\"A10:A10\", ws.Cell(\"A10\").CurrentRegion.RangeAddress.ToString());\n                Assert.AreEqual(\"B5:B5\", ws.Cell(\"B5\").CurrentRegion.RangeAddress.ToString());\n                Assert.AreEqual(\"P1:P1\", ws.Cell(\"P1\").CurrentRegion.RangeAddress.ToString());\n\n                Assert.AreEqual(\"B1:D3\", ws.Cell(\"D3\").CurrentRegion.RangeAddress.ToString());\n                Assert.AreEqual(\"B1:D4\", ws.Cell(\"D4\").CurrentRegion.RangeAddress.ToString());\n                Assert.AreEqual(\"B1:E4\", ws.Cell(\"E4\").CurrentRegion.RangeAddress.ToString());\n\n                foreach (var c in ws.Range(\"B1:D3\").Cells())\n                {\n                    Assert.AreEqual(\"B1:D3\", c.CurrentRegion.RangeAddress.ToString());\n                }\n\n                foreach (var c in ws.Range(\"A1:A3\").Cells())\n                {\n                    Assert.AreEqual(\"A1:D3\", c.CurrentRegion.RangeAddress.ToString());\n                }\n\n                Assert.AreEqual(\"A1:D4\", ws.Cell(\"A4\").CurrentRegion.RangeAddress.ToString());\n\n                foreach (var c in ws.Range(\"E1:E3\").Cells())\n                {\n                    Assert.AreEqual(\"B1:E3\", c.CurrentRegion.RangeAddress.ToString());\n                }\n\n                Assert.AreEqual(\"B1:E4\", ws.Cell(\"E4\").CurrentRegion.RangeAddress.ToString());\n\n                \/\/\/\/ SECOND REGION\n                foreach (var c in ws.Range(\"F1:F4\").Cells())\n                {\n                    Assert.AreEqual(\"F1:H4\", c.CurrentRegion.RangeAddress.ToString());\n                }\n\n                Assert.AreEqual(\"F1:H5\", ws.Cell(\"F5\").CurrentRegion.RangeAddress.ToString());\n\n                \/\/\/\/ DIAGONAL\n                Assert.AreEqual(\"E8:I12\", ws.Cell(\"E8\").CurrentRegion.RangeAddress.ToString());\n                Assert.AreEqual(\"E8:I12\", ws.Cell(\"F9\").CurrentRegion.RangeAddress.ToString());\n                Assert.AreEqual(\"E8:I12\", ws.Cell(\"G10\").CurrentRegion.RangeAddress.ToString());\n                Assert.AreEqual(\"E8:I12\", ws.Cell(\"H11\").CurrentRegion.RangeAddress.ToString());\n                Assert.AreEqual(\"E8:I12\", ws.Cell(\"I12\").CurrentRegion.RangeAddress.ToString());\n\n                Assert.AreEqual(\"E8:I12\", ws.Cell(\"G9\").CurrentRegion.RangeAddress.ToString());\n                Assert.AreEqual(\"E8:I12\", ws.Cell(\"F10\").CurrentRegion.RangeAddress.ToString());\n\n                Assert.AreEqual(\"D7:I12\", ws.Cell(\"D7\").CurrentRegion.RangeAddress.ToString());\n                Assert.AreEqual(\"E8:J13\", ws.Cell(\"J13\").CurrentRegion.RangeAddress.ToString());\n            }\n        }\n\n        \/\/ https:\/\/github.com\/ClosedXML\/ClosedXML\/issues\/630\n        [Test]\n        public void ConsiderEmptyValueAsNumericInSumFormula()\n        {\n            using (var wb = new XLWorkbook())\n            {\n                var ws = wb.AddWorksheet(\"Sheet1\");\n\n                ws.Cell(\"A1\").SetValue(\"Empty\");\n                ws.Cell(\"A2\").SetValue(\"Numeric\");\n                ws.Cell(\"A3\").SetValue(\"Copy of numeric\");\n\n                ws.Cell(\"B2\").SetFormulaA1(\"=B1\");\n                ws.Cell(\"B3\").SetFormulaA1(\"=B2\");\n\n                ws.Cell(\"C2\").SetFormulaA1(\"=SUM(C1)\");\n                ws.Cell(\"C3\").SetFormulaA1(\"=C2\");\n\n                object b1 = ws.Cell(\"B1\").Value;\n                object b2 = ws.Cell(\"B2\").Value;\n                object b3 = ws.Cell(\"B3\").Value;\n\n                Assert.AreEqual(\"\", b1);\n                Assert.AreEqual(0, b2);\n                Assert.AreEqual(0, b3);\n\n                object c1 = ws.Cell(\"C1\").Value;\n                object c2 = ws.Cell(\"C2\").Value;\n                object c3 = ws.Cell(\"C3\").Value;\n\n                Assert.AreEqual(\"\", c1);\n                Assert.AreEqual(0, c2);\n                Assert.AreEqual(0, c3);\n            }\n        }\n\n        [Test]\n        public void SetFormulaA1AffectsR1C1()\n        {\n            using (var wb = new XLWorkbook())\n            {\n                var ws = wb.AddWorksheet(\"Sheet1\");\n                var cell = ws.Cell(1, 1);\n                cell.FormulaR1C1 = \"R[1]C\";\n\n                cell.FormulaA1 = \"B2\";\n\n                Assert.AreEqual(\"R[1]C[1]\", cell.FormulaR1C1);\n            }\n        }\n\n        [Test]\n        public void SetFormulaR1C1AffectsA1()\n        {\n            using (var wb = new XLWorkbook())\n            {\n                var ws = wb.AddWorksheet(\"Sheet1\");\n                var cell = ws.Cell(1, 1);\n                cell.FormulaA1 = \"A2\";\n\n                cell.FormulaR1C1 = \"R[1]C[1]\";\n\n                Assert.AreEqual(\"B2\", cell.FormulaA1);\n            }\n        }\n\n        [Test]\n        public void FormulaWithCircularReferenceFails()\n        {\n            using (var wb = new XLWorkbook())\n            {\n                var ws = wb.AddWorksheet(\"Sheet1\");\n                var A1 = ws.Cell(\"A1\");\n                var A2 = ws.Cell(\"A2\");\n                A1.FormulaA1 = \"A2 + 1\";\n                A2.FormulaA1 = \"A1 + 1\";\n\n                Assert.Throws<InvalidOperationException>(() =>\n                {\n                    var _ = A1.Value;\n                });\n                Assert.Throws<InvalidOperationException>(() =>\n                {\n                    var _ = A2.Value;\n                });\n            }\n        }\n\n        [Test]\n        public void InvalidFormulaShiftProducesREF()\n        {\n            using (var ms = new MemoryStream())\n            {\n                using (var wb = new XLWorkbook())\n                {\n                    var ws = wb.Worksheets.Add(\"Sheet1\");\n                    ws.Cell(\"A1\").Value = 1;\n                    ws.Cell(\"B1\").Value = 2;\n                    ws.Cell(\"B2\").FormulaA1 = \"=A1+B1\";\n\n                    Assert.AreEqual(3, ws.Cell(\"B2\").Value);\n\n                    ws.Range(\"A2\").Value = ws.Range(\"B2\");\n                    var fA2 = ws.Cell(\"A2\").FormulaA1;\n\n                    wb.SaveAs(ms);\n\n                    Assert.AreEqual(\"#REF!+A1\", fA2);\n                }\n\n                using (var wb2 = new XLWorkbook(ms))\n                {\n                    var fA2 = wb2.Worksheets.First().Cell(\"A2\").FormulaA1;\n                    Assert.AreEqual(\"#REF!+A1\", fA2);\n                }\n            }\n        }\n\n        public void FormulaWithCircularReferenceFails2()\n        {\n            var cell = new XLWorkbook().Worksheets.Add(\"Sheet1\").FirstCell();\n            cell.FormulaA1 = \"A1\";\n            Assert.Throws<InvalidOperationException>(() =>\n            {\n                var _ = cell.Value;\n            });\n        }\n\n        [Test]\n        public void TryGetValueFormulaEvaluation()\n        {\n            using (var wb = new XLWorkbook())\n            {\n                var ws = wb.AddWorksheet(\"Sheet1\");\n                var A1 = ws.Cell(\"A1\");\n                var A2 = ws.Cell(\"A2\");\n                var A3 = ws.Cell(\"A3\");\n                A1.FormulaA1 = \"A2 + 1\";\n                A2.FormulaA1 = \"A1 + 1\";\n\n                Assert.IsFalse(A1.TryGetValue(out String _));\n                Assert.IsFalse(A2.TryGetValue(out String _));\n                Assert.IsTrue(A3.TryGetValue(out String _));\n            }\n        }\n    }\n}\n","old_contents":"using ClosedXML.Excel;\nusing NUnit.Framework;\nusing System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Threading;\n\nnamespace ClosedXML_Tests\n{\n    [TestFixture]\n    public class XLCellTests\n    {\n        [Test]\n        public void CellsUsed()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            ws.Cell(1, 1);\n            ws.Cell(2, 2);\n            int count = ws.Range(\"A1:B2\").CellsUsed().Count();\n            Assert.AreEqual(0, count);\n        }\n\n        [Test]\n        public void CellsUsedIncludeStyles1()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            ws.Row(3).Style.Fill.BackgroundColor = XLColor.Red;\n            ws.Column(3).Style.Fill.BackgroundColor = XLColor.Red;\n            ws.Cell(2, 2).Value = \"ASDF\";\n            var range = ws.RangeUsed(XLCellsUsedOptions.All).RangeAddress.ToString();\n            Assert.AreEqual(\"B2:C3\", range);\n        }\n\n        [Test]\n        public void CellsUsedIncludeStyles2()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            ws.Row(2).Style.Fill.BackgroundColor = XLColor.Red;\n            ws.Column(2).Style.Fill.BackgroundColor = XLColor.Red;\n            ws.Cell(3, 3).Value = \"ASDF\";\n            var range = ws.RangeUsed(XLCellsUsedOptions.All).RangeAddress.ToString();\n            Assert.AreEqual(\"B2:C3\", range);\n        }\n\n        [Test]\n        public void CellsUsedIncludeStyles3()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            var range = ws.RangeUsed(XLCellsUsedOptions.All);\n            Assert.AreEqual(null, range);\n        }\n\n        [Test]\n        public void Double_Infinity_is_a_string()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(\"A1\");\n            var doubleList = new List<Double> { 1.0 \/ 0.0 };\n\n            cell.Value = 5;\n            cell.Value = doubleList;\n            Assert.AreEqual(XLDataType.Text, cell.DataType);\n            Assert.AreEqual(CultureInfo.CurrentCulture.NumberFormat.PositiveInfinitySymbol, cell.Value);\n\n            cell.Value = 5;\n            Assert.Throws<ArgumentException>(() => cell.SetValue(doubleList));\n        }\n\n        [Test]\n        public void Double_NaN_is_a_string()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(\"A1\");\n            var doubleList = new List<Double> { 0.0 \/ 0.0 };\n\n            cell.Value = 5;\n            cell.Value = doubleList;\n            Assert.AreEqual(XLDataType.Text, cell.DataType);\n            Assert.AreEqual(CultureInfo.CurrentCulture.NumberFormat.NaNSymbol, cell.Value);\n\n            cell.Value = 5;\n            Assert.Throws<ArgumentException>(() => cell.SetValue(doubleList));\n        }\n\n        [Test]\n        public void InsertData1()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLRange range = ws.Cell(2, 2).InsertData(new[] { \"a\", \"b\", \"c\" });\n            Assert.AreEqual(\"Sheet1!B2:B4\", range.ToString());\n        }\n\n        [Test]\n        public void InsertData2()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLRange range = ws.Cell(2, 2).InsertData(new[] { \"a\", \"b\", \"c\" }, false);\n            Assert.AreEqual(\"Sheet1!B2:B4\", range.ToString());\n        }\n\n        [Test]\n        public void InsertData3()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLRange range = ws.Cell(2, 2).InsertData(new[] { \"a\", \"b\", \"c\" }, true);\n            Assert.AreEqual(\"Sheet1!B2:D2\", range.ToString());\n        }\n\n        [Test]\n        public void InsertData_with_Guids()\n        {\n            var ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            ws.FirstCell().InsertData(Enumerable.Range(1, 20).Select(i => new { Guid = Guid.NewGuid() }));\n\n            Assert.AreEqual(XLDataType.Text, ws.FirstCell().DataType);\n            Assert.AreEqual(Guid.NewGuid().ToString().Length, ws.FirstCell().GetString().Length);\n        }\n\n        [Test]\n        public void IsEmpty1()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(1, 1);\n            bool actual = cell.IsEmpty();\n            bool expected = true;\n            Assert.AreEqual(expected, actual);\n        }\n\n        [Test]\n        public void IsEmpty2()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(1, 1);\n            bool actual = cell.IsEmpty(XLCellsUsedOptions.All);\n            bool expected = true;\n            Assert.AreEqual(expected, actual);\n        }\n\n        [Test]\n        public void IsEmpty3()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(1, 1);\n            cell.Style.Fill.BackgroundColor = XLColor.Red;\n            bool actual = cell.IsEmpty();\n            bool expected = true;\n            Assert.AreEqual(expected, actual);\n        }\n\n        [Test]\n        public void IsEmpty4()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(1, 1);\n            cell.Style.Fill.BackgroundColor = XLColor.Red;\n            bool actual = cell.IsEmpty(XLCellsUsedOptions.AllContents);\n            bool expected = true;\n            Assert.AreEqual(expected, actual);\n        }\n\n        [Test]\n        public void IsEmpty5()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(1, 1);\n            cell.Style.Fill.BackgroundColor = XLColor.Red;\n            bool actual = cell.IsEmpty(XLCellsUsedOptions.All);\n            bool expected = false;\n            Assert.AreEqual(expected, actual);\n        }\n\n        [Test]\n        public void IsEmpty6()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(1, 1);\n            cell.Value = \"X\";\n            bool actual = cell.IsEmpty();\n            bool expected = false;\n            Assert.AreEqual(expected, actual);\n        }\n\n        [Test]\n        public void NaN_is_not_a_number()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(\"A1\");\n            cell.Value = \"NaN\";\n\n            Assert.AreNotEqual(XLDataType.Number, cell.DataType);\n        }\n\n        [Test]\n        public void Nan_is_not_a_number()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(\"A1\");\n            cell.Value = \"Nan\";\n\n            Assert.AreNotEqual(XLDataType.Number, cell.DataType);\n        }\n\n        [Test]\n        public void TryGetValue_Boolean_Bad()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(\"A1\").SetValue(\"ABC\");\n            bool success = cell.TryGetValue(out bool outValue);\n            Assert.IsFalse(success);\n        }\n\n        [Test]\n        public void TryGetValue_Boolean_False()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(\"A1\").SetValue(false);\n            bool success = cell.TryGetValue(out bool outValue);\n            Assert.IsTrue(success);\n            Assert.IsFalse(outValue);\n        }\n\n        [Test]\n        public void TryGetValue_Boolean_Good()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(\"A1\").SetValue(\"True\");\n            bool success = cell.TryGetValue(out bool outValue);\n            Assert.IsTrue(success);\n            Assert.IsTrue(outValue);\n        }\n\n        [Test]\n        public void TryGetValue_Boolean_True()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(\"A1\").SetValue(true);\n            bool success = cell.TryGetValue(out bool outValue);\n            Assert.IsTrue(success);\n            Assert.IsTrue(outValue);\n        }\n\n        [Test]\n        public void TryGetValue_DateTime_Good()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            var date = \"2018-01-01\";\n            bool success = ws.Cell(\"A1\").SetValue(date).TryGetValue(out DateTime outValue);\n            Assert.IsTrue(success);\n            Assert.AreEqual(new DateTime(2018, 1, 1), outValue);\n        }\n\n        [Test]\n        public void TryGetValue_DateTime_BadString()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            var date = \"ABC\";\n            bool success = ws.Cell(\"A1\").SetValue(date).TryGetValue(out DateTime outValue);\n            Assert.IsFalse(success);\n        }\n\n        [Test]\n        public void TryGetValue_DateTime_BadString2()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            var date = 5545454;\n            ws.FirstCell().SetValue(date).DataType = XLDataType.DateTime;\n            bool success = ws.FirstCell().TryGetValue(out DateTime outValue);\n            Assert.IsFalse(success);\n        }\n\n        [Test]\n        public void TryGetValue_RichText_Bad()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(\"A1\").SetValue(\"Anything\");\n            bool success = cell.TryGetValue(out IXLRichText outValue);\n            Assert.IsTrue(success);\n            Assert.AreEqual(cell.RichText, outValue);\n            Assert.AreEqual(\"Anything\", outValue.ToString());\n        }\n\n        [Test]\n        public void TryGetValue_RichText_Good()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(\"A1\");\n            cell.RichText.AddText(\"Anything\");\n            bool success = cell.TryGetValue(out IXLRichText outValue);\n            Assert.IsTrue(success);\n            Assert.AreEqual(cell.RichText, outValue);\n        }\n\n        [Test]\n        public void TryGetValue_TimeSpan_BadString()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            string timeSpan = \"ABC\";\n            bool success = ws.Cell(\"A1\").SetValue(timeSpan).TryGetValue(out TimeSpan outValue);\n            Assert.IsFalse(success);\n        }\n\n        [Test]\n        public void TryGetValue_TimeSpan_Good()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            var timeSpan = new TimeSpan(1, 1, 1);\n            bool success = ws.Cell(\"A1\").SetValue(timeSpan).TryGetValue(out TimeSpan outValue);\n            Assert.IsTrue(success);\n            Assert.AreEqual(timeSpan, outValue);\n        }\n\n        [Test]\n        public void TryGetValue_TimeSpan_GoodString()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            var timeSpan = new TimeSpan(1, 1, 1);\n            bool success = ws.Cell(\"A1\").SetValue(timeSpan.ToString()).TryGetValue(out TimeSpan outValue);\n            Assert.IsTrue(success);\n            Assert.AreEqual(timeSpan, outValue);\n        }\n\n        [Test]\n        public void TryGetValue_sbyte_Bad()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(\"A1\").SetValue(255);\n            bool success = cell.TryGetValue(out sbyte outValue);\n            Assert.IsFalse(success);\n        }\n\n        [Test]\n        public void TryGetValue_sbyte_Bad2()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(\"A1\").SetValue(\"255\");\n            bool success = cell.TryGetValue(out sbyte outValue);\n            Assert.IsFalse(success);\n        }\n\n        [Test]\n        public void TryGetValue_sbyte_Good()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(\"A1\").SetValue(5);\n            bool success = cell.TryGetValue(out sbyte outValue);\n            Assert.IsTrue(success);\n            Assert.AreEqual(5, outValue);\n        }\n\n        [Test]\n        public void TryGetValue_sbyte_Good2()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(\"A1\").SetValue(\"5\");\n            bool success = cell.TryGetValue(out sbyte outValue);\n            Assert.IsTrue(success);\n            Assert.AreEqual(5, outValue);\n        }\n\n        [Test]\n        public void TryGetValue_decimal_Good()\n        {\n            var ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            var cell = ws.Cell(\"A1\").SetValue(\"5\");\n            bool success = cell.TryGetValue(out decimal outValue);\n            Assert.IsTrue(success);\n            Assert.AreEqual(5, outValue);\n        }\n\n        [Test]\n        public void TryGetValue_decimal_Good2()\n        {\n            var ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            var cell = ws.Cell(\"A1\").SetValue(\"1.60000001869776E-06\");\n            bool success = cell.TryGetValue(out decimal outValue);\n            Assert.IsTrue(success);\n            Assert.AreEqual(1.60000001869776E-06, outValue);\n        }\n\n        [Test]\n        public void TryGetValue_Hyperlink()\n        {\n            using (var wb = new XLWorkbook())\n            {\n                var ws1 = wb.Worksheets.Add(\"Sheet1\");\n                var ws2 = wb.Worksheets.Add(\"Sheet2\");\n\n                var targetCell = ws2.Cell(\"A1\");\n\n                var linkCell1 = ws1.Cell(\"A1\");\n                linkCell1.Value = \"Link to IXLCell\";\n                linkCell1.Hyperlink = new XLHyperlink(targetCell);\n\n                var success = linkCell1.TryGetValue(out XLHyperlink hyperlink);\n                Assert.IsTrue(success);\n                Assert.AreEqual(\"Sheet2!A1\", hyperlink.InternalAddress);\n            }\n        }\n\n        [Test]\n        public void TryGetValue_Unicode_String()\n        {\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n\n            Boolean success;\n            String outValue;\n\n            success = ws.Cell(\"A1\")\n                .SetValue(\"Site_x0020_Column_x0020_Test\")\n                .TryGetValue(out outValue);\n            Assert.IsTrue(success);\n            Assert.AreEqual(\"Site Column Test\", outValue);\n\n            success = ws.Cell(\"A1\")\n                .SetValue(\"Site_x005F_x0020_Column_x005F_x0020_Test\")\n                .TryGetValue(out outValue);\n\n            Assert.IsTrue(success);\n            Assert.AreEqual(\"Site_x005F_x0020_Column_x005F_x0020_Test\", outValue);\n        }\n\n\n        [Test]\n        public void SetCellValueToGuid()\n        {\n            var ws = new XLWorkbook().AddWorksheet(\"Sheet1\");\n            var guid = Guid.NewGuid();\n            ws.FirstCell().Value = guid;\n            Assert.AreEqual(XLDataType.Text, ws.FirstCell().DataType);\n            Assert.AreEqual(guid.ToString(), ws.FirstCell().Value);\n            Assert.AreEqual(guid.ToString(), ws.FirstCell().GetString());\n\n            guid = Guid.NewGuid();\n            ws.FirstCell().SetValue(guid);\n            Assert.AreEqual(XLDataType.Text, ws.FirstCell().DataType);\n            Assert.AreEqual(guid.ToString(), ws.FirstCell().Value);\n            Assert.AreEqual(guid.ToString(), ws.FirstCell().GetString());\n        }\n\n        [Test]\n        public void SetCellValueToEnum()\n        {\n            var ws = new XLWorkbook().AddWorksheet(\"Sheet1\");\n            var dataType = XLDataType.Number;\n            ws.FirstCell().Value = dataType;\n            Assert.AreEqual(XLDataType.Text, ws.FirstCell().DataType);\n            Assert.AreEqual(dataType.ToString(), ws.FirstCell().Value);\n            Assert.AreEqual(dataType.ToString(), ws.FirstCell().GetString());\n\n            dataType = XLDataType.TimeSpan;\n            ws.FirstCell().SetValue(dataType);\n            Assert.AreEqual(XLDataType.Text, ws.FirstCell().DataType);\n            Assert.AreEqual(dataType.ToString(), ws.FirstCell().Value);\n            Assert.AreEqual(dataType.ToString(), ws.FirstCell().GetString());\n        }\n        [Test]\n        public void SetCellValueToRange()\n        {\n            var ws = new XLWorkbook().AddWorksheet(\"Sheet1\");\n\n            ws.Cell(\"A1\").SetValue(2)\n                .CellRight().SetValue(3)\n                .CellRight().SetValue(5)\n                .CellRight().SetValue(7);\n\n            var range = ws.Range(\"1:1\");\n\n            ws.Cell(\"B2\").Value = range;\n\n            Assert.AreEqual(2, ws.Cell(\"B2\").Value);\n            Assert.AreEqual(3, ws.Cell(\"C2\").Value);\n            Assert.AreEqual(5, ws.Cell(\"D2\").Value);\n            Assert.AreEqual(7, ws.Cell(\"E2\").Value);\n        }\n\n        [Test]\n        public void ValueSetToEmptyString()\n        {\n            string expected = String.Empty;\n\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(1, 1);\n            cell.Value = new DateTime(2000, 1, 2);\n            cell.Value = String.Empty;\n            Assert.AreEqual(expected, cell.GetString());\n            Assert.AreEqual(expected, cell.Value);\n\n            cell.Value = new DateTime(2000, 1, 2);\n            cell.SetValue(string.Empty);\n            Assert.AreEqual(expected, cell.GetString());\n            Assert.AreEqual(expected, cell.Value);\n        }\n\n        [Test]\n        public void ValueSetToNull()\n        {\n            string expected = String.Empty;\n\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(1, 1);\n            cell.Value = new DateTime(2000, 1, 2);\n            cell.Value = null;\n            Assert.AreEqual(expected, cell.GetString());\n            Assert.AreEqual(expected, cell.Value);\n\n            cell.Value = new DateTime(2000, 1, 2);\n            cell.SetValue(null as string);\n            Assert.AreEqual(expected, cell.GetString());\n            Assert.AreEqual(expected, cell.Value);\n        }\n\n        [Test]\n        public void ValueSetDateWithShortUserDateFormat()\n        {\n            \/\/ For this test to make sense, user's local date format should be dd\/MM\/yy (note without the 2 century digits)\n            \/\/ What happened previously was that the century digits got lost in .ToString() conversion and wrong century was sometimes returned.\n            var ci = new CultureInfo(CultureInfo.InvariantCulture.LCID);\n            ci.DateTimeFormat.ShortDatePattern = \"dd\/MM\/yy\";\n            Thread.CurrentThread.CurrentCulture = ci;\n            IXLWorksheet ws = new XLWorkbook().Worksheets.Add(\"Sheet1\");\n            IXLCell cell = ws.Cell(1, 1);\n            var expected = DateTime.Today.AddYears(20);\n            cell.Value = expected;\n            var actual = (DateTime)cell.Value;\n            Assert.AreEqual(expected, actual);\n        }\n\n        [Test]\n        public void SetStringCellValues()\n        {\n            using (var wb = new XLWorkbook())\n            {\n                var ws = wb.AddWorksheet(\"Sheet1\");\n                var cell = ws.FirstCell();\n\n                object expected;\n\n                var date = new DateTime(2018, 4, 18);\n                expected = date.ToString();\n                cell.Value = expected;\n                Assert.AreEqual(XLDataType.DateTime, cell.DataType);\n                Assert.AreEqual(date, cell.Value);\n\n                var b = true;\n                expected = b.ToString();\n                cell.Value = expected;\n                Assert.AreEqual(XLDataType.Boolean, cell.DataType);\n                Assert.AreEqual(b, cell.Value);\n\n                var ts = new TimeSpan(8, 12, 4);\n                expected = ts.ToString();\n                cell.Value = expected;\n                Assert.AreEqual(XLDataType.TimeSpan, cell.DataType);\n                Assert.AreEqual(ts, cell.Value);\n            }\n        }\n\n        [Test]\n        public void SetStringValueTooLong()\n        {\n            using (var wb = new XLWorkbook())\n            {\n                var ws = wb.AddWorksheet(\"Sheet1\");\n\n                ws.FirstCell().Value = new DateTime(2018, 5, 15);\n\n                ws.FirstCell().SetValue(new String('A', 32767));\n\n                Assert.Throws<ArgumentOutOfRangeException>(() => ws.FirstCell().Value = new String('A', 32768));\n                Assert.Throws<ArgumentOutOfRangeException>(() => ws.FirstCell().SetValue(new String('A', 32768)));\n            }\n        }\n\n        [Test]\n        public void SetDateOutOfRange()\n        {\n            Thread.CurrentThread.CurrentCulture = CultureInfo.GetCultureInfo(\"en-ZA\");\n\n            using (var wb = new XLWorkbook())\n            {\n                var ws = wb.AddWorksheet(\"Sheet1\");\n\n                ws.FirstCell().Value = 5;\n\n                var date = XLCell.BaseDate.AddDays(-1);\n                ws.FirstCell().Value = date;\n\n                \/\/ Should default to string representation using current culture's date format\n                Assert.AreEqual(XLDataType.Text, ws.FirstCell().DataType);\n                Assert.AreEqual(date.ToString(), ws.FirstCell().Value);\n\n                Assert.Throws<ArgumentException>(() => ws.FirstCell().SetValue(XLCell.BaseDate.AddDays(-1)));\n            }\n        }\n\n        [Test]\n        public void SetCellValueWipesFormulas()\n        {\n            using (var wb = new XLWorkbook())\n            {\n                var ws = wb.AddWorksheet(\"Sheet1\");\n\n                ws.FirstCell().FormulaA1 = \"=TODAY()\";\n                ws.FirstCell().Value = \"hello world\";\n                Assert.IsFalse(ws.FirstCell().HasFormula);\n\n                ws.FirstCell().FormulaA1 = \"=TODAY()\";\n                ws.FirstCell().SetValue(\"hello world\");\n                Assert.IsFalse(ws.FirstCell().HasFormula);\n            }\n        }\n\n        [Test]\n        public void CellValueLineWrapping()\n        {\n            using (var wb = new XLWorkbook())\n            {\n                var ws = wb.AddWorksheet(\"Sheet1\");\n\n                ws.FirstCell().Value = \"hello world\";\n                Assert.IsFalse(ws.FirstCell().Style.Alignment.WrapText);\n\n                ws.FirstCell().Value = \"hello\\r\\nworld\";\n                Assert.IsTrue(ws.FirstCell().Style.Alignment.WrapText);\n\n                ws.FirstCell().Style.Alignment.WrapText = false;\n\n                ws.FirstCell().SetValue(\"hello world\");\n                Assert.IsFalse(ws.FirstCell().Style.Alignment.WrapText);\n\n                ws.FirstCell().SetValue(\"hello\\r\\nworld\");\n                Assert.IsTrue(ws.FirstCell().Style.Alignment.WrapText);\n            }\n        }\n\n        [Test]\n        public void TestInvalidXmlCharacters()\n        {\n            byte[] data;\n\n            using (var stream = new MemoryStream())\n            {\n                var wb = new XLWorkbook();\n                wb.AddWorksheet(\"Sheet1\").FirstCell().SetValue(\"\\u0018\");\n                wb.SaveAs(stream);\n                data = stream.ToArray();\n            }\n\n            using (var stream = new MemoryStream(data))\n            {\n                var wb = new XLWorkbook(stream);\n                Assert.AreEqual(\"\\u0018\", wb.Worksheets.First().FirstCell().Value);\n            }\n        }\n\n        [Test]\n        public void CanClearCellValueBySettingNullValue()\n        {\n            using (var wb = new XLWorkbook())\n            {\n                var ws = wb.AddWorksheet(\"Sheet1\");\n                var cell = ws.FirstCell();\n\n                cell.Value = \"Test\";\n                Assert.AreEqual(\"Test\", cell.Value);\n                Assert.AreEqual(XLDataType.Text, cell.DataType);\n\n                string s = null;\n                cell.SetValue(s);\n                Assert.AreEqual(string.Empty, cell.Value);\n\n                cell.Value = \"Test\";\n                cell.Value = null;\n                Assert.AreEqual(string.Empty, cell.Value);\n            }\n        }\n\n        [Test]\n        public void CanClearDateTimeCellValue()\n        {\n            using (var ms = new MemoryStream())\n            {\n                using (var wb = new XLWorkbook())\n                {\n                    var ws = wb.AddWorksheet(\"Sheet1\");\n                    var c = ws.FirstCell();\n                    c.SetValue(new DateTime(2017, 10, 08));\n                    Assert.AreEqual(XLDataType.DateTime, c.DataType);\n                    Assert.AreEqual(new DateTime(2017, 10, 08), c.Value);\n\n                    wb.SaveAs(ms);\n                }\n\n                using (var wb = new XLWorkbook(ms))\n                {\n                    var ws = wb.Worksheets.First();\n                    var c = ws.FirstCell();\n                    Assert.AreEqual(XLDataType.DateTime, c.DataType);\n                    Assert.AreEqual(new DateTime(2017, 10, 08), c.Value);\n\n                    c.Clear();\n                    wb.Save();\n                }\n\n                using (var wb = new XLWorkbook(ms))\n                {\n                    var ws = wb.Worksheets.First();\n                    var c = ws.FirstCell();\n                    Assert.AreEqual(XLDataType.Text, c.DataType);\n                    Assert.True(c.IsEmpty());\n                }\n            }\n        }\n\n        [Test]\n        public void CurrentRegion()\n        {\n            \/\/ Partially based on sample in https:\/\/github.com\/ClosedXML\/ClosedXML\/issues\/120\n            using (var wb = new XLWorkbook())\n            {\n                var ws = wb.AddWorksheet(\"Sheet1\");\n\n                ws.Cell(\"B1\").SetValue(\"x\")\n                    .CellBelow().SetValue(\"x\")\n                    .CellBelow().SetValue(\"x\");\n\n                ws.Cell(\"C1\").SetValue(\"x\")\n                    .CellBelow().SetValue(\"x\")\n                    .CellBelow().SetValue(\"x\");\n\n                \/\/Deliberately D2\n                ws.Cell(\"D2\").SetValue(\"x\")\n                    .CellBelow().SetValue(\"x\");\n\n                ws.Cell(\"G1\").SetValue(\"x\")\n                    .CellBelow() \/\/ skip a cell\n                    .CellBelow().SetValue(\"x\")\n                    .CellBelow().SetValue(\"x\");\n\n                \/\/ Deliberately H2\n                ws.Cell(\"H2\").SetValue(\"x\")\n                    .CellBelow().SetValue(\"x\")\n                    .CellBelow().SetValue(\"x\");\n\n                \/\/ A diagonal\n                ws.Cell(\"E8\").SetValue(\"x\")\n                    .CellBelow().CellRight().SetValue(\"x\")\n                    .CellBelow().CellRight().SetValue(\"x\")\n                    .CellBelow().CellRight().SetValue(\"x\")\n                    .CellBelow().CellRight().SetValue(\"x\");\n\n                Assert.AreEqual(\"A10:A10\", ws.Cell(\"A10\").CurrentRegion.RangeAddress.ToString());\n                Assert.AreEqual(\"B5:B5\", ws.Cell(\"B5\").CurrentRegion.RangeAddress.ToString());\n                Assert.AreEqual(\"P1:P1\", ws.Cell(\"P1\").CurrentRegion.RangeAddress.ToString());\n\n                Assert.AreEqual(\"B1:D3\", ws.Cell(\"D3\").CurrentRegion.RangeAddress.ToString());\n                Assert.AreEqual(\"B1:D4\", ws.Cell(\"D4\").CurrentRegion.RangeAddress.ToString());\n                Assert.AreEqual(\"B1:E4\", ws.Cell(\"E4\").CurrentRegion.RangeAddress.ToString());\n\n                foreach (var c in ws.Range(\"B1:D3\").Cells())\n                {\n                    Assert.AreEqual(\"B1:D3\", c.CurrentRegion.RangeAddress.ToString());\n                }\n\n                foreach (var c in ws.Range(\"A1:A3\").Cells())\n                {\n                    Assert.AreEqual(\"A1:D3\", c.CurrentRegion.RangeAddress.ToString());\n                }\n\n                Assert.AreEqual(\"A1:D4\", ws.Cell(\"A4\").CurrentRegion.RangeAddress.ToString());\n\n                foreach (var c in ws.Range(\"E1:E3\").Cells())\n                {\n                    Assert.AreEqual(\"B1:E3\", c.CurrentRegion.RangeAddress.ToString());\n                }\n\n                Assert.AreEqual(\"B1:E4\", ws.Cell(\"E4\").CurrentRegion.RangeAddress.ToString());\n\n                \/\/\/\/ SECOND REGION\n                foreach (var c in ws.Range(\"F1:F4\").Cells())\n                {\n                    Assert.AreEqual(\"F1:H4\", c.CurrentRegion.RangeAddress.ToString());\n                }\n\n                Assert.AreEqual(\"F1:H5\", ws.Cell(\"F5\").CurrentRegion.RangeAddress.ToString());\n\n                \/\/\/\/ DIAGONAL\n                Assert.AreEqual(\"E8:I12\", ws.Cell(\"E8\").CurrentRegion.RangeAddress.ToString());\n                Assert.AreEqual(\"E8:I12\", ws.Cell(\"F9\").CurrentRegion.RangeAddress.ToString());\n                Assert.AreEqual(\"E8:I12\", ws.Cell(\"G10\").CurrentRegion.RangeAddress.ToString());\n                Assert.AreEqual(\"E8:I12\", ws.Cell(\"H11\").CurrentRegion.RangeAddress.ToString());\n                Assert.AreEqual(\"E8:I12\", ws.Cell(\"I12\").CurrentRegion.RangeAddress.ToString());\n\n                Assert.AreEqual(\"E8:I12\", ws.Cell(\"G9\").CurrentRegion.RangeAddress.ToString());\n                Assert.AreEqual(\"E8:I12\", ws.Cell(\"F10\").CurrentRegion.RangeAddress.ToString());\n\n                Assert.AreEqual(\"D7:I12\", ws.Cell(\"D7\").CurrentRegion.RangeAddress.ToString());\n                Assert.AreEqual(\"E8:J13\", ws.Cell(\"J13\").CurrentRegion.RangeAddress.ToString());\n            }\n        }\n\n        \/\/ https:\/\/github.com\/ClosedXML\/ClosedXML\/issues\/630\n        [Test]\n        public void ConsiderEmptyValueAsNumericInSumFormula()\n        {\n            using (var wb = new XLWorkbook())\n            {\n                var ws = wb.AddWorksheet(\"Sheet1\");\n\n                ws.Cell(\"A1\").SetValue(\"Empty\");\n                ws.Cell(\"A2\").SetValue(\"Numeric\");\n                ws.Cell(\"A3\").SetValue(\"Copy of numeric\");\n\n                ws.Cell(\"B2\").SetFormulaA1(\"=B1\");\n                ws.Cell(\"B3\").SetFormulaA1(\"=B2\");\n\n                ws.Cell(\"C2\").SetFormulaA1(\"=SUM(C1)\");\n                ws.Cell(\"C3\").SetFormulaA1(\"=C2\");\n\n                object b1 = ws.Cell(\"B1\").Value;\n                object b2 = ws.Cell(\"B2\").Value;\n                object b3 = ws.Cell(\"B3\").Value;\n\n                Assert.AreEqual(\"\", b1);\n                Assert.AreEqual(0, b2);\n                Assert.AreEqual(0, b3);\n\n                object c1 = ws.Cell(\"C1\").Value;\n                object c2 = ws.Cell(\"C2\").Value;\n                object c3 = ws.Cell(\"C3\").Value;\n\n                Assert.AreEqual(\"\", c1);\n                Assert.AreEqual(0, c2);\n                Assert.AreEqual(0, c3);\n            }\n        }\n\n        [Test]\n        public void SetFormulaA1AffectsR1C1()\n        {\n            using (var wb = new XLWorkbook())\n            {\n                var ws = wb.AddWorksheet(\"Sheet1\");\n                var cell = ws.Cell(1, 1);\n                cell.FormulaR1C1 = \"R[1]C\";\n\n                cell.FormulaA1 = \"B2\";\n\n                Assert.AreEqual(\"R[1]C[1]\", cell.FormulaR1C1);\n            }\n        }\n\n        [Test]\n        public void SetFormulaR1C1AffectsA1()\n        {\n            using (var wb = new XLWorkbook())\n            {\n                var ws = wb.AddWorksheet(\"Sheet1\");\n                var cell = ws.Cell(1, 1);\n                cell.FormulaA1 = \"A2\";\n\n                cell.FormulaR1C1 = \"R[1]C[1]\";\n\n                Assert.AreEqual(\"B2\", cell.FormulaA1);\n            }\n        }\n\n        [Test]\n        public void FormulaWithCircularReferenceFails()\n        {\n            using (var wb = new XLWorkbook())\n            {\n                var ws = wb.AddWorksheet(\"Sheet1\");\n                var A1 = ws.Cell(\"A1\");\n                var A2 = ws.Cell(\"A2\");\n                A1.FormulaA1 = \"A2 + 1\";\n                A2.FormulaA1 = \"A1 + 1\";\n\n                Assert.Throws<InvalidOperationException>(() =>\n                {\n                    var _ = A1.Value;\n                });\n                Assert.Throws<InvalidOperationException>(() =>\n                {\n                    var _ = A2.Value;\n                });\n            }\n        }\n\n        [Test]\n        public void InvalidFormulaShiftProducesREF()\n        {\n            using (var ms = new MemoryStream())\n            {\n                using (var wb = new XLWorkbook())\n                {\n                    var ws = wb.Worksheets.Add(\"Sheet1\");\n                    ws.Cell(\"A1\").Value = 1;\n                    ws.Cell(\"B1\").Value = 2;\n                    ws.Cell(\"B2\").FormulaA1 = \"=A1+B1\";\n\n                    Assert.AreEqual(3, ws.Cell(\"B2\").Value);\n\n                    ws.Range(\"A2\").Value = ws.Range(\"B2\");\n                    var fA2 = ws.Cell(\"A2\").FormulaA1;\n\n                    wb.SaveAs(ms);\n\n                    Assert.AreEqual(\"#REF!+A1\", fA2);\n                }\n\n                using (var wb2 = new XLWorkbook(ms))\n                {\n                    var fA2 = wb2.Worksheets.First().Cell(\"A2\").FormulaA1;\n                    Assert.AreEqual(\"#REF!+A1\", fA2);\n                }\n            }\n        }\n\n        public void FormulaWithCircularReferenceFails2()\n        {\n            var cell = new XLWorkbook().Worksheets.Add(\"Sheet1\").FirstCell();\n            cell.FormulaA1 = \"A1\";\n            Assert.Throws<InvalidOperationException>(() =>\n            {\n                var _ = cell.Value;\n            });\n        }\n\n        [Test]\n        public void TryGetValueFormulaEvaluation()\n        {\n            using (var wb = new XLWorkbook())\n            {\n                var ws = wb.AddWorksheet(\"Sheet1\");\n                var A1 = ws.Cell(\"A1\");\n                var A2 = ws.Cell(\"A2\");\n                var A3 = ws.Cell(\"A3\");\n                A1.FormulaA1 = \"A2 + 1\";\n                A2.FormulaA1 = \"A1 + 1\";\n\n                Assert.IsFalse(A1.TryGetValue(out String _));\n                Assert.IsFalse(A2.TryGetValue(out String _));\n                Assert.IsTrue(A3.TryGetValue(out String _));\n            }\n        }\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"88575f7a542d150c9ba5280b23270d507c715ff8","subject":"Removed unnecessary property","message":"Removed unnecessary property\n","repos":"aalok05\/CodeHub,PoLaKoSz\/CodeHub","old_file":"CodeHub\/ViewModels\/FileContentViewModel.cs","new_file":"CodeHub\/ViewModels\/FileContentViewModel.cs","new_contents":"\ufeffusing GalaSoft.MvvmLight.Messaging;\nusing CodeHub.Helpers;\nusing CodeHub.Services;\nusing Octokit;\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Windows.UI;\nusing Windows.UI.Xaml.Media;\nusing Windows.UI.Xaml.Media.Imaging;\nusing CodeHub.Services.Hilite_me;\nusing MarkdownSharp;\nusing GalaSoft.MvvmLight.Command;\nusing GalaSoft.MvvmLight.Ioc;\nusing CodeHub.Views;\n\nnamespace CodeHub.ViewModels\n{\n    public class FileContentViewmodel : AppViewmodel\n    {\n        public Repository _repository;\n        public Repository Repository\n        {\n            get\n            {\n                return _repository;\n            }\n            set\n            {\n                Set(() => Repository, ref _repository, value);\n\n            }\n        }\n\n        public bool _isSupportedFile;\n        public bool IsSupportedFile\n        {\n            get\n            {\n                return _isSupportedFile;\n            }\n            set\n            {\n                Set(() => IsSupportedFile, ref _isSupportedFile, value);\n\n            }\n        }\n\n        public bool _isImage;\n        public bool IsImage\n        {\n            get\n            {\n                return _isImage;\n            }\n            set\n            {\n                Set(() => IsImage, ref _isImage, value);\n\n            }\n        }\n\n        public ImageSource _imageFile;\n        public ImageSource ImageFile\n        {\n            get\n            {\n                return _imageFile;\n            }\n            set\n            {\n                Set(() => ImageFile, ref _imageFile, value);\n\n            }\n        }\n\n        public string _path;\n        public string Path\n        {\n            get\n            {\n                return _path;\n            }\n            set\n            {\n                Set(() => Path, ref _path, value);\n\n            }\n        }\n\n        \/\/ HTMLContent\n        public string _HTMLContent;\n        public string HTMLContent\n        {\n            get\n            {\n                return _HTMLContent;\n            }\n            set\n            {\n                Set(() => HTMLContent, ref _HTMLContent, value);\n\n            }\n        }\n\n\n        public string _selectedBranch;\n        public string SelectedBranch\n        {\n            get\n            {\n                return _selectedBranch;\n            }\n            set\n            {\n                Set(() => SelectedBranch, ref _selectedBranch, value);\n\n            }\n        }\n\n        public Color _HTMLBackgroundColor = SettingsService.Get<bool>(SettingsKeys.AppLightThemeEnabled) ? Colors.White : Colors.Black;\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the base background color for the HTML content\n        \/\/\/ <\/summary>\n        public Color HTMLBackgroundColor\n        {\n            get { return _HTMLBackgroundColor; }\n            private set\n            { \n                Set(() => HTMLBackgroundColor, ref _HTMLBackgroundColor, value);\n            }\n        }\n\n        public async Task Load(Tuple<Repository, string, string> repoPath)  \/\/This page recieves RepositoryId and name of the file\n        {\n            IsSupportedFile = true;\n            Repository = repoPath.Item1;\n            Path = repoPath.Item2;\n\n            if (string.IsNullOrWhiteSpace(repoPath.Item3))\n            {\n                SelectedBranch = await RepositoryUtility.GetDefaultBranch(Repository.Id);\n            }\n            else\n            {\n                SelectedBranch = repoPath.Item3;\n            }\n\n\n            MarkdownOptions options = new MarkdownOptions\n            {\n                AsteriskIntraWordEmphasis = true,\n                AutoNewlines = true,\n                StrictBoldItalic = true,\n                AutoHyperlink = false,\n                LinkEmails = true\n            };\n            Markdown markDown = new Markdown(options);\n\n            if (!GlobalHelper.IsInternet())\n            {\n                Messenger.Default.Send(new GlobalHelper.NoInternetMessageType()); \/\/Sending NoInternet message to all viewModels\n            }\n            else\n            {\n                Messenger.Default.Send(new GlobalHelper.HasInternetMessageType()); \/\/Sending Internet available message to all viewModels\n                isLoading = true;\n                IsImage = false;\n\n                if ((Path.ToLower().EndsWith(\".exe\")) ||\n                   (Path.ToLower().EndsWith(\".pdf\")) ||\n                   (Path.ToLower().EndsWith(\".ttf\")) ||\n                   (Path.ToLower().EndsWith(\".suo\")) ||\n                   (Path.ToLower().EndsWith(\".mp3\")) ||\n                   (Path.ToLower().EndsWith(\".mp4\")) ||\n                   (Path.ToLower().EndsWith(\".avi\")))\n                {\n                    \/*\n                     * Unsupported file types\n                     *\/\n                    IsSupportedFile = false;\n                    isLoading = false;\n                    return;\n                }\n                if ((Path.ToLower()).EndsWith(\".png\") ||\n                    (Path.ToLower()).EndsWith(\".jpg\") ||\n                    (Path.ToLower()).EndsWith(\".jpeg\") ||\n                    (Path.ToLower().EndsWith(\".gif\")))\n                {\n                    \/*\n                    * Image file types\n                    *\/\n\n                    IsImage = true;\n                    var uri = (await RepositoryUtility.GetRepositoryContentByPath(Repository.Id, Path, SelectedBranch))[0].DownloadUrl;\n                    ImageFile = new BitmapImage(uri);\n                    isLoading = false;\n                    return;\n                }\n                if ((Path.ToLower()).EndsWith(\".md\"))\n                {\n                    \/*\n                     *  Files with .md extension will be shown with full markdown\n                     *\/\n                    HTMLBackgroundColor = Colors.White;\n                    var str = (await RepositoryUtility.GetRepositoryContentByPath(Repository.Id, Path, SelectedBranch))[0].Content;\n                    HTMLContent = \"<html><head><meta charset = \\\"utf-8\\\" \/><\/head><body style=\\\"font-family: sans-serif\\\">\" + markDown.Transform(str) + \"<\/body><\/html>\";\n                    isLoading = false;\n                    return;\n                }\n\n                string content = (await RepositoryUtility.GetRepositoryContentByPath(Repository.Id, Path, SelectedBranch))[0].Content;\n                SyntaxHighlightStyle style = (SyntaxHighlightStyle)SettingsService.Get<int>(SettingsKeys.HighlightStyleIndex);\n                bool lineNumbers = SettingsService.Get<bool>(SettingsKeys.ShowLineNumbers);\n                HTMLContent = await HiliteAPI.TryGetHighlightedCodeAsync(content, Path, style, lineNumbers, CancellationToken.None);\n\n                IsSupportedFile = HTMLContent == null ? false : true;\n                isLoading = false;\n\n            }\n        }\n\n        private RelayCommand _repoDetailNavigateCommand;\n        public RelayCommand RepoDetailNavigateCommand\n        {\n            get\n            {\n                return _repoDetailNavigateCommand\n                    ?? (_repoDetailNavigateCommand = new RelayCommand(\n                                          () =>\n                                          {\n                                              SimpleIoc.Default.GetInstance<Services.INavigationService>().Navigate(typeof(RepoDetailView), Repository, \"Repository\");\n                                          }));\n            }\n        }\n    }\n}","old_contents":"\ufeffusing GalaSoft.MvvmLight.Messaging;\nusing CodeHub.Helpers;\nusing CodeHub.Services;\nusing Octokit;\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Windows.UI;\nusing Windows.UI.Xaml.Media;\nusing Windows.UI.Xaml.Media.Imaging;\nusing CodeHub.Services.Hilite_me;\nusing MarkdownSharp;\nusing GalaSoft.MvvmLight.Command;\nusing GalaSoft.MvvmLight.Ioc;\nusing CodeHub.Views;\n\nnamespace CodeHub.ViewModels\n{\n    public class FileContentViewmodel : AppViewmodel\n    {\n        public Repository _repository;\n        public Repository Repository\n        {\n            get\n            {\n                return _repository;\n            }\n            set\n            {\n                Set(() => Repository, ref _repository, value);\n\n            }\n        }\n\n        public bool _isSupportedFile;\n        public bool IsSupportedFile\n        {\n            get\n            {\n                return _isSupportedFile;\n            }\n            set\n            {\n                Set(() => IsSupportedFile, ref _isSupportedFile, value);\n\n            }\n        }\n\n        public bool _isImage;\n        public bool IsImage\n        {\n            get\n            {\n                return _isImage;\n            }\n            set\n            {\n                Set(() => IsImage, ref _isImage, value);\n\n            }\n        }\n\n        public ImageSource _imageFile;\n        public ImageSource ImageFile\n        {\n            get\n            {\n                return _imageFile;\n            }\n            set\n            {\n                Set(() => ImageFile, ref _imageFile, value);\n\n            }\n        }\n\n        public string _path;\n        public string Path\n        {\n            get\n            {\n                return _path;\n            }\n            set\n            {\n                Set(() => Path, ref _path, value);\n\n            }\n        }\n\n        \/\/TextContent\n        public string _Textcontent;\n        public string TextContent\n        {\n            get\n            {\n                return _Textcontent;\n            }\n            set\n            {\n                Set(() => TextContent, ref _Textcontent, value);\n\n            }\n        }\n\n        \/\/ HTMLContent\n\n        public string _HTMLContent;\n        public string HTMLContent\n        {\n            get\n            {\n                return _HTMLContent;\n            }\n            set\n            {\n                Set(() => HTMLContent, ref _HTMLContent, value);\n\n            }\n        }\n\n\n        public string _selectedBranch;\n        public string SelectedBranch\n        {\n            get\n            {\n                return _selectedBranch;\n            }\n            set\n            {\n                Set(() => SelectedBranch, ref _selectedBranch, value);\n\n            }\n        }\n\n        public Color _HTMLBackgroundColor = SettingsService.Get<bool>(SettingsKeys.AppLightThemeEnabled) ? Colors.White : Colors.Black;\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the base background color for the HTML content\n        \/\/\/ <\/summary>\n        public Color HTMLBackgroundColor\n        {\n            get { return _HTMLBackgroundColor; }\n            private set\n            { \n                Set(() => HTMLBackgroundColor, ref _HTMLBackgroundColor, value);\n            }\n        }\n\n        public async Task Load(Tuple<Repository, string, string> repoPath)  \/\/This page recieves RepositoryId and name of the file\n        {\n            IsSupportedFile = true;\n            Repository = repoPath.Item1;\n            Path = repoPath.Item2;\n\n            if (string.IsNullOrWhiteSpace(repoPath.Item3))\n            {\n                SelectedBranch = await RepositoryUtility.GetDefaultBranch(Repository.Id);\n            }\n            else\n            {\n                SelectedBranch = repoPath.Item3;\n            }\n\n\n            MarkdownOptions options = new MarkdownOptions\n            {\n                AsteriskIntraWordEmphasis = true,\n                AutoNewlines = true,\n                StrictBoldItalic = true,\n                AutoHyperlink = false,\n                LinkEmails = true\n            };\n            Markdown markDown = new Markdown(options);\n\n            if (!GlobalHelper.IsInternet())\n            {\n                Messenger.Default.Send(new GlobalHelper.NoInternetMessageType()); \/\/Sending NoInternet message to all viewModels\n            }\n            else\n            {\n                Messenger.Default.Send(new GlobalHelper.HasInternetMessageType()); \/\/Sending Internet available message to all viewModels\n                isLoading = true;\n                IsImage = false;\n\n                if ((Path.ToLower().EndsWith(\".exe\")) ||\n                   (Path.ToLower().EndsWith(\".pdf\")) ||\n                   (Path.ToLower().EndsWith(\".ttf\")) ||\n                   (Path.ToLower().EndsWith(\".suo\")) ||\n                   (Path.ToLower().EndsWith(\".mp3\")) ||\n                   (Path.ToLower().EndsWith(\".mp4\")) ||\n                   (Path.ToLower().EndsWith(\".avi\")))\n                {\n                    \/*\n                     * Unsupported file types\n                     *\/\n                    IsSupportedFile = false;\n                    isLoading = false;\n                    return;\n                }\n                if ((Path.ToLower()).EndsWith(\".png\") ||\n                    (Path.ToLower()).EndsWith(\".jpg\") ||\n                    (Path.ToLower()).EndsWith(\".jpeg\") ||\n                    (Path.ToLower().EndsWith(\".gif\")))\n                {\n                    \/*\n                    * Image file types\n                    *\/\n\n                    IsImage = true;\n                    var uri = (await RepositoryUtility.GetRepositoryContentByPath(Repository.Id, Path, SelectedBranch))[0].DownloadUrl;\n                    ImageFile = new BitmapImage(uri);\n                    isLoading = false;\n                    return;\n                }\n                if ((Path.ToLower()).EndsWith(\".md\"))\n                {\n                    \/*\n                     *  Files with .md extension will be shown with full markdown\n                     *\/\n                    HTMLBackgroundColor = Colors.White;\n                    var str = (await RepositoryUtility.GetRepositoryContentByPath(Repository.Id, Path, SelectedBranch))[0].Content;\n                    HTMLContent = \"<html><head><meta charset = \\\"utf-8\\\" \/><\/head><body style=\\\"font-family: sans-serif\\\">\" + markDown.Transform(str) + \"<\/body><\/html>\";\n                    isLoading = false;\n                    return;\n                }\n\n                string content = (await RepositoryUtility.GetRepositoryContentByPath(Repository.Id, Path, SelectedBranch))[0].Content;\n                SyntaxHighlightStyle style = (SyntaxHighlightStyle)SettingsService.Get<int>(SettingsKeys.HighlightStyleIndex);\n                bool lineNumbers = SettingsService.Get<bool>(SettingsKeys.ShowLineNumbers);\n                HTMLContent = await HiliteAPI.TryGetHighlightedCodeAsync(content, Path, style, lineNumbers, CancellationToken.None);\n\n                IsSupportedFile = HTMLContent == null ? false : true;\n                isLoading = false;\n\n            }\n        }\n\n        private RelayCommand _repoDetailNavigateCommand;\n        public RelayCommand RepoDetailNavigateCommand\n        {\n            get\n            {\n                return _repoDetailNavigateCommand\n                    ?? (_repoDetailNavigateCommand = new RelayCommand(\n                                          () =>\n                                          {\n                                              SimpleIoc.Default.GetInstance<Services.INavigationService>().Navigate(typeof(RepoDetailView), Repository, \"Repository\");\n                                          }));\n            }\n        }\n    }\n}","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"ad913a42dd213de75388daf11b316bf8aaf56db5","subject":"historylist with command\/connection policies","message":"historylist with command\/connection policies\n","repos":"Teleopti\/Stardust","old_file":"Manager\/Manager\/JobRepository.cs","new_file":"Manager\/Manager\/JobRepository.cs","new_contents":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.Data.SqlClient;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing Microsoft.Practices.EnterpriseLibrary.TransientFaultHandling;\nusing Stardust.Manager.Extensions;\nusing Stardust.Manager.Helpers;\nusing Stardust.Manager.Interfaces;\nusing Stardust.Manager.Models;\n\nnamespace Stardust.Manager\n{\n\tpublic class JobRepository : IJobRepository\n\t{\n\t\tprivate readonly RetryPolicyProvider _retryPolicyProvider;\n\t\tprivate readonly RetryPolicy _retryPolicy;\n\t\tprivate readonly string _connectionString;\n\n\t\tpublic JobRepository(string connectionString, RetryPolicyProvider retryPolicyProvider)\n\t\t{\n\t\t\t_connectionString = connectionString;\n\t\t\t_retryPolicyProvider = retryPolicyProvider;\n\t\t\t_retryPolicy = retryPolicyProvider.GetPolicy();\n\t\t}\n\n\t\tprivate void runner(Action funcToRun, string faliureMessage)\n\t\t{\n\t\t\tvar policy = _retryPolicyProvider.GetPolicy();\n\t\t\tapplyLoggingOnRetries(policy);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tpolicy.ExecuteAction(funcToRun);\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tthis.Log().ErrorWithLineNumber(ex.Message + faliureMessage);\n\t\t\t}\n\t\t}\n\n\t\tprivate void applyLoggingOnRetries(RetryPolicy<SqlDatabaseTransientErrorDetectionStrategy> policy)\n\t\t{\n\t\t\tpolicy.Retrying += (sender, args) =>\n\t\t\t{\n\t\t\t\tvar msg = String.Format(\"Retry - Count:{0}, Delay:{1}, Exception:{2}\", args.CurrentRetryCount, args.Delay,\n\t\t\t\t\targs.LastException);\n\t\t\t\tthis.Log().ErrorWithLineNumber(msg);\n\t\t\t};\n\t\t}\n\n\t\tpublic void Add(JobDefinition job)\n\t\t{\n\t\t\tusing (var connection = new SqlConnection(_connectionString))\n\t\t\t{\n\t\t\t\tSqlCommand jobHistoryCommand = connection.CreateCommand();\n\t\t\t\tjobHistoryCommand.CommandText = \"INSERT INTO [Stardust].JobHistory (JobId, Name, CreatedBy, Serialized, Type) VALUES(@Id, @Name, @By, @Serialized, @Type)\";\n\t\t\t\tjobHistoryCommand.Parameters.AddWithValue(\"@Id\", job.Id);\n\t\t\t\tjobHistoryCommand.Parameters.AddWithValue(\"@Name\", job.Name);\n\t\t\t\tjobHistoryCommand.Parameters.AddWithValue(\"@By\", job.UserName);\n\t\t\t\tjobHistoryCommand.Parameters.AddWithValue(\"@Serialized\", job.Serialized);\n\t\t\t\tjobHistoryCommand.Parameters.AddWithValue(\"@Type\", job.Type);\n\n\t\t\t\tSqlCommand jobDefinitionCommand = connection.CreateCommand();\n\t\t\t\tjobDefinitionCommand.CommandText = \"INSERT INTO [Stardust].JobDefinitions (Id, Name, Serialized, Type, userName) VALUES(@Id, @Name, @Serialized, @Type, @UserName)\";\n\t\t\t\tjobDefinitionCommand.Parameters.AddWithValue(\"@Id\", job.Id);\n\t\t\t\tjobDefinitionCommand.Parameters.AddWithValue(\"@Name\", job.Name);\n\t\t\t\tjobDefinitionCommand.Parameters.AddWithValue(\"@UserName\", job.UserName);\n\t\t\t\tjobDefinitionCommand.Parameters.AddWithValue(\"@Serialized\", job.Serialized);\n\t\t\t\tjobDefinitionCommand.Parameters.AddWithValue(\"@Type\", job.Type);\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tconnection.OpenWithRetry(_retryPolicy);\n\t\t\t\t\tusing (var tran = connection.BeginTransaction())\n\t\t\t\t\t{\n\t\t\t\t\t\tjobDefinitionCommand.Transaction = tran;\n\t\t\t\t\t\tjobHistoryCommand.Transaction = tran;\n\t\t\t\t\t\tjobDefinitionCommand.ExecuteNonQueryWithRetry(_retryPolicy);\n\t\t\t\t\t\tjobHistoryCommand.ExecuteNonQueryWithRetry(_retryPolicy);\n\t\t\t\t\t\tReportProgress(job.Id, \"Added\", DateTime.Now); \n\t\t\t\t\t\ttran.Commit();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception exp)\n\t\t\t\t{\n\t\t\t\t\tthis.Log().ErrorWithLineNumber(exp.Message, exp);\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tconnection.Close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tpublic List<JobDefinition> LoadAll()\n\t\t{\n\t\t\tconst string selectCommand = @\"SELECT  Id    \n                                            ,Name\n                                            ,Serialized\n                                            ,Type\n                                            ,UserName\n                                            ,AssignedNode\n\t\t\t\t\t\t\t\t\t\t\t,Status\n                                        FROM [Stardust].JobDefinitions\";\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar listToReturn = new List<JobDefinition>();\n\t\t\t\tusing (var connection = new SqlConnection(_connectionString))\n\t\t\t\t{\n\t\t\t\t\tconnection.OpenWithRetry(_retryPolicy);\n\t\t\t\t\tvar command = new SqlCommand\n\t\t\t\t\t{\n\t\t\t\t\t\tConnection = connection,\n\t\t\t\t\t\tCommandText = selectCommand,\n\t\t\t\t\t\tCommandType = CommandType.Text\n\t\t\t\t\t};\n\t\t\t\t\tvar reader = command.ExecuteReaderWithRetry(_retryPolicy);\n\t\t\t\t\tif (reader.HasRows)\n\t\t\t\t\t{\n\t\t\t\t\t\twhile (reader.Read())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar jobDefinition = new JobDefinition\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tId = (Guid)reader.GetValue(reader.GetOrdinal(\"Id\")),\n\t\t\t\t\t\t\t\tName = (string)reader.GetValue(reader.GetOrdinal(\"Name\")),\n\t\t\t\t\t\t\t\tSerialized = (string)reader.GetValue(reader.GetOrdinal(\"Serialized\")),\n\t\t\t\t\t\t\t\tType = (string)reader.GetValue(reader.GetOrdinal(\"Type\")),\n\t\t\t\t\t\t\t\tUserName = (string)reader.GetValue(reader.GetOrdinal(\"UserName\")),\n\t\t\t\t\t\t\t\tAssignedNode = GetValue<string>(reader.GetValue(reader.GetOrdinal(\"AssignedNode\"))),\n\t\t\t\t\t\t\t\tStatus = GetValue<string>(reader.GetValue(reader.GetOrdinal(\"Status\")))\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tlistToReturn.Add(jobDefinition);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treader.Close();\n\t\t\t\t\tconnection.Close();\n\t\t\t\t}\n\t\t\t\treturn listToReturn;\n\t\t\t}\n\t\t\tcatch (Exception exp)\n\t\t\t{\n\t\t\t\tthis.Log().ErrorWithLineNumber(exp.Message, exp);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tpublic void DeleteJob(Guid jobId)\n\t\t{\n\t\t\tusing (var connection = new SqlConnection(_connectionString))\n\t\t\t{\n\t\t\t\tSqlCommand deleteCommand = connection.CreateCommand();\n\t\t\t\tdeleteCommand.CommandText = \"DELETE FROM[Stardust].JobDefinitions WHERE Id = @ID\";\n\t\t\t\tdeleteCommand.Parameters.AddWithValue(\"@ID\", jobId);\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tconnection.OpenWithRetry(_retryPolicy);\n\n\t\t\t\t\tusing (var tran = connection.BeginTransaction())\n\t\t\t\t\t{\n\t\t\t\t\t\tdeleteCommand.Transaction = tran;\n\t\t\t\t\t\tdeleteCommand.ExecuteNonQueryWithRetry(_retryPolicy);\n\t\t\t\t\t\ttran.Commit();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception exp)\n\t\t\t\t{\n\t\t\t\t\tthis.Log().ErrorWithLineNumber(exp.Message, exp);\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tconnection.Close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void FreeJobIfNodeIsAssigned(string url)\n\t\t{\n\t\t\tusing (var connection = new SqlConnection(_connectionString))\n\t\t\t{\n\t\t\t\tSqlCommand deleteCommand = connection.CreateCommand();\n\t\t\t\tdeleteCommand.CommandText = \"Update [Stardust].JobDefinitions Set AssignedNode = null where AssignedNode = @assingedNode\";\n\t\t\t\tdeleteCommand.Parameters.AddWithValue(\"@assingedNode\", url);\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tconnection.OpenWithRetry(_retryPolicy);\n\t\t\t\t\tusing (var tran = connection.BeginTransaction())\n\t\t\t\t\t{\n\t\t\t\t\t\tdeleteCommand.Transaction = tran;\n\t\t\t\t\t\tdeleteCommand.ExecuteNonQueryWithRetry(_retryPolicy);\n\t\t\t\t\t\ttran.Commit();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception exp)\n\t\t\t\t{\n\t\t\t\t\tthis.Log().ErrorWithLineNumber(exp.Message, exp);\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tconnection.Close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void CheckAndAssignNextJob(List<WorkerNode> availableNodes, IHttpSender httpSender)\n\t\t{\n\t\t\trunner(() => tryCheckAndAssignNextJob(availableNodes, httpSender), \"Unable to perform operation\");\n\t\t}\n\n\t\tprivate async void tryCheckAndAssignNextJob(List<WorkerNode> availableNodes,\n\t\t\t\t\t\t\t\t\t\t\t\tIHttpSender httpSender)\n\t\t{\n\t\t\tif (!availableNodes.Any()) return;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing (var connection = new SqlConnection(_connectionString))\n\t\t\t\t{\n\t\t\t\t\tconnection.OpenWithRetry(_retryPolicy);\n\t\t\t\t\tusing (var tran = connection.BeginTransaction(IsolationLevel.Serializable))\n\t\t\t\t\t{\n\t\t\t\t\t\tusing (\n\t\t\t\t\t\t\tvar da =\n\t\t\t\t\t\t\t\tnew SqlDataAdapter(\n\t\t\t\t\t\t\t\t\t\"SELECT TOP 1 * FROM [Stardust].JobDefinitions WITH (TABLOCKX) WHERE AssignedNode IS NULL OR AssignedNode = ''\",\n\t\t\t\t\t\t\t\t\tconnection)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tSelectCommand =\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tTransaction = tran,\n\t\t\t\t\t\t\t\t\t\tCommandTimeout = 10\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar jobs = new DataTable();\n\t\t\t\t\t\t\tda.Fill(jobs);\n\n\t\t\t\t\t\t\tif (jobs.Rows.Count > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar jobRow = jobs.Rows[0];\n\t\t\t\t\t\t\t\tvar job = new JobToDo\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tId = (Guid) jobRow[\"Id\"],\n\t\t\t\t\t\t\t\t\tName = GetValue<string>(jobRow[\"Name\"]),\n\t\t\t\t\t\t\t\t\tSerialized = GetValue<string>(jobRow[\"Serialized\"]).Replace(@\"\\\", @\"\"),\n\t\t\t\t\t\t\t\t\tType = GetValue<string>(jobRow[\"Type\"]),\n\t\t\t\t\t\t\t\t\tCreatedBy = GetValue<string>(jobRow[\"UserName\"])\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tda.UpdateCommand =\n\t\t\t\t\t\t\t\t\tnew SqlCommand(\n\t\t\t\t\t\t\t\t\t\t\"UPDATE [Stardust].JobDefinitions SET AssignedNode = @AssignedNode, Status = 'Started' WHERE Id = @Id\",\n\t\t\t\t\t\t\t\t\t\tconnection);\n\n\t\t\t\t\t\t\t\tvar nodeParam = da.UpdateCommand.Parameters.Add(\"@AssignedNode\", SqlDbType.NVarChar);\n\t\t\t\t\t\t\t\tnodeParam.SourceColumn = \"AssignedNode\";\n\n\t\t\t\t\t\t\t\tvar parameter = da.UpdateCommand.Parameters.Add(\"@Id\", SqlDbType.UniqueIdentifier);\n\t\t\t\t\t\t\t\tparameter.SourceColumn = \"Id\";\n\t\t\t\t\t\t\t\tparameter.Value = job.Id;\n\n\t\t\t\t\t\t\t\tda.UpdateCommand.Transaction = tran;\n\n\t\t\t\t\t\t\t\tforeach (var node in availableNodes)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tvar builderHelper = new NodeUriBuilderHelper(node.Url);\n\t\t\t\t\t\t\t\t\t\tvar urijob = builderHelper.GetJobTemplateUri();\n\t\t\t\t\t\t\t\t\t\tHttpResponseMessage response = await httpSender.PostAsync(urijob, job);\n\n\t\t\t\t\t\t\t\t\t\tif (response.IsSuccessStatusCode)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\/\/save\n\t\t\t\t\t\t\t\t\t\t\tnodeParam.Value = node.Url.ToString();\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.ExecuteNonQueryWithRetry(_retryPolicy);\n\n\t\t\t\t\t\t\t\t\t\t\t\/\/update history\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand =\n\t\t\t\t\t\t\t\t\t\t\t\tnew SqlCommand(\"UPDATE [Stardust].JobHistory SET Started = @Started, SentTo = @Node WHERE JobId = @Id\",\n\t\t\t\t\t\t\t\t\t\t\t\t               connection);\n\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters.Add(\"@Id\", SqlDbType.UniqueIdentifier, 16, \"JobId\");\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters[0].Value = job.Id;\n\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters.Add(\"@Started\", SqlDbType.DateTime, 16, \"Started\");\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters[1].Value = DateTime.UtcNow;\n\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters.Add(\"@Node\", SqlDbType.NVarChar, 2000, \"SentTo\");\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters[2].Value = node.Url.ToString();\n\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.Transaction = tran;\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.ExecuteNonQueryWithRetry(_retryPolicy);\n\n\t\t\t\t\t\t\t\t\t\t\tReportProgress(job.Id, \"Started\", DateTime.Now);\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (response.StatusCode.Equals(HttpStatusCode.BadRequest))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\/\/remove the job if badrequest\n\t\t\t\t\t\t\t\t\t\t\tda.DeleteCommand = new SqlCommand(\"DELETE FROM [Stardust].JobDefinitions WHERE Id = @Id\",\n\t\t\t\t\t\t\t\t\t\t\t                                  connection);\n\t\t\t\t\t\t\t\t\t\t\tvar deleteParameter = da.DeleteCommand.Parameters.Add(\"@Id\", SqlDbType.UniqueIdentifier);\n\t\t\t\t\t\t\t\t\t\t\tdeleteParameter.SourceColumn = \"Id\";\n\t\t\t\t\t\t\t\t\t\t\tdeleteParameter.Value = job.Id;\n\n\t\t\t\t\t\t\t\t\t\t\tda.DeleteCommand.Transaction = tran;\n\t\t\t\t\t\t\t\t\t\t\tda.DeleteCommand.ExecuteNonQueryWithRetry(_retryPolicy);\n\n\t\t\t\t\t\t\t\t\t\t\t\/\/update history\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand =\n\t\t\t\t\t\t\t\t\t\t\t\tnew SqlCommand(\"UPDATE [Stardust].JobHistory \" +\n\t\t\t\t\t\t\t\t\t\t\t\t               \"SET Result = @Result, SentTo = @Node WHERE JobId = @Id\",\n\t\t\t\t\t\t\t\t\t\t\t\t               connection);\n\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters.Add(\"@Id\", SqlDbType.UniqueIdentifier, 16, \"JobId\");\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters[0].Value = job.Id;\n\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters.Add(\"@Result\", SqlDbType.NVarChar, 200, \"Result\");\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters[1].Value = \"Removed because of bad request\";\n\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters.Add(\"@Node\", SqlDbType.NVarChar, 2000, \"SentTo\");\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters[2].Value = node.Url.ToString();\n\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.Transaction = tran;\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.ExecuteNonQueryWithRetry(_retryPolicy);\n\n\t\t\t\t\t\t\t\t\t\t\t\/\/insert into history detail.\n\t\t\t\t\t\t\t\t\t\t\tif (response.ReasonPhrase != null)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tstring insertcommand = @\"INSERT INTO [Stardust].[JobHistoryDetail]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t([JobId]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t,[Created]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t,[Detail])\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tVALUES\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(@JobId\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t,@Created\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t,@Detail)\";\n\n\t\t\t\t\t\t\t\t\t\t\t\tda.InsertCommand = new SqlCommand(insertcommand, connection);\n\n\t\t\t\t\t\t\t\t\t\t\t\tda.InsertCommand.Parameters.Add(\"@JobId\", SqlDbType.UniqueIdentifier, 16);\n\t\t\t\t\t\t\t\t\t\t\t\tda.InsertCommand.Parameters[0].Value = job.Id;\n\n\n\t\t\t\t\t\t\t\t\t\t\t\tda.InsertCommand.Parameters.Add(\"@Detail\",\n\t\t\t\t\t\t\t\t\t\t\t\t                                SqlDbType.NText);\n\t\t\t\t\t\t\t\t\t\t\t\tda.InsertCommand.Parameters[1].Value = response.ReasonPhrase;\n\n\t\t\t\t\t\t\t\t\t\t\t\tda.InsertCommand.Parameters.Add(\"@Created\", SqlDbType.DateTime, 16);\n\t\t\t\t\t\t\t\t\t\t\t\tda.InsertCommand.Parameters[2].Value = DateTime.Now;\n\n\t\t\t\t\t\t\t\t\t\t\t\tda.InsertCommand.Transaction = tran;\n\t\t\t\t\t\t\t\t\t\t\t\tda.InsertCommand.ExecuteNonQueryWithRetry(_retryPolicy);\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcatch (SqlException exp)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (exp.Number == -2) \/\/Timeout\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tthis.Log().InfoWithLineNumber(exp.Message);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tthis.Log().ErrorWithLineNumber(exp.Message, exp);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcatch (Exception exp)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tthis.Log().ErrorWithLineNumber(exp.Message, exp);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttran.Commit();\n\t\t\t\t\t\tconnection.Close();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (SqlException exp)\n\t\t\t{\n\t\t\t\tif (exp.Number == -2) \/\/Timeout\n\t\t\t\t{\n\t\t\t\t\tthis.Log().InfoWithLineNumber(exp.Message);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.Log().ErrorWithLineNumber(exp.Message, exp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcatch (Exception exp)\n\t\t\t{\n\t\t\t\tthis.Log().ErrorWithLineNumber(exp.Message, exp);\n\t\t\t}\n\t\t}\n\n\n\t\tpublic async void CancelThisJob(Guid jobId, IHttpSender httpSender)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing (var connection = new SqlConnection(_connectionString))\n\t\t\t\t{\n\t\t\t\t\tconnection.OpenWithRetry(_retryPolicy);\n\t\t\t\t\tvar tran = connection.BeginTransaction(IsolationLevel.Serializable);\n\n\t\t\t\t\tusing (var da =\n\t\t\t\t\t\tnew SqlDataAdapter(string.Format(\"SELECT * From [Stardust].JobDefinitions  WITH (TABLOCKX) WHERE Id = '{0}'\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t jobId),\n\t\t\t\t\t\t\t\t\t\t   connection)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSelectCommand =\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tTransaction = tran\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t{\n\t\t\t\t\t\tvar jobs = new DataTable();\n\t\t\t\t\t\tda.Fill(jobs);\n\t\t\t\t\t\tif (jobs.Rows.Count > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar jobRow = jobs.Rows[0];\n\t\t\t\t\t\t\tvar node = GetValue<string>(jobRow[\"AssignedNode\"]);\n\n\t\t\t\t\t\t\tif (string.IsNullOrEmpty(node))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tda.DeleteCommand = new SqlCommand(\"DELETE FROM [Stardust].JobDefinitions WHERE Id = @Id\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  connection);\n\n\t\t\t\t\t\t\t\tvar parameter = da.DeleteCommand.Parameters.Add(\"@Id\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSqlDbType.UniqueIdentifier);\n\t\t\t\t\t\t\t\tparameter.SourceColumn = \"Id\";\n\t\t\t\t\t\t\t\tparameter.Value = jobId;\n\t\t\t\t\t\t\t\tda.DeleteCommand.Transaction = tran;\n\t\t\t\t\t\t\t\tda.DeleteCommand.ExecuteNonQueryWithRetry(_retryPolicy);\n\n\t\t\t\t\t\t\t\t\/\/update history\n\t\t\t\t\t\t\t\tda.UpdateCommand = new SqlCommand(\"UPDATE [Stardust].JobHistory SET Result = @Result WHERE JobId = @Id\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  connection);\n\n\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters.Add(\"@Id\", SqlDbType.UniqueIdentifier, 16, \"JobId\");\n\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters[0].Value = jobId;\n\n\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters.Add(\"@Result\", SqlDbType.NVarChar, 2000, \"Result\");\n\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters[1].Value = \"Deleted\";\n\n\t\t\t\t\t\t\t\tda.UpdateCommand.Transaction = tran;\n\t\t\t\t\t\t\t\tda.UpdateCommand.ExecuteNonQueryWithRetry(_retryPolicy);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar builderHelper = new NodeUriBuilderHelper(node);\n\t\t\t\t\t\t\t\tvar uriCancel = builderHelper.GetCancelJobUri(jobId);\n\n\t\t\t\t\t\t\t\tvar response = await httpSender.DeleteAsync(uriCancel);\n\n\t\t\t\t\t\t\t\tif (response != null && response.IsSuccessStatusCode)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tda.UpdateCommand = new SqlCommand(\"UPDATE [Stardust].JobDefinitions SET Status = 'Canceling' WHERE Id = @Id\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  connection);\n\n\t\t\t\t\t\t\t\t\tvar parameter = da.UpdateCommand.Parameters.Add(\"@Id\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSqlDbType.UniqueIdentifier);\n\t\t\t\t\t\t\t\t\tparameter.SourceColumn = \"Id\";\n\t\t\t\t\t\t\t\t\tparameter.Value = jobId;\n\n\t\t\t\t\t\t\t\t\tda.UpdateCommand.Transaction = tran;\n\t\t\t\t\t\t\t\t\tda.UpdateCommand.ExecuteNonQueryWithRetry(_retryPolicy);\n\n\t\t\t\t\t\t\t\t\tReportProgress(jobId,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"Canceling\",\n\t\t\t\t\t\t\t\t\t\t\t\t   DateTime.Now);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.Log().WarningWithLineNumber(\"[MANAGER, \" + Environment.MachineName +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   \"] : Could not find job defintion for id : \" + jobId);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttran.Commit();\n\t\t\t\t\tconnection.Close();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception exp)\n\t\t\t{\n\t\t\t\tthis.Log().ErrorWithLineNumber(exp.Message, exp);\n\t\t\t}\n\n\t\t}\n\n\t\tpublic void SetEndResultOnJob(Guid jobId, string result)\n\t\t{\n\t\t\tusing (var connection = new SqlConnection(_connectionString))\n\t\t\t{\n\t\t\t\tSqlCommand command = connection.CreateCommand();\n\t\t\t\tcommand.CommandText = \"UPDATE [Stardust].JobHistory SET Result = @Result, Ended = @Ended WHERE JobId = @Id\";\n\t\t\t\tcommand.Parameters.AddWithValue(\"@Id\", jobId);\n\t\t\t\tcommand.Parameters.AddWithValue(\"@Result\", result);\n\t\t\t\tcommand.Parameters.AddWithValue(\"@Ended\", DateTime.Now);\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tconnection.OpenWithRetry(_retryPolicy);\n\t\t\t\t\tusing (var tran = connection.BeginTransaction())\n\t\t\t\t\t{\n\t\t\t\t\t\tcommand.Transaction = tran;\n\t\t\t\t\t\tcommand.ExecuteNonQueryWithRetry(_retryPolicy);\n\t\t\t\t\t\tReportProgress(jobId, result, DateTime.Now);\n\t\t\t\t\t\ttran.Commit();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception exp)\n\t\t\t\t{\n\t\t\t\t\tthis.Log().ErrorWithLineNumber(exp.Message, exp);\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tconnection.Close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void ReportProgress(Guid jobId, string detail, DateTime created)\n\t\t{\n\t\t\tusing (var connection = new SqlConnection(_connectionString))\n\t\t\t{\n\t\t\t\tSqlCommand command = connection.CreateCommand();\n\t\t\t\tcommand.CommandText = \"INSERT INTO [Stardust].JobHistoryDetail (JobId, Detail, Created) VALUES (@Id, @Detail, @Created)\";\n\t\t\t\tcommand.Parameters.AddWithValue(\"@Id\", jobId);\n\t\t\t\tcommand.Parameters.AddWithValue(\"@Detail\", detail);\n\t\t\t\tcommand.Parameters.AddWithValue(\"@Created\", created);\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tconnection.OpenWithRetry(_retryPolicy);\n\t\t\t\t\tusing (var tran = connection.BeginTransaction())\n\t\t\t\t\t{\n\t\t\t\t\t\tcommand.Transaction = tran;\n\t\t\t\t\t\tcommand.ExecuteNonQueryWithRetry(_retryPolicy);\n\t\t\t\t\t\ttran.Commit();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception exp)\n\t\t\t\t{\n\t\t\t\t\tthis.Log().ErrorWithLineNumber(exp.Message, exp);\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tconnection.Close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\t\tpublic JobHistory History(Guid jobId)\n\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar selectCommand = SelectHistoryCommand(true);\n\t\t\t\tusing (var connection = new SqlConnection(_connectionString))\n\t\t\t\t{\n\t\t\t\t\tvar command = new SqlCommand\n\t\t\t\t\t{\n\t\t\t\t\t\tConnection = connection,\n\t\t\t\t\t\tCommandText = selectCommand,\n\t\t\t\t\t\tCommandType = CommandType.Text\n\t\t\t\t\t};\n\n\t\t\t\t\tcommand.Parameters.Add(\"@JobId\", SqlDbType.UniqueIdentifier, 16, \"JobId\");\n\t\t\t\t\tcommand.Parameters[0].Value = jobId;\n\n\t\t\t\t\tconnection.OpenWithRetry(_retryPolicy);\n\t\t\t\t\tusing (var reader = command.ExecuteReaderWithRetry(_retryPolicy))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (reader.HasRows)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treader.Read();\n\t\t\t\t\t\t\tvar jobHist = NewJobHistoryModel(reader);\n\t\t\t\t\t\t\treturn jobHist;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treader.Close();\n\t\t\t\t\t\tconnection.Close();\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception exp)\n\t\t\t{\n\t\t\t\tthis.Log().ErrorWithLineNumber(exp.Message, exp);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic IList<JobHistory> HistoryList()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar selectCommand = SelectHistoryCommand(false);\n\t\t\t\tvar returnList = new List<JobHistory>();\n\t\t\t\tusing (var connection = new SqlConnection(_connectionString))\n\t\t\t\t{\n\t\t\t\t\tvar command = new SqlCommand\n\t\t\t\t\t{\n\t\t\t\t\t\tConnection = connection,\n\t\t\t\t\t\tCommandText = selectCommand,\n\t\t\t\t\t\tCommandType = CommandType.Text\n\t\t\t\t\t};\n\n\t\t\t\t\tconnection.OpenWithRetry(_retryPolicy);\n\t\t\t\t\tusing (var reader = command.ExecuteReaderWithRetry(_retryPolicy))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (reader.HasRows)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\twhile (reader.Read())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar jobHist = NewJobHistoryModel(reader);\n\t\t\t\t\t\t\t\treturnList.Add(jobHist);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treader.Close();\n\t\t\t\t\t\tconnection.Close();\n\t\t\t\t\t}\n\t\t\t\t\treturn returnList;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception exp)\n\t\t\t{\n\t\t\t\tthis.Log().ErrorWithLineNumber(exp.Message, exp);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\n\t\tpublic IList<JobHistoryDetail> JobHistoryDetails(Guid jobId)\n\t\t{\n\t\t\tvar returnList = new List<JobHistoryDetail>();\n\t\t\tvar policy = _retryPolicyProvider.GetPolicy();\n\t\t\tapplyLoggingOnRetries(policy);\n\t\t\ttry\n\t\t\t{\n\t\t\t\treturnList = policy.ExecuteAction(() => tryJobHistoryDetails(jobId)).ToList();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tthis.Log().ErrorWithLineNumber(ex.Message + \"Unable to perform operation\");\n\t\t\t}\n\t\t\treturn returnList;\n\t\t}\n\n\t\tprivate IList<JobHistoryDetail> tryJobHistoryDetails(Guid jobId)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar selectCommand = @\"SELECT  Created, Detail  FROM [Stardust].JobHistoryDetail WHERE JobId = @JobId\";\n\t\t\t\tvar returnList = new List<JobHistoryDetail>();\n\t\t\t\tusing (var connection = new SqlConnection(_connectionString))\n\t\t\t\t{\n\t\t\t\t\tvar command = new SqlCommand\n\t\t\t\t\t{\n\t\t\t\t\t\tConnection = connection,\n\t\t\t\t\t\tCommandText = selectCommand,\n\t\t\t\t\t\tCommandType = CommandType.Text\n\t\t\t\t\t};\n\t\t\t\t\tcommand.Parameters.Add(\"@JobId\", SqlDbType.UniqueIdentifier, 16, \"JobId\");\n\t\t\t\t\tcommand.Parameters[0].Value = jobId;\n\n\t\t\t\t\tconnection.Open();\n\n\t\t\t\t\tusing (var reader = command.ExecuteReader())\n\t\t\t\t\t{\n\t\t\t\t\t\tif (reader.HasRows)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\twhile (reader.Read())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar detail = new JobHistoryDetail\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tCreated = (DateTime)reader.GetValue(reader.GetOrdinal(\"Created\")),\n\t\t\t\t\t\t\t\t\tDetail = (string)reader.GetValue(reader.GetOrdinal(\"Detail\"))\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\treturnList.Add(detail);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treader.Close();\n\t\t\t\t\t\tconnection.Close();\n\t\t\t\t\t}\n\n\t\t\t\t\treturn returnList;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcatch (Exception exp)\n\t\t\t{\n\t\t\t\tthis.Log().ErrorWithLineNumber(exp.Message, exp);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tprivate string GetValue<T>(object value)\n\t\t{\n\t\t\treturn value == DBNull.Value\n\t\t\t\t? null\n\t\t\t\t: (string)value;\n\t\t}\n\n\t\tprivate JobHistory NewJobHistoryModel(SqlDataReader reader)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar jobHist = new JobHistory\n\t\t\t\t{\n\t\t\t\t\tId = (Guid)reader.GetValue(reader.GetOrdinal(\"JobId\")),\n\t\t\t\t\tName = (string)reader.GetValue(reader.GetOrdinal(\"Name\")),\n\t\t\t\t\tCreatedBy = (string)reader.GetValue(reader.GetOrdinal(\"CreatedBy\")),\n\t\t\t\t\tSentTo = GetValue<string>(reader.GetValue(reader.GetOrdinal(\"SentTo\"))),\n\t\t\t\t\tResult = GetValue<string>(reader.GetValue(reader.GetOrdinal(\"Result\"))),\n\t\t\t\t\tCreated = (DateTime)reader.GetValue(reader.GetOrdinal(\"Created\")),\n\t\t\t\t\tStarted = GetDateTime(reader.GetValue(reader.GetOrdinal(\"Started\"))),\n\t\t\t\t\tEnded = GetDateTime(reader.GetValue(reader.GetOrdinal(\"Ended\")))\n\t\t\t\t};\n\n\t\t\t\treturn jobHist;\n\t\t\t}\n\t\t\tcatch (Exception exp)\n\t\t\t{\n\t\t\t\tthis.Log().ErrorWithLineNumber(exp.Message, exp);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tprivate static string SelectHistoryCommand(bool addParameter)\n\t\t{\n\t\t\tvar selectCommand = @\"SELECT \n                                             JobId    \n                                            ,Name\n                                            ,CreatedBy\n                                            ,Created\n                                            ,Started\n                                            ,Ended\n                                            ,SentTo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tResult\n                                        FROM [Stardust].JobHistory\";\n\n\t\t\tif (addParameter) selectCommand += \" WHERE JobId = @JobId\";\n\n\t\t\treturn selectCommand;\n\t\t}\n\n\t\tprivate DateTime? GetDateTime(object databaseValue)\n\t\t{\n\t\t\tif (databaseValue.Equals(DBNull.Value))\n\t\t\t\treturn null;\n\n\t\t\treturn (DateTime)databaseValue;\n\t\t}\n\t}\n}","old_contents":"\ufeffusing System;\nusing System.Collections.Generic;\nusing System.Data;\nusing System.Data.SqlClient;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Http;\nusing Microsoft.Practices.EnterpriseLibrary.TransientFaultHandling;\nusing Stardust.Manager.Extensions;\nusing Stardust.Manager.Helpers;\nusing Stardust.Manager.Interfaces;\nusing Stardust.Manager.Models;\n\nnamespace Stardust.Manager\n{\n\tpublic class JobRepository : IJobRepository\n\t{\n\t\tprivate readonly RetryPolicyProvider _retryPolicyProvider;\n\t\tprivate readonly RetryPolicy _retryPolicy;\n\t\tprivate readonly string _connectionString;\n\n\t\tpublic JobRepository(string connectionString, RetryPolicyProvider retryPolicyProvider)\n\t\t{\n\t\t\t_connectionString = connectionString;\n\t\t\t_retryPolicyProvider = retryPolicyProvider;\n\t\t\t_retryPolicy = retryPolicyProvider.GetPolicy();\n\t\t}\n\n\t\tprivate void runner(Action funcToRun, string faliureMessage)\n\t\t{\n\t\t\tvar policy = _retryPolicyProvider.GetPolicy();\n\t\t\tapplyLoggingOnRetries(policy);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tpolicy.ExecuteAction(funcToRun);\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tthis.Log().ErrorWithLineNumber(ex.Message + faliureMessage);\n\t\t\t}\n\t\t}\n\n\t\tprivate void applyLoggingOnRetries(RetryPolicy<SqlDatabaseTransientErrorDetectionStrategy> policy)\n\t\t{\n\t\t\tpolicy.Retrying += (sender, args) =>\n\t\t\t{\n\t\t\t\tvar msg = String.Format(\"Retry - Count:{0}, Delay:{1}, Exception:{2}\", args.CurrentRetryCount, args.Delay,\n\t\t\t\t\targs.LastException);\n\t\t\t\tthis.Log().ErrorWithLineNumber(msg);\n\t\t\t};\n\t\t}\n\n\t\tpublic void Add(JobDefinition job)\n\t\t{\n\t\t\tusing (var connection = new SqlConnection(_connectionString))\n\t\t\t{\n\t\t\t\tSqlCommand jobHistoryCommand = connection.CreateCommand();\n\t\t\t\tjobHistoryCommand.CommandText = \"INSERT INTO [Stardust].JobHistory (JobId, Name, CreatedBy, Serialized, Type) VALUES(@Id, @Name, @By, @Serialized, @Type)\";\n\t\t\t\tjobHistoryCommand.Parameters.AddWithValue(\"@Id\", job.Id);\n\t\t\t\tjobHistoryCommand.Parameters.AddWithValue(\"@Name\", job.Name);\n\t\t\t\tjobHistoryCommand.Parameters.AddWithValue(\"@By\", job.UserName);\n\t\t\t\tjobHistoryCommand.Parameters.AddWithValue(\"@Serialized\", job.Serialized);\n\t\t\t\tjobHistoryCommand.Parameters.AddWithValue(\"@Type\", job.Type);\n\n\t\t\t\tSqlCommand jobDefinitionCommand = connection.CreateCommand();\n\t\t\t\tjobDefinitionCommand.CommandText = \"INSERT INTO [Stardust].JobDefinitions (Id, Name, Serialized, Type, userName) VALUES(@Id, @Name, @Serialized, @Type, @UserName)\";\n\t\t\t\tjobDefinitionCommand.Parameters.AddWithValue(\"@Id\", job.Id);\n\t\t\t\tjobDefinitionCommand.Parameters.AddWithValue(\"@Name\", job.Name);\n\t\t\t\tjobDefinitionCommand.Parameters.AddWithValue(\"@UserName\", job.UserName);\n\t\t\t\tjobDefinitionCommand.Parameters.AddWithValue(\"@Serialized\", job.Serialized);\n\t\t\t\tjobDefinitionCommand.Parameters.AddWithValue(\"@Type\", job.Type);\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tconnection.OpenWithRetry(_retryPolicy);\n\t\t\t\t\tusing (var tran = connection.BeginTransaction())\n\t\t\t\t\t{\n\t\t\t\t\t\tjobDefinitionCommand.Transaction = tran;\n\t\t\t\t\t\tjobHistoryCommand.Transaction = tran;\n\t\t\t\t\t\tjobDefinitionCommand.ExecuteNonQueryWithRetry(_retryPolicy);\n\t\t\t\t\t\tjobHistoryCommand.ExecuteNonQueryWithRetry(_retryPolicy);\n\t\t\t\t\t\tReportProgress(job.Id, \"Added\", DateTime.Now); \n\t\t\t\t\t\ttran.Commit();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception exp)\n\t\t\t\t{\n\t\t\t\t\tthis.Log().ErrorWithLineNumber(exp.Message, exp);\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tconnection.Close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tpublic List<JobDefinition> LoadAll()\n\t\t{\n\t\t\tconst string selectCommand = @\"SELECT  Id    \n                                            ,Name\n                                            ,Serialized\n                                            ,Type\n                                            ,UserName\n                                            ,AssignedNode\n\t\t\t\t\t\t\t\t\t\t\t,Status\n                                        FROM [Stardust].JobDefinitions\";\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar listToReturn = new List<JobDefinition>();\n\t\t\t\tusing (var connection = new SqlConnection(_connectionString))\n\t\t\t\t{\n\t\t\t\t\tconnection.OpenWithRetry(_retryPolicy);\n\t\t\t\t\tvar command = new SqlCommand\n\t\t\t\t\t{\n\t\t\t\t\t\tConnection = connection,\n\t\t\t\t\t\tCommandText = selectCommand,\n\t\t\t\t\t\tCommandType = CommandType.Text\n\t\t\t\t\t};\n\t\t\t\t\tvar reader = command.ExecuteReaderWithRetry(_retryPolicy);\n\t\t\t\t\tif (reader.HasRows)\n\t\t\t\t\t{\n\t\t\t\t\t\twhile (reader.Read())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar jobDefinition = new JobDefinition\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tId = (Guid)reader.GetValue(reader.GetOrdinal(\"Id\")),\n\t\t\t\t\t\t\t\tName = (string)reader.GetValue(reader.GetOrdinal(\"Name\")),\n\t\t\t\t\t\t\t\tSerialized = (string)reader.GetValue(reader.GetOrdinal(\"Serialized\")),\n\t\t\t\t\t\t\t\tType = (string)reader.GetValue(reader.GetOrdinal(\"Type\")),\n\t\t\t\t\t\t\t\tUserName = (string)reader.GetValue(reader.GetOrdinal(\"UserName\")),\n\t\t\t\t\t\t\t\tAssignedNode = GetValue<string>(reader.GetValue(reader.GetOrdinal(\"AssignedNode\"))),\n\t\t\t\t\t\t\t\tStatus = GetValue<string>(reader.GetValue(reader.GetOrdinal(\"Status\")))\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tlistToReturn.Add(jobDefinition);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treader.Close();\n\t\t\t\t\tconnection.Close();\n\t\t\t\t}\n\t\t\t\treturn listToReturn;\n\t\t\t}\n\t\t\tcatch (Exception exp)\n\t\t\t{\n\t\t\t\tthis.Log().ErrorWithLineNumber(exp.Message, exp);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tpublic void DeleteJob(Guid jobId)\n\t\t{\n\t\t\tusing (var connection = new SqlConnection(_connectionString))\n\t\t\t{\n\t\t\t\tSqlCommand deleteCommand = connection.CreateCommand();\n\t\t\t\tdeleteCommand.CommandText = \"DELETE FROM[Stardust].JobDefinitions WHERE Id = @ID\";\n\t\t\t\tdeleteCommand.Parameters.AddWithValue(\"@ID\", jobId);\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tconnection.OpenWithRetry(_retryPolicy);\n\n\t\t\t\t\tusing (var tran = connection.BeginTransaction())\n\t\t\t\t\t{\n\t\t\t\t\t\tdeleteCommand.Transaction = tran;\n\t\t\t\t\t\tdeleteCommand.ExecuteNonQueryWithRetry(_retryPolicy);\n\t\t\t\t\t\ttran.Commit();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception exp)\n\t\t\t\t{\n\t\t\t\t\tthis.Log().ErrorWithLineNumber(exp.Message, exp);\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tconnection.Close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void FreeJobIfNodeIsAssigned(string url)\n\t\t{\n\t\t\tusing (var connection = new SqlConnection(_connectionString))\n\t\t\t{\n\t\t\t\tSqlCommand deleteCommand = connection.CreateCommand();\n\t\t\t\tdeleteCommand.CommandText = \"Update [Stardust].JobDefinitions Set AssignedNode = null where AssignedNode = @assingedNode\";\n\t\t\t\tdeleteCommand.Parameters.AddWithValue(\"@assingedNode\", url);\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tconnection.OpenWithRetry(_retryPolicy);\n\t\t\t\t\tusing (var tran = connection.BeginTransaction())\n\t\t\t\t\t{\n\t\t\t\t\t\tdeleteCommand.Transaction = tran;\n\t\t\t\t\t\tdeleteCommand.ExecuteNonQueryWithRetry(_retryPolicy);\n\t\t\t\t\t\ttran.Commit();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception exp)\n\t\t\t\t{\n\t\t\t\t\tthis.Log().ErrorWithLineNumber(exp.Message, exp);\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tconnection.Close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void CheckAndAssignNextJob(List<WorkerNode> availableNodes, IHttpSender httpSender)\n\t\t{\n\t\t\trunner(() => tryCheckAndAssignNextJob(availableNodes, httpSender), \"Unable to perform operation\");\n\t\t}\n\n\t\tprivate async void tryCheckAndAssignNextJob(List<WorkerNode> availableNodes,\n\t\t\t\t\t\t\t\t\t\t\t\tIHttpSender httpSender)\n\t\t{\n\t\t\tif (!availableNodes.Any()) return;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing (var connection = new SqlConnection(_connectionString))\n\t\t\t\t{\n\t\t\t\t\tconnection.OpenWithRetry(_retryPolicy);\n\t\t\t\t\tusing (var tran = connection.BeginTransaction(IsolationLevel.Serializable))\n\t\t\t\t\t{\n\t\t\t\t\t\tusing (\n\t\t\t\t\t\t\tvar da =\n\t\t\t\t\t\t\t\tnew SqlDataAdapter(\n\t\t\t\t\t\t\t\t\t\"SELECT TOP 1 * FROM [Stardust].JobDefinitions WITH (TABLOCKX) WHERE AssignedNode IS NULL OR AssignedNode = ''\",\n\t\t\t\t\t\t\t\t\tconnection)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tSelectCommand =\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tTransaction = tran,\n\t\t\t\t\t\t\t\t\t\tCommandTimeout = 10\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar jobs = new DataTable();\n\t\t\t\t\t\t\tda.Fill(jobs);\n\n\t\t\t\t\t\t\tif (jobs.Rows.Count > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar jobRow = jobs.Rows[0];\n\t\t\t\t\t\t\t\tvar job = new JobToDo\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tId = (Guid) jobRow[\"Id\"],\n\t\t\t\t\t\t\t\t\tName = GetValue<string>(jobRow[\"Name\"]),\n\t\t\t\t\t\t\t\t\tSerialized = GetValue<string>(jobRow[\"Serialized\"]).Replace(@\"\\\", @\"\"),\n\t\t\t\t\t\t\t\t\tType = GetValue<string>(jobRow[\"Type\"]),\n\t\t\t\t\t\t\t\t\tCreatedBy = GetValue<string>(jobRow[\"UserName\"])\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tda.UpdateCommand =\n\t\t\t\t\t\t\t\t\tnew SqlCommand(\n\t\t\t\t\t\t\t\t\t\t\"UPDATE [Stardust].JobDefinitions SET AssignedNode = @AssignedNode, Status = 'Started' WHERE Id = @Id\",\n\t\t\t\t\t\t\t\t\t\tconnection);\n\n\t\t\t\t\t\t\t\tvar nodeParam = da.UpdateCommand.Parameters.Add(\"@AssignedNode\", SqlDbType.NVarChar);\n\t\t\t\t\t\t\t\tnodeParam.SourceColumn = \"AssignedNode\";\n\n\t\t\t\t\t\t\t\tvar parameter = da.UpdateCommand.Parameters.Add(\"@Id\", SqlDbType.UniqueIdentifier);\n\t\t\t\t\t\t\t\tparameter.SourceColumn = \"Id\";\n\t\t\t\t\t\t\t\tparameter.Value = job.Id;\n\n\t\t\t\t\t\t\t\tda.UpdateCommand.Transaction = tran;\n\n\t\t\t\t\t\t\t\tforeach (var node in availableNodes)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tvar builderHelper = new NodeUriBuilderHelper(node.Url);\n\t\t\t\t\t\t\t\t\t\tvar urijob = builderHelper.GetJobTemplateUri();\n\t\t\t\t\t\t\t\t\t\tHttpResponseMessage response = await httpSender.PostAsync(urijob, job);\n\n\t\t\t\t\t\t\t\t\t\tif (response.IsSuccessStatusCode)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\/\/save\n\t\t\t\t\t\t\t\t\t\t\tnodeParam.Value = node.Url.ToString();\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.ExecuteNonQueryWithRetry(_retryPolicy);\n\n\t\t\t\t\t\t\t\t\t\t\t\/\/update history\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand =\n\t\t\t\t\t\t\t\t\t\t\t\tnew SqlCommand(\"UPDATE [Stardust].JobHistory SET Started = @Started, SentTo = @Node WHERE JobId = @Id\",\n\t\t\t\t\t\t\t\t\t\t\t\t               connection);\n\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters.Add(\"@Id\", SqlDbType.UniqueIdentifier, 16, \"JobId\");\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters[0].Value = job.Id;\n\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters.Add(\"@Started\", SqlDbType.DateTime, 16, \"Started\");\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters[1].Value = DateTime.UtcNow;\n\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters.Add(\"@Node\", SqlDbType.NVarChar, 2000, \"SentTo\");\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters[2].Value = node.Url.ToString();\n\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.Transaction = tran;\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.ExecuteNonQueryWithRetry(_retryPolicy);\n\n\t\t\t\t\t\t\t\t\t\t\tReportProgress(job.Id, \"Started\", DateTime.Now);\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (response.StatusCode.Equals(HttpStatusCode.BadRequest))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\/\/remove the job if badrequest\n\t\t\t\t\t\t\t\t\t\t\tda.DeleteCommand = new SqlCommand(\"DELETE FROM [Stardust].JobDefinitions WHERE Id = @Id\",\n\t\t\t\t\t\t\t\t\t\t\t                                  connection);\n\t\t\t\t\t\t\t\t\t\t\tvar deleteParameter = da.DeleteCommand.Parameters.Add(\"@Id\", SqlDbType.UniqueIdentifier);\n\t\t\t\t\t\t\t\t\t\t\tdeleteParameter.SourceColumn = \"Id\";\n\t\t\t\t\t\t\t\t\t\t\tdeleteParameter.Value = job.Id;\n\n\t\t\t\t\t\t\t\t\t\t\tda.DeleteCommand.Transaction = tran;\n\t\t\t\t\t\t\t\t\t\t\tda.DeleteCommand.ExecuteNonQueryWithRetry(_retryPolicy);\n\n\t\t\t\t\t\t\t\t\t\t\t\/\/update history\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand =\n\t\t\t\t\t\t\t\t\t\t\t\tnew SqlCommand(\"UPDATE [Stardust].JobHistory \" +\n\t\t\t\t\t\t\t\t\t\t\t\t               \"SET Result = @Result, SentTo = @Node WHERE JobId = @Id\",\n\t\t\t\t\t\t\t\t\t\t\t\t               connection);\n\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters.Add(\"@Id\", SqlDbType.UniqueIdentifier, 16, \"JobId\");\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters[0].Value = job.Id;\n\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters.Add(\"@Result\", SqlDbType.NVarChar, 200, \"Result\");\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters[1].Value = \"Removed because of bad request\";\n\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters.Add(\"@Node\", SqlDbType.NVarChar, 2000, \"SentTo\");\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters[2].Value = node.Url.ToString();\n\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.Transaction = tran;\n\t\t\t\t\t\t\t\t\t\t\tda.UpdateCommand.ExecuteNonQueryWithRetry(_retryPolicy);\n\n\t\t\t\t\t\t\t\t\t\t\t\/\/insert into history detail.\n\t\t\t\t\t\t\t\t\t\t\tif (response.ReasonPhrase != null)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tstring insertcommand = @\"INSERT INTO [Stardust].[JobHistoryDetail]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t([JobId]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t,[Created]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t,[Detail])\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tVALUES\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(@JobId\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t,@Created\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t,@Detail)\";\n\n\t\t\t\t\t\t\t\t\t\t\t\tda.InsertCommand = new SqlCommand(insertcommand, connection);\n\n\t\t\t\t\t\t\t\t\t\t\t\tda.InsertCommand.Parameters.Add(\"@JobId\", SqlDbType.UniqueIdentifier, 16);\n\t\t\t\t\t\t\t\t\t\t\t\tda.InsertCommand.Parameters[0].Value = job.Id;\n\n\n\t\t\t\t\t\t\t\t\t\t\t\tda.InsertCommand.Parameters.Add(\"@Detail\",\n\t\t\t\t\t\t\t\t\t\t\t\t                                SqlDbType.NText);\n\t\t\t\t\t\t\t\t\t\t\t\tda.InsertCommand.Parameters[1].Value = response.ReasonPhrase;\n\n\t\t\t\t\t\t\t\t\t\t\t\tda.InsertCommand.Parameters.Add(\"@Created\", SqlDbType.DateTime, 16);\n\t\t\t\t\t\t\t\t\t\t\t\tda.InsertCommand.Parameters[2].Value = DateTime.Now;\n\n\t\t\t\t\t\t\t\t\t\t\t\tda.InsertCommand.Transaction = tran;\n\t\t\t\t\t\t\t\t\t\t\t\tda.InsertCommand.ExecuteNonQueryWithRetry(_retryPolicy);\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcatch (SqlException exp)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (exp.Number == -2) \/\/Timeout\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tthis.Log().InfoWithLineNumber(exp.Message);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tthis.Log().ErrorWithLineNumber(exp.Message, exp);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcatch (Exception exp)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tthis.Log().ErrorWithLineNumber(exp.Message, exp);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttran.Commit();\n\t\t\t\t\t\tconnection.Close();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (SqlException exp)\n\t\t\t{\n\t\t\t\tif (exp.Number == -2) \/\/Timeout\n\t\t\t\t{\n\t\t\t\t\tthis.Log().InfoWithLineNumber(exp.Message);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthis.Log().ErrorWithLineNumber(exp.Message, exp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcatch (Exception exp)\n\t\t\t{\n\t\t\t\tthis.Log().ErrorWithLineNumber(exp.Message, exp);\n\t\t\t}\n\t\t}\n\n\n\t\tpublic async void CancelThisJob(Guid jobId, IHttpSender httpSender)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tusing (var connection = new SqlConnection(_connectionString))\n\t\t\t\t{\n\t\t\t\t\tconnection.OpenWithRetry(_retryPolicy);\n\t\t\t\t\tvar tran = connection.BeginTransaction(IsolationLevel.Serializable);\n\n\t\t\t\t\tusing (var da =\n\t\t\t\t\t\tnew SqlDataAdapter(string.Format(\"SELECT * From [Stardust].JobDefinitions  WITH (TABLOCKX) WHERE Id = '{0}'\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t jobId),\n\t\t\t\t\t\t\t\t\t\t   connection)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSelectCommand =\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tTransaction = tran\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t{\n\t\t\t\t\t\tvar jobs = new DataTable();\n\t\t\t\t\t\tda.Fill(jobs);\n\t\t\t\t\t\tif (jobs.Rows.Count > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar jobRow = jobs.Rows[0];\n\t\t\t\t\t\t\tvar node = GetValue<string>(jobRow[\"AssignedNode\"]);\n\n\t\t\t\t\t\t\tif (string.IsNullOrEmpty(node))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tda.DeleteCommand = new SqlCommand(\"DELETE FROM [Stardust].JobDefinitions WHERE Id = @Id\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  connection);\n\n\t\t\t\t\t\t\t\tvar parameter = da.DeleteCommand.Parameters.Add(\"@Id\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSqlDbType.UniqueIdentifier);\n\t\t\t\t\t\t\t\tparameter.SourceColumn = \"Id\";\n\t\t\t\t\t\t\t\tparameter.Value = jobId;\n\t\t\t\t\t\t\t\tda.DeleteCommand.Transaction = tran;\n\t\t\t\t\t\t\t\tda.DeleteCommand.ExecuteNonQueryWithRetry(_retryPolicy);\n\n\t\t\t\t\t\t\t\t\/\/update history\n\t\t\t\t\t\t\t\tda.UpdateCommand = new SqlCommand(\"UPDATE [Stardust].JobHistory SET Result = @Result WHERE JobId = @Id\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  connection);\n\n\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters.Add(\"@Id\", SqlDbType.UniqueIdentifier, 16, \"JobId\");\n\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters[0].Value = jobId;\n\n\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters.Add(\"@Result\", SqlDbType.NVarChar, 2000, \"Result\");\n\t\t\t\t\t\t\t\tda.UpdateCommand.Parameters[1].Value = \"Deleted\";\n\n\t\t\t\t\t\t\t\tda.UpdateCommand.Transaction = tran;\n\t\t\t\t\t\t\t\tda.UpdateCommand.ExecuteNonQueryWithRetry(_retryPolicy);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar builderHelper = new NodeUriBuilderHelper(node);\n\t\t\t\t\t\t\t\tvar uriCancel = builderHelper.GetCancelJobUri(jobId);\n\n\t\t\t\t\t\t\t\tvar response = await httpSender.DeleteAsync(uriCancel);\n\n\t\t\t\t\t\t\t\tif (response != null && response.IsSuccessStatusCode)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tda.UpdateCommand = new SqlCommand(\"UPDATE [Stardust].JobDefinitions SET Status = 'Canceling' WHERE Id = @Id\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  connection);\n\n\t\t\t\t\t\t\t\t\tvar parameter = da.UpdateCommand.Parameters.Add(\"@Id\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSqlDbType.UniqueIdentifier);\n\t\t\t\t\t\t\t\t\tparameter.SourceColumn = \"Id\";\n\t\t\t\t\t\t\t\t\tparameter.Value = jobId;\n\n\t\t\t\t\t\t\t\t\tda.UpdateCommand.Transaction = tran;\n\t\t\t\t\t\t\t\t\tda.UpdateCommand.ExecuteNonQueryWithRetry(_retryPolicy);\n\n\t\t\t\t\t\t\t\t\tReportProgress(jobId,\n\t\t\t\t\t\t\t\t\t\t\t\t   \"Canceling\",\n\t\t\t\t\t\t\t\t\t\t\t\t   DateTime.Now);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.Log().WarningWithLineNumber(\"[MANAGER, \" + Environment.MachineName +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   \"] : Could not find job defintion for id : \" + jobId);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttran.Commit();\n\t\t\t\t\tconnection.Close();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception exp)\n\t\t\t{\n\t\t\t\tthis.Log().ErrorWithLineNumber(exp.Message, exp);\n\t\t\t}\n\n\t\t}\n\n\t\tpublic void SetEndResultOnJob(Guid jobId, string result)\n\t\t{\n\t\t\tusing (var connection = new SqlConnection(_connectionString))\n\t\t\t{\n\t\t\t\tSqlCommand command = connection.CreateCommand();\n\t\t\t\tcommand.CommandText = \"UPDATE [Stardust].JobHistory SET Result = @Result, Ended = @Ended WHERE JobId = @Id\";\n\t\t\t\tcommand.Parameters.AddWithValue(\"@Id\", jobId);\n\t\t\t\tcommand.Parameters.AddWithValue(\"@Result\", result);\n\t\t\t\tcommand.Parameters.AddWithValue(\"@Ended\", DateTime.Now);\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tconnection.OpenWithRetry(_retryPolicy);\n\t\t\t\t\tusing (var tran = connection.BeginTransaction())\n\t\t\t\t\t{\n\t\t\t\t\t\tcommand.Transaction = tran;\n\t\t\t\t\t\tcommand.ExecuteNonQueryWithRetry(_retryPolicy);\n\t\t\t\t\t\tReportProgress(jobId, result, DateTime.Now);\n\t\t\t\t\t\ttran.Commit();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception exp)\n\t\t\t\t{\n\t\t\t\t\tthis.Log().ErrorWithLineNumber(exp.Message, exp);\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tconnection.Close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void ReportProgress(Guid jobId, string detail, DateTime created)\n\t\t{\n\t\t\tusing (var connection = new SqlConnection(_connectionString))\n\t\t\t{\n\t\t\t\tSqlCommand command = connection.CreateCommand();\n\t\t\t\tcommand.CommandText = \"INSERT INTO [Stardust].JobHistoryDetail (JobId, Detail, Created) VALUES (@Id, @Detail, @Created)\";\n\t\t\t\tcommand.Parameters.AddWithValue(\"@Id\", jobId);\n\t\t\t\tcommand.Parameters.AddWithValue(\"@Detail\", detail);\n\t\t\t\tcommand.Parameters.AddWithValue(\"@Created\", created);\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tconnection.OpenWithRetry(_retryPolicy);\n\t\t\t\t\tusing (var tran = connection.BeginTransaction())\n\t\t\t\t\t{\n\t\t\t\t\t\tcommand.Transaction = tran;\n\t\t\t\t\t\tcommand.ExecuteNonQueryWithRetry(_retryPolicy);\n\t\t\t\t\t\ttran.Commit();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception exp)\n\t\t\t\t{\n\t\t\t\t\tthis.Log().ErrorWithLineNumber(exp.Message, exp);\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tconnection.Close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\t\tpublic JobHistory History(Guid jobId)\n\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar selectCommand = SelectHistoryCommand(true);\n\t\t\t\tusing (var connection = new SqlConnection(_connectionString))\n\t\t\t\t{\n\t\t\t\t\tvar command = new SqlCommand\n\t\t\t\t\t{\n\t\t\t\t\t\tConnection = connection,\n\t\t\t\t\t\tCommandText = selectCommand,\n\t\t\t\t\t\tCommandType = CommandType.Text\n\t\t\t\t\t};\n\n\t\t\t\t\tcommand.Parameters.Add(\"@JobId\", SqlDbType.UniqueIdentifier, 16, \"JobId\");\n\t\t\t\t\tcommand.Parameters[0].Value = jobId;\n\n\t\t\t\t\tconnection.OpenWithRetry(_retryPolicy);\n\t\t\t\t\tusing (var reader = command.ExecuteReaderWithRetry(_retryPolicy))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (reader.HasRows)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treader.Read();\n\t\t\t\t\t\t\tvar jobHist = NewJobHistoryModel(reader);\n\t\t\t\t\t\t\treturn jobHist;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treader.Close();\n\t\t\t\t\t\tconnection.Close();\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception exp)\n\t\t\t{\n\t\t\t\tthis.Log().ErrorWithLineNumber(exp.Message, exp);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tpublic IList<JobHistory> HistoryList()\n\t\t{\n\t\t\tvar returnList = new List<JobHistory>();\n\t\t\tvar policy = _retryPolicyProvider.GetPolicy();\n\t\t\tapplyLoggingOnRetries(policy);\n\t\t\ttry\n\t\t\t{\n\t\t\t\treturnList = policy.ExecuteAction(() => tryHistoryList()).ToList();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tthis.Log().ErrorWithLineNumber(ex.Message + \"Unable to perform operation\");\n\t\t\t}\n\t\t\treturn returnList;\n\t\t}\n\n\t\tprivate IList<JobHistory> tryHistoryList()\n\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar selectCommand = SelectHistoryCommand(false);\n\t\t\t\tvar returnList = new List<JobHistory>();\n\t\t\t\tusing (var connection = new SqlConnection(_connectionString))\n\t\t\t\t{\n\t\t\t\t\tvar command = new SqlCommand\n\t\t\t\t\t{\n\t\t\t\t\t\tConnection = connection,\n\t\t\t\t\t\tCommandText = selectCommand,\n\t\t\t\t\t\tCommandType = CommandType.Text\n\t\t\t\t\t};\n\n\t\t\t\t\tconnection.Open();\n\t\t\t\t\tusing (var reader = command.ExecuteReader())\n\t\t\t\t\t{\n\t\t\t\t\t\tif (reader.HasRows)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\twhile (reader.Read())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar jobHist = NewJobHistoryModel(reader);\n\t\t\t\t\t\t\t\treturnList.Add(jobHist);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treader.Close();\n\t\t\t\t\t\tconnection.Close();\n\t\t\t\t\t}\n\n\t\t\t\t\treturn returnList;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception exp)\n\t\t\t{\n\t\t\t\tthis.Log().ErrorWithLineNumber(exp.Message, exp);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\n\t\tpublic IList<JobHistoryDetail> JobHistoryDetails(Guid jobId)\n\t\t{\n\t\t\tvar returnList = new List<JobHistoryDetail>();\n\t\t\tvar policy = _retryPolicyProvider.GetPolicy();\n\t\t\tapplyLoggingOnRetries(policy);\n\t\t\ttry\n\t\t\t{\n\t\t\t\treturnList = policy.ExecuteAction(() => tryJobHistoryDetails(jobId)).ToList();\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tthis.Log().ErrorWithLineNumber(ex.Message + \"Unable to perform operation\");\n\t\t\t}\n\t\t\treturn returnList;\n\t\t}\n\n\t\tprivate IList<JobHistoryDetail> tryJobHistoryDetails(Guid jobId)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar selectCommand = @\"SELECT  Created, Detail  FROM [Stardust].JobHistoryDetail WHERE JobId = @JobId\";\n\t\t\t\tvar returnList = new List<JobHistoryDetail>();\n\t\t\t\tusing (var connection = new SqlConnection(_connectionString))\n\t\t\t\t{\n\t\t\t\t\tvar command = new SqlCommand\n\t\t\t\t\t{\n\t\t\t\t\t\tConnection = connection,\n\t\t\t\t\t\tCommandText = selectCommand,\n\t\t\t\t\t\tCommandType = CommandType.Text\n\t\t\t\t\t};\n\t\t\t\t\tcommand.Parameters.Add(\"@JobId\", SqlDbType.UniqueIdentifier, 16, \"JobId\");\n\t\t\t\t\tcommand.Parameters[0].Value = jobId;\n\n\t\t\t\t\tconnection.Open();\n\n\t\t\t\t\tusing (var reader = command.ExecuteReader())\n\t\t\t\t\t{\n\t\t\t\t\t\tif (reader.HasRows)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\twhile (reader.Read())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar detail = new JobHistoryDetail\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tCreated = (DateTime)reader.GetValue(reader.GetOrdinal(\"Created\")),\n\t\t\t\t\t\t\t\t\tDetail = (string)reader.GetValue(reader.GetOrdinal(\"Detail\"))\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\treturnList.Add(detail);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treader.Close();\n\t\t\t\t\t\tconnection.Close();\n\t\t\t\t\t}\n\n\t\t\t\t\treturn returnList;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcatch (Exception exp)\n\t\t\t{\n\t\t\t\tthis.Log().ErrorWithLineNumber(exp.Message, exp);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tprivate string GetValue<T>(object value)\n\t\t{\n\t\t\treturn value == DBNull.Value\n\t\t\t\t? null\n\t\t\t\t: (string)value;\n\t\t}\n\n\t\tprivate JobHistory NewJobHistoryModel(SqlDataReader reader)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar jobHist = new JobHistory\n\t\t\t\t{\n\t\t\t\t\tId = (Guid)reader.GetValue(reader.GetOrdinal(\"JobId\")),\n\t\t\t\t\tName = (string)reader.GetValue(reader.GetOrdinal(\"Name\")),\n\t\t\t\t\tCreatedBy = (string)reader.GetValue(reader.GetOrdinal(\"CreatedBy\")),\n\t\t\t\t\tSentTo = GetValue<string>(reader.GetValue(reader.GetOrdinal(\"SentTo\"))),\n\t\t\t\t\tResult = GetValue<string>(reader.GetValue(reader.GetOrdinal(\"Result\"))),\n\t\t\t\t\tCreated = (DateTime)reader.GetValue(reader.GetOrdinal(\"Created\")),\n\t\t\t\t\tStarted = GetDateTime(reader.GetValue(reader.GetOrdinal(\"Started\"))),\n\t\t\t\t\tEnded = GetDateTime(reader.GetValue(reader.GetOrdinal(\"Ended\")))\n\t\t\t\t};\n\n\t\t\t\treturn jobHist;\n\t\t\t}\n\t\t\tcatch (Exception exp)\n\t\t\t{\n\t\t\t\tthis.Log().ErrorWithLineNumber(exp.Message, exp);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tprivate static string SelectHistoryCommand(bool addParameter)\n\t\t{\n\t\t\tvar selectCommand = @\"SELECT \n                                             JobId    \n                                            ,Name\n                                            ,CreatedBy\n                                            ,Created\n                                            ,Started\n                                            ,Ended\n                                            ,SentTo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tResult\n                                        FROM [Stardust].JobHistory\";\n\n\t\t\tif (addParameter) selectCommand += \" WHERE JobId = @JobId\";\n\n\t\t\treturn selectCommand;\n\t\t}\n\n\t\tprivate DateTime? GetDateTime(object databaseValue)\n\t\t{\n\t\t\tif (databaseValue.Equals(DBNull.Value))\n\t\t\t\treturn null;\n\n\t\t\treturn (DateTime)databaseValue;\n\t\t}\n\t}\n}","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"59a585c6fe40427210dfdb743dd8f3b4936f693b","subject":"FIxed up some of the class definitions","message":"FIxed up some of the class definitions\n","repos":"xamarin\/XamarinComponents,xamarin\/XamarinComponents,xamarin\/XamarinComponents,xamarin\/XamarinComponents,xamarin\/XamarinComponents,xamarin\/XamarinComponents","old_file":"iOS\/MaterialComponents\/source\/MaterialComponents\/ApiDefinition.cs","new_file":"iOS\/MaterialComponents\/source\/MaterialComponents\/ApiDefinition.cs","new_contents":"using System;\nusing CoreAnimation;\nusing CoreGraphics;\nusing Foundation;\nusing ObjCRuntime;\nusing UIKit;\nusing NSTextAlignment = UIKit.UITextAlignment;\n\nnamespace MaterialComponents\n{\n\n    delegate void ActionSheetHandler(ActionSheetAction arg0);\n\n    delegate void RippleCompletionBlock();\n\n    delegate void ActivityIndicatorAnimationHandler(nfloat strokeStart, nfloat strokeEnd);\n\n    delegate void ActionHandler(AlertAction action);\n\n    delegate void FeatureHighlightCompletionHandler(bool accepted);\n\n    delegate void FlexibleHeaderChangeContentInsetsHandler();\n\n    delegate void FlexibleHeaderShadowIntensityChangeHandler(CALayer shadowLayer, nfloat intensity);\n\n    delegate void InkCompletionHandler();\n\n    delegate void EnumerateOverlaysHandler(IOverlay overlay, nuint idx, ref bool stop);\n\n    delegate void SnackbarMessageCompletionHandler(bool arg0);\n\n    delegate void SnackbarMessageActionHandler();\n\n\n    [Protocol(Name = \"MDCElevatable\")]\n    interface Elevatable\n    {\n        [Abstract]\n        [Export(\"mdc_currentElevation\")]\n        nfloat CurrentElevation { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"mdc_elevationDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<IElevatable, nfloat> ElevationDidChangeBlock { get; set; }\n    }\n\n    [Protocol(Name = \"MDCElevationOverriding\")]\n    interface ElevationOverriding\n    {\n        [Abstract]\n        [Export(\"mdc_overrideBaseElevation\")]\n        nfloat OverrideBaseElevation { get; set; }\n    }\n\n    [Category]\n    [BaseType(typeof(UIColor))]\n    interface UIColor_MaterialElevation\n    {\n        [Export(\"mdc_resolvedColorWithElevation:\")]\n        UIColor ResolvedColorWithElevation(nfloat elevation);\n\n        [Export(\"mdc_resolvedColorWithTraitCollection:previousTraitCollection:elevation:\")]\n        UIColor ResolvedColorWithTraitCollection(UITraitCollection traitCollection, UITraitCollection previousTraitCollection, nfloat elevation);\n\n        [Export(\"mdc_resolvedColorWithTraitCollection:elevation:\")]\n        UIColor ResolvedColorWithTraitCollection(UITraitCollection traitCollection, nfloat elevation);\n    }\n\n    [Category]\n    [BaseType(typeof(UIView))]\n    interface UIView_MaterialElevationResponding\n    {\n        [Export(\"mdc_baseElevation\")]\n        [Static]\n        nfloat BaseElevation { get; }\n\n        [Export(\"mdc_absoluteElevation\")]\n        [Static]\n        nfloat AbsoluteElevation { get; }\n\n        [Export(\"mdc_elevationDidChange\")]\n        void ElevationDidChange();\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCCornerTreatment\")]\n    interface CornerTreatment : INSCopying\n\n    {\n        [Export(\"valueType\", ArgumentSemantic.Assign)]\n        CornerTreatmentValueType ValueType { get; set; }\n\n        [Export(\"pathGeneratorForCornerWithAngle:\")]\n        PathGenerator PathGeneratorForCornerWithAngle(nfloat angle);\n\n        [Export(\"pathGeneratorForCornerWithAngle:forViewSize:\")]\n        PathGenerator PathGeneratorForCornerWithAngle(nfloat angle, CGSize size);\n\n        [Static]\n        [Export(\"cornerWithRadius:\")]\n        RoundedCornerTreatment CreateCornerWithRadius(nfloat value);\n\n        [Static]\n        [Export(\"cornerWithRadius:valueType:\")]\n        RoundedCornerTreatment CreateCornerWithRadius(nfloat value, CornerTreatmentValueType valueType);\n\n        [Static]\n        [Export(\"cornerWithCut:\")]\n        CutCornerTreatment CreateCornerWithCut(nfloat value);\n\n        [Static]\n        [Export(\"cornerWithCut:valueType:\")]\n        CutCornerTreatment CreateCornerWithCut(nfloat value, CornerTreatmentValueType valueType);\n\n        [Static]\n        [Export(\"cornerWithCurve:\")]\n        CurvedCornerTreatment CreateCornerWithCurve(CGSize value);\n\n        [Static]\n        [Export(\"cornerWithCurve:valueType:\")]\n        CurvedCornerTreatment CreateCornerWithCurve(CGSize value, CornerTreatmentValueType valueType);\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCEdgeTreatment\")]\n    interface EdgeTreatment : INSCopying\n\n    {\n        [Export(\"pathGeneratorForEdgeWithLength:\")]\n        PathGenerator GetPathGeneratorForEdge(nfloat length);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCPathGenerator\")]\n    interface PathGenerator\n    {\n        [Export(\"startPoint\")]\n        CGPoint StartPoint { get; }\n\n        [Export(\"endPoint\")]\n        CGPoint EndPoint { get; }\n\n        [Static]\n        [Export(\"pathGenerator\")]\n        PathGenerator Create();\n\n        [Static]\n        [Export(\"pathGeneratorWithStartPoint:\")]\n        PathGenerator Create(CGPoint startPoint);\n\n        [Export(\"addLineToPoint:\")]\n        void AddLine(CGPoint point);\n\n        [Export(\"addArcWithCenter:radius:startAngle:endAngle:clockwise:\")]\n        void AddArc(CGPoint center, nfloat radius, nfloat startAngle, nfloat endAngle, bool clockwise);\n\n        [Export(\"addArcWithTangentPoint:toPoint:radius:\")]\n        void AddArc(CGPoint tangentPoint, CGPoint toPoint, nfloat radius);\n\n        [Export(\"addCurveWithControlPoint1:controlPoint2:toPoint:\")]\n        void AddCurve(CGPoint controlPoint1, CGPoint controlPoint2, CGPoint toPoint);\n\n        [Export(\"addQuadCurveWithControlPoint:toPoint:\")]\n        void AddQuadCurve(CGPoint controlPoint, CGPoint toPoint);\n\n        [Export(\"appendToCGPath:transform:\")]\n        void AppendTo(CGPath cgPath, [NullAllowed]  CGAffineTransform transform);\n    }\n\n    [Protocol(Name = \"MDCShapeGenerating\")]\n    interface ShapeGenerating : INSCopying\n\n    {\n        [return: NullAllowed]\n        [Abstract]\n        [Export(\"pathForSize:\")]\n        CGPath GetPath(CGSize size);\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCRectangleShapeGenerator\")]\n    interface RectangleShapeGenerator : ShapeGenerating\n\n    {\n        [Export(\"topLeftCorner\", ArgumentSemantic.Strong)]\n        CornerTreatment TopLeftCorner { get; set; }\n\n        [Export(\"topRightCorner\", ArgumentSemantic.Strong)]\n        CornerTreatment TopRightCorner { get; set; }\n\n        [Export(\"bottomLeftCorner\", ArgumentSemantic.Strong)]\n        CornerTreatment BottomLeftCorner { get; set; }\n\n        [Export(\"bottomRightCorner\", ArgumentSemantic.Strong)]\n        CornerTreatment BottomRightCorner { get; set; }\n\n        [Export(\"topLeftCornerOffset\", ArgumentSemantic.Assign)]\n        CGPoint TopLeftCornerOffset { get; set; }\n\n        [Export(\"topRightCornerOffset\", ArgumentSemantic.Assign)]\n        CGPoint TopRightCornerOffset { get; set; }\n\n        [Export(\"bottomLeftCornerOffset\", ArgumentSemantic.Assign)]\n        CGPoint BottomLeftCornerOffset { get; set; }\n\n        [Export(\"bottomRightCornerOffset\", ArgumentSemantic.Assign)]\n        CGPoint BottomRightCornerOffset { get; set; }\n\n        [Export(\"topEdge\", ArgumentSemantic.Strong)]\n        EdgeTreatment TopEdge { get; set; }\n\n        [Export(\"rightEdge\", ArgumentSemantic.Strong)]\n        EdgeTreatment RightEdge { get; set; }\n\n        [Export(\"bottomEdge\", ArgumentSemantic.Strong)]\n        EdgeTreatment BottomEdge { get; set; }\n\n        [Export(\"leftEdge\", ArgumentSemantic.Strong)]\n        EdgeTreatment LeftEdge { get; set; }\n\n        [Export(\"setCorners:\")]\n        void SetCorners(CornerTreatment cornerShape);\n\n        [Export(\"setEdges:\")]\n        void SetEdges(EdgeTreatment edgeShape);\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCShadowMetrics\")]\n    interface ShadowMetrics\n    {\n        [Export(\"topShadowRadius\")]\n        nfloat TopShadowRadius { get; }\n\n        [Export(\"topShadowOffset\")]\n        CGSize TopShadowOffset { get; }\n\n        [Export(\"topShadowOpacity\")]\n        float TopShadowOpacity { get; }\n\n        [Export(\"bottomShadowRadius\")]\n        nfloat BottomShadowRadius { get; }\n\n        [Export(\"bottomShadowOffset\")]\n        CGSize BottomShadowOffset { get; }\n\n        [Export(\"bottomShadowOpacity\")]\n        float BottomShadowOpacity { get; }\n\n        [Static]\n        [Export(\"metricsWithElevation:\")]\n        ShadowMetrics Create(nfloat elevation);\n    }\n\n    [BaseType(typeof(CALayer),\n        Name = \"MDCShadowLayer\")]\n    interface ShadowLayer : ICALayerDelegate\n\n    {\n        [Export(\"elevation\")]\n        nfloat Elevation { get; set; }\n\n        [Export(\"shadowMaskEnabled\")]\n        bool ShadowMaskEnabled { [Bind(\"isShadowMaskEnabled\")] get; set; }\n\n        [Export(\"animateCornerRadius:withTimingFunction:duration:\")]\n        void AnimateCornerRadius(nfloat cornerRadius, CAMediaTimingFunction timingFunction, double duration);\n    }\n\n    [BaseType(typeof(ShadowLayer),\n        Name = \"MDCShapedShadowLayer\")]\n    interface ShapedShadowLayer\n    {\n        [NullAllowed]\n        [Export(\"shapedBackgroundColor\", ArgumentSemantic.Strong)]\n        UIColor ShapedBackgroundColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"shapedBorderColor\", ArgumentSemantic.Strong)]\n        UIColor ShapedBorderColor { get; set; }\n\n        [Export(\"shapedBorderWidth\")]\n        nfloat ShapedBorderWidth { get; set; }\n\n        [NullAllowed]\n        [Export(\"shapeGenerator\", ArgumentSemantic.Strong)]\n        IShapeGenerating ShapeGenerator { get; set; }\n\n        [Export(\"shapeLayer\", ArgumentSemantic.Strong)]\n        CAShapeLayer ShapeLayer { get; set; }\n\n        [Export(\"colorLayer\", ArgumentSemantic.Strong)]\n        CAShapeLayer ColorLayer { get; set; }\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCShapedView\")]\n    interface ShapedView\n    {\n        [Export(\"elevation\")]\n        nfloat Elevation { get; set; }\n\n        [NullAllowed]\n        [Export(\"shapeGenerator\", ArgumentSemantic.Strong)]\n        IShapeGenerating ShapeGenerator { get; set; }\n\n        [DesignatedInitializer]\n        [Export(\"initWithFrame:shapeGenerator:\")]\n        IntPtr Constructor(CGRect frame, [NullAllowed]  IShapeGenerating shapeGenerator);\n\n        [Wrap(\"this (frame, null)\")]\n        IntPtr Constructor(CGRect frame);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(UIViewController),\n        Name = \"MDCBottomSheetController\",\n        Delegates = new[] { \"Delegate\" },\n        Events = new[] { typeof(BottomSheetControllerDelegate) })]\n    interface BottomSheetController : IElevatable, IElevationOverriding\n\n    {\n        [Export(\"contentViewController\", ArgumentSemantic.Strong)]\n        UIViewController ContentViewController { get; }\n\n        [NullAllowed]\n        [Export(\"trackingScrollView\", ArgumentSemantic.Weak)]\n        UIScrollView TrackingScrollView { get; set; }\n\n        [Export(\"shouldFlashScrollIndicatorsOnAppearance\")]\n        bool ShouldFlashScrollIndicatorsOnAppearance { get; set; }\n\n        [Export(\"dismissOnBackgroundTap\")]\n        bool DismissOnBackgroundTap { get; set; }\n\n        [NullAllowed]\n        [Export(\"scrimColor\", ArgumentSemantic.Strong)]\n        UIColor ScrimColor { get; set; }\n\n        [Export(\"isScrimAccessibilityElement\")]\n        bool IsScrimAccessibilityElement { get; set; }\n\n        [NullAllowed]\n        [Export(\"scrimAccessibilityLabel\")]\n        string ScrimAccessibilityLabel { get; set; }\n\n        [NullAllowed]\n        [Export(\"scrimAccessibilityHint\")]\n        string ScrimAccessibilityHint { get; set; }\n\n        [Export(\"scrimAccessibilityTraits\")]\n        ulong ScrimAccessibilityTraits { get; set; }\n\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        IBottomSheetControllerDelegate Delegate { get; set; }\n\n        [Export(\"state\")]\n        SheetState State { get; }\n\n        [Export(\"elevation\")]\n        double Elevation { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<BottomSheetController, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"initWithContentViewController:\")]\n        IntPtr Constructor(UIViewController contentViewController);\n\n        [Export(\"setShapeGenerator:forState:\")]\n        void SetShapeGenerator([NullAllowed] IShapeGenerating shapeGenerator, SheetState state);\n\n        [return: NullAllowed]\n        [Export(\"shapeGeneratorForState:\")]\n        IShapeGenerating ShapeGenerator(SheetState state);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCBottomSheetControllerDelegate\")]\n    interface BottomSheetControllerDelegate\n    {\n        [EventArgs(\"BottomSheetControllerBottomSheetDismissed\")]\n        [EventName(\"BottomSheetDismissed\")]\n        [Export(\"bottomSheetControllerDidDismissBottomSheet:\")]\n        void DidDismissBottomSheet(BottomSheetController controller);\n\n        [EventArgs(\"BottomSheetControllerBottomSheetStateChanged\")]\n        [EventName(\"BottomSheetStateChanged\")]\n        [Export(\"bottomSheetControllerStateChanged:state:\")]\n        void BottomSheetControllerStateChanged(BottomSheetController controller, SheetState state);\n\n        [EventArgs(\"BottomSheetControllerBottomSheetDidChangeYOffset\")]\n        [EventName(\"BottomSheetDidChangeYOffset\")]\n        [Export(\"bottomSheetControllerDidChangeYOffset:yOffset:\")]\n        void BottomSheetControllerDidChangeYOffset(BottomSheetController controller, nfloat yOffset);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCBottomSheetPresentationControllerDelegate\")]\n    interface BottomSheetPresentationControllerDelegate : IUIAdaptivePresentationControllerDelegate\n\n    {\n        [EventArgs(\"BottomSheetPresentationControllerPrepareForPresentation\")]\n        [Export(\"prepareForBottomSheetPresentation:\")]\n        void PrepareForPresentation(BottomSheetPresentationController bottomSheet);\n\n        [EventArgs(\"BottomSheetPresentationControllerDismissed\")]\n        [EventName(\"Dismissed\")]\n        [Export(\"bottomSheetPresentationControllerDidDismissBottomSheet:\")]\n        void DidDismiss(BottomSheetPresentationController bottomSheet);\n\n        [EventArgs(\"BottomSheetPresentationControllerWillChangeState\")]\n        [Export(\"bottomSheetWillChangeState:sheetState:\")]\n        void WillChangeState(BottomSheetPresentationController bottomSheet, SheetState sheetState);\n\n        [EventArgs(\"BottomSheetPresentationControllerDidChangeYOffset\")]\n        [EventName(\"DidChangeYOffset\")]\n        [Export(\"bottomSheetDidChangeYOffset:yOffset:\")]\n        void BottomSheetDidChangeYOffset(BottomSheetPresentationController bottomSheet, nfloat yOffset);\n    }\n\n    [BaseType(typeof(UIPresentationController),\n        Name = \"MDCBottomSheetPresentationController\",\n        Delegates = new[] { \"Delegate\" },\n        Events = new[] { typeof(BottomSheetPresentationControllerDelegate) })]\n    interface BottomSheetPresentationController\n    {\n        [NullAllowed]\n        [Export(\"trackingScrollView\", ArgumentSemantic.Weak)]\n        UIScrollView TrackingScrollView { get; set; }\n\n        [Export(\"dismissOnBackgroundTap\")]\n        bool DismissOnBackgroundTap { get; set; }\n\n        [Export(\"preferredSheetHeight\")]\n        nfloat PreferredSheetHeight { get; set; }\n\n        [NullAllowed]\n        [Export(\"scrimColor\", ArgumentSemantic.Strong)]\n        UIColor ScrimColor { get; set; }\n\n        [Export(\"isScrimAccessibilityElement\")]\n        bool IsScrimAccessibilityElement { get; set; }\n\n        [NullAllowed]\n        [Export(\"scrimAccessibilityLabel\")]\n        string ScrimAccessibilityLabel { get; set; }\n\n        [NullAllowed]\n        [Export(\"scrimAccessibilityHint\")]\n        string ScrimAccessibilityHint { get; set; }\n\n        [Export(\"scrimAccessibilityTraits\")]\n        ulong ScrimAccessibilityTraits { get; set; }\n\n        [New]\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        IBottomSheetPresentationControllerDelegate Delegate { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<BottomSheetPresentationController, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCBottomSheetTransitionController\")]\n    interface BottomSheetTransitionController : IUIViewControllerAnimatedTransitioning, IUIViewControllerTransitioningDelegate\n\n    {\n        [NullAllowed]\n        [Export(\"trackingScrollView\", ArgumentSemantic.Weak)]\n        UIScrollView TrackingScrollView { get; set; }\n\n        [Export(\"dismissOnBackgroundTap\")]\n        bool DismissOnBackgroundTap { get; set; }\n\n        [Export(\"preferredSheetHeight\")]\n        nfloat PreferredSheetHeight { get; set; }\n\n        [NullAllowed]\n        [Export(\"scrimColor\", ArgumentSemantic.Strong)]\n        UIColor ScrimColor { get; set; }\n\n        [Export(\"isScrimAccessibilityElement\")]\n        bool IsScrimAccessibilityElement { get; set; }\n\n        [NullAllowed]\n        [Export(\"scrimAccessibilityLabel\")]\n        string ScrimAccessibilityLabel { get; set; }\n\n        [NullAllowed]\n        [Export(\"scrimAccessibilityHint\")]\n        string ScrimAccessibilityHint { get; set; }\n\n        [Export(\"scrimAccessibilityTraits\")]\n        ulong ScrimAccessibilityTraits { get; set; }\n    }\n\n    [Category]\n    [BaseType(typeof(UIViewController))]\n    interface UIViewController_MaterialBottomSheet\n    {\n        [return: NullAllowed]\n        [Export(\"mdc_bottomSheetPresentationController\")]\n        BottomSheetPresentationController GetBottomSheetPresentationController();\n\n        [return: NullAllowed]\n        [Wrap(\"GetBottomSheetPresentationController(This)\")]\n        BottomSheetPresentationController MdcGetBottomSheetPresentationController();\n    }\n\n    [BaseType(typeof(UIViewController),\n        Name = \"MDCActionSheetController\")]\n    interface ActionSheetController : IElevatable, IElevationOverriding\n\n    {\n        [Export(\"actions\", ArgumentSemantic.Copy)]\n        ActionSheetAction Actions { get; }\n\n        [NullAllowed]\n        [Export(\"title\")]\n        string Title { get; set; }\n\n        [NullAllowed]\n        [Export(\"message\")]\n        string Message { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<ActionSheetController, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"mdc_adjustsFontForContentSizeCategory\")]\n        bool AdjustsFontForContentSizeCategory { get; [Bind(\"mdc_setAdjustsFontForContentSizeCategory:\")]set; }\n\n        [Obsolete(\"Use AdjustsFontForContentSizeCategory instead\")]\n        [Wrap(\"AdjustsFontForContentSizeCategory\")]\n        bool MdcAdjustsFontForContentSizeCategory { get; set; }\n\n        [Export(\"titleFont\", ArgumentSemantic.Strong)]\n        UIFont TitleFont { get; set; }\n\n        [Export(\"messageFont\", ArgumentSemantic.Strong)]\n        UIFont MessageFont { get; set; }\n\n        [NullAllowed]\n        [Export(\"actionFont\", ArgumentSemantic.Strong)]\n        UIFont ActionFont { get; set; }\n\n        [Export(\"backgroundColor\", ArgumentSemantic.Strong)]\n        UIColor BackgroundColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"titleTextColor\", ArgumentSemantic.Strong)]\n        UIColor TitleTextColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"messageTextColor\", ArgumentSemantic.Strong)]\n        UIColor MessageTextColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"actionTextColor\", ArgumentSemantic.Strong)]\n        UIColor ActionTextColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"actionTintColor\", ArgumentSemantic.Strong)]\n        UIColor ActionTintColor { get; set; }\n\n        [Export(\"enableRippleBehavior\")]\n        bool EnableRippleBehavior { get; set; }\n\n        [NullAllowed]\n        [Export(\"rippleColor\", ArgumentSemantic.Strong)]\n        UIColor RippleColor { get; set; }\n\n        [Export(\"imageRenderingMode\", ArgumentSemantic.Assign)]\n        UIImageRenderingMode ImageRenderingMode { get; set; }\n\n        [Export(\"showsHeaderDivider\")]\n        bool ShowsHeaderDivider { get; set; }\n\n        [Export(\"headerDividerColor\", ArgumentSemantic.Copy)]\n        UIColor HeaderDividerColor { get; set; }\n\n        [Export(\"elevation\")]\n        double Elevation { get; set; }\n\n        [Export(\"alwaysAlignTitleLeadingEdges\")]\n        bool AlwaysAlignTitleLeadingEdges { get; set; }\n\n        [Export(\"transitionController\", ArgumentSemantic.Strong)]\n        BottomSheetTransitionController TransitionController { get; }\n\n        [Static]\n        [Export(\"actionSheetControllerWithTitle:message:\")]\n        ActionSheetController ActionSheetControllerWithTitle([NullAllowed] string title, [NullAllowed]  string message);\n\n        [Static]\n        [Export(\"actionSheetControllerWithTitle:\")]\n        ActionSheetController ActionSheetControllerWithTitle([NullAllowed] string title);\n\n        [Export(\"addAction:\")]\n        void AddAction(ActionSheetAction action);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCActionSheetAction\")]\n    interface ActionSheetAction : INSCopying, IUIAccessibilityIdentification\n\n    {\n        [Export(\"title\")]\n        string Title { get; }\n\n        [NullAllowed]\n        [Export(\"image\")]\n        UIImage Image { get; }\n\n        [NullAllowed]\n        [Export(\"accessibilityIdentifier\")]\n        string AccessibilityIdentifier { get; set; }\n\n        [NullAllowed]\n        [Export(\"titleColor\", ArgumentSemantic.Copy)]\n        UIColor TitleColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"tintColor\", ArgumentSemantic.Copy)]\n        UIColor TintColor { get; set; }\n\n        [Static]\n        [Export(\"actionWithTitle:image:handler:\")]\n        ActionSheetAction ActionWithTitle(string title, [NullAllowed]  UIImage image, [NullAllowed]  ActionSheetHandler handler);\n\n        [NullAllowed]\n        [Export(\"inkColor\", ArgumentSemantic.Strong)]\n        [Static]\n        UIColor InkColor { get; set; }\n    }\n\n    [Advice(\"This class will soon be deprecated. Consider using IColorScheming interface instead.\")]\n    [Protocol(Name = \"MDCColorScheme\")]\n    [BaseType(typeof(NSObject))]\n    interface ColorScheme\n    {\n        [Abstract]\n        [Export(\"primaryColor\")]\n        UIColor PrimaryColor { get; }\n\n        [Export(\"primaryLightColor\")]\n        UIColor PrimaryLightColor { get; }\n\n        [Export(\"primaryDarkColor\")]\n        UIColor PrimaryDarkColor { get; }\n\n        [Export(\"secondaryColor\")]\n        UIColor SecondaryColor { get; }\n\n        [Export(\"secondaryLightColor\")]\n        UIColor SecondaryLightColor { get; }\n\n        [Export(\"secondaryDarkColor\")]\n        UIColor SecondaryDarkColor { get; }\n    }\n\n    [Obsolete(\"This class will soon be deprecated. Consider using SemanticColorScheme class instead.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCBasicColorScheme\")]\n    interface BasicColorScheme : ColorScheme, INSCopying\n\n    {\n        [Export(\"primaryColor\", ArgumentSemantic.Strong)]\n        UIColor PrimaryColor { get; }\n\n        [Export(\"primaryLightColor\", ArgumentSemantic.Strong)]\n        UIColor PrimaryLightColor { get; }\n\n        [Export(\"primaryDarkColor\", ArgumentSemantic.Strong)]\n        UIColor PrimaryDarkColor { get; }\n\n        [Export(\"secondaryColor\", ArgumentSemantic.Strong)]\n        UIColor SecondaryColor { get; }\n\n        [Export(\"secondaryLightColor\", ArgumentSemantic.Strong)]\n        UIColor SecondaryLightColor { get; }\n\n        [Export(\"secondaryDarkColor\", ArgumentSemantic.Strong)]\n        UIColor SecondaryDarkColor { get; }\n\n        [DesignatedInitializer]\n        [Export(\"initWithPrimaryColor:primaryLightColor:primaryDarkColor:secondaryColor:secondaryLightColor:secondaryDarkColor:\")]\n        IntPtr Constructor(UIColor primaryColor, UIColor primaryLightColor, UIColor primaryDarkColor, UIColor secondaryColor, UIColor secondaryLightColor, UIColor secondaryDarkColor);\n\n        [Export(\"initWithPrimaryColor:\")]\n        IntPtr Constructor(UIColor primaryColor);\n\n        [Export(\"initWithPrimaryColor:primaryLightColor:primaryDarkColor:\")]\n        IntPtr Constructor(UIColor primaryColor, UIColor primaryLightColor, UIColor primaryDarkColor);\n\n        [Export(\"initWithPrimaryColor:secondaryColor:\")]\n        IntPtr Constructor(UIColor primaryColor, UIColor secondaryColor);\n    }\n\n    [Obsolete(\"This class will soon be deprecated. Consider using IColorScheming interface instead.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTonalColorScheme\")]\n    interface TonalColorScheme : ColorScheme, INSCopying\n\n    {\n        [Export(\"primaryColor\", ArgumentSemantic.Strong)]\n        UIColor PrimaryColor { get; }\n\n        [Export(\"primaryLightColor\", ArgumentSemantic.Strong)]\n        UIColor PrimaryLightColor { get; }\n\n        [Export(\"primaryDarkColor\", ArgumentSemantic.Strong)]\n        UIColor PrimaryDarkColor { get; }\n\n        [Export(\"secondaryColor\", ArgumentSemantic.Strong)]\n        UIColor SecondaryColor { get; }\n\n        [Export(\"secondaryLightColor\", ArgumentSemantic.Strong)]\n        UIColor SecondaryLightColor { get; }\n\n        [Export(\"secondaryDarkColor\", ArgumentSemantic.Strong)]\n        UIColor SecondaryDarkColor { get; }\n\n        [Export(\"primaryTonalPalette\", ArgumentSemantic.Strong)]\n        TonalPalette PrimaryTonalPalette { get; }\n\n        [Export(\"secondaryTonalPalette\", ArgumentSemantic.Strong)]\n        TonalPalette SecondaryTonalPalette { get; }\n\n        [DesignatedInitializer]\n        [Export(\"initWithPrimaryTonalPalette:secondaryTonalPalette:\")]\n        IntPtr Constructor(TonalPalette primaryTonalPalette, TonalPalette secondaryTonalPalette);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTonalPalette\")]\n    interface TonalPalette : INSCopying\n\n    {\n        [Export(\"colors\", ArgumentSemantic.Copy)]\n        UIColor[] Colors { get; }\n\n        [Export(\"mainColorIndex\")]\n        nuint MainColorIndex { get; }\n\n        [Export(\"lightColorIndex\")]\n        nuint LightColorIndex { get; }\n\n        [Export(\"darkColorIndex\")]\n        nuint DarkColorIndex { get; }\n\n        [Export(\"mainColor\", ArgumentSemantic.Strong)]\n        UIColor MainColor { get; }\n\n        [Export(\"lightColor\", ArgumentSemantic.Strong)]\n        UIColor LightColor { get; }\n\n        [Export(\"darkColor\", ArgumentSemantic.Strong)]\n        UIColor DarkColor { get; }\n\n        [DesignatedInitializer]\n        [Export(\"initWithColors:mainColorIndex:lightColorIndex:darkColorIndex:\")]\n        IntPtr Constructor(UIColor colors, nuint mainColorIndex, nuint lightColorIndex, nuint darkColorIndex);\n    }\n\n    [Protocol(Name = \"MDCColorScheming\")]\n    [BaseType(typeof(NSObject))]\n    interface ColorScheming\n    {\n        [Abstract]\n        [Export(\"primaryColor\", ArgumentSemantic.Copy)]\n        UIColor PrimaryColor { get; }\n\n        [Abstract]\n        [Export(\"primaryColorVariant\", ArgumentSemantic.Copy)]\n        UIColor PrimaryColorVariant { get; }\n\n        [Abstract]\n        [Export(\"secondaryColor\", ArgumentSemantic.Copy)]\n        UIColor SecondaryColor { get; }\n\n        [Abstract]\n        [Export(\"errorColor\", ArgumentSemantic.Copy)]\n        UIColor ErrorColor { get; }\n\n        [Abstract]\n        [Export(\"surfaceColor\", ArgumentSemantic.Copy)]\n        UIColor SurfaceColor { get; }\n\n        [Abstract]\n        [Export(\"backgroundColor\", ArgumentSemantic.Copy)]\n        UIColor BackgroundColor { get; }\n\n        [Abstract]\n        [Export(\"onPrimaryColor\", ArgumentSemantic.Copy)]\n        UIColor OnPrimaryColor { get; }\n\n        [Abstract]\n        [Export(\"onSecondaryColor\", ArgumentSemantic.Copy)]\n        UIColor OnSecondaryColor { get; }\n\n        [Abstract]\n        [Export(\"onSurfaceColor\", ArgumentSemantic.Copy)]\n        UIColor OnSurfaceColor { get; }\n\n        [Abstract]\n        [Export(\"onBackgroundColor\", ArgumentSemantic.Copy)]\n        UIColor OnBackgroundColor { get; }\n\n        [Abstract]\n        [Export(\"elevationOverlayColor\", ArgumentSemantic.Copy)]\n        UIColor ElevationOverlayColor { get; }\n\n        [Abstract]\n        [Export(\"elevationOverlayEnabledForDarkMode\")]\n        bool ElevationOverlayEnabledForDarkMode { get; }\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCSemanticColorScheme\")]\n    interface SemanticColorScheme : ColorScheming, INSCopying\n\n    {\n        [Export(\"primaryColor\", ArgumentSemantic.Copy)]\n        UIColor PrimaryColor { get; set; }\n\n        [Export(\"primaryColorVariant\", ArgumentSemantic.Copy)]\n        UIColor PrimaryColorVariant { get; set; }\n\n        [Export(\"secondaryColor\", ArgumentSemantic.Copy)]\n        UIColor SecondaryColor { get; set; }\n\n        [Export(\"errorColor\", ArgumentSemantic.Copy)]\n        UIColor ErrorColor { get; set; }\n\n        [Export(\"surfaceColor\", ArgumentSemantic.Copy)]\n        UIColor SurfaceColor { get; set; }\n\n        [Export(\"backgroundColor\", ArgumentSemantic.Copy)]\n        UIColor BackgroundColor { get; set; }\n\n        [Export(\"onPrimaryColor\", ArgumentSemantic.Copy)]\n        UIColor OnPrimaryColor { get; set; }\n\n        [Export(\"onSecondaryColor\", ArgumentSemantic.Copy)]\n        UIColor OnSecondaryColor { get; set; }\n\n        [Export(\"onSurfaceColor\", ArgumentSemantic.Copy)]\n        UIColor OnSurfaceColor { get; set; }\n\n        [Export(\"onBackgroundColor\", ArgumentSemantic.Copy)]\n        UIColor OnBackgroundColor { get; set; }\n\n        [Export(\"elevationOverlayColor\", ArgumentSemantic.Copy)]\n        UIColor ElevationOverlayColor { get; set; }\n\n        [Export(\"elevationOverlayEnabledForDarkMode\")]\n        bool ElevationOverlayEnabledForDarkMode { get; set; }\n\n        [Export(\"initWithDefaults:\")]\n        IntPtr Constructor(ColorSchemeDefaults defaults);\n\n        [Static]\n        [Export(\"blendColor:withBackgroundColor:\")]\n        UIColor BlendColor(UIColor color, UIColor backgroundColor);\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCShapeCategory\")]\n    interface ShapeCategory : INSCopying\n\n    {\n        [Export(\"topLeftCorner\", ArgumentSemantic.Copy)]\n        CornerTreatment TopLeftCorner { get; set; }\n\n        [Export(\"topRightCorner\", ArgumentSemantic.Copy)]\n        CornerTreatment TopRightCorner { get; set; }\n\n        [Export(\"bottomLeftCorner\", ArgumentSemantic.Copy)]\n        CornerTreatment BottomLeftCorner { get; set; }\n\n        [Export(\"bottomRightCorner\", ArgumentSemantic.Copy)]\n        CornerTreatment BottomRightCorner { get; set; }\n\n        [Export(\"initCornersWithFamily:andSize:\")]\n        IntPtr Constructor(ShapeCornerFamily cornerFamily, nfloat cornerSize);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCShapeScheming\")]\n    interface ShapeScheming\n    {\n        [Abstract]\n        [Export(\"smallComponentShape\")]\n        ShapeCategory SmallComponentShape { get; }\n\n        [Abstract]\n        [Export(\"mediumComponentShape\")]\n        ShapeCategory MediumComponentShape { get; }\n\n        [Abstract]\n        [Export(\"largeComponentShape\")]\n        ShapeCategory LargeComponentShape { get; }\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCShapeScheme\")]\n    interface ShapeScheme : ShapeScheming\n\n    {\n        [Export(\"smallComponentShape\", ArgumentSemantic.Assign)]\n        ShapeCategory SmallComponentShape { get; set; }\n\n        [Export(\"mediumComponentShape\", ArgumentSemantic.Assign)]\n        ShapeCategory MediumComponentShape { get; set; }\n\n        [Export(\"largeComponentShape\", ArgumentSemantic.Assign)]\n        ShapeCategory LargeComponentShape { get; set; }\n\n        [Export(\"initWithDefaults:\")]\n        IntPtr Constructor(ShapeSchemeDefaults defaults);\n    }\n\n    [Obsolete(\"This class will soon be deprecated. Consider using ITypographyScheming interface instead.\")]\n    [Protocol(Name = \"MDCFontScheme\")]\n    [BaseType(typeof(NSObject))]\n    interface FontScheme\n    {\n        [Abstract]\n        [NullAllowed]\n        [Export(\"headline1\", ArgumentSemantic.Strong)]\n        UIFont Headline1 { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"headline2\", ArgumentSemantic.Strong)]\n        UIFont Headline2 { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"headline3\", ArgumentSemantic.Strong)]\n        UIFont Headline3 { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"headline4\", ArgumentSemantic.Strong)]\n        UIFont Headline4 { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"headline5\", ArgumentSemantic.Strong)]\n        UIFont Headline5 { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"headline6\", ArgumentSemantic.Strong)]\n        UIFont Headline6 { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"subtitle1\", ArgumentSemantic.Strong)]\n        UIFont Subtitle1 { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"subtitle2\", ArgumentSemantic.Strong)]\n        UIFont Subtitle2 { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"body1\", ArgumentSemantic.Strong)]\n        UIFont Body1 { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"body2\", ArgumentSemantic.Strong)]\n        UIFont Body2 { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"caption\", ArgumentSemantic.Strong)]\n        UIFont Caption { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"button\", ArgumentSemantic.Strong)]\n        UIFont Button { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"overline\", ArgumentSemantic.Strong)]\n        UIFont Overline { get; }\n    }\n\n    [Obsolete(\"This class will soon be deprecated. Consider using TypographyScheme class instead.\")]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCBasicFontScheme\")]\n    interface BasicFontScheme : FontScheme\n\n    {\n        [NullAllowed]\n        [Export(\"headline1\", ArgumentSemantic.Assign)]\n        UIFont Headline1 { get; set; }\n\n        [NullAllowed]\n        [Export(\"headline2\", ArgumentSemantic.Assign)]\n        UIFont Headline2 { get; set; }\n\n        [NullAllowed]\n        [Export(\"headline3\", ArgumentSemantic.Assign)]\n        UIFont Headline3 { get; set; }\n\n        [NullAllowed]\n        [Export(\"headline4\", ArgumentSemantic.Assign)]\n        UIFont Headline4 { get; set; }\n\n        [NullAllowed]\n        [Export(\"headline5\", ArgumentSemantic.Assign)]\n        UIFont Headline5 { get; set; }\n\n        [NullAllowed]\n        [Export(\"headline6\", ArgumentSemantic.Assign)]\n        UIFont Headline6 { get; set; }\n\n        [NullAllowed]\n        [Export(\"subtitle1\", ArgumentSemantic.Assign)]\n        UIFont Subtitle1 { get; set; }\n\n        [NullAllowed]\n        [Export(\"subtitle2\", ArgumentSemantic.Assign)]\n        UIFont Subtitle2 { get; set; }\n\n        [NullAllowed]\n        [Export(\"body1\", ArgumentSemantic.Assign)]\n        UIFont Body1 { get; set; }\n\n        [NullAllowed]\n        [Export(\"body2\", ArgumentSemantic.Assign)]\n        UIFont Body2 { get; set; }\n\n        [NullAllowed]\n        [Export(\"caption\", ArgumentSemantic.Assign)]\n        UIFont Caption { get; set; }\n\n        [NullAllowed]\n        [Export(\"button\", ArgumentSemantic.Assign)]\n        UIFont Button { get; set; }\n\n        [NullAllowed]\n        [Export(\"overline\", ArgumentSemantic.Assign)]\n        UIFont Overline { get; set; }\n    }\n\n    [Protocol(Name = \"MDCTypographyScheming\")]\n    [BaseType(typeof(NSObject))]\n    interface TypographyScheming\n    {\n        [Abstract]\n        [Export(\"headline1\", ArgumentSemantic.Copy)]\n        UIFont Headline1 { get; }\n\n        [Abstract]\n        [Export(\"headline2\", ArgumentSemantic.Copy)]\n        UIFont Headline2 { get; }\n\n        [Abstract]\n        [Export(\"headline3\", ArgumentSemantic.Copy)]\n        UIFont Headline3 { get; }\n\n        [Abstract]\n        [Export(\"headline4\", ArgumentSemantic.Copy)]\n        UIFont Headline4 { get; }\n\n        [Abstract]\n        [Export(\"headline5\", ArgumentSemantic.Copy)]\n        UIFont Headline5 { get; }\n\n        [Abstract]\n        [Export(\"headline6\", ArgumentSemantic.Copy)]\n        UIFont Headline6 { get; }\n\n        [Abstract]\n        [Export(\"subtitle1\", ArgumentSemantic.Copy)]\n        UIFont Subtitle1 { get; }\n\n        [Abstract]\n        [Export(\"subtitle2\", ArgumentSemantic.Copy)]\n        UIFont Subtitle2 { get; }\n\n        [Abstract]\n        [Export(\"body1\", ArgumentSemantic.Copy)]\n        UIFont Body1 { get; }\n\n        [Abstract]\n        [Export(\"body2\", ArgumentSemantic.Copy)]\n        UIFont Body2 { get; }\n\n        [Abstract]\n        [Export(\"caption\", ArgumentSemantic.Copy)]\n        UIFont Caption { get; }\n\n        [Abstract]\n        [Export(\"button\", ArgumentSemantic.Copy)]\n        UIFont Button { get; }\n\n        [Abstract]\n        [Export(\"overline\", ArgumentSemantic.Copy)]\n        UIFont Overline { get; }\n\n        [Abstract]\n        [Export(\"useCurrentContentSizeCategoryWhenApplied\")]\n        bool UseCurrentContentSizeCategoryWhenApplied { get; }\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTypographyScheme\")]\n    interface TypographyScheme : TypographyScheming, INSCopying\n\n    {\n        [Export(\"headline1\", ArgumentSemantic.Copy)]\n        UIFont Headline1 { get; set; }\n\n        [Export(\"headline2\", ArgumentSemantic.Copy)]\n        UIFont Headline2 { get; set; }\n\n        [Export(\"headline3\", ArgumentSemantic.Copy)]\n        UIFont Headline3 { get; set; }\n\n        [Export(\"headline4\", ArgumentSemantic.Copy)]\n        UIFont Headline4 { get; set; }\n\n        [Export(\"headline5\", ArgumentSemantic.Copy)]\n        UIFont Headline5 { get; set; }\n\n        [Export(\"headline6\", ArgumentSemantic.Copy)]\n        UIFont Headline6 { get; set; }\n\n        [Export(\"subtitle1\", ArgumentSemantic.Copy)]\n        UIFont Subtitle1 { get; set; }\n\n        [Export(\"subtitle2\", ArgumentSemantic.Copy)]\n        UIFont Subtitle2 { get; set; }\n\n        [Export(\"body1\", ArgumentSemantic.Copy)]\n        UIFont Body1 { get; set; }\n\n        [Export(\"body2\", ArgumentSemantic.Copy)]\n        UIFont Body2 { get; set; }\n\n        [Export(\"caption\", ArgumentSemantic.Copy)]\n        UIFont Caption { get; set; }\n\n        [Export(\"button\", ArgumentSemantic.Copy)]\n        UIFont Button { get; set; }\n\n        [Export(\"overline\", ArgumentSemantic.Copy)]\n        UIFont Overline { get; set; }\n\n        [Export(\"useCurrentContentSizeCategoryWhenApplied\")]\n        bool UseCurrentContentSizeCategoryWhenApplied { get; set; }\n\n        [Export(\"initWithDefaults:\")]\n        IntPtr Constructor(TypographySchemeDefaults defaults);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCContainerScheming\")]\n    interface ContainerScheming\n    {\n        [Abstract]\n        [Export(\"colorScheme\")]\n        ColorScheming ColorScheme { get; }\n\n        [Abstract]\n        [Export(\"typographyScheme\")]\n        TypographyScheming TypographyScheme { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"shapeScheme\")]\n        ShapeScheming ShapeScheme { get; }\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCContainerScheme\")]\n    interface ContainerScheme : ContainerScheming\n\n    {\n        [Export(\"colorScheme\", ArgumentSemantic.Assign)]\n        SemanticColorScheme ColorScheme { get; set; }\n\n        [Export(\"typographyScheme\", ArgumentSemantic.Assign)]\n        TypographyScheme TypographyScheme { get; set; }\n\n        [NullAllowed]\n        [Export(\"shapeScheme\", ArgumentSemantic.Assign)]\n        ShapeScheme ShapeScheme { get; set; }\n    }\n\n    [Category]\n    [BaseType(typeof(ActionSheetController),\n        Name = \"MDCActionSheetController_MaterialTheming\")]\n    interface ActionSheetController_MaterialTheming\n    {\n        [Export(\"applyThemeWithScheme:\")]\n        void ApplyTheme(IContainerScheming scheme);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCActivityIndicator\",\n        Delegates = new[] { \"Delegate\" },\n        Events = new[] { typeof(ActivityIndicatorDelegate) })]\n    interface ActivityIndicator\n    {\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        IActivityIndicatorDelegate Delegate { get; set; }\n\n        [Export(\"animating\")]\n        bool Animating { [Bind(\"isAnimating\")] get; set; }\n\n        [Export(\"radius\")]\n        nfloat Radius { get; set; }\n\n        [Export(\"strokeWidth\")]\n        nfloat StrokeWidth { get; set; }\n\n        [Export(\"trackEnabled\")]\n        bool TrackEnabled { get; set; }\n\n        [Export(\"indicatorMode\", ArgumentSemantic.Assign)]\n        ActivityIndicatorMode IndicatorMode { get; set; }\n\n        [Export(\"progress\")]\n        float Progress { get; set; }\n\n        [Export(\"cycleColors\", ArgumentSemantic.Copy)]\n        UIColor[] CycleColors { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<ActivityIndicator, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"setIndicatorMode:animated:\")]\n        void SetIndicatorMode(ActivityIndicatorMode mode, bool animated);\n\n        [Export(\"setProgress:animated:\")]\n        void SetProgress(float progress, bool animated);\n\n        [Export(\"startAnimating\")]\n        void StartAnimating();\n\n        [Export(\"startAnimatingWithTransition:cycleStartIndex:\")]\n        void StartAnimating(ActivityIndicatorTransition startTransition, nint cycleStartIndex);\n\n        [Export(\"stopAnimating\")]\n        void StopAnimating();\n\n        [Export(\"stopAnimatingWithTransition:\")]\n        void StopAnimatingWithTransition(ActivityIndicatorTransition stopTransition);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCActivityIndicatorDelegate\")]\n    interface ActivityIndicatorDelegate\n    {\n        [EventArgs(\"ActivityIndicatorFinished\")]\n        [EventName(\"AnimationFinished\")]\n        [Export(\"activityIndicatorAnimationDidFinish:\")]\n        void AnimationDidFinish(ActivityIndicator activityIndicator);\n\n        [EventArgs(\"ActivityIndicatorFinished\")]\n        [EventName(\"ModeTransitionFinished\")]\n        [Export(\"activityIndicatorModeTransitionDidFinish:\")]\n        void ModeTransitionDidFinish(ActivityIndicator activityIndicator);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCActivityIndicatorTransition\")]\n    interface ActivityIndicatorTransition\n    {\n        [Export(\"animation\", ArgumentSemantic.Copy)]\n        ActivityIndicatorAnimationHandler Animation { get; set; }\n\n        [NullAllowed]\n        [Export(\"completion\", ArgumentSemantic.Copy)]\n        Action Completion { get; set; }\n\n        [Export(\"duration\")]\n        double Duration { get; set; }\n\n        [DesignatedInitializer]\n        [Export(\"initWithAnimation:\")]\n        IntPtr Constructor(ActivityIndicatorAnimationHandler animation);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCActivityIndicatorColorThemer\")]\n    interface ActivityIndicatorColorThemer\n    {\n        [Static]\n        [Export(\"applySemanticColorScheme:toActivityIndicator:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, ActivityIndicator activityIndicator);\n\n        [Obsolete(\"This method will soon be deprecated. Consider using ApplySemanticColorScheme method instead.\")]\n        [Static]\n        [Export(\"applyColorScheme:toActivityIndicator:\")]\n        void ApplyColorScheme(IColorScheme colorScheme, ActivityIndicator activityIndicator);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(UIViewController),\n        Name = \"MDCAppBarContainerViewController\")]\n    interface AppBarContainerViewController\n    {\n        [Export(\"appBarViewController\", ArgumentSemantic.Strong)]\n        AppBarViewController AppBarViewController { get; }\n\n        [Export(\"contentViewController\", ArgumentSemantic.Strong)]\n        UIViewController ContentViewController { get; }\n\n        [Export(\"topLayoutGuideAdjustmentEnabled\")]\n        bool TopLayoutGuideAdjustmentEnabled { [Bind(\"isTopLayoutGuideAdjustmentEnabled\")] get; set; }\n\n        [Obsolete(\"This API will eventually be deprecated. Use AppBarViewController property instead.\")]\n        [Export(\"appBar\", ArgumentSemantic.Strong)]\n        AppBar AppBar { get; }\n\n        [DesignatedInitializer]\n        [Export(\"initWithContentViewController:\")]\n        IntPtr Constructor(UIViewController contentViewController);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCAppBarNavigationControllerDelegate\")]\n    interface AppBarNavigationControllerDelegate : IUINavigationControllerDelegate\n\n    {\n        [EventArgs(\"AppBarNavigationControllerWillAddAppBarViewController\")]\n        [Export(\"appBarNavigationController:willAddAppBarViewController:asChildOfViewController:\")]\n        void WillAddAppBarViewController(AppBarNavigationController navigationController, AppBarViewController appBarViewController, UIViewController viewController);\n\n        [return: NullAllowed]\n        [Export(\"appBarNavigationController:trackingScrollViewForViewController:suggestedTrackingScrollView:\")]\n        UIScrollView TrackScrollView(AppBarNavigationController navigationController, UIViewController viewController, [NullAllowed]  UIScrollView scrollView);\n\n        [EventArgs(\"AppBarNavigationControllerWillAddAppBar\")]\n        [Obsolete(\"This method will soon be deprecated. Please use WillAddAppBarViewController method instead.\")]\n        [Export(\"appBarNavigationController:willAddAppBar:asChildOfViewController:\")]\n        void WillAddAppBar(AppBarNavigationController navigationController, AppBar appBar, UIViewController viewController);\n    }\n\n    [BaseType(typeof(UINavigationController),\n        Name = \"MDCAppBarNavigationController\")]\n    interface AppBarNavigationController\n    {\n        [New]\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        IAppBarNavigationControllerDelegate Delegate { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlockForAppBarController\", ArgumentSemantic.Copy)]\n        Action<FlexibleHeaderViewController, UITraitCollection> TraitCollectionDidChangeBlockForAppBarController { get; set; }\n\n        [return: NullAllowed]\n        [Export(\"appBarViewControllerForViewController:\")]\n        AppBarViewController GetAppBarViewController(UIViewController viewController);\n\n        [Obsolete(\"This method will eventually be deprecated. Use GetAppBarViewController method instead.\")]\n        [return: NullAllowed]\n        [Export(\"appBarForViewController:\")]\n        AppBar GetAppBar(UIViewController viewController);\n    }\n\n    [BaseType(typeof(UIViewController),\n        Name = \"MDCFlexibleHeaderContainerViewController\")]\n    interface FlexibleHeaderContainerViewController\n    {\n        [Export(\"headerViewController\", ArgumentSemantic.Strong)]\n        FlexibleHeaderViewController HeaderViewController { get; }\n\n        [NullAllowed]\n        [Export(\"contentViewController\", ArgumentSemantic.Strong)]\n        UIViewController ContentViewController { get; set; }\n\n        [Export(\"topLayoutGuideAdjustmentEnabled\")]\n        bool TopLayoutGuideAdjustmentEnabled { [Bind(\"isTopLayoutGuideAdjustmentEnabled\")] get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<FlexibleHeaderContainerViewController, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [DesignatedInitializer]\n        [Export(\"initWithContentViewController:\")]\n        IntPtr Constructor([NullAllowed] UIViewController contentViewController);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCFlexibleHeaderView\",\n        Delegates = new[] { \"Delegate\" },\n        Events = new[] { typeof(FlexibleHeaderViewDelegate) })]\n    interface FlexibleHeaderView : IElevatable, IElevationOverriding\n\n    {\n        [Export(\"shadowLayer\", ArgumentSemantic.Strong)]\n        CALayer ShadowLayer { get; set; }\n\n        [Export(\"shadowColor\", ArgumentSemantic.Copy)]\n        UIColor ShadowColor { get; set; }\n\n        [Export(\"prefersStatusBarHidden\")]\n        bool PrefersStatusBarHidden { get; }\n\n        [Export(\"scrollPhase\")]\n        FlexibleHeaderScrollPhase ScrollPhase { get; }\n\n        [Export(\"scrollPhaseValue\")]\n        nfloat ScrollPhaseValue { get; }\n\n        [Export(\"scrollPhasePercentage\")]\n        nfloat ScrollPhasePercentage { get; }\n\n        [Export(\"minimumHeight\")]\n        nfloat MinimumHeight { get; set; }\n\n        [Export(\"maximumHeight\")]\n        nfloat MaximumHeight { get; set; }\n\n        [Export(\"minMaxHeightIncludesSafeArea\")]\n        bool MinMaxHeightIncludesSafeArea { get; set; }\n\n        [Export(\"topSafeAreaGuide\")]\n        NSObject TopSafeAreaGuide { get; }\n\n        [Export(\"canOverExtend\")]\n        bool CanOverExtend { get; set; }\n\n        [Export(\"visibleShadowOpacity\")]\n        float VisibleShadowOpacity { get; set; }\n\n        [Export(\"resetShadowAfterTrackingScrollViewIsReset\")]\n        bool ResetShadowAfterTrackingScrollViewIsReset { get; set; }\n\n        [NullAllowed]\n        [Export(\"trackingScrollView\", ArgumentSemantic.Weak)]\n        UIScrollView TrackingScrollView { get; set; }\n\n        [Export(\"observesTrackingScrollViewScrollEvents\")]\n        bool ObservesTrackingScrollViewScrollEvents { get; set; }\n\n        [Export(\"inFrontOfInfiniteContent\")]\n        bool InFrontOfInfiniteContent { [Bind(\"isInFrontOfInfiniteContent\")] get; set; }\n\n        [Export(\"sharedWithManyScrollViews\")]\n        bool SharedWithManyScrollViews { get; set; }\n\n        [Introduced(PlatformName.iOS, 11, 0)]\n        [Introduced(PlatformName.TvOS, 11, 0)]\n        [Export(\"disableContentInsetAdjustmentWhenContentInsetAdjustmentBehaviorIsNever\")]\n        bool DisableContentInsetAdjustmentWhenContentInsetAdjustmentBehaviorIsNever { get; set; }\n\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        IFlexibleHeaderViewDelegate Delegate { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<FlexibleHeaderView, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"elevation\")]\n        double Elevation { get; set; }\n\n        [Export(\"canAlwaysExpandToMaximumHeight\")]\n        bool CanAlwaysExpandToMaximumHeight { get; set; }\n\n        [Export(\"shiftBehavior\", ArgumentSemantic.Assign)]\n        FlexibleHeaderShiftBehavior ShiftBehavior { get; set; }\n\n        [Export(\"headerContentImportance\", ArgumentSemantic.Assign)]\n        FlexibleHeaderContentImportance HeaderContentImportance { get; set; }\n\n        [Export(\"trackingScrollViewIsBeingScrubbed\")]\n        bool TrackingScrollViewIsBeingScrubbed { get; set; }\n\n        [Export(\"contentIsTranslucent\")]\n        bool ContentIsTranslucent { get; set; }\n\n        [Export(\"statusBarHintCanOverlapHeader\")]\n        bool StatusBarHintCanOverlapHeader { get; set; }\n\n        [Export(\"setShadowLayer:intensityDidChangeBlock:\")]\n        void SetShadowLayer(CALayer shadowLayer, FlexibleHeaderShadowIntensityChangeHandler block);\n\n        [Advice(\"Do not invoke this method if ObservesTrackingScrollViewScrollEvents property is set to true.\")]\n        [Export(\"trackingScrollViewDidScroll\")]\n        void TrackingScrollViewDidScroll();\n\n        [Export(\"trackingScrollViewDidChangeAdjustedContentInset:\")]\n        void TrackingScrollViewDidChangeAdjustedContentInset([NullAllowed] UIScrollView trackingScrollView);\n\n        [Export(\"trackingScrollWillChangeToScrollView:\")]\n        void TrackingScrollWillChangeToScrollView([NullAllowed] UIScrollView scrollView);\n\n        [Export(\"interfaceOrientationWillChange\")]\n        void InterfaceOrientationWillChange();\n\n        [Export(\"interfaceOrientationIsChanging\")]\n        void InterfaceOrientationIsChanging();\n\n        [Export(\"interfaceOrientationDidChange\")]\n        void InterfaceOrientationDidChange();\n\n        [Export(\"viewWillTransitionToSize:withTransitionCoordinator:\")]\n        void ViewWillTransitionToSize(CGSize size, IUIViewControllerTransitionCoordinator coordinator);\n\n        [Export(\"changeContentInsets:\")]\n        void ChangeContentInsets(FlexibleHeaderChangeContentInsetsHandler block);\n\n        [Export(\"forwardTouchEventsForView:\")]\n        void ForwardTouchEventsForView(UIView view);\n\n        [Export(\"stopForwardingTouchEventsForView:\")]\n        void StopForwardingTouchEventsForView(UIView view);\n\n        [Export(\"hideViewWhenShifted:\")]\n        void HideViewWhenShifted(UIView view);\n\n        [Export(\"stopHidingViewWhenShifted:\")]\n        void StopHidingViewWhenShifted(UIView view);\n\n        [Export(\"shiftHeaderOnScreenAnimated:\")]\n        void ShiftHeaderOnScreen(bool animated);\n\n        [Export(\"shiftHeaderOffScreenAnimated:\")]\n        void ShiftHeaderOffScreen(bool animated);\n\n        [Advice(\"Do not invoke this method if ObservesTrackingScrollViewScrollEvents property is set to true.\")]\n        [Export(\"trackingScrollViewDidEndDraggingWillDecelerate:\")]\n        void TrackingScrollViewDidEndDragging(bool willDecelerate);\n\n        [Advice(\"Do not invoke this method if ObservesTrackingScrollViewScrollEvents property is set to true.\")]\n        [Export(\"trackingScrollViewDidEndDecelerating\")]\n        void TrackingScrollViewDidEndDecelerating();\n\n        [Advice(\"Do not invoke this method if ObservesTrackingScrollViewScrollEvents property is set to true.\")]\n        [Export(\"trackingScrollViewWillEndDraggingWithVelocity:targetContentOffset:\")]\n        bool TrackingScrollViewWillEndDragging(CGPoint velocity, ref CGPoint targetContentOffset);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCFlexibleHeaderViewDelegate\")]\n    interface FlexibleHeaderViewDelegate\n    {\n        [EventArgs(\"FlexibleHeaderView\")]\n        [Abstract]\n        [Export(\"flexibleHeaderViewNeedsStatusBarAppearanceUpdate:\")]\n        void NeedsStatusBarAppearanceUpdate(FlexibleHeaderView headerView);\n\n        [EventArgs(\"FlexibleHeaderView\")]\n        [EventName(\"FrameChanged\")]\n        [Abstract]\n        [Export(\"flexibleHeaderViewFrameDidChange:\")]\n        void FrameDidChange(FlexibleHeaderView headerView);\n    }\n\n    [BaseType(typeof(UIViewController),\n        Name = \"MDCFlexibleHeaderViewController\",\n        Delegates = new[] { \"LayoutDelegate\" },\n        Events = new[] { typeof(FlexibleHeaderViewLayoutDelegate) })]\n    interface FlexibleHeaderViewController : IUIScrollViewDelegate, IUITableViewDelegate\n\n    {\n        [Export(\"headerView\", ArgumentSemantic.Strong)]\n        FlexibleHeaderView HeaderView { get; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<FlexibleHeaderViewController, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [NullAllowed]\n        [Export(\"layoutDelegate\", ArgumentSemantic.Weak)]\n        IFlexibleHeaderViewLayoutDelegate LayoutDelegate { get; set; }\n\n        [Wrap(\"WeakSafeAreaDelegate\")]\n        [NullAllowed]\n        IFlexibleHeaderSafeAreaDelegate SafeAreaDelegate { get; set; }\n\n        [NullAllowed]\n        [Export(\"safeAreaDelegate\", ArgumentSemantic.Weak)]\n        NSObject WeakSafeAreaDelegate { get; set; }\n\n        [Export(\"topLayoutGuideAdjustmentEnabled\")]\n        bool TopLayoutGuideAdjustmentEnabled { [Bind(\"isTopLayoutGuideAdjustmentEnabled\")] get; set; }\n\n        [NullAllowed]\n        [Export(\"topLayoutGuideViewController\", ArgumentSemantic.Weak)]\n        UIViewController TopLayoutGuideViewController { get; set; }\n\n        [Export(\"inferTopSafeAreaInsetFromViewController\")]\n        bool InferTopSafeAreaInsetFromViewController { get; set; }\n\n        [Export(\"useAdditionalSafeAreaInsetsForWebKitScrollViews\")]\n        bool UseAdditionalSafeAreaInsetsForWebKitScrollViews { get; set; }\n\n        [New]\n        [Export(\"prefersStatusBarHidden\")]\n        bool PrefersStatusBarHidden { get; }\n\n        [New]\n        [Export(\"preferredStatusBarStyle\")]\n        UIStatusBarStyle PreferredStatusBarStyle { get; }\n\n        [Export(\"inferPreferredStatusBarStyle\")]\n        bool InferPreferredStatusBarStyle { get; set; }\n\n        [Export(\"updateTopLayoutGuide\")]\n        void UpdateTopLayoutGuide();\n    }\n\n    [Protocol(Name = \"MDCFlexibleHeaderSafeAreaDelegate\")]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject))]\n    interface FlexibleHeaderSafeAreaDelegate\n    {\n        [return: NullAllowed]\n        [Abstract]\n        [Export(\"flexibleHeaderViewControllerTopSafeAreaInsetViewController:\")]\n        UIViewController FlexibleHeaderViewControllerTopSafeAreaInsetViewController(FlexibleHeaderViewController flexibleHeaderViewController);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCFlexibleHeaderViewLayoutDelegate\")]\n    interface FlexibleHeaderViewLayoutDelegate\n    {\n        [EventArgs(\"FlexibleHeaderViewLayoutFrameChanged\")]\n        [EventName(\"FrameChanged\")]\n        [Abstract]\n        [Export(\"flexibleHeaderViewController:flexibleHeaderViewFrameDidChange:\")]\n        void FrameDidChange(FlexibleHeaderViewController flexibleHeaderViewController, FlexibleHeaderView flexibleHeaderView);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCHeaderStackView\")]\n    interface HeaderStackView\n    {\n        [NullAllowed]\n        [Export(\"topBar\", ArgumentSemantic.Strong)]\n        UIView TopBar { get; set; }\n\n        [NullAllowed]\n        [Export(\"bottomBar\", ArgumentSemantic.Strong)]\n        UIView BottomBar { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<HeaderStackView, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n    }\n\n    [Protocol(Name = \"MDCUINavigationItemObservables\")]\n    [BaseType(typeof(NSObject))]\n    interface UINavigationItemObservables\n    {\n        [Abstract]\n        [NullAllowed]\n        [Export(\"title\")]\n        string Title { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"titleView\", ArgumentSemantic.Strong)]\n        UIView TitleView { get; set; }\n\n        [Abstract]\n        [Export(\"hidesBackButton\")]\n        bool HidesBackButton { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"leftBarButtonItems\", ArgumentSemantic.Copy)]\n        UIBarButtonItem[] LeftBarButtonItems { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"rightBarButtonItems\", ArgumentSemantic.Copy)]\n        UIBarButtonItem[] RightBarButtonItems { get; set; }\n\n        [Abstract]\n        [Export(\"leftItemsSupplementBackButton\")]\n        bool LeftItemsSupplementBackButton { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"leftBarButtonItem\", ArgumentSemantic.Strong)]\n        UIBarButtonItem LeftBarButtonItem { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"rightBarButtonItem\", ArgumentSemantic.Strong)]\n        UIBarButtonItem RightBarButtonItem { get; set; }\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCNavigationBarTextColorAccessibilityMutator\")]\n    interface NavigationBarTextColorAccessibilityMutator\n    {\n        [Export(\"mutate:\")]\n        void Mutate(NavigationBar navBar);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCNavigationBar\")]\n    interface NavigationBar : IElevatable, IElevationOverriding\n\n    {\n        [NullAllowed]\n        [Export(\"title\")]\n        string Title { get; set; }\n\n        [NullAllowed]\n        [Export(\"titleView\", ArgumentSemantic.Strong)]\n        UIView TitleView { get; set; }\n\n        [Export(\"titleViewLayoutBehavior\", ArgumentSemantic.Assign)]\n        NavigationBarTitleViewLayoutBehavior TitleViewLayoutBehavior { get; set; }\n\n        [Export(\"titleInsets\", ArgumentSemantic.Assign)]\n        UIEdgeInsets TitleInsets { get; set; }\n\n        [Export(\"titleFont\", ArgumentSemantic.Strong)]\n        UIFont TitleFont { get; set; }\n\n        [Export(\"allowAnyTitleFontSize\")]\n        bool AllowAnyTitleFontSize { get; set; }\n\n        [NullAllowed]\n        [Export(\"titleTextColor\", ArgumentSemantic.Strong)]\n        UIColor TitleTextColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"rippleColor\", ArgumentSemantic.Strong)]\n        UIColor RippleColor { get; set; }\n\n        [Export(\"enableRippleBehavior\")]\n        bool EnableRippleBehavior { get; set; }\n\n        [Export(\"uppercasesButtonTitles\")]\n        bool UppercasesButtonTitles { get; set; }\n\n        [NullAllowed]\n        [Export(\"leadingBarItemsTintColor\", ArgumentSemantic.Strong)]\n        UIColor LeadingBarItemsTintColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"trailingBarItemsTintColor\", ArgumentSemantic.Strong)]\n        UIColor TrailingBarItemsTintColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"backItem\", ArgumentSemantic.Strong)]\n        UIBarButtonItem BackItem { get; set; }\n\n        [Export(\"hidesBackButton\")]\n        bool HidesBackButton { get; set; }\n\n        [NullAllowed]\n        [Export(\"leadingBarButtonItems\", ArgumentSemantic.Copy)]\n        UIBarButtonItem[] LeadingBarButtonItems { get; set; }\n\n        [NullAllowed]\n        [Export(\"trailingBarButtonItems\", ArgumentSemantic.Copy)]\n        UIBarButtonItem[] TrailingBarButtonItems { get; set; }\n\n        [Export(\"leadingItemsSupplementBackButton\")]\n        bool LeadingItemsSupplementBackButton { get; set; }\n\n        [NullAllowed]\n        [Export(\"leadingBarButtonItem\", ArgumentSemantic.Strong)]\n        UIBarButtonItem LeadingBarButtonItem { get; set; }\n\n        [NullAllowed]\n        [Export(\"trailingBarButtonItem\", ArgumentSemantic.Strong)]\n        UIBarButtonItem TrailingBarButtonItem { get; set; }\n\n        [Export(\"titleAlignment\", ArgumentSemantic.Assign)]\n        NavigationBarTitleAlignment TitleAlignment { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<NavigationBar, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [NullAllowed]\n        [Export(\"leftBarButtonItems\", ArgumentSemantic.Copy)]\n        UIBarButtonItem[] LeftBarButtonItems { get; set; }\n\n        [NullAllowed]\n        [Export(\"rightBarButtonItems\", ArgumentSemantic.Copy)]\n        UIBarButtonItem[] RightBarButtonItems { get; set; }\n\n        [NullAllowed]\n        [Export(\"leftBarButtonItem\", ArgumentSemantic.Strong)]\n        UIBarButtonItem LeftBarButtonItem { get; set; }\n\n        [NullAllowed]\n        [Export(\"rightBarButtonItem\", ArgumentSemantic.Strong)]\n        UIBarButtonItem RightBarButtonItem { get; set; }\n\n        [Export(\"leftItemsSupplementBackButton\")]\n        bool LeftItemsSupplementBackButton { get; set; }\n\n        [Obsolete(\"This property will be deprecated in future, please use TitleFont and TitleTextColor properties instead.\")]\n        [NullAllowed]\n        [Export(\"titleTextAttributes\", ArgumentSemantic.Copy)]\n        NSDictionary<NSString, NSObject> TitleTextAttributes { get; set; }\n\n        [Export(\"setButtonsTitleFont:forState:\")]\n        void SetButtonsTitleFont([NullAllowed] UIFont font, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"buttonsTitleFontForState:\")]\n        UIFont GetButtonsTitleFont(UIControlState state);\n\n        [Export(\"setButtonsTitleColor:forState:\")]\n        void SetButtonsTitleColor([NullAllowed] UIColor color, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"buttonsTitleColorForState:\")]\n        UIColor GetButtonsTitleColor(UIControlState state);\n\n        [Export(\"rectForLeadingBarButtonItem:inCoordinateSpace:\")]\n        CGRect RectForLeadingBarButtonItem(UIBarButtonItem item, UICoordinateSpace coordinateSpace);\n\n        [Export(\"rectForTrailingBarButtonItem:inCoordinateSpace:\")]\n        CGRect RectForTrailingBarButtonItem(UIBarButtonItem item, UICoordinateSpace coordinateSpace);\n\n        [Export(\"observeNavigationItem:\")]\n        void ObserveNavigationItem(UINavigationItem navigationItem);\n\n        [Export(\"unobserveNavigationItem\")]\n        void UnobserveNavigationItem();\n\n        [NullAllowed]\n        [Export(\"inkColor\", ArgumentSemantic.Strong)]\n        UIColor InkColor { get; set; }\n    }\n\n    [BaseType(typeof(FlexibleHeaderViewController),\n        Name = \"MDCAppBarViewController\")]\n    interface AppBarViewController\n    {\n        [Export(\"navigationBar\", ArgumentSemantic.Strong)]\n        NavigationBar NavigationBar { get; set; }\n\n        [Export(\"headerStackView\", ArgumentSemantic.Strong)]\n        HeaderStackView HeaderStackView { get; set; }\n    }\n\n    [Obsolete(\"This API will be deprecated in favor of AppBarViewController class.\")]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCAppBar\")]\n    interface AppBar\n    {\n        [Export(\"headerViewController\", ArgumentSemantic.Strong)]\n        FlexibleHeaderViewController HeaderViewController { get; }\n\n        [Export(\"appBarViewController\", ArgumentSemantic.Strong)]\n        AppBarViewController AppBarViewController { get; }\n\n        [Export(\"navigationBar\", ArgumentSemantic.Strong)]\n        NavigationBar NavigationBar { get; }\n\n        [Export(\"headerStackView\", ArgumentSemantic.Strong)]\n        HeaderStackView HeaderStackView { get; }\n\n        [Export(\"inferTopSafeAreaInsetFromViewController\")]\n        bool InferTopSafeAreaInsetFromViewController { get; set; }\n\n        [Export(\"addSubviewsToParent\")]\n        void AddSubviewsToParent();\n    }\n\n    [Obsolete(\"This class will soon be deprecated.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCAppBarColorThemer\")]\n    interface AppBarColorThemer\n    {\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Export(\"applySemanticColorScheme:toAppBar:\")]\n        [Static]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, AppBar appBar);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Export(\"applySurfaceVariantWithColorScheme:toAppBar:\")]\n        [Static]\n        void ApplySurfaceVariant(IColorScheming colorScheme, AppBar appBar);\n\n        [Obsolete(\"This method will soon be deprecated. Consider using ApplySemanticColorScheme method instead.\")]\n        [Export(\"applyColorScheme:toAppBar:\")]\n        [Static]\n        void ApplyColorScheme(IColorScheme colorScheme, AppBar appBar);\n\n        [Obsolete(\"This method will soon be deprecated. Consider using ApplySemanticColorScheme method instead.\")]\n        [Static]\n        [Export(\"applyColorScheme:toAppBarViewController:\")]\n        void ApplyColorScheme(IColorScheming colorScheme, AppBarViewController appBarViewController);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Export(\"applySurfaceVariantWithColorScheme:toAppBarViewController:\")]\n        [Static]\n        void ApplySurfaceVariant(IColorScheming colorScheme, AppBarViewController appBarViewController);\n    }\n\n    [Category]\n    [BaseType(typeof(AppBarViewController),\n        Name = \"MDCAppBarViewController_MaterialTheming\")]\n    interface AppBarViewController_MaterialTheming\n    {\n        [Export(\"applyPrimaryThemeWithScheme:\")]\n        void ApplyPrimaryThemeWithScheme(IContainerScheming containerScheme);\n\n        [Export(\"applySurfaceThemeWithScheme:\")]\n        void ApplySurfaceThemeWithScheme(IContainerScheming containerScheme);\n    }\n\n    [Obsolete(\"This class will soon be deprecated.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCAppBarTypographyThemer\")]\n    interface AppBarTypographyThemer\n    {\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyTypographyScheme:toAppBar:\")]\n        void ApplyTypographyScheme(ITypographyScheming typographyScheme, AppBar appBar);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyTypographyScheme:toAppBarViewController:\")]\n        void ApplyTypographyScheme(ITypographyScheming typographyScheme, AppBarViewController appBarViewController);\n    }\n\n    [BaseType(typeof(UIGestureRecognizer),\n        Name = \"MDCInkGestureRecognizer\")]\n    interface InkGestureRecognizer\n    {\n        [Export(\"dragCancelDistance\")]\n        nfloat DragCancelDistance { get; set; }\n\n        [Export(\"cancelOnDragOut\")]\n        bool CancelOnDragOut { get; set; }\n\n        [Export(\"targetBounds\", ArgumentSemantic.Assign)]\n        CGRect TargetBounds { get; set; }\n\n\n        [Export(\"isTouchWithinTargetBounds\")]\n        bool IsTouchWithinTargetBounds { get; }\n\n        [Export(\"touchStartLocationInView:\")]\n        CGPoint GetTouchStartLocation(UIView view);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCInkTouchController\",\n        Delegates = new[] { \"Delegate\" },\n        Events = new[] { typeof(InkTouchControllerDelegate) })]\n    interface InkTouchController : IUIGestureRecognizerDelegate\n\n    {\n        [NullAllowed]\n        [Export(\"view\", ArgumentSemantic.Weak)]\n        UIView View { get; }\n\n        [Export(\"defaultInkView\", ArgumentSemantic.Strong)]\n        InkView DefaultInkView { get; }\n\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        IInkTouchControllerDelegate Delegate { get; set; }\n\n        [Export(\"delaysInkSpread\")]\n        bool DelaysInkSpread { get; set; }\n\n        [Export(\"dragCancelDistance\")]\n        nfloat DragCancelDistance { get; set; }\n\n        [Export(\"cancelsOnDragOut\")]\n        bool CancelsOnDragOut { get; set; }\n\n        [Export(\"requiresFailureOfScrollViewGestures\")]\n        bool RequiresFailureOfScrollViewGestures { get; set; }\n\n        [Export(\"targetBounds\", ArgumentSemantic.Assign)]\n        CGRect TargetBounds { get; set; }\n\n        [Export(\"gestureRecognizer\", ArgumentSemantic.Strong)]\n        InkGestureRecognizer GestureRecognizer { get; }\n\n        [DesignatedInitializer]\n        [Export(\"initWithView:\")]\n        IntPtr Constructor(UIView view);\n\n        [Export(\"addInkView\")]\n        void AddInkView();\n\n        [Export(\"cancelInkTouchProcessing\")]\n        void CancelInkTouchProcessing();\n\n        [return: NullAllowed]\n        [Export(\"inkViewAtTouchLocation:\")]\n        InkView GetInkView(CGPoint location);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCInkTouchControllerDelegate\")]\n    interface InkTouchControllerDelegate\n    {\n        [EventArgs(\"InkTouchControllerInsertInkView\")]\n        [Export(\"inkTouchController:insertInkView:intoView:\")]\n        void InsertInkView(InkTouchController inkTouchController, UIView inkView, UIView view);\n\n        [NoDefaultValue]\n        [DelegateName(\"InkTouchControllerGetInkViewAtTouchLocation\")]\n        [return: NullAllowed]\n        [Export(\"inkTouchController:inkViewAtTouchLocation:\")]\n        InkView GetInkViewAtTouchLocation(InkTouchController inkTouchController, CGPoint location);\n\n        [DefaultValue(true)]\n        [DelegateName(\"InkTouchControllerShouldProcessInkTouches\")]\n        [Export(\"inkTouchController:shouldProcessInkTouchesAtTouchLocation:\")]\n        bool ShouldProcessInkTouches(InkTouchController inkTouchController, CGPoint location);\n\n        [EventArgs(\"InkTouchControllerInkViewProcessed\")]\n        [EventName(\"InkViewProcessed\")]\n        [Export(\"inkTouchController:didProcessInkView:atTouchLocation:\")]\n        void DidProcessInkView(InkTouchController inkTouchController, InkView inkView, CGPoint location);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCInkView\",\n        Delegates = new[] { \"AnimationDelegate\" },\n        Events = new[] { typeof(InkViewDelegate) })]\n    interface InkView\n    {\n        [NullAllowed]\n        [Export(\"animationDelegate\", ArgumentSemantic.Weak)]\n        IInkViewDelegate AnimationDelegate { get; set; }\n\n        [Export(\"inkStyle\", ArgumentSemantic.Assign)]\n        InkStyle InkStyle { get; set; }\n\n        [Export(\"inkColor\", ArgumentSemantic.Strong)]\n        UIColor InkColor { get; set; }\n\n        [Export(\"defaultInkColor\", ArgumentSemantic.Strong)]\n        UIColor DefaultInkColor { get; }\n\n        [Export(\"maxRippleRadius\")]\n        nfloat MaxRippleRadius { get; set; }\n\n        [Export(\"usesLegacyInkRipple\")]\n        bool UsesLegacyInkRipple { get; set; }\n\n        [Export(\"usesCustomInkCenter\")]\n        bool UsesCustomInkCenter { get; set; }\n\n        [Export(\"customInkCenter\", ArgumentSemantic.Assign)]\n        CGPoint CustomInkCenter { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<InkView, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"startTouchBeganAnimationAtPoint:completion:\")]\n        void StartTouchBeganAnimation(CGPoint point, [NullAllowed]  InkCompletionHandler completionBlock);\n\n        [Export(\"startTouchEndedAnimationAtPoint:completion:\")]\n        void StartTouchEndedAnimation(CGPoint point, [NullAllowed]  InkCompletionHandler completionBlock);\n\n        [Export(\"cancelAllAnimationsAnimated:\")]\n        void CancelAllAnimations(bool animated);\n\n        [Export(\"startTouchBeganAtPoint:animated:withCompletion:\")]\n        void StartTouchBegan(CGPoint point, bool animated, [NullAllowed]  InkCompletionHandler completionBlock);\n\n        [Export(\"startTouchEndAtPoint:animated:withCompletion:\")]\n        void StartTouchEnd(CGPoint point, bool animated, [NullAllowed]  InkCompletionHandler completionBlock);\n\n        [Static]\n        [Export(\"injectedInkViewForView:\")]\n        InkView GetInjectedInkView(UIView view);\n    }\n\n    [BaseType(typeof(UIButton),\n        Name = \"MDCButton\")]\n    interface Button : INativeObject\n\n    {\n        [Export(\"inkStyle\", ArgumentSemantic.Assign)]\n        InkStyle InkStyle { get; set; }\n\n        [Export(\"inkColor\", ArgumentSemantic.Strong)]\n        UIColor InkColor { get; set; }\n\n        [Export(\"inkMaxRippleRadius\")]\n        nfloat InkMaxRippleRadius { get; set; }\n\n        [Export(\"enableRippleBehavior\")]\n        bool EnableRippleBehavior { get; set; }\n\n        [Export(\"disabledAlpha\")]\n        nfloat DisabledAlpha { get; set; }\n\n        [Export(\"uppercaseTitle\")]\n        bool UppercaseTitle { [Bind(\"isUppercaseTitle\")] get; set; }\n\n        [Export(\"hitAreaInsets\", ArgumentSemantic.Assign)]\n        UIEdgeInsets HitAreaInsets { get; set; }\n\n        [Export(\"minimumSize\", ArgumentSemantic.Assign)]\n        CGSize MinimumSize { get; set; }\n\n        [Export(\"maximumSize\", ArgumentSemantic.Assign)]\n        CGSize MaximumSize { get; set; }\n\n        [NullAllowed]\n        [Export(\"underlyingColorHint\", ArgumentSemantic.Strong)]\n        UIColor UnderlyingColorHint { get; set; }\n\n        [Export(\"adjustsFontForContentSizeCategoryWhenScaledFontIsUnavailable\")]\n        bool AdjustsFontForContentSizeCategoryWhenScaledFontIsUnavailable { get; set; }\n\n        [NullAllowed]\n        [Export(\"shapeGenerator\", ArgumentSemantic.Strong)]\n        IShapeGenerating ShapeGenerator { get; set; }\n\n        [Export(\"accessibilityTraitsIncludesButton\")]\n        bool AccessibilityTraitsIncludesButton { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<Button, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"mdc_adjustsFontForContentSizeCategory\")]\n        bool AdjustsFontForContentSizeCategory { get; [Bind(\"mdc_setAdjustsFontForContentSizeCategory:\")]set; }\n\n        [Obsolete(\"Use AdjustsFontForContentSizeCategory instead\")]\n        [Wrap(\"AdjustsFontForContentSizeCategory\")]\n        bool MdcAdjustsFontForContentSizeCategory { get; set; }\n\n        [return: NullAllowed]\n        [Export(\"backgroundColorForState:\")]\n        UIColor GetBackgroundColor(UIControlState state);\n\n        [Export(\"setBackgroundColor:forState:\")]\n        void SetBackgroundColor([NullAllowed] UIColor backgroundColor, UIControlState state);\n\n        [Export(\"setBackgroundColor:\")]\n        void SetBackgroundColor([NullAllowed] UIColor backgroundColor);\n\n        [return: NullAllowed]\n        [Export(\"titleFontForState:\")]\n        UIFont GetTitleFont(UIControlState state);\n\n        [Export(\"setTitleFont:forState:\")]\n        void SetTitleFont([NullAllowed] UIFont font, UIControlState state);\n\n        [Export(\"setEnabled:animated:\")]\n        void SetEnabled(bool enabled, bool animated);\n\n        [Export(\"elevationForState:\")]\n        nfloat GetElevation(UIControlState state);\n\n        [Export(\"setElevation:forState:\")]\n        void SetElevation(nfloat elevation, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"borderColorForState:\")]\n        UIColor GetBorderColor(UIControlState state);\n\n        [Export(\"setBorderColor:forState:\")]\n        void SetBorderColor([NullAllowed] UIColor borderColor, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"imageTintColorForState:\")]\n        UIColor GetImageTintColor(UIControlState state);\n\n        [Export(\"setImageTintColor:forState:\")]\n        void SetImageTintColor([NullAllowed] UIColor imageTintColor, UIControlState state);\n\n        [Export(\"borderWidthForState:\")]\n        nfloat GetBorderWidth(UIControlState state);\n\n        [Export(\"setBorderWidth:forState:\")]\n        void SetBorderWidth(nfloat borderWidth, UIControlState state);\n\n        [Export(\"setShadowColor:forState:\")]\n        void SetShadowColor([NullAllowed] UIColor shadowColor, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"shadowColorForState:\")]\n        UIColor GetShadowColor(UIControlState state);\n\n        [Wrap(\"SetElevation ((nfloat)elevation, state)\")]\n        void SetElevation(double elevation, UIControlState state);\n    }\n\n    [Obsolete(\"This class will be deprecated soon. Consider using TextButtonThemer with a Button instead.\")]\n    [BaseType(typeof(Button),\n        Name = \"MDCFlatButton\")]\n    interface FlatButton\n    {\n        [Export(\"hasOpaqueBackground\")]\n        bool HasOpaqueBackground { get; set; }\n    }\n\n    [BaseType(typeof(Button),\n        Name = \"MDCFloatingButton\")]\n    interface FloatingButton\n    {\n        [Export(\"mode\", ArgumentSemantic.Assign)]\n        FloatingButtonMode Mode { get; set; }\n\n        [Export(\"imageLocation\", ArgumentSemantic.Assign)]\n        FloatingButtonImageLocation ImageLocation { get; set; }\n\n        [Export(\"imageTitleSpace\")]\n        nfloat ImageTitleSpace { get; set; }\n\n        [Static]\n\n        [Export(\"defaultDimension\")]\n        nfloat DefaultDimension { get; }\n\n        [Static]\n\n        [Export(\"miniDimension\")]\n        nfloat MiniDimension { get; }\n\n        [Static]\n        [Export(\"floatingButtonWithShape:\")]\n        FloatingButton Create(FloatingButtonShape shape);\n\n        [DesignatedInitializer]\n        [Export(\"initWithFrame:shape:\")]\n        IntPtr Constructor(CGRect frame, FloatingButtonShape shape);\n\n        [Export(\"initWithFrame:\")]\n        IntPtr Constructor(CGRect frame);\n\n        [Export(\"setMinimumSize:forShape:inMode:\")]\n        void SetMinimumSize(CGSize minimumSize, FloatingButtonShape shape, FloatingButtonMode mode);\n\n        [Export(\"setMaximumSize:forShape:inMode:\")]\n        void SetMaximumSize(CGSize maximumSize, FloatingButtonShape shape, FloatingButtonMode mode);\n\n        [Export(\"setContentEdgeInsets:forShape:inMode:\")]\n        void SetContentEdgeInsets(UIEdgeInsets contentEdgeInsets, FloatingButtonShape shape, FloatingButtonMode mode);\n\n        [Export(\"setHitAreaInsets:forShape:inMode:\")]\n        void SetHitAreaInsets(UIEdgeInsets hitAreaInsets, FloatingButtonShape shape, FloatingButtonMode mode);\n\n        [Export(\"expand:completion:\")]\n        void Expand(bool animated, [NullAllowed]  Action completion);\n\n        [Export(\"collapse:completion:\")]\n        void Collapse(bool animated, [NullAllowed]  Action completion);\n    }\n\n    [Obsolete(\"This class will be deprecated soon. Consider using ContainedButtonThemer with a Button instead.\")]\n    [BaseType(typeof(Button),\n        Name = \"MDCRaisedButton\")]\n    interface RaisedButton\n    { }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCBannerView\")]\n    interface BannerView : IElevatable, IElevationOverriding\n\n    {\n        [Export(\"bannerViewLayoutStyle\", ArgumentSemantic.Assign)]\n        BannerViewLayoutStyle BannerViewLayoutStyle { get; set; }\n\n        [Export(\"textView\", ArgumentSemantic.Strong)]\n        UITextView TextView { get; }\n\n        [Export(\"imageView\", ArgumentSemantic.Strong)]\n        UIImageView ImageView { get; }\n\n        [Export(\"leadingButton\", ArgumentSemantic.Strong)]\n        Button LeadingButton { get; }\n\n        [Export(\"trailingButton\", ArgumentSemantic.Strong)]\n        Button TrailingButton { get; }\n\n        [Export(\"showsDivider\")]\n        bool ShowsDivider { get; set; }\n\n        [Export(\"dividerColor\", ArgumentSemantic.Strong)]\n        UIColor DividerColor { get; set; }\n\n        [Export(\"mdc_adjustsFontForContentSizeCategory\")]\n        bool AdjustsFontForContentSizeCategory { get; [Bind(\"mdc_setAdjustsFontForContentSizeCategory:\")]set; }\n\n        [Obsolete(\"Use AdjustsFontForContentSizeCategory instead\")]\n        [Wrap(\"AdjustsFontForContentSizeCategory\")]\n        bool MdcAdjustsFontForContentSizeCategory { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<BannerView, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n    }\n\n    [Category]\n    [BaseType(typeof(BannerView),\n        Name = \"MDCBannerView_MaterialTheming\")]\n    interface BannerView_MaterialTheming\n    {\n        [Export(\"applyThemeWithScheme:\")]\n        void ApplyTheme(IContainerScheming scheme);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCBottomAppBarView\")]\n    interface BottomAppBarView : IElevatable, IElevationOverriding\n\n    {\n        [Export(\"floatingButtonHidden\")]\n        bool FloatingButtonHidden { [Bind(\"isFloatingButtonHidden\")] get; set; }\n\n        [Export(\"floatingButtonElevation\", ArgumentSemantic.Assign)]\n        BottomAppBarFloatingButtonElevation FloatingButtonElevation { get; set; }\n\n        [Export(\"floatingButtonPosition\", ArgumentSemantic.Assign)]\n        BottomAppBarFloatingButtonPosition FloatingButtonPosition { get; set; }\n\n        [Export(\"floatingButton\", ArgumentSemantic.Strong)]\n        FloatingButton FloatingButton { get; }\n\n        [Export(\"floatingButtonVerticalOffset\")]\n        nfloat FloatingButtonVerticalOffset { get; set; }\n\n        [NullAllowed]\n        [Export(\"leadingBarButtonItems\", ArgumentSemantic.Copy)]\n        UIBarButtonItem[] LeadingBarButtonItems { get; set; }\n\n        [NullAllowed]\n        [Export(\"trailingBarButtonItems\", ArgumentSemantic.Copy)]\n        UIBarButtonItem[] TrailingBarButtonItems { get; set; }\n\n        [NullAllowed]\n        [Export(\"barTintColor\", ArgumentSemantic.Strong)]\n        UIColor BarTintColor { get; set; }\n\n        [Export(\"leadingBarItemsTintColor\", ArgumentSemantic.Strong)]\n        UIColor LeadingBarItemsTintColor { get; set; }\n\n        [Export(\"trailingBarItemsTintColor\", ArgumentSemantic.Strong)]\n        UIColor TrailingBarItemsTintColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"shadowColor\", ArgumentSemantic.Strong)]\n        UIColor ShadowColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<BottomAppBarView, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"elevation\")]\n        double Elevation { get; set; }\n\n        [Export(\"setFloatingButtonHidden:animated:\")]\n        void SetFloatingButtonHidden(bool floatingButtonHidden, bool animated);\n\n        [Export(\"setFloatingButtonElevation:animated:\")]\n        void SetFloatingButtonElevation(BottomAppBarFloatingButtonElevation floatingButtonElevation, bool animated);\n\n        [Export(\"setFloatingButtonPosition:animated:\")]\n        void SetFloatingButtonPosition(BottomAppBarFloatingButtonPosition floatingButtonPosition, bool animated);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCBottomAppBarColorThemer\")]\n    interface BottomAppBarColorThemer\n    {\n        [Static]\n        [Export(\"applySurfaceVariantWithSemanticColorScheme:toBottomAppBarView:\")]\n        void ApplySurfaceVariant(IColorScheming colorScheme, BottomAppBarView bottomAppBarView);\n\n        [Wrap(\"ApplySurfaceVariant (colorScheme, bottomAppBarView)\")]\n        [Obsolete(\"Use ApplySurfaceVariant instead.\")]\n        [Static]\n        void ApplySurfaceVariantWithSemanticColorScheme(IColorScheming colorScheme, BottomAppBarView bottomAppBarView);\n\n        [Obsolete(\"This method will soon be deprecated. Use ApplySurfaceVariantWithSemanticColorScheme instead.\")]\n        [Static]\n        [Export(\"applyColorScheme:toBottomAppBarView:\")]\n        void ApplyColorScheme(IColorScheme colorScheme, BottomAppBarView bottomAppBarView);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCBottomNavigationBar\",\n        Delegates = new[] { \"Delegate\" },\n        Events = new[] { typeof(BottomNavigationBarDelegate) })]\n    interface BottomNavigationBar : IElevatable, IElevationOverriding\n\n    {\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        IBottomNavigationBarDelegate Delegate { get; set; }\n\n        [Export(\"titleVisibility\", ArgumentSemantic.Assign)]\n        BottomNavigationBarTitleVisibility TitleVisibility { get; set; }\n\n        [Export(\"alignment\", ArgumentSemantic.Assign)]\n        BottomNavigationBarAlignment Alignment { get; set; }\n\n        [Export(\"items\", ArgumentSemantic.Copy)]\n        UITabBarItem[] Items { get; set; }\n\n        [NullAllowed]\n        [Export(\"selectedItem\", ArgumentSemantic.Weak)]\n        UITabBarItem SelectedItem { get; set; }\n\n        [Export(\"itemTitleFont\", ArgumentSemantic.Strong)]\n        UIFont ItemTitleFont { get; set; }\n\n        [Export(\"selectedItemTintColor\", ArgumentSemantic.Strong)]\n        UIColor SelectedItemTintColor { get; set; }\n\n        [Export(\"selectedItemTitleColor\", ArgumentSemantic.Strong)]\n        UIColor SelectedItemTitleColor { get; set; }\n\n        [Export(\"unselectedItemTintColor\", ArgumentSemantic.Strong)]\n        UIColor UnselectedItemTintColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"barTintColor\", ArgumentSemantic.Strong)]\n        UIColor BarTintColor { get; set; }\n\n        [New]\n        [NullAllowed]\n        [Export(\"backgroundColor\", ArgumentSemantic.Copy)]\n        UIColor BackgroundColor { get; set; }\n\n        [Export(\"backgroundBlurEffectStyle\", ArgumentSemantic.Assign)]\n        UIBlurEffectStyle BackgroundBlurEffectStyle { get; set; }\n\n        [Export(\"backgroundBlurEnabled\")]\n        bool BackgroundBlurEnabled { [Bind(\"isBackgroundBlurEnabled\")] get; set; }\n\n        [Export(\"itemsContentVerticalMargin\")]\n        nfloat ItemsContentVerticalMargin { get; set; }\n\n        [Export(\"itemsContentHorizontalMargin\")]\n        nfloat ItemsContentHorizontalMargin { get; set; }\n\n        [iOS(9, 0)]\n        [Export(\"barItemsBottomAnchor\")]\n        NSLayoutYAxisAnchor BarItemsBottomAnchor { get; }\n\n        [Export(\"truncatesLongTitles\")]\n        bool TruncatesLongTitles { get; set; }\n\n        [Export(\"elevation\")]\n        nfloat Elevation { get; set; }\n\n        [Export(\"shadowColor\", ArgumentSemantic.Copy)]\n        UIColor ShadowColor { get; set; }\n\n        [Export(\"titlesNumberOfLines\")]\n        nint TitlesNumberOfLines { get; set; }\n\n        [Export(\"enableRippleBehavior\")]\n        bool EnableRippleBehavior { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<BottomNavigationBar, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [return: NullAllowed]\n        [Export(\"viewForItem:\")]\n        UIView GetView(UITabBarItem item);\n\n        [Export(\"sizeThatFitsIncludesSafeArea\")]\n        [Static]\n        bool SizeThatFitsIncludesSafeArea { get; set; }\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCBottomNavigationBarDelegate\")]\n    interface BottomNavigationBarDelegate : IUINavigationBarDelegate\n\n    {\n        [DefaultValue(true)]\n        [DelegateName(\"BottomNavigationBarShouldSelectItem\")]\n        [Export(\"bottomNavigationBar:shouldSelectItem:\")]\n        bool ShouldSelectItem(BottomNavigationBar bottomNavigationBar, UITabBarItem item);\n\n        [EventArgs(\"BottomNavigationBarItemSelected\")]\n        [EventName(\"ItemSelected\")]\n        [Export(\"bottomNavigationBar:didSelectItem:\")]\n        void DidSelectItem(BottomNavigationBar bottomNavigationBar, UITabBarItem item);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCBottomNavigationBarColorThemer\")]\n    interface BottomNavigationBarColorThemer\n    {\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toBottomNavigation:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, BottomNavigationBar bottomNavigation);\n\n        [Obsolete(\"This method will soon be deprecated. Consider using ApplySemanticColorScheme method instead.\")]\n        [Static]\n        [Export(\"applyColorScheme:toBottomNavigationBar:\")]\n        void ApplyColorScheme(IColorScheme colorScheme, BottomNavigationBar bottomNavigationBar);\n    }\n\n    [Category]\n    [BaseType(typeof(BottomNavigationBar),\n        Name = \"MDCBottomNavigationBar_MaterialTheming\")]\n    interface BottomNavigationBar_MaterialTheming\n    {\n        [Export(\"applyPrimaryThemeWithScheme:\")]\n        void ApplyPrimaryThemeWithScheme(IContainerScheming scheme);\n\n        [Export(\"applySurfaceThemeWithScheme:\")]\n        void ApplySurfaceThemeWithScheme(IContainerScheming scheme);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCBottomNavigationBarTypographyThemer\")]\n    interface BottomNavigationBarTypographyThemer\n    {\n        [Static]\n        [Export(\"applyTypographyScheme:toBottomNavigationBar:\")]\n        void ApplyTypographyScheme (ITypographyScheming typographyScheme, BottomNavigationBar bottomNavigationBar);\n    }\n\n    [BaseType(typeof(CornerTreatment),\n        Name = \"MDCCurvedCornerTreatment\")]\n    interface CurvedCornerTreatment\n    {\n        [Export(\"size\", ArgumentSemantic.Assign)]\n        CGSize Size { get; set; }\n\n        [DesignatedInitializer]\n        [Export(\"initWithSize:\")]\n        IntPtr Constructor(CGSize size);\n    }\n\n    [BaseType(typeof(CornerTreatment),\n        Name = \"MDCCutCornerTreatment\")]\n    interface CutCornerTreatment\n    {\n        [Export(\"cut\")]\n        nfloat Cut { get; set; }\n\n        [DesignatedInitializer]\n        [Export(\"initWithCut:\")]\n        IntPtr Constructor(nfloat cut);\n    }\n\n    [BaseType(typeof(CornerTreatment),\n        Name = \"MDCRoundedCornerTreatment\")]\n    interface RoundedCornerTreatment\n    {\n        [Export(\"radius\")]\n        nfloat Radius { get; set; }\n\n        [DesignatedInitializer]\n        [Export(\"initWithRadius:\")]\n        IntPtr Constructor(nfloat radius);\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCCurvedRectShapeGenerator\")]\n    interface CurvedRectShapeGenerator : ShapeGenerating\n\n    {\n        [Export(\"cornerSize\", ArgumentSemantic.Assign)]\n        CGSize CornerSize { get; set; }\n\n        [DesignatedInitializer]\n        [Export(\"initWithCornerSize:\")]\n        IntPtr Constructor(CGSize cornerSize);\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCPillShapeGenerator\")]\n    interface PillShapeGenerator : ShapeGenerating\n\n    { }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCSlantedRectShapeGenerator\")]\n    interface SlantedRectShapeGenerator : ShapeGenerating\n\n    {\n        [Export(\"slant\")]\n        nfloat Slant { get; set; }\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(EdgeTreatment),\n        Name = \"MDCTriangleEdgeTreatment\")]\n    interface TriangleEdgeTreatment\n    {\n        [Export(\"size\")]\n        nfloat Size { get; set; }\n\n        [Export(\"style\", ArgumentSemantic.Assign)]\n        TriangleEdgeStyle Style { get; set; }\n\n        [DesignatedInitializer]\n        [Export(\"initWithSize:style:\")]\n        IntPtr Constructor(nfloat size, TriangleEdgeStyle style);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCBottomSheetControllerShapeThemer\")]\n    interface BottomSheetControllerShapeThemer\n    {\n        [Static]\n        [Export(\"applyShapeScheme:toBottomSheetController:\")]\n        void ApplyShapeScheme(IShapeScheming shapeScheme, BottomSheetController bottomSheetController);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCButtonBar\",\n        Delegates = new[] { \"Delegate\" },\n        Events = new[] { typeof(ButtonBarDelegate) })]\n    interface ButtonBar\n    {\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        IButtonBarDelegate Delegate { get; set; }\n\n        [NullAllowed]\n        [Export(\"items\", ArgumentSemantic.Copy)]\n        UIBarButtonItem[] Items { get; set; }\n\n        [Export(\"buttonTitleBaseline\")]\n        nfloat ButtonTitleBaseline { get; set; }\n\n        [Export(\"uppercasesButtonTitles\")]\n        bool UppercasesButtonTitles { get; set; }\n\n        [Export(\"layoutPosition\", ArgumentSemantic.Assign)]\n        ButtonBarLayoutPosition LayoutPosition { get; set; }\n\n        [NullAllowed]\n        [Export(\"rippleColor\", ArgumentSemantic.Strong)]\n        UIColor RippleColor { get; set; }\n\n        [Export(\"enableRippleBehavior\")]\n        bool EnableRippleBehavior { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<ButtonBar, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"rectForItem:inCoordinateSpace:\")]\n        CGRect RectForItem(UIBarButtonItem item, UICoordinateSpace coordinateSpace);\n\n        [Export(\"setButtonsTitleFont:forState:\")]\n        void SetButtonsTitleFont([NullAllowed] UIFont font, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"buttonsTitleFontForState:\")]\n        UIFont GetButtonsTitleFont(UIControlState state);\n\n        [Export(\"setButtonsTitleColor:forState:\")]\n        void SetButtonsTitleColor([NullAllowed] UIColor color, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"buttonsTitleColorForState:\")]\n        UIColor GetButtonsTitleColor(UIControlState state);\n\n        [New]\n        [Export(\"sizeThatFits:\")]\n        CGSize SizeThatFits(CGSize size);\n\n        [NullAllowed]\n        [Export(\"inkColor\", ArgumentSemantic.Strong)]\n        UIColor InkColor { get; set; }\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCButtonBarDelegate\")]\n    interface ButtonBarDelegate\n    {\n        [EventArgs(\"ButtonBarDidInvalidateIntrinsicContentSize\")]\n        [EventName(\"IntrinsicContentSizeInvalidated\")]\n        [Export(\"buttonBarDidInvalidateIntrinsicContentSize:\")]\n        void DidInvalidateIntrinsicContentSize(ButtonBar buttonBar);\n\n        [DefaultValue(null)]\n        [DelegateName(\"ButtonBarViewForItem\")]\n        [Abstract]\n        [Export(\"buttonBar:viewForItem:layoutHints:\")]\n        UIView ViewForItem(ButtonBar buttonBar, UIBarButtonItem barButtonItem, BarButtonItemLayoutHints layoutHints);\n    }\n\n    [BaseType(typeof(FlatButton),\n        Name = \"MDCButtonBarButton\")]\n    interface ButtonBarButton\n    {\n        [New]\n        [Export(\"setTitleFont:forState:\")]\n        void SetTitleFont([NullAllowed] UIFont font, UIControlState state);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCButtonBarColorThemer\")]\n    interface ButtonBarColorThemer\n    {\n        [Static]\n        [Export(\"applyColorScheme:toButtonBar:\")]\n        void ApplyColorScheme(IColorScheme colorScheme, ButtonBar buttonBar);\n\n        [Static]\n        [Export(\"applySemanticColorScheme:toButtonBar:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, ButtonBar buttonBar);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCButtonBarTypographyThemer\")]\n    interface ButtonBarTypographyThemer\n    {\n        [Static]\n        [Export(\"applyTypographyScheme:toButtonBar:\")]\n        void ApplyTypographyScheme(ITypographyScheming typographyScheme, ButtonBar buttonBar);\n    }\n\n    [Protocol(Name = \"MDCButtonScheming\")]\n    [BaseType(typeof(NSObject))]\n    interface ButtonScheming\n    {\n        [Abstract]\n        [Export(\"colorScheme\")]\n        ColorScheming ColorScheme { get; }\n\n        [Abstract]\n        [Export(\"shapeScheme\")]\n        ShapeScheming ShapeScheme { get; }\n\n        [Abstract]\n        [Export(\"typographyScheme\")]\n        TypographyScheming TypographyScheme { get; }\n\n        [Abstract]\n        [Export(\"cornerRadius\")]\n        nfloat CornerRadius { get; }\n\n        [Abstract]\n        [Export(\"minimumHeight\")]\n        nfloat MinimumHeight { get; }\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCButtonScheme\")]\n    interface ButtonScheme : ButtonScheming\n\n    {\n        [Export(\"colorScheme\", ArgumentSemantic.Assign)]\n        ColorScheming ColorScheme { get; set; }\n\n        [Export(\"shapeScheme\", ArgumentSemantic.Assign)]\n        ShapeScheming ShapeScheme { get; set; }\n\n        [Export(\"typographyScheme\", ArgumentSemantic.Assign)]\n        TypographyScheming TypographyScheme { get; set; }\n\n        [Export(\"cornerRadius\")]\n        nfloat CornerRadius { get; set; }\n\n        [Export(\"minimumHeight\")]\n        nfloat MinimumHeight { get; set; }\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCContainedButtonThemer\")]\n    interface ContainedButtonThemer\n    {\n        [Static]\n        [Export(\"applyScheme:toButton:\")]\n        void ApplyScheme(ButtonScheming scheme, Button button);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCFloatingActionButtonThemer\")]\n    interface FloatingActionButtonThemer\n    {\n        [Static]\n        [Export(\"applyScheme:toButton:\")]\n        void ApplyScheme(ButtonScheming scheme, FloatingButton button);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCOutlinedButtonThemer\")]\n    interface OutlinedButtonThemer\n    {\n        [Static]\n        [Export(\"applyScheme:toButton:\")]\n        void ApplyScheme(ButtonScheming scheme, Button button);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTextButtonThemer\")]\n    interface TextButtonThemer\n    {\n        [Static]\n        [Export(\"applyScheme:toButton:\")]\n        void ApplyScheme(ButtonScheming scheme, Button button);\n    }\n\n    [Obsolete(\"This class will soon be deprecated. Please consider using one of the more specific ButtonColorThemer classes instead.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCButtonColorThemer\")]\n    interface ButtonColorThemer\n    {\n        [Static]\n        [Export(\"applySemanticColorScheme:toButton:\")]\n        void ApplySemanticColorSchemeToButton(IColorScheming colorScheme, Button button);\n\n        [Static]\n        [Export(\"applySemanticColorScheme:toFlatButton:\")]\n        void ApplySemanticColorSchemeToFlatButton(IColorScheming colorScheme, Button flatButton);\n\n        [Static]\n        [Export(\"applySemanticColorScheme:toRaisedButton:\")]\n        void ApplySemanticColorSchemeToRaisedButton(IColorScheming colorScheme, Button raisedButton);\n\n        [Static]\n        [Export(\"applySemanticColorScheme:toFloatingButton:\")]\n        void ApplySemanticColorSchemeToFloatingButton(IColorScheming colorScheme, FloatingButton floatingButton);\n\n        [Static]\n        [Export(\"applyColorScheme:toButton:\")]\n        void ApplyColorScheme(IColorScheme colorScheme, Button button);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCContainedButtonColorThemer\")]\n    interface ContainedButtonColorThemer\n    {\n        [Static]\n        [Export(\"applySemanticColorScheme:toButton:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, Button button);\n    }\n\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCFloatingButtonColorThemer\")]\n    interface FloatingButtonColorThemer\n    {\n        [Static]\n        [Export(\"applySemanticColorScheme:toButton:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, FloatingButton button);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCOutlinedButtonColorThemer\")]\n    interface OutlinedButtonColorThemer\n    {\n        [Static]\n        [Export(\"applySemanticColorScheme:toButton:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, Button button);\n    }\n\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTextButtonColorThemer\")]\n    interface TextButtonColorThemer\n    {\n        [Static]\n        [Export(\"applySemanticColorScheme:toButton:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, Button button);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCButtonShapeThemer\")]\n    interface ButtonShapeThemer\n    {\n        [Static]\n        [Export(\"applyShapeScheme:toButton:\")]\n        void ApplyShapeScheme(IShapeScheming shapeScheme, Button button);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCFloatingButtonShapeThemer\")]\n    interface FloatingButtonShapeThemer\n    {\n        [Static]\n        [Export(\"applyShapeScheme:toButton:\")]\n        void ApplyShapeScheme (IShapeScheming shapeScheme, FloatingButton button);\n    }\n\n\n    [Category]\n    [BaseType(typeof(Button),\n        Name = \"MDCButton_MaterialTheming\")]\n    interface Button_MaterialTheming\n    {\n        [Export(\"applyContainedThemeWithScheme:\")]\n        void ApplyContainedThemeWithScheme(IContainerScheming scheme);\n\n        [Export(\"applyOutlinedThemeWithScheme:\")]\n        void ApplyOutlinedThemeWithScheme(IContainerScheming scheme);\n\n        [Export(\"applyTextThemeWithScheme:\")]\n        void ApplyTextThemeWithScheme(IContainerScheming scheme);\n    }\n\n    [Category]\n    [BaseType(typeof(FloatingButton),\n        Name = \"MDCFloatingButton_MaterialTheming\")]\n    interface FloatingButton_MaterialTheming\n    {\n        [Export(\"applySecondaryThemeWithScheme:\")]\n        void ApplySecondaryThemeWithScheme(IContainerScheming scheme);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCButtonTitleColorAccessibilityMutator\")]\n    interface ButtonTitleColorAccessibilityMutator\n    {\n        [Static]\n        [Export(\"changeTitleColorOfButton:\")]\n        void ChangeTitleColor(Button button);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCButtonTypographyThemer\")]\n    interface ButtonTypographyThemer\n    {\n        [Static]\n        [Export(\"applyTypographyScheme:toButton:\")]\n        void ApplyTypographyScheme(ITypographyScheming typographyScheme, Button button);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCRippleView\")]\n    interface RippleView\n    {\n        [Wrap(\"WeakRippleViewDelegate\")]\n        [NullAllowed]\n        IRippleViewDelegate RippleViewDelegate { get; set; }\n\n        [NullAllowed]\n        [Export(\"rippleViewDelegate\", ArgumentSemantic.Weak)]\n        NSObject WeakRippleViewDelegate { get; set; }\n\n        [Export(\"rippleStyle\", ArgumentSemantic.Assign)]\n        RippleStyle RippleStyle { get; set; }\n\n        [Export(\"rippleColor\", ArgumentSemantic.Strong)]\n        UIColor RippleColor { get; set; }\n\n        [Export(\"maximumRadius\")]\n        nfloat MaximumRadius { get; set; }\n\n        [Export(\"activeRippleColor\", ArgumentSemantic.Strong)]\n        UIColor ActiveRippleColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<RippleView, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"cancelAllRipplesAnimated:completion:\")]\n        void CancelAllRipplesAnimated(bool animated, [NullAllowed]  RippleCompletionBlock completion);\n\n        [Export(\"fadeInRippleAnimated:completion:\")]\n        void FadeInRippleAnimated(bool animated, [NullAllowed]  RippleCompletionBlock completion);\n\n        [Export(\"fadeOutRippleAnimated:completion:\")]\n        void FadeOutRippleAnimated(bool animated, [NullAllowed]  RippleCompletionBlock completion);\n\n        [Export(\"beginRippleTouchDownAtPoint:animated:completion:\")]\n        void BeginRippleTouchDownAtPoint(CGPoint point, bool animated, [NullAllowed]  RippleCompletionBlock completion);\n\n        [Export(\"beginRippleTouchUpAnimated:completion:\")]\n        void BeginRippleTouchUpAnimated(bool animated, [NullAllowed]  RippleCompletionBlock completion);\n    }\n\n    [Protocol(Name = \"MDCRippleViewDelegate\")]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject))]\n    interface RippleViewDelegate\n    {\n        [Export(\"rippleTouchDownAnimationDidBegin:\")]\n        void RippleTouchDownAnimationDidBegin(RippleView rippleView);\n\n        [Export(\"rippleTouchDownAnimationDidEnd:\")]\n        void RippleTouchDownAnimationDidEnd(RippleView rippleView);\n\n        [Export(\"rippleTouchUpAnimationDidBegin:\")]\n        void RippleTouchUpAnimationDidBegin(RippleView rippleView);\n\n        [Export(\"rippleTouchUpAnimationDidEnd:\")]\n        void RippleTouchUpAnimationDidEnd(RippleView rippleView);\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCRippleTouchController\")]\n    interface RippleTouchController : IUIGestureRecognizerDelegate\n\n    {\n        [NullAllowed]\n        [Export(\"view\", ArgumentSemantic.Weak)]\n        UIView View { get; }\n\n        [Export(\"rippleView\", ArgumentSemantic.Strong)]\n        RippleView RippleView { get; }\n\n        [Wrap(\"WeakDelegate\")]\n        [NullAllowed]\n        IRippleTouchControllerDelegate Delegate { get; set; }\n\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        NSObject WeakDelegate { get; set; }\n\n        [Export(\"gestureRecognizer\", ArgumentSemantic.Strong)]\n        UILongPressGestureRecognizer GestureRecognizer { get; }\n\n        [Export(\"shouldProcessRippleWithScrollViewGestures\")]\n        bool ShouldProcessRippleWithScrollViewGestures { get; set; }\n\n        [Export(\"initWithView:\")]\n        IntPtr Constructor(UIView view);\n\n        [Export(\"addRippleToView:\")]\n        void AddRippleToView(UIView view);\n    }\n\n    [Protocol(Name = \"MDCRippleTouchControllerDelegate\")]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject))]\n    interface RippleTouchControllerDelegate\n    {\n        [Export(\"rippleTouchController:shouldProcessRippleTouchesAtTouchLocation:\")]\n        bool RippleTouchController(RippleTouchController rippleTouchController, CGPoint location);\n\n        [Export(\"rippleTouchController:didProcessRippleView:atTouchLocation:\")]\n        void RippleTouchController(RippleTouchController rippleTouchController, RippleView rippleView, CGPoint location);\n\n        [Export(\"rippleTouchController:insertRippleView:intoView:\")]\n        void RippleTouchController(RippleTouchController rippleTouchController, RippleView rippleView, UIView view);\n    }\n\n    [BaseType(typeof(RippleView),\n        Name = \"MDCStatefulRippleView\")]\n    interface StatefulRippleView\n    {\n        [Export(\"selected\")]\n        bool Selected { [Bind(\"isSelected\")] get; set; }\n\n        [Export(\"rippleHighlighted\")]\n        bool RippleHighlighted { [Bind(\"isRippleHighlighted\")] get; set; }\n\n        [Export(\"dragged\")]\n        bool Dragged { [Bind(\"isDragged\")] get; set; }\n\n        [Export(\"allowsSelection\")]\n        bool AllowsSelection { get; set; }\n\n        [Export(\"setRippleColor:forState:\")]\n        void SetRippleColor([NullAllowed] UIColor rippleColor, RippleState state);\n\n        [return: NullAllowed]\n        [Export(\"rippleColorForState:\")]\n        UIColor RippleColorForState(RippleState state);\n\n        [Export(\"touchesBegan:withEvent:\")]\n        void TouchesBegan([NullAllowed] NSSet<UITouch> touches, [NullAllowed]  UIEvent @event);\n\n        [Export(\"touchesMoved:withEvent:\")]\n        void TouchesMoved([NullAllowed] NSSet<UITouch> touches, [NullAllowed]  UIEvent @event);\n\n        [Export(\"touchesEnded:withEvent:\")]\n        void TouchesEnded([NullAllowed] NSSet<UITouch> touches, [NullAllowed]  UIEvent @event);\n\n        [Export(\"touchesCancelled:withEvent:\")]\n        void TouchesCancelled([NullAllowed] NSSet<UITouch> touches, [NullAllowed]  UIEvent @event);\n    }\n\n    [BaseType(typeof(UIControl),\n        Name = \"MDCCard\")]\n    interface Card : IElevatable, IElevationOverriding\n\n    {\n        [Export(\"cornerRadius\")]\n        nfloat CornerRadius { get; set; }\n\n        [Export(\"inkView\", ArgumentSemantic.Strong)]\n        InkView InkView { get; }\n\n        [Export(\"rippleView\", ArgumentSemantic.Strong)]\n        StatefulRippleView RippleView { get; }\n\n        [Export(\"interactable\")]\n        bool Interactable { [Bind(\"isInteractable\")] get; set; }\n\n        [Export(\"enableRippleBehavior\")]\n        bool EnableRippleBehavior { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<Card, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [NullAllowed]\n        [Export(\"shapeGenerator\", ArgumentSemantic.Strong)]\n        IShapeGenerating ShapeGenerator { get; set; }\n\n        [Export(\"setShadowElevation:forState:\")]\n        void SetShadowElevation(nfloat shadowElevation, UIControlState state);\n\n        [Export(\"shadowElevationForState:\")]\n        nfloat GetShadowElevation(UIControlState state);\n\n        [Export(\"setBorderWidth:forState:\")]\n        void SetBorderWidth(nfloat borderWidth, UIControlState state);\n\n        [Export(\"borderWidthForState:\")]\n        nfloat GetBorderWidth(UIControlState state);\n\n        [Export(\"setBorderColor:forState:\")]\n        void SetBorderColor([NullAllowed] UIColor borderColor, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"borderColorForState:\")]\n        UIColor GetBorderColorForState(UIControlState state);\n\n        [Export(\"setShadowColor:forState:\")]\n        void SetShadowColor([NullAllowed] UIColor shadowColor, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"shadowColorForState:\")]\n        UIColor GetShadowColor(UIControlState state);\n\n        [Wrap(\"SetShadowElevation ((nfloat)shadowElevation, state)\")]\n        void SetShadowElevation(double shadowElevation, UIControlState state);\n    }\n\n    [BaseType(typeof(UICollectionViewCell),\n        Name = \"MDCCardCollectionCell\")]\n    interface CardCollectionCell : IElevatable, IElevationOverriding\n\n    {\n        [Export(\"selectable\")]\n        bool Selectable { [Bind(\"isSelectable\")] get; set; }\n\n        [Export(\"dragged\")]\n        bool Dragged { [Bind(\"isDragged\")] get; set; }\n\n        [Export(\"cornerRadius\")]\n        nfloat CornerRadius { get; set; }\n\n        [Export(\"inkView\", ArgumentSemantic.Strong)]\n        InkView InkView { get; }\n\n        [Export(\"rippleView\", ArgumentSemantic.Strong)]\n        StatefulRippleView RippleView { get; }\n\n        [Export(\"interactable\")]\n        bool Interactable { [Bind(\"isInteractable\")] get; set; }\n\n        [NullAllowed]\n        [Export(\"shapeGenerator\", ArgumentSemantic.Strong)]\n        IShapeGenerating ShapeGenerator { get; set; }\n\n        [Export(\"enableRippleBehavior\")]\n        bool EnableRippleBehavior { get; set; }\n\n        [Export(\"state\")]\n        CardCellState State { get; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<CardCollectionCell, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"setShadowElevation:forState:\")]\n        void SetShadowElevation(nfloat shadowElevation, CardCellState state);\n\n        [Export(\"shadowElevationForState:\")]\n        nfloat GetShadowElevation(CardCellState state);\n\n        [Export(\"setBorderWidth:forState:\")]\n        void SetBorderWidth(nfloat borderWidth, CardCellState state);\n\n        [Export(\"borderWidthForState:\")]\n        nfloat GetBorderWidth(CardCellState state);\n\n        [Export(\"setBorderColor:forState:\")]\n        void SetBorderColor([NullAllowed] UIColor borderColor, CardCellState state);\n\n        [return: NullAllowed]\n        [Export(\"borderColorForState:\")]\n        UIColor GetBorderColor(CardCellState state);\n\n        [Export(\"setShadowColor:forState:\")]\n        void SetShadowColor([NullAllowed] UIColor shadowColor, CardCellState state);\n\n        [return: NullAllowed]\n        [Export(\"shadowColorForState:\")]\n        UIColor GetShadowColor(CardCellState state);\n\n        [return: NullAllowed]\n        [Export(\"imageForState:\")]\n        UIImage GetImage(CardCellState state);\n\n        [Export(\"setImage:forState:\")]\n        void SetImage([NullAllowed] UIImage image, CardCellState state);\n\n        [Export(\"horizontalImageAlignmentForState:\")]\n        CardCellHorizontalImageAlignment GetHorizontalImageAlignment(CardCellState state);\n\n        [Export(\"setHorizontalImageAlignment:forState:\")]\n        void SetHorizontalImageAlignment(CardCellHorizontalImageAlignment horizontalImageAlignment, CardCellState state);\n\n        [Export(\"verticalImageAlignmentForState:\")]\n        CardCellVerticalImageAlignment GetVerticalImageAlignment(CardCellState state);\n\n        [Export(\"setVerticalImageAlignment:forState:\")]\n        void SetVerticalImageAlignment(CardCellVerticalImageAlignment verticalImageAlignment, CardCellState state);\n\n        [return: NullAllowed]\n        [Export(\"imageTintColorForState:\")]\n        UIColor GetImageTintColor(CardCellState state);\n\n        [Export(\"setImageTintColor:forState:\")]\n        void SetImageTintColor([NullAllowed] UIColor imageTintColor, CardCellState state);\n\n        [Wrap(\"SetShadowElevation ((nfloat)shadowElevation, state)\")]\n        void SetShadowElevation(double shadowElevation, CardCellState state);\n    }\n\n    [Category]\n    [BaseType(typeof(UICollectionViewController))]\n    interface UICollectionViewController_MDCCardReordering\n    {\n        [Export(\"mdc_setupCardReordering\")]\n        void SetupCardReordering();\n\n        [Wrap(\"SetupCardReordering(This)\")]\n        void MdcSetupCardReordering();\n    }\n\n    [Protocol(Name = \"MDCCardScheming\")]\n    [BaseType(typeof(NSObject))]\n    interface CardScheming\n    {\n        [Abstract]\n        [Export(\"colorScheme\")]\n        IColorScheming ColorScheme { get; }\n\n        [Abstract]\n        [Export(\"shapeScheme\")]\n        IShapeScheming ShapeScheme { get; }\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCCardScheme\")]\n    interface CardScheme : CardScheming\n\n    {\n        [Export(\"colorScheme\", ArgumentSemantic.Assign)]\n        IColorScheming ColorScheme { get; set; }\n\n        [Export(\"shapeScheme\", ArgumentSemantic.Assign)]\n        IShapeScheming ShapeScheme { get; set; }\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCCardThemer\")]\n    interface CardThemer\n    {\n        [Static]\n        [Export(\"applyScheme:toCard:\")]\n        void ApplyScheme(CardScheming scheme, Card card);\n\n        [Static]\n        [Export(\"applyScheme:toCardCell:\")]\n        void ApplyScheme(CardScheming scheme, CardCollectionCell cardCell);\n\n        [Static]\n        [Export(\"applyOutlinedVariantWithScheme:toCard:\")]\n        void ApplyOutlinedVariant(CardScheming scheme, Card card);\n\n        [Static]\n        [Export(\"applyOutlinedVariantWithScheme:toCardCell:\")]\n        void ApplyOutlinedVariantWithScheme(CardScheming scheme, CardCollectionCell cardCell);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCCardsColorThemer\")]\n    interface CardsColorThemer\n    {\n        [Static]\n        [Export(\"applySemanticColorScheme:toCard:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, Card card);\n\n        [Static]\n        [Export(\"applySemanticColorScheme:toCardCell:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, CardCollectionCell cardCell);\n\n        [Static]\n        [Export(\"applyOutlinedVariantWithColorScheme:toCard:\")]\n        void ApplyOutlinedVariant(IColorScheming colorScheme, Card card);\n\n        [Static]\n        [Export(\"applyOutlinedVariantWithColorScheme:toCardCell:\")]\n        void ApplyOutlinedVariant(IColorScheming colorScheme, CardCollectionCell cardCell);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCCardsShapeThemer\")]\n    interface CardsShapeThemer\n    {\n        [Static]\n        [Export(\"applyShapeScheme:toCard:\")]\n        void ApplyShapeScheme(IShapeScheming shapeScheme, Card card);\n\n        [Static]\n        [Export(\"applyShapeScheme:toCardCell:\")]\n        void ApplyShapeScheme(IShapeScheming shapeScheme, CardCollectionCell cardCell);\n    }\n\n    [Category]\n    [BaseType(typeof(Card),\n        Name = \"MDCCard_MaterialTheming\")]\n    interface Card_MaterialTheming\n    {\n        [Export(\"applyThemeWithScheme:\")]\n        void ApplyTheme(IContainerScheming scheme);\n\n        [Export(\"applyOutlinedThemeWithScheme:\")]\n        void ApplyOutlinedThemeWithScheme(IContainerScheming scheme);\n    }\n\n    [Category]\n    [BaseType(typeof(CardCollectionCell),\n        Name = \"MDCCardCollectionCell_MaterialTheming\")]\n    interface CardCollectionCell_MaterialTheming\n    {\n        [Export(\"applyThemeWithScheme:\")]\n        void ApplyTheme(IContainerScheming scheme);\n\n        [Export(\"applyOutlinedThemeWithScheme:\")]\n        void ApplyOutlinedThemeWithScheme(IContainerScheming scheme);\n    }\n\n    [BaseType(typeof(UICollectionViewCell),\n        Name = \"MDCChipCollectionViewCell\")]\n    interface ChipCollectionViewCell\n    {\n        [Export(\"chipView\", ArgumentSemantic.Strong)]\n        ChipView ChipView { get; }\n\n        [Export(\"alwaysAnimateResize\")]\n        bool AlwaysAnimateResize { get; set; }\n\n        [Export(\"createChipView\")]\n        ChipView CreateChipView();\n    }\n\n    [BaseType(typeof(UICollectionViewFlowLayout),\n        Name = \"MDCChipCollectionViewFlowLayout\")]\n    interface ChipCollectionViewFlowLayout\n    { }\n\n    [BaseType(typeof(UIControl),\n        Name = \"MDCChipView\")]\n    interface ChipView : IElevatable, IElevationOverriding\n\n    {\n        [Export(\"imageView\")]\n        UIImageView ImageView { get; }\n\n        [Export(\"selectedImageView\")]\n        UIImageView SelectedImageView { get; }\n\n        [NullAllowed]\n        [Export(\"accessoryView\", ArgumentSemantic.Strong)]\n        UIView AccessoryView { get; set; }\n\n        [Export(\"titleLabel\")]\n        UILabel TitleLabel { get; }\n\n        [Export(\"contentPadding\", ArgumentSemantic.Assign)]\n        UIEdgeInsets ContentPadding { get; set; }\n\n        [Export(\"imagePadding\", ArgumentSemantic.Assign)]\n        UIEdgeInsets ImagePadding { get; set; }\n\n        [Export(\"accessoryPadding\", ArgumentSemantic.Assign)]\n        UIEdgeInsets AccessoryPadding { get; set; }\n\n        [Export(\"titlePadding\", ArgumentSemantic.Assign)]\n        UIEdgeInsets TitlePadding { get; set; }\n\n        [NullAllowed]\n        [Export(\"titleFont\", ArgumentSemantic.Strong)]\n        UIFont TitleFont { get; set; }\n\n        [Export(\"enableRippleBehavior\")]\n        bool EnableRippleBehavior { get; set; }\n\n        [Export(\"rippleAllowsSelection\")]\n        bool RippleAllowsSelection { get; set; }\n\n        [NullAllowed]\n        [Export(\"shapeGenerator\", ArgumentSemantic.Strong)]\n        IShapeGenerating ShapeGenerator { get; set; }\n\n        [Export(\"adjustsFontForContentSizeCategoryWhenScaledFontIsUnavailable\")]\n        bool AdjustsFontForContentSizeCategoryWhenScaledFontIsUnavailable { get; set; }\n\n        [Export(\"minimumSize\", ArgumentSemantic.Assign)]\n        CGSize MinimumSize { get; set; }\n\n        [Export(\"hitAreaInsets\", ArgumentSemantic.Assign)]\n        UIEdgeInsets HitAreaInsets { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<ChipView, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"mdc_adjustsFontForContentSizeCategory\")]\n        bool AdjustsFontForContentSizeCategory { get; [Bind(\"mdc_setAdjustsFontForContentSizeCategory:\")]set; }\n\n        [Obsolete(\"Use AdjustsFontForContentSizeCategory instead\")]\n        [Wrap(\"AdjustsFontForContentSizeCategory\")]\n        bool MdcAdjustsFontForContentSizeCategory { get; set; }\n\n        [return: NullAllowed]\n        [Export(\"backgroundColorForState:\")]\n        UIColor GetBackgroundColor(UIControlState state);\n\n        [Export(\"setBackgroundColor:forState:\")]\n        void SetBackgroundColor([NullAllowed] UIColor backgroundColor, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"borderColorForState:\")]\n        UIColor GetBorderColor(UIControlState state);\n\n        [Export(\"setBorderColor:forState:\")]\n        void SetBorderColor([NullAllowed] UIColor borderColor, UIControlState state);\n\n        [Export(\"borderWidthForState:\")]\n        nfloat GetBorderWidth(UIControlState state);\n\n        [Export(\"setBorderWidth:forState:\")]\n        void SetBorderWidth(nfloat borderWidth, UIControlState state);\n\n        [Export(\"elevationForState:\")]\n        nfloat GetElevation(UIControlState state);\n\n        [Export(\"setElevation:forState:\")]\n        void SetElevation(nfloat elevation, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"inkColorForState:\")]\n        UIColor GetInkColor(UIControlState state);\n\n        [Export(\"setInkColor:forState:\")]\n        void SetInkColor([NullAllowed] UIColor inkColor, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"shadowColorForState:\")]\n        UIColor GetShadowColor(UIControlState state);\n\n        [Export(\"setShadowColor:forState:\")]\n        void SetShadowColor([NullAllowed] UIColor shadowColor, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"titleColorForState:\")]\n        UIColor GetTitleColor(UIControlState state);\n\n        [Export(\"setTitleColor:forState:\")]\n        void SetTitleColor([NullAllowed] UIColor titleColor, UIControlState state);\n\n        [Wrap(\"SetElevation ((nfloat)elevation, state)\")]\n        void SetElevation(double elevation, UIControlState state);\n    }\n\n    [BaseType(typeof(UITextView),\n        Name = \"MDCIntrinsicHeightTextView\")]\n    interface IntrinsicHeightTextView\n    { }\n\n    [Protocol(Name = \"MDCTextInput\")]\n    interface TextInput\n    {\n        [Abstract]\n        [NullAllowed]\n        [Export(\"attributedPlaceholder\", ArgumentSemantic.Copy)]\n        NSAttributedString AttributedPlaceholder { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"attributedText\", ArgumentSemantic.Copy)]\n        NSAttributedString AttributedText { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"borderPath\", ArgumentSemantic.Copy)]\n        UIBezierPath BorderPath { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"borderView\", ArgumentSemantic.Strong)]\n        TextInputBorderView BorderView { get; set; }\n\n        [Abstract]\n        [Export(\"clearButton\", ArgumentSemantic.Strong)]\n        UIButton ClearButton { get; }\n\n        [Abstract]\n        [Export(\"clearButtonMode\", ArgumentSemantic.Assign)]\n        UITextFieldViewMode ClearButtonMode { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"cursorColor\", ArgumentSemantic.Strong)]\n        UIColor CursorColor { get; set; }\n\n        [Abstract]\n        [Export(\"editing\")]\n        bool Editing { [Bind(\"isEditing\")] get; }\n\n        [Abstract]\n        [Export(\"enabled\")]\n        bool Enabled { [Bind(\"isEnabled\")] get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"font\", ArgumentSemantic.Strong)]\n        UIFont Font { get; set; }\n\n        [Abstract]\n        [Export(\"hidesPlaceholderOnInput\")]\n        bool HidesPlaceholderOnInput { get; set; }\n\n        [Abstract]\n        [Export(\"leadingUnderlineLabel\", ArgumentSemantic.Strong)]\n        UILabel LeadingUnderlineLabel { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"placeholder\")]\n        string Placeholder { get; set; }\n\n        [Abstract]\n        [Export(\"placeholderLabel\", ArgumentSemantic.Strong)]\n        UILabel PlaceholderLabel { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"positioningDelegate\", ArgumentSemantic.Weak)]\n        ITextInputPositioningDelegate PositioningDelegate { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"text\")]\n        string Text { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"textColor\", ArgumentSemantic.Strong)]\n        UIColor TextColor { get; set; }\n\n        [Abstract]\n        [Export(\"textInsets\", ArgumentSemantic.Assign)]\n        UIEdgeInsets TextInsets { get; }\n\n        [Abstract]\n        [Export(\"textInsetsMode\", ArgumentSemantic.Assign)]\n        TextInputTextInsetsMode TextInsetsMode { get; set; }\n\n        [Abstract]\n        [Export(\"trailingUnderlineLabel\", ArgumentSemantic.Strong)]\n        UILabel TrailingUnderlineLabel { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"trailingView\", ArgumentSemantic.Strong)]\n        UIView TrailingView { get; set; }\n\n        [Abstract]\n        [Export(\"trailingViewMode\", ArgumentSemantic.Assign)]\n        UITextFieldViewMode TrailingViewMode { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"underline\", ArgumentSemantic.Strong)]\n        TextInputUnderlineView Underline { get; }\n\n        [Abstract]\n        [Export(\"hasTextContent\")]\n        bool HasTextContent { get; }\n\n        [Abstract]\n        [Export(\"mdc_adjustsFontForContentSizeCategory\")]\n        bool AdjustsFontForContentSizeCategory { get; [Bind(\"mdc_setAdjustsFontForContentSizeCategory:\")]set; }\n\n        [Abstract]\n        [Obsolete(\"Use AdjustsFontForContentSizeCategory instead\")]\n        [Wrap(\"AdjustsFontForContentSizeCategory\")]\n        bool MdcAdjustsFontForContentSizeCategory { get; set; }\n\n        [Abstract]\n        [Export(\"clearText\")]\n        void ClearText();\n    }\n\n    [Protocol(Name = \"MDCLeadingViewTextInput\")]\n    interface LeadingViewTextInput : TextInput\n\n    {\n        [Abstract]\n        [NullAllowed]\n        [Export(\"leadingView\", ArgumentSemantic.Strong)]\n        UIView LeadingView { get; set; }\n\n        [Abstract]\n        [Export(\"leadingViewMode\", ArgumentSemantic.Assign)]\n        UITextFieldViewMode LeadingViewMode { get; set; }\n    }\n\n    [Protocol(Name = \"MDCMultilineTextInput\")]\n    interface MultilineTextInput : TextInput\n\n    {\n        [Abstract]\n        [Export(\"expandsOnOverflow\")]\n        bool ExpandsOnOverflow { get; set; }\n\n        [Abstract]\n        [Export(\"minimumLines\")]\n        nuint MinimumLines { get; set; }\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCMultilineTextField\")]\n    interface MultilineTextField : TextInput, MultilineTextInput\n\n    {\n        [Export(\"adjustsFontForContentSizeCategory\")]\n        bool AdjustsFontForContentSizeCategory { get; set; }\n\n        [Obsolete(\"Use AdjustsFontForContentSizeCategory instead\")]\n        [Wrap(\"AdjustsFontForContentSizeCategory\")]\n        bool MdcAdjustsFontForContentSizeCategory { get; set; }\n\n        [Export(\"expandsOnOverflow\")]\n        bool ExpandsOnOverflow { get; set; }\n\n        [NullAllowed]\n        [Export(\"layoutDelegate\", ArgumentSemantic.Weak)]\n        IMultilineTextInputLayoutDelegate LayoutDelegate { get; set; }\n\n        [NullAllowed]\n        [Export(\"multilineDelegate\", ArgumentSemantic.Weak)]\n        IMultilineTextInputDelegate MultilineDelegate { get; set; }\n\n        [NullAllowed]\n        [Export(\"placeholder\")]\n        string Placeholder { get; set; }\n\n        [Export(\"textInsets\", ArgumentSemantic.Assign)]\n        UIEdgeInsets TextInsets { get; }\n\n        [NullAllowed]\n        [Export(\"textView\", ArgumentSemantic.Strong)]\n        IntrinsicHeightTextView TextView { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<MultilineTextField, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCMultilineTextInputLayoutDelegate\")]\n    interface MultilineTextInputLayoutDelegate\n    {\n        [Export(\"multilineTextField:didChangeContentSize:\")]\n        void DidChangeContentSize(IMultilineTextInput multilineTextField, CGSize size);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCMultilineTextInputDelegate\")]\n    interface MultilineTextInputDelegate\n    {\n        [Export(\"multilineTextFieldShouldClear:\")]\n        bool MultilineTextFieldShouldClear(ITextInput textField);\n    }\n\n    [BaseType(typeof(UITextField),\n        Name = \"MDCTextField\")]\n    interface TextField : TextInput, LeadingViewTextInput\n\n    {\n        [Export(\"inputLayoutStrut\", ArgumentSemantic.Strong)]\n        UILabel InputLayoutStrut { get; }\n\n        [NullAllowed]\n        [Export(\"leadingView\", ArgumentSemantic.Strong)]\n        UIView LeadingView { get; set; }\n\n        [Export(\"leadingViewMode\", ArgumentSemantic.Assign)]\n        UITextFieldViewMode LeadingViewMode { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<TextField, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Notification]\n        [Field(\"MDCTextFieldTextDidSetTextNotification\", \"__Internal\")]\n        NSString TextDidSetTextNotification { get; }\n\n        [Notification]\n        [Field(\"MDCTextInputDidToggleEnabledNotification\", \"__Internal\")]\n        NSString TextInputDidToggleEnabledNotification { get; }\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTextInputPositioningDelegate\")]\n    interface TextInputPositioningDelegate\n    {\n        [Export(\"textInsets:\")]\n        UIEdgeInsets TextInsets(UIEdgeInsets defaultInsets);\n\n        [Export(\"editingRectForBounds:defaultRect:\")]\n        CGRect GetEditingRect(CGRect bounds, CGRect defaultRect);\n\n        [Export(\"leadingViewRectForBounds:defaultRect:\")]\n        CGRect GetLeadingViewRect(CGRect bounds, CGRect defaultRect);\n\n        [Export(\"textInputDidLayoutSubviews\")]\n        void DidLayoutSubviews();\n\n        [Export(\"textInputDidUpdateConstraints\")]\n        void DidUpdateConstraints();\n\n        [Export(\"trailingViewRectForBounds:defaultRect:\")]\n        CGRect GetTrailingViewRect(CGRect bounds, CGRect defaultRect);\n\n        [Export(\"leadingViewTrailingPaddingConstant\")]\n        nfloat GetLeadingViewTrailingPaddingConstant();\n\n        [Export(\"trailingViewTrailingPaddingConstant\")]\n        nfloat GetTrailingViewTrailingPaddingConstant();\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCTextInputBorderView\")]\n    interface TextInputBorderView : INSCopying\n\n    {\n        [NullAllowed]\n        [Export(\"borderFillColor\", ArgumentSemantic.Strong)]\n        UIColor BorderFillColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"borderPath\", ArgumentSemantic.Strong)]\n        UIBezierPath BorderPath { get; set; }\n\n        [NullAllowed]\n        [Export(\"borderStrokeColor\", ArgumentSemantic.Strong)]\n        UIColor BorderStrokeColor { get; set; }\n    }\n\n    [Protocol(Name = \"MDCTextInputCharacterCounter\")]\n    [BaseType(typeof(NSObject))]\n    interface TextInputCharacterCounter\n    {\n        [Abstract]\n        [Export(\"characterCountForTextInput:\")]\n        nuint CharacterCount([NullAllowed] ITextInput textInput);\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTextInputAllCharactersCounter\")]\n    interface TextInputAllCharactersCounter : TextInputCharacterCounter\n\n    { }\n\n    [Protocol(Name = \"MDCTextInputController\")]\n    interface TextInputController : INSCopying, TextInputPositioningDelegate\n\n    {\n        [Abstract]\n        [Export(\"activeColor\", ArgumentSemantic.Strong)]\n        UIColor ActiveColor { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"activeColorDefault\", ArgumentSemantic.Strong)]\n        UIColor ActiveColorDefault { get; set; }\n\n        [Abstract]\n        [Export(\"characterCounter\", ArgumentSemantic.Weak)]\n        ITextInputCharacterCounter CharacterCounter { get; set; }\n\n        [Abstract]\n        [Export(\"characterCountMax\")]\n        nuint CharacterCountMax { get; set; }\n\n        [Abstract]\n        [Export(\"characterCountViewMode\", ArgumentSemantic.Assign)]\n        UITextFieldViewMode CharacterCountViewMode { get; set; }\n\n        [Abstract]\n        [Export(\"disabledColor\", ArgumentSemantic.Strong)]\n        UIColor DisabledColor { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"disabledColorDefault\", ArgumentSemantic.Strong)]\n        UIColor DisabledColorDefault { get; set; }\n\n        [Abstract]\n        [Export(\"errorColor\", ArgumentSemantic.Strong)]\n        UIColor ErrorColor { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"errorColorDefault\", ArgumentSemantic.Strong)]\n        UIColor ErrorColorDefault { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"errorText\")]\n        string ErrorText { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"helperText\")]\n        string HelperText { get; set; }\n\n        [Abstract]\n        [Export(\"inlinePlaceholderColor\", ArgumentSemantic.Strong)]\n        UIColor InlinePlaceholderColor { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"inlinePlaceholderColorDefault\", ArgumentSemantic.Strong)]\n        UIColor InlinePlaceholderColorDefault { get; set; }\n\n        [Abstract]\n        [Export(\"textInputFont\", ArgumentSemantic.Strong)]\n        UIFont TextInputFont { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Static]\n        [Export(\"textInputFontDefault\", ArgumentSemantic.Strong)]\n        UIFont TextInputFontDefault { get; set; }\n\n        [Abstract]\n        [Export(\"inlinePlaceholderFont\", ArgumentSemantic.Strong)]\n        UIFont InlinePlaceholderFont { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"inlinePlaceholderFontDefault\", ArgumentSemantic.Strong)]\n        UIFont InlinePlaceholderFontDefault { get; set; }\n\n        [Abstract]\n        [Export(\"leadingUnderlineLabelFont\", ArgumentSemantic.Strong)]\n        UIFont LeadingUnderlineLabelFont { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"leadingUnderlineLabelFontDefault\", ArgumentSemantic.Strong)]\n        UIFont LeadingUnderlineLabelFontDefault { get; set; }\n\n        [Abstract]\n        [Export(\"leadingUnderlineLabelTextColor\", ArgumentSemantic.Strong)]\n        UIColor LeadingUnderlineLabelTextColor { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"leadingUnderlineLabelTextColorDefault\", ArgumentSemantic.Strong)]\n        UIColor LeadingUnderlineLabelTextColorDefault { get; set; }\n\n        [Abstract]\n        [Export(\"normalColor\", ArgumentSemantic.Strong)]\n        UIColor NormalColor { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"normalColorDefault\", ArgumentSemantic.Strong)]\n        UIColor NormalColorDefault { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"placeholderText\")]\n        string PlaceholderText { get; set; }\n\n        [Abstract]\n        [Export(\"roundedCorners\", ArgumentSemantic.Assign)]\n        UIRectCorner RoundedCorners { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"roundedCornersDefault\", ArgumentSemantic.Assign)]\n        UIRectCorner RoundedCornersDefault { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"textInput\", ArgumentSemantic.Strong)]\n        ITextInput TextInput { get; set; }\n\n        [Abstract]\n        [Export(\"textInputClearButtonTintColor\", ArgumentSemantic.Strong)]\n        UIColor TextInputClearButtonTintColor { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Static]\n        [Export(\"textInputClearButtonTintColorDefault\", ArgumentSemantic.Strong)]\n        UIColor TextInputClearButtonTintColorDefault { get; set; }\n\n        [Abstract]\n        [Export(\"trailingUnderlineLabelFont\", ArgumentSemantic.Strong)]\n        UIFont TrailingUnderlineLabelFont { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"trailingUnderlineLabelFontDefault\", ArgumentSemantic.Strong)]\n        UIFont TrailingUnderlineLabelFontDefault { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"trailingUnderlineLabelTextColor\", ArgumentSemantic.Strong)]\n        UIColor TrailingUnderlineLabelTextColor { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Static]\n        [Export(\"trailingUnderlineLabelTextColorDefault\", ArgumentSemantic.Strong)]\n        UIColor TrailingUnderlineLabelTextColorDefault { get; set; }\n\n        [Abstract]\n        [Export(\"underlineHeightActive\")]\n        nfloat UnderlineHeightActive { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"underlineHeightActiveDefault\")]\n        nfloat UnderlineHeightActiveDefault { get; set; }\n\n        [Abstract]\n        [Export(\"underlineHeightNormal\")]\n        nfloat UnderlineHeightNormal { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"underlineHeightNormalDefault\")]\n        nfloat UnderlineHeightNormalDefault { get; set; }\n\n        [Abstract]\n        [Export(\"underlineViewMode\", ArgumentSemantic.Assign)]\n        UITextFieldViewMode UnderlineViewMode { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"underlineViewModeDefault\", ArgumentSemantic.Assign)]\n        UITextFieldViewMode UnderlineViewModeDefault { get; set; }\n\n        [Abstract]\n        [Export(\"mdc_adjustsFontForContentSizeCategory\")]\n        bool AdjustsFontForContentSizeCategory { get; [Bind(\"mdc_setAdjustsFontForContentSizeCategory:\")]set; }\n\n        [Obsolete(\"Use AdjustsFontForContentSizeCategory instead\")]\n        [Abstract]\n        [Wrap(\"AdjustsFontForContentSizeCategory\")]\n        bool MdcAdjustsFontForContentSizeCategory { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"mdc_adjustsFontForContentSizeCategoryDefault\")]\n        bool AdjustsFontForContentSizeCategoryDefault { get; set; }\n\n        [Obsolete(\"Use AdjustsFontForContentSizeCategoryDefault instead\")]\n        [Static]\n        [Wrap(\"AdjustsFontForContentSizeCategoryDefault\")]\n        bool MdcAdjustsFontForContentSizeCategoryDefault { get; set; }\n\n        [Abstract]\n        [Export(\"setErrorText:errorAccessibilityValue:\")]\n        void SetErrorText([NullAllowed] string errorText, [NullAllowed]  string errorAccessibilityValue);\n\n        [Abstract]\n        [Export(\"setHelperText:helperAccessibilityLabel:\")]\n        void SetHelperText([NullAllowed] string helperText, [NullAllowed]  string helperAccessibilityLabel);\n    }\n\n    [Protocol(Name = \"MDCTextInputControllerFloatingPlaceholder\")]\n    interface TextInputControllerFloatingPlaceholder : TextInputController\n\n    {\n        [Abstract]\n        [Export(\"floatingPlaceholderActiveColor\", ArgumentSemantic.Strong)]\n        UIColor FloatingPlaceholderActiveColor { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"floatingPlaceholderActiveColorDefault\", ArgumentSemantic.Strong)]\n        UIColor FloatingPlaceholderActiveColorDefault { get; set; }\n\n        [Abstract]\n        [Export(\"floatingPlaceholderNormalColor\", ArgumentSemantic.Strong)]\n        UIColor FloatingPlaceholderNormalColor { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"floatingPlaceholderNormalColorDefault\", ArgumentSemantic.Strong)]\n        UIColor FloatingPlaceholderNormalColorDefault { get; set; }\n\n        [Abstract]\n        [Export(\"floatingPlaceholderOffset\")]\n        UIOffset FloatingPlaceholderOffset { get; }\n\n        [Abstract]\n        [Export(\"floatingPlaceholderScale\", ArgumentSemantic.Strong)]\n        NSNumber FloatingPlaceholderScale { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"floatingPlaceholderScaleDefault\")]\n        nfloat FloatingPlaceholderScaleDefault { get; set; }\n\n        [Abstract]\n        [Export(\"floatingEnabled\")]\n        bool FloatingEnabled { [Bind(\"isFloatingEnabled\")] get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"floatingEnabledDefault\")]\n        bool FloatingEnabledDefault { [Bind(\"isFloatingEnabledDefault\")] get; set; }\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTextInputControllerBase\")]\n    interface TextInputControllerBase : TextInputControllerFloatingPlaceholder\n\n    {\n        [NullAllowed]\n        [Export(\"borderFillColor\", ArgumentSemantic.Strong)]\n        UIColor BorderFillColor { get; set; }\n\n        [Static]\n        [Export(\"borderFillColorDefault\", ArgumentSemantic.Strong)]\n        UIColor BorderFillColorDefault { get; set; }\n\n        [Export(\"expandsOnOverflow\")]\n        bool ExpandsOnOverflow { get; set; }\n\n        [Export(\"minimumLines\")]\n        nuint MinimumLines { get; set; }\n\n        [Field(\"MDCTextInputControllerBaseDefaultBorderRadius\", \"__Internal\")]\n        nfloat DefaultBorderRadius { get; }\n\n        [Export(\"initWithTextInput:\")]\n        IntPtr Constructor([NullAllowed] ITextInput input);\n    }\n\n    [BaseType(typeof(TextInputControllerBase),\n        Name = \"MDCTextInputControllerFilled\")]\n    interface TextInputControllerFilled\n    {\n        [Export(\"initWithTextInput:\")]\n        IntPtr Constructor([NullAllowed] ITextInput input);\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTextInputControllerFullWidth\")]\n    interface TextInputControllerFullWidth : TextInputController\n\n    {\n        [Export(\"backgroundColor\", ArgumentSemantic.Strong)]\n        UIColor BackgroundColor { get; set; }\n\n        [Static]\n        [Export(\"backgroundColorDefault\", ArgumentSemantic.Strong)]\n        UIColor BackgroundColorDefault { get; set; }\n\n        [Export(\"initWithTextInput:\")]\n        IntPtr Constructor([NullAllowed] ITextInput input);\n    }\n\n    [BaseType(typeof(TextInputControllerBase),\n        Name = \"MDCTextInputControllerLegacyDefault\")]\n    interface TextInputControllerLegacyDefault : TextInputController\n\n    {\n        [Export(\"initWithTextInput:\")]\n        IntPtr Constructor([NullAllowed] ITextInput input);\n    }\n\n    [BaseType(typeof(TextInputControllerFullWidth),\n        Name = \"MDCTextInputControllerLegacyFullWidth\")]\n    interface TextInputControllerLegacyFullWidth : TextInputController\n\n    {\n        [Export(\"initWithTextInput:\")]\n        IntPtr Constructor([NullAllowed] ITextInput input);\n    }\n\n    [BaseType(typeof(TextInputControllerBase),\n        Name = \"MDCTextInputControllerOutlined\")]\n    interface TextInputControllerOutlined\n    {\n        [Export(\"initWithTextInput:\")]\n        IntPtr Constructor([NullAllowed] ITextInput input);\n    }\n\n    [BaseType(typeof(TextInputControllerBase),\n        Name = \"MDCTextInputControllerOutlinedTextArea\")]\n    interface TextInputControllerOutlinedTextArea\n    {\n        [Export(\"initWithTextInput:\")]\n        IntPtr Constructor([NullAllowed] ITextInput input);\n    }\n\n    [BaseType(typeof(TextInputControllerBase),\n        Name = \"MDCTextInputControllerUnderline\")]\n    interface TextInputControllerUnderline\n    {\n        [Export(\"initWithTextInput:\")]\n        IntPtr Constructor([NullAllowed] ITextInput input);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCTextInputUnderlineView\")]\n    interface TextInputUnderlineView : INSCopying\n\n    {\n        [Export(\"color\", ArgumentSemantic.Strong)]\n        UIColor Color { get; set; }\n\n        [Export(\"disabledColor\", ArgumentSemantic.Strong)]\n        UIColor DisabledColor { get; set; }\n\n        [Export(\"enabled\")]\n        bool Enabled { get; set; }\n\n        [Export(\"lineHeight\")]\n        nfloat LineHeight { get; set; }\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCChipField\",\n        Delegates = new[] { \"Delegate\" },\n        Events = new[] { typeof(ChipFieldDelegate) })]\n    interface ChipField\n    {\n        [Export(\"textField\")]\n        TextField TextField { get; }\n\n        [Export(\"chipHeight\")]\n        nfloat ChipHeight { get; set; }\n\n        [Export(\"showPlaceholderWithChips\")]\n        bool ShowPlaceholderWithChips { get; set; }\n\n        [Export(\"showChipsDeleteButton\")]\n        bool ShowChipsDeleteButton { get; set; }\n\n        [Export(\"delimiter\", ArgumentSemantic.Assign)]\n        ChipFieldDelimiter Delimiter { get; set; }\n\n        [Export(\"minTextFieldWidth\")]\n        nfloat MinTextFieldWidth { get; set; }\n\n        [Export(\"chips\", ArgumentSemantic.Copy)]\n        ChipView[] Chips { get; set; }\n\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        IChipFieldDelegate Delegate { get; set; }\n\n        [Export(\"contentEdgeInsets\", ArgumentSemantic.Assign)]\n        UIEdgeInsets ContentEdgeInsets { get; set; }\n\n        [Field(\"MDCChipFieldDefaultMinTextFieldWidth\", \"__Internal\")]\n        nfloat DefaultMinTextFieldWidth { get; }\n\n        [Internal]\n        [Field(\"MDCChipFieldDefaultContentEdgeInsets\", \"__Internal\")]\n        IntPtr _DefaultContentEdgeInsets { get; }\n\n        [Export(\"addChip:\")]\n        void AddChip(ChipView chip);\n\n        [Export(\"removeChip:\")]\n        void RemoveChip(ChipView chip);\n\n        [Export(\"removeSelectedChips\")]\n        void RemoveSelectedChips();\n\n        [Export(\"clearTextInput\")]\n        void ClearTextInput();\n\n        [Export(\"selectChip:\")]\n        void SelectChip(ChipView chip);\n\n        [Export(\"deselectAllChips\")]\n        void DeselectAllChips();\n\n        [Export(\"focusTextFieldForAccessibility\")]\n        void FocusTextFieldForAccessibility();\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCChipFieldDelegate\")]\n    interface ChipFieldDelegate\n    {\n        [EventArgs(\"ChipFieldEditingStarted\")]\n        [EventName(\"EditingStarted\")]\n        [Export(\"chipFieldDidBeginEditing:\")]\n        void DidBeginEditing(ChipField chipField);\n\n        [EventArgs(\"ChipFieldEditingEnded\")]\n        [EventName(\"EditingEnded\")]\n        [Export(\"chipFieldDidEndEditing:\")]\n        void DidEndEditing(ChipField chipField);\n\n        [EventArgs(\"ChipFieldChipAdded\")]\n        [EventName(\"ChipAdded\")]\n        [Export(\"chipField:didAddChip:\")]\n        void DidAddChip(ChipField chipField, ChipView chip);\n\n        [DefaultValue(true)]\n        [DelegateName(\"ChipFieldShouldAddChip\")]\n        [Export(\"chipField:shouldAddChip:\")]\n        bool ShouldAddChip(ChipField chipField, ChipView chip);\n\n        [EventArgs(\"ChipFieldChipRemoved\")]\n        [EventName(\"ChipRemoved\")]\n        [Export(\"chipField:didRemoveChip:\")]\n        void DidRemoveChip(ChipField chipField, ChipView chip);\n\n        [EventArgs(\"ChipFieldHeightChanged\")]\n        [EventName(\"HeightChanged\")]\n        [Export(\"chipFieldHeightDidChange:\")]\n        void HeightDidChange(ChipField chipField);\n\n        [EventArgs(\"ChipFieldInputChanged\")]\n        [EventName(\"InputChanged\")]\n        [Export(\"chipField:didChangeInput:\")]\n        void DidChangeInput(ChipField chipField, [NullAllowed]  string input);\n\n        [EventArgs(\"ChipFieldChipTapped\")]\n        [EventName(\"ChipTapped\")]\n        [Export(\"chipField:didTapChip:\")]\n        void DidTapChip(ChipField chipField, ChipView chip);\n\n        [DefaultValue(true)]\n        [DelegateName(\"ChipFieldShouldReturn\")]\n        [Export(\"chipFieldShouldReturn:\")]\n        bool ShouldReturn(ChipField chipField);\n\n        [DefaultValue(true)]\n        [DelegateName(\"ChipFieldShouldBecomeFirstResponder\")]\n        [Export(\"chipFieldShouldBecomeFirstResponder:\")]\n        bool ShouldBecomeFirstResponder(ChipField chipField);\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCChipViewScheme\")]\n    interface ChipViewScheme : ChipViewScheming\n\n    {\n        [Export(\"colorScheme\", ArgumentSemantic.Assign)]\n        ColorScheming ColorScheme { get; set; }\n\n        [Export(\"shapeScheme\", ArgumentSemantic.Assign)]\n        ShapeScheming ShapeScheme { get; set; }\n\n        [Export(\"typographyScheme\", ArgumentSemantic.Assign)]\n        TypographyScheming TypographyScheme { get; set; }\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCChipViewThemer\")]\n    interface ChipViewThemer\n    {\n        [Static]\n        [Export(\"applyScheme:toChipView:\")]\n        void ApplyScheme(ChipViewScheming scheme, ChipView chip);\n\n        [Static]\n        [Export(\"applyOutlinedVariantWithScheme:toChipView:\")]\n        void ApplyOutlinedVariant(ChipViewScheming scheme, ChipView chip);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCChipViewColorThemer\")]\n    interface ChipViewColorThemer\n    {\n        [Obsolete(\"This method will soon be deprecated\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toChipView:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, ChipView chipView);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toStrokedChipView:\")]\n        void ApplySemanticColorSchemeToStrokedChipView(IColorScheming colorScheme, ChipView strokedChipView);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyOutlinedVariantWithColorScheme:toChipView:\")]\n        void ApplyOutlinedVariant(IColorScheming colorScheme, ChipView chipView);\n\n    }\n\n    [Obsolete(\"This class will soon be deprecated. Please consider using ChipViewTypographyThemer class instead.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCChipViewFontThemer\")]\n    interface ChipViewFontThemer\n    {\n        [Static]\n        [Export(\"applyFontScheme:toChipView:\")]\n        void ApplyFontScheme(IFontScheme fontScheme, ChipView chipView);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCChipViewShapeThemer\")]\n    interface ChipViewShapeThemer\n    {\n        [Static]\n        [Export(\"applyShapeScheme:toChipView:\")]\n        void ApplyShapeScheme(IShapeScheming shapeScheme, ChipView chipView);\n    }\n\n    [Category]\n    [BaseType(typeof(ChipView),\n        Name = \"MDCChipView_MaterialTheming\")]\n    interface ChipView_MaterialTheming\n    {\n        [Export(\"applyThemeWithScheme:\")]\n        void ApplyTheme(IContainerScheming scheme);\n\n        [Export(\"applyOutlinedThemeWithScheme:\")]\n        void ApplyOutlinedThemeWithScheme(IContainerScheming scheme);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCChipViewTypographyThemer\")]\n    interface ChipViewTypographyThemer\n    {\n        [Static]\n        [Export(\"applyTypographyScheme:toChipView:\")]\n        void ApplyTypographyScheme(ITypographyScheming typographyScheme, ChipView chipView);\n    }\n\n    [BaseType(typeof(UICollectionViewCell),\n        Name = \"MDCCollectionViewCell\")]\n    interface CollectionViewCell\n    {\n        [Export(\"accessoryType\", ArgumentSemantic.Assign)]\n        CollectionViewCellAccessoryType AccessoryType { get; set; }\n\n        [NullAllowed]\n        [Export(\"accessoryView\", ArgumentSemantic.Strong)]\n        UIView AccessoryView { get; set; }\n\n        [Export(\"accessoryInset\", ArgumentSemantic.Assign)]\n        UIEdgeInsets AccessoryInset { get; set; }\n\n        [Export(\"shouldHideSeparator\")]\n        bool ShouldHideSeparator { get; set; }\n\n        [Export(\"separatorInset\", ArgumentSemantic.Assign)]\n        UIEdgeInsets SeparatorInset { get; set; }\n\n        [Export(\"allowsCellInteractionsWhileEditing\")]\n        bool AllowsCellInteractionsWhileEditing { get; set; }\n\n        [Export(\"editing\")]\n        bool Editing { [Bind(\"isEditing\")] get; set; }\n\n        [Export(\"editingSelectorColor\", ArgumentSemantic.Strong)]\n        UIColor EditingSelectorColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"inkView\", ArgumentSemantic.Strong)]\n        InkView InkView { get; set; }\n\n        [Field(\"kSelectedCellAccessibilityHintKey\", \"__Internal\")]\n        NSString SelectedCellAccessibilityHintKey { get; }\n\n        [Field(\"kDeselectedCellAccessibilityHintKey\", \"__Internal\")]\n        NSString DeselectedCellAccessibilityHintKey { get; }\n\n        [Field(\"MDCCollectionViewCellStyleCardSectionInset\", \"__Internal\")]\n        nfloat StyleCardSectionInset { get; }\n\n        [Export(\"setEditing:animated:\")]\n        void SetEditing(bool editing, bool animated);\n    }\n\n    [BaseType(typeof(CollectionViewCell),\n        Name = \"MDCCollectionViewTextCell\")]\n    interface CollectionViewTextCell\n    {\n        [NullAllowed]\n        [Export(\"textLabel\", ArgumentSemantic.Strong)]\n        UILabel TextLabel { get; }\n\n        [NullAllowed]\n        [Export(\"detailTextLabel\", ArgumentSemantic.Strong)]\n        UILabel DetailTextLabel { get; }\n\n        [NullAllowed]\n        [Export(\"imageView\", ArgumentSemantic.Strong)]\n        UIImageView ImageView { get; }\n\n        [Field(\"MDCCellDefaultOneLineHeight\", \"__Internal\")]\n        nfloat DefaultOneLineHeight { get; }\n\n        [Field(\"MDCCellDefaultOneLineWithAvatarHeight\", \"__Internal\")]\n        nfloat DefaultOneLineWithAvatarHeight { get; }\n\n        [Field(\"MDCCellDefaultTwoLineHeight\", \"__Internal\")]\n        nfloat DefaultTwoLineHeight { get; }\n\n        [Field(\"MDCCellDefaultThreeLineHeight\", \"__Internal\")]\n        nfloat DefaultThreeLineHeight { get; }\n    }\n\n    [BaseType(typeof(UICollectionViewLayoutAttributes),\n        Name = \"MDCCollectionViewLayoutAttributes\")]\n    interface CollectionViewLayoutAttributes : INSCopying\n\n    {\n        [Export(\"editing\")]\n        bool Editing { [Bind(\"isEditing\")] get; set; }\n\n        [Export(\"shouldShowReorderStateMask\")]\n        bool ShouldShowReorderStateMask { get; set; }\n\n        [Export(\"shouldShowSelectorStateMask\")]\n        bool ShouldShowSelectorStateMask { get; set; }\n\n        [Export(\"shouldShowGridBackground\")]\n        bool ShouldShowGridBackground { get; set; }\n\n        [NullAllowed]\n        [Export(\"backgroundImage\", ArgumentSemantic.Strong)]\n        UIImage BackgroundImage { get; set; }\n\n        [Export(\"backgroundImageViewInsets\", ArgumentSemantic.Assign)]\n        UIEdgeInsets BackgroundImageViewInsets { get; set; }\n\n        [Export(\"isGridLayout\")]\n        bool IsGridLayout { get; set; }\n\n        [Export(\"sectionOrdinalPosition\", ArgumentSemantic.Assign)]\n        CollectionViewOrdinalPosition SectionOrdinalPosition { get; set; }\n\n        [NullAllowed]\n        [Export(\"separatorColor\", ArgumentSemantic.Strong)]\n        UIColor SeparatorColor { get; set; }\n\n        [Export(\"separatorInset\", ArgumentSemantic.Assign)]\n        UIEdgeInsets SeparatorInset { get; set; }\n\n        [Export(\"separatorLineHeight\")]\n        nfloat SeparatorLineHeight { get; set; }\n\n        [Export(\"shouldHideSeparators\")]\n        bool ShouldHideSeparators { get; set; }\n\n        [Export(\"willAnimateCellsOnAppearance\")]\n        bool WillAnimateCellsOnAppearance { get; set; }\n\n        [Export(\"animateCellsOnAppearanceDuration\")]\n        double AnimateCellsOnAppearanceDuration { get; set; }\n\n        [Export(\"animateCellsOnAppearanceDelay\")]\n        double AnimateCellsOnAppearanceDelay { get; set; }\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCCollectionViewEditingDelegate\")]\n    interface CollectionViewEditingDelegate\n    {\n        [Export(\"collectionViewAllowsEditing:\")]\n        bool AllowsEditing(UICollectionView collectionView);\n\n        [Export(\"collectionViewWillBeginEditing:\")]\n        void WillBeginEditing(UICollectionView collectionView);\n\n        [Export(\"collectionViewDidBeginEditing:\")]\n        void EditingStarted(UICollectionView collectionView);\n\n        [Export(\"collectionViewWillEndEditing:\")]\n        void WillEndEditing(UICollectionView collectionView);\n\n        [Export(\"collectionViewDidEndEditing:\")]\n        void EditingEnded(UICollectionView collectionView);\n\n        [Export(\"collectionView:canEditItemAtIndexPath:\")]\n        bool CanEditItem(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [Export(\"collectionView:canSelectItemDuringEditingAtIndexPath:\")]\n        bool CanSelectItemDuringEditing(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [Export(\"collectionViewAllowsReordering:\")]\n        bool AllowsReordering(UICollectionView collectionView);\n\n        [Export(\"collectionView:canMoveItemAtIndexPath:\")]\n        bool CanMoveItem(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [Export(\"collectionView:canMoveItemAtIndexPath:toIndexPath:\")]\n        bool CanMoveItem(UICollectionView collectionView, NSIndexPath indexPath, NSIndexPath newIndexPath);\n\n        [Export(\"collectionView:willMoveItemAtIndexPath:toIndexPath:\")]\n        void WillMoveItem(UICollectionView collectionView, NSIndexPath indexPath, NSIndexPath newIndexPath);\n\n        [Export(\"collectionView:didMoveItemAtIndexPath:toIndexPath:\")]\n        void ItemMoved(UICollectionView collectionView, NSIndexPath indexPath, NSIndexPath newIndexPath);\n\n        [Export(\"collectionView:willBeginDraggingItemAtIndexPath:\")]\n        void WillBeginDraggingItem(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [Export(\"collectionView:didEndDraggingItemAtIndexPath:\")]\n        void DraggingItemEnded(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [Export(\"collectionView:willDeleteItemsAtIndexPaths:\")]\n        void WillDeleteItems(UICollectionView collectionView, NSIndexPath indexPaths);\n\n        [Export(\"collectionView:didDeleteItemsAtIndexPaths:\")]\n        void ItemsDeleted(UICollectionView collectionView, NSIndexPath indexPaths);\n\n        [Export(\"collectionView:willDeleteSections:\")]\n        void WillDeleteSections(UICollectionView collectionView, NSIndexSet sections);\n\n        [Export(\"collectionView:didDeleteSections:\")]\n        void SectionsDeleted(UICollectionView collectionView, NSIndexSet sections);\n\n        [Export(\"collectionViewAllowsSwipeToDismissItem:\")]\n        bool AllowsSwipeToDismissItem(UICollectionView collectionView);\n\n        [Export(\"collectionView:canSwipeToDismissItemAtIndexPath:\")]\n        bool CanSwipeToDismissItem(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [Export(\"collectionView:canSwipeInDirection:toDismissItemAtIndexPath:\")]\n        bool CollectionView(UICollectionView collectionView, UISwipeGestureRecognizerDirection swipeDirection, NSIndexPath indexPath);\n\n        [Export(\"collectionView:willBeginSwipeToDismissItemAtIndexPath:\")]\n        void WillBeginSwipeToDismissItem(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [Export(\"collectionView:didEndSwipeToDismissItemAtIndexPath:\")]\n        void SwipeToDismissItemEnded(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [Export(\"collectionView:didCancelSwipeToDismissItemAtIndexPath:\")]\n        void SwipeToDismissItemCanceled(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [Export(\"collectionViewAllowsSwipeToDismissSection:\")]\n        bool AllowsSwipeToDismissSection(UICollectionView collectionView);\n\n        [Export(\"collectionView:canSwipeToDismissSection:\")]\n        bool CanSwipeToDismissSection(UICollectionView collectionView, nint section);\n\n        [Export(\"collectionView:willBeginSwipeToDismissSection:\")]\n        void WillBeginSwipeToDismissSection(UICollectionView collectionView, nint section);\n\n        [Export(\"collectionView:didEndSwipeToDismissSection:\")]\n        void SwipeToDismissSectionEnded(UICollectionView collectionView, nint section);\n\n        [Export(\"collectionView:didCancelSwipeToDismissSection:\")]\n        void SwipeToDismissSectionCanceled(UICollectionView collectionView, nint section);\n    }\n\n    [Protocol(Name = \"MDCCollectionViewStyling\")]\n    [BaseType(typeof(NSObject))]\n    interface CollectionViewStyling\n    {\n        [Abstract]\n        [NullAllowed]\n        [Export(\"collectionView\", ArgumentSemantic.Weak)]\n        UICollectionView CollectionView { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        ICollectionViewStylingDelegate Delegate { get; set; }\n\n        [Abstract]\n        [Export(\"shouldInvalidateLayout\")]\n        bool ShouldInvalidateLayout { get; set; }\n\n        [Abstract]\n        [Export(\"cellBackgroundColor\", ArgumentSemantic.Strong)]\n        UIColor CellBackgroundColor { get; set; }\n\n        [Abstract]\n        [Export(\"cellLayoutType\", ArgumentSemantic.Assign)]\n        CollectionViewCellLayoutType CellLayoutType { get; set; }\n\n        [Abstract]\n        [Export(\"gridColumnCount\")]\n        nint GridColumnCount { get; set; }\n\n        [Abstract]\n        [Export(\"gridPadding\")]\n        nfloat GridPadding { get; set; }\n\n        [Abstract]\n        [Export(\"cellStyle\", ArgumentSemantic.Assign)]\n        CollectionViewCellStyle CellStyle { get; set; }\n\n        [Abstract]\n        [Export(\"cardBorderRadius\")]\n        nfloat CardBorderRadius { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"separatorColor\", ArgumentSemantic.Strong)]\n        UIColor SeparatorColor { get; set; }\n\n        [Abstract]\n        [Export(\"separatorInset\", ArgumentSemantic.Assign)]\n        UIEdgeInsets SeparatorInset { get; set; }\n\n        [Abstract]\n        [Export(\"separatorLineHeight\")]\n        nfloat SeparatorLineHeight { get; set; }\n\n        [Abstract]\n        [Export(\"shouldHideSeparators\")]\n        bool ShouldHideSeparators { get; set; }\n\n        [Abstract]\n        [Export(\"allowsItemInlay\")]\n        bool AllowsItemInlay { get; set; }\n\n        [Abstract]\n        [Export(\"allowsMultipleItemInlays\")]\n        bool AllowsMultipleItemInlays { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n\n        [Export(\"indexPathsForInlaidItems\")]\n        NSIndexPath[] IndexPathsForInlaidItems { get; }\n\n        [Abstract]\n        [Export(\"shouldAnimateCellsOnAppearance\")]\n        bool ShouldAnimateCellsOnAppearance { get; set; }\n\n        [Abstract]\n        [Export(\"willAnimateCellsOnAppearance\")]\n        bool WillAnimateCellsOnAppearance { get; }\n\n        [Abstract]\n        [Export(\"animateCellsOnAppearancePadding\")]\n        nfloat AnimateCellsOnAppearancePadding { get; }\n\n        [Abstract]\n        [Export(\"animateCellsOnAppearanceDuration\")]\n        double AnimateCellsOnAppearanceDuration { get; }\n\n        [Abstract]\n        [Export(\"setCellStyle:animated:\")]\n        void SetCellStyle(CollectionViewCellStyle cellStyle, bool animated);\n\n        [Abstract]\n        [Export(\"cellStyleAtSectionIndex:\")]\n        CollectionViewCellStyle GetCellStyle(nint section);\n\n        [Abstract]\n        [Export(\"backgroundImageViewOutsetsForCellWithAttribute:\")]\n        UIEdgeInsets GetBackgroundImageViewOutsetsForCell(CollectionViewLayoutAttributes attr);\n\n        [return: NullAllowed]\n        [Abstract]\n        [Export(\"backgroundImageForCellLayoutAttributes:\")]\n        UIImage GetBackgroundImageForCell(CollectionViewLayoutAttributes attr);\n\n        [Abstract]\n        [Export(\"shouldHideSeparatorForCellLayoutAttributes:\")]\n        bool ShouldHideSeparatorForCellLayoutAttributes(CollectionViewLayoutAttributes attr);\n\n        [Abstract]\n        [Export(\"isItemInlaidAtIndexPath:\")]\n        bool IsItemInlaid(NSIndexPath indexPath);\n\n        [Abstract]\n        [Export(\"applyInlayToItemAtIndexPath:animated:\")]\n        void ApplyInlayToItem(NSIndexPath indexPath, bool animated);\n\n        [Abstract]\n        [Export(\"removeInlayFromItemAtIndexPath:animated:\")]\n        void RemoveInlayFromItem(NSIndexPath indexPath, bool animated);\n\n        [Abstract]\n        [Export(\"applyInlayToAllItemsAnimated:\")]\n        void ApplyInlayToAllItems(bool animated);\n\n        [Abstract]\n        [Export(\"removeInlayFromAllItemsAnimated:\")]\n        void RemoveInlayFromAllItems(bool animated);\n\n        [Abstract]\n        [Export(\"resetIndexPathsForInlaidItems\")]\n        void ResetIndexPathsForInlaidItems();\n\n        [Abstract]\n        [Export(\"beginCellAppearanceAnimation\")]\n        void BeginCellAppearanceAnimation();\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCCollectionViewStylingDelegate\")]\n    interface CollectionViewStylingDelegate\n    {\n        [Export(\"collectionView:cellHeightAtIndexPath:\")]\n        nfloat GetCellHeight(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [Export(\"collectionView:cellStyleForSection:\")]\n        CollectionViewCellStyle CellStyleForSection(UICollectionView collectionView, nint section);\n\n        [return: NullAllowed]\n        [Export(\"collectionView:cellBackgroundColorAtIndexPath:\")]\n        UIColor GetCellBackgroundColor(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [Export(\"collectionView:shouldHideItemBackgroundAtIndexPath:\")]\n        bool ShouldHideItemBackground(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [Export(\"collectionView:shouldHideHeaderBackgroundForSection:\")]\n        bool ShouldHideHeaderBackground(UICollectionView collectionView, nint section);\n\n        [Export(\"collectionView:shouldHideFooterBackgroundForSection:\")]\n        bool ShouldHideFooterBackground(UICollectionView collectionView, nint section);\n\n        [Export(\"collectionView:shouldHideItemSeparatorAtIndexPath:\")]\n        bool ShouldHideItemSeparator(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [Export(\"collectionView:shouldHideHeaderSeparatorForSection:\")]\n        bool ShouldHideHeaderSeparator(UICollectionView collectionView, nint section);\n\n        [Export(\"collectionView:shouldHideFooterSeparatorForSection:\")]\n        bool ShouldHideFooterSeparator(UICollectionView collectionView, nint section);\n\n        [Export(\"collectionView:didApplyInlayToItemAtIndexPaths:\")]\n        void InlayToItemApplied(UICollectionView collectionView, NSIndexPath indexPaths);\n\n        [Export(\"collectionView:didRemoveInlayFromItemAtIndexPaths:\")]\n        void InlayFromItemRemoved(UICollectionView collectionView, NSIndexPath indexPaths);\n\n        [Export(\"collectionView:hidesInkViewAtIndexPath:\")]\n        bool HidesInkView(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [return: NullAllowed]\n        [Export(\"collectionView:inkColorAtIndexPath:\")]\n        UIColor GetInkColor(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [Export(\"collectionView:inkTouchController:inkViewAtIndexPath:\")]\n        InkView GetInkView(UICollectionView collectionView, InkTouchController inkTouchController, NSIndexPath indexPath);\n    }\n\n    [BaseType(typeof(UICollectionViewController),\n        Name = \"MDCCollectionViewController\")]\n    interface CollectionViewController : CollectionViewEditingDelegate, CollectionViewStylingDelegate, IUICollectionViewDelegateFlowLayout\n\n    {\n        [Export(\"styler\", ArgumentSemantic.Strong)]\n        ICollectionViewStyling Styler { get; }\n\n        [Export(\"editor\", ArgumentSemantic.Strong)]\n        ICollectionViewEditing Editor { get; }\n\n        [New]\n        [RequiresSuper]\n        [Export(\"collectionView:didHighlightItemAtIndexPath:\")]\n        void ItemHighlighted(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [New]\n        [RequiresSuper]\n        [Export(\"collectionView:didUnhighlightItemAtIndexPath:\")]\n        void ItemUnhighlighted(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [New]\n        [RequiresSuper]\n        [Export(\"collectionView:didSelectItemAtIndexPath:\")]\n        void ItemSelected(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [New]\n        [RequiresSuper]\n        [Export(\"collectionView:didDeselectItemAtIndexPath:\")]\n        void ItemDeselected(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [RequiresSuper]\n        [Export(\"collectionViewWillBeginEditing:\")]\n        void WillBeginEditing(UICollectionView collectionView);\n\n        [RequiresSuper]\n        [Export(\"collectionViewWillEndEditing:\")]\n        void WillEndEditing(UICollectionView collectionView);\n\n        [Export(\"cellWidthAtSectionIndex:\")]\n        nfloat GetCellWidth(nint section);\n    }\n\n    [Protocol(Name = \"MDCCollectionViewEditing\")]\n    [BaseType(typeof(NSObject))]\n    interface CollectionViewEditing\n    {\n        [Abstract]\n        [NullAllowed]\n        [Export(\"collectionView\", ArgumentSemantic.Weak)]\n        UICollectionView CollectionView { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        ICollectionViewEditingDelegate Delegate { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"reorderingCellIndexPath\", ArgumentSemantic.Strong)]\n        NSIndexPath ReorderingCellIndexPath { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"dismissingCellIndexPath\", ArgumentSemantic.Strong)]\n        NSIndexPath DismissingCellIndexPath { get; }\n\n        [Abstract]\n        [Export(\"dismissingSection\")]\n        nint DismissingSection { get; }\n\n        [Abstract]\n        [Export(\"minimumPressDuration\")]\n        double MinimumPressDuration { get; set; }\n\n        [Abstract]\n        [Export(\"editing\")]\n        bool Editing { [Bind(\"isEditing\")] get; set; }\n\n        [Abstract]\n        [Export(\"setEditing:animated:\")]\n        void SetEditing(bool editing, bool animated);\n\n        [Abstract]\n        [Export(\"updateReorderCellPosition\")]\n        void UpdateReorderCellPosition();\n    }\n\n    [BaseType(typeof(UICollectionViewFlowLayout),\n        Name = \"MDCCollectionViewFlowLayout\")]\n    interface CollectionViewFlowLayout\n    { }\n\n    [BaseType(typeof(UIViewController),\n        Name = \"MDCAlertController\")]\n    interface AlertController : IElevatable, IElevationOverriding\n\n    {\n        [NullAllowed]\n        [Export(\"titleFont\", ArgumentSemantic.Strong)]\n        UIFont TitleFont { get; set; }\n\n        [NullAllowed]\n        [Export(\"titleColor\", ArgumentSemantic.Strong)]\n        UIColor TitleColor { get; set; }\n\n        [Export(\"titleAlignment\", ArgumentSemantic.Assign)]\n        NSTextAlignment TitleAlignment { get; set; }\n\n        [NullAllowed]\n        [Export(\"titleIcon\", ArgumentSemantic.Strong)]\n        UIImage TitleIcon { get; set; }\n\n        [NullAllowed]\n        [Export(\"titleIconTintColor\", ArgumentSemantic.Strong)]\n        UIColor TitleIconTintColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"messageFont\", ArgumentSemantic.Strong)]\n        UIFont MessageFont { get; set; }\n\n        [NullAllowed]\n        [Export(\"messageColor\", ArgumentSemantic.Strong)]\n        UIColor MessageColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"buttonFont\", ArgumentSemantic.Strong)]\n        UIFont ButtonFont { get; set; }\n\n        [NullAllowed]\n        [Export(\"buttonTitleColor\", ArgumentSemantic.Strong)]\n        UIColor ButtonTitleColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"scrimColor\", ArgumentSemantic.Strong)]\n        UIColor ScrimColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"backgroundColor\", ArgumentSemantic.Strong)]\n        UIColor BackgroundColor { get; set; }\n\n        [Export(\"cornerRadius\")]\n        nfloat CornerRadius { get; set; }\n\n        [Export(\"elevation\")]\n        nfloat Elevation { get; set; }\n\n        [Export(\"shadowColor\", ArgumentSemantic.Copy)]\n        UIColor ShadowColor { get; set; }\n\n        [New]\n        [NullAllowed]\n        [Export(\"title\")]\n        string Title { get; set; }\n\n        [NullAllowed]\n        [Export(\"message\")]\n        string Message { get; set; }\n\n        [Export(\"enableRippleBehavior\")]\n        bool EnableRippleBehavior { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<AlertController, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"adjustsFontForContentSizeCategoryWhenScaledFontIsUnavailable\")]\n        bool AdjustsFontForContentSizeCategoryWhenScaledFontIsUnavailable { get; set; }\n\n        [Export(\"actions\")]\n        AlertAction[] Actions { get; }\n\n        [Export(\"mdc_adjustsFontForContentSizeCategory\")]\n        bool AdjustsFontForContentSizeCategory { get; [Bind(\"mdc_setAdjustsFontForContentSizeCategory:\")]set; }\n\n        [Obsolete(\"Use AdjustsFontForContentSizeCategory instead\")]\n        [Wrap(\"AdjustsFontForContentSizeCategory\")]\n        bool MdcAdjustsFontForContentSizeCategory { get; set; }\n\n        [Static]\n        [Export(\"alertControllerWithTitle:message:\")]\n        AlertController Create([NullAllowed] string title, [NullAllowed]  string message);\n\n        [Export(\"addAction:\")]\n        void AddAction(AlertAction action);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCAlertAction\")]\n    interface AlertAction : INSCopying, IUIAccessibilityIdentification\n\n    {\n        [NullAllowed]\n        [Export(\"title\")]\n        string Title { get; }\n\n        [Export(\"emphasis\")]\n        ActionEmphasis Emphasis { get; }\n\n        [NullAllowed]\n        [Export(\"accessibilityIdentifier\")]\n        string AccessibilityIdentifier { get; set; }\n\n        [Static]\n        [Export(\"actionWithTitle:handler:\")]\n        AlertAction Create(string title, [NullAllowed]  ActionHandler handler);\n\n        [Static]\n        [Export(\"actionWithTitle:emphasis:handler:\")]\n        AlertAction Create(string title, ActionEmphasis emphasis, [NullAllowed]  ActionHandler handler);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCAlertControllerView\")]\n    interface AlertControllerView\n    {\n        [NullAllowed]\n        [Export(\"titleFont\", ArgumentSemantic.Strong)]\n        UIFont TitleFont { get; set; }\n\n        [NullAllowed]\n        [Export(\"titleColor\", ArgumentSemantic.Strong)]\n        UIColor TitleColor { get; set; }\n\n        [Export(\"titleAlignment\", ArgumentSemantic.Assign)]\n        NSTextAlignment TitleAlignment { get; set; }\n\n        [NullAllowed]\n        [Export(\"titleIcon\", ArgumentSemantic.Strong)]\n        UIImage TitleIcon { get; set; }\n\n        [NullAllowed]\n        [Export(\"titleIconTintColor\", ArgumentSemantic.Strong)]\n        UIColor TitleIconTintColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"messageFont\", ArgumentSemantic.Strong)]\n        UIFont MessageFont { get; set; }\n\n        [NullAllowed]\n        [Export(\"messageColor\", ArgumentSemantic.Strong)]\n        UIColor MessageColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"buttonFont\", ArgumentSemantic.Strong)]\n        UIFont ButtonFont { get; set; }\n\n        [NullAllowed]\n        [Export(\"buttonColor\", ArgumentSemantic.Strong)]\n        UIColor ButtonColor { get; set; }\n\n        [Export(\"cornerRadius\")]\n        nfloat CornerRadius { get; set; }\n\n        [Export(\"enableRippleBehavior\")]\n        bool EnableRippleBehavior { get; set; }\n\n        [Export(\"mdc_adjustsFontForContentSizeCategory\")]\n        bool AdjustsFontForContentSizeCategory { get; [Bind(\"mdc_setAdjustsFontForContentSizeCategory:\")]set; }\n\n        [Obsolete(\"Use AdjustsFontForContentSizeCategory instead\")]\n        [Wrap(\"AdjustsFontForContentSizeCategory\")]\n        bool MdcAdjustsFontForContentSizeCategory { get; set; }\n\n        [return: NullAllowed]\n        [Export(\"buttonForAction:\")]\n        Button GetButton(AlertAction action);\n    }\n\n    [Protocol(Name = \"MDCDialogPresentationControllerDelegate\")]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject))]\n    interface DialogPresentationControllerDelegate\n    {\n        [Export(\"dialogPresentationControllerDidDismiss:\")]\n        void DialogPresentationControllerDidDismiss(DialogPresentationController dialogPresentationController);\n    }\n\n    [BaseType(typeof(UIPresentationController),\n        Name = \"MDCDialogPresentationController\")]\n    interface DialogPresentationController\n    {\n        [Wrap(\"WeakDialogPresentationControllerDelegate\")]\n        [NullAllowed]\n        IDialogPresentationControllerDelegate DialogPresentationControllerDelegate { get; set; }\n\n        [NullAllowed]\n        [Export(\"dialogPresentationControllerDelegate\", ArgumentSemantic.Weak)]\n        NSObject WeakDialogPresentationControllerDelegate { get; set; }\n\n        [Export(\"dismissOnBackgroundTap\")]\n        bool DismissOnBackgroundTap { get; set; }\n\n        [Export(\"dialogCornerRadius\")]\n        nfloat DialogCornerRadius { get; set; }\n\n        [Export(\"dialogElevation\")]\n        nfloat DialogElevation { get; set; }\n\n        [Export(\"dialogShadowColor\", ArgumentSemantic.Copy)]\n        UIColor DialogShadowColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"scrimColor\", ArgumentSemantic.Strong)]\n        UIColor ScrimColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<DialogPresentationController, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [New]\n        [Export(\"sizeForChildContentContainer:withParentContainerSize:\")]\n        CGSize GetSizeForChildContentContainer(IUIContentContainer container, CGSize parentSize);\n\n        [Export(\"frameOfPresentedViewInContainerView\")]\n        CGRect GetFrameOfPresentedViewInContainerView();\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCDialogTransitionController\")]\n    interface DialogTransitionController : IUIViewControllerAnimatedTransitioning, IUIViewControllerTransitioningDelegate\n    { }\n\n    [Category]\n    [BaseType(typeof(UIViewController))]\n    interface UIViewController_MaterialDialogs\n    {\n        [return: NullAllowed]\n        [Export(\"mdc_dialogPresentationController\")]\n        DialogPresentationController GetDialogPresentationController();\n\n        [return: NullAllowed]\n        [Wrap(\"GetDialogPresentationController(This)\")]\n        DialogPresentationController MdcGetDialogPresentationController();\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCAlertColorThemer\")]\n    interface AlertColorThemer\n    {\n        [Obsolete(\"This method will soon be deprecated. Consider using ApplySemanticColorScheme method instead.\")]\n        [Static]\n        [Export(\"applyColorScheme:\")]\n        void ApplyColorScheme(IColorScheme colorScheme);\n\n        [Static]\n        [Export(\"applySemanticColorScheme:toAlertController:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, AlertController alertController);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCAlertScheming\")]\n    interface AlertScheming\n    {\n        [Abstract]\n        [Export(\"colorScheme\")]\n        ColorScheming ColorScheme { get; }\n\n        [Abstract]\n        [Export(\"typographyScheme\")]\n        TypographyScheming TypographyScheme { get; }\n\n        [Abstract]\n        [Export(\"buttonScheme\")]\n        ButtonScheming ButtonScheme { get; }\n\n        [Abstract]\n        [Export(\"cornerRadius\")]\n        nfloat CornerRadius { get; }\n\n        [Abstract]\n        [Export(\"elevation\")]\n        nfloat Elevation { get; }\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCAlertScheme\")]\n    interface AlertScheme : AlertScheming\n\n    {\n        [Export(\"colorScheme\", ArgumentSemantic.Assign)]\n        ColorScheming ColorScheme { get; set; }\n\n        [Export(\"typographyScheme\", ArgumentSemantic.Assign)]\n        TypographyScheming TypographyScheme { get; set; }\n\n        [Export(\"buttonScheme\", ArgumentSemantic.Assign)]\n        ButtonScheming ButtonScheme { get; set; }\n\n        [Export(\"cornerRadius\")]\n        nfloat CornerRadius { get; set; }\n\n        [Export(\"elevation\")]\n        nfloat Elevation { get; set; }\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCAlertControllerThemer\")]\n    interface AlertControllerThemer\n    {\n        [Static]\n        [Export(\"applyScheme:toAlertController:\")]\n        void ApplyScheme(IAlertScheming alertScheme, AlertController alertController);\n    }\n\n    [Category]\n    [BaseType(typeof(AlertController),\n        Name = \"MDCAlertController_MaterialTheming\")]\n    interface AlertController_MaterialTheming\n    {\n        [Export(\"applyThemeWithScheme:\")]\n        void ApplyTheme(IContainerScheming scheme);\n    }\n\n    [Category]\n    [BaseType(typeof(DialogPresentationController),\n        Name = \"MDCDialogPresentationController_MaterialTheming\")]\n    interface DialogPresentationController_MaterialTheming\n    {\n        [Export(\"applyThemeWithScheme:\")]\n        void ApplyTheme(IContainerScheming scheme);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCAlertTypographyThemer\")]\n    interface AlertTypographyThemer\n    {\n        [Static]\n        [Export(\"applyTypographyScheme:toAlertController:\")]\n        void ApplyTypographyScheme(ITypographyScheming typographyScheme, AlertController alertController);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCFeatureHighlightView\")]\n    interface FeatureHighlightView\n    {\n        [NullAllowed]\n        [Export(\"innerHighlightColor\", ArgumentSemantic.Strong)]\n        UIColor InnerHighlightColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"outerHighlightColor\", ArgumentSemantic.Strong)]\n        UIColor OuterHighlightColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"titleFont\", ArgumentSemantic.Strong)]\n        UIFont TitleFont { get; set; }\n\n        [NullAllowed]\n        [Export(\"titleColor\", ArgumentSemantic.Strong)]\n        UIColor TitleColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"bodyFont\", ArgumentSemantic.Strong)]\n        UIFont BodyFont { get; set; }\n\n        [NullAllowed]\n        [Export(\"bodyColor\", ArgumentSemantic.Strong)]\n        UIColor BodyColor { get; set; }\n\n        [Export(\"mdc_legacyFontScaling\")]\n        bool LegacyFontScaling { get; [Bind(\"mdc_setLegacyFontScaling:\")]set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<FeatureHighlightView, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"mdc_adjustsFontForContentSizeCategory\")]\n        bool AdjustsFontForContentSizeCategory { get; [Bind(\"mdc_setAdjustsFontForContentSizeCategory:\")]set; }\n\n        [Obsolete(\"Use AdjustsFontForContentSizeCategory instead\")]\n        [Wrap(\"AdjustsFontForContentSizeCategory\")]\n        bool MdcAdjustsFontForContentSizeCategory { get; set; }\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(UIViewController),\n        Name = \"MDCFeatureHighlightViewController\")]\n    interface FeatureHighlightViewController\n    {\n        [NullAllowed]\n        [Export(\"titleText\")]\n        string TitleText { get; set; }\n\n        [NullAllowed]\n        [Export(\"bodyText\")]\n        string BodyText { get; set; }\n\n        [Export(\"outerHighlightColor\", ArgumentSemantic.Strong)]\n        UIColor OuterHighlightColor { get; set; }\n\n        [Export(\"innerHighlightColor\", ArgumentSemantic.Strong)]\n        UIColor InnerHighlightColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"titleColor\", ArgumentSemantic.Strong)]\n        UIColor TitleColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"bodyColor\", ArgumentSemantic.Strong)]\n        UIColor BodyColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"titleFont\", ArgumentSemantic.Strong)]\n        UIFont TitleFont { get; set; }\n\n        [NullAllowed]\n        [Export(\"bodyFont\", ArgumentSemantic.Strong)]\n        UIFont BodyFont { get; set; }\n\n        [Export(\"mdc_legacyFontScaling\")]\n        bool LegacyFontScaling { get; [Bind(\"mdc_setLegacyFontScaling:\")]set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<FeatureHighlightViewController, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Field(\"kMDCFeatureHighlightOuterHighlightAlpha\", \"__Internal\")]\n        nfloat FeatureHighlightOuterHighlightAlpha { get; }\n\n        [Export(\"mdc_adjustsFontForContentSizeCategory\")]\n        bool AdjustsFontForContentSizeCategory { get; [Bind(\"mdc_setAdjustsFontForContentSizeCategory:\")]set; }\n\n        [Obsolete(\"Use AdjustsFontForContentSizeCategory instead\")]\n        [Wrap(\"AdjustsFontForContentSizeCategory\")]\n        bool MdcAdjustsFontForContentSizeCategory { get; set; }\n\n        [DesignatedInitializer]\n        [Export(\"initWithHighlightedView:andShowView:completion:\")]\n        IntPtr Constructor(UIView highlightedView, UIView displayedView, [NullAllowed]  FeatureHighlightCompletionHandler completion);\n\n        [Export(\"initWithHighlightedView:completion:\")]\n        IntPtr Constructor(UIView highlightedView, [NullAllowed]  FeatureHighlightCompletionHandler completion);\n\n        [Export(\"acceptFeature\")]\n        void AcceptFeature();\n\n        [Export(\"rejectFeature\")]\n        void RejectFeature();\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCFeatureHighlightColorThemer\")]\n    interface FeatureHighlightColorThemer\n    {\n        [Obsolete(\" This method will soon be deprecated. Consider using ApplySemanticColorScheme method instead.\")]\n        [Static]\n        [Export(\"applyColorScheme:toFeatureHighlightView:\")]\n        void ApplyColorScheme(IColorScheme colorScheme, FeatureHighlightView featureHighlightView);\n\n        [Obsolete(\" This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toFeatureHighlightViewController:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, FeatureHighlightViewController featureHighlightViewController);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCFeatureHighlightAccessibilityMutator\")]\n    interface FeatureHighlightAccessibilityMutator\n    {\n        [Static]\n        [Export(\"mutate:\")]\n        void Mutate(FeatureHighlightViewController featureHighlightViewController);\n    }\n\n    [Obsolete(\"This class will soon be deprecated. Please consider using FeatureHighlightTypographyThemer class instead.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCFeatureHighlightFontThemer\")]\n    interface FeatureHighlightFontThemer\n    {\n        [Obsolete(\" This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyFontScheme:toFeatureHighlightView:\")]\n        void ApplyFontScheme(IFontScheme fontScheme, FeatureHighlightView featureHighlightView);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCFeatureHighlightTypographyThemer\")]\n    interface FeatureHighlightTypographyThemer\n    {\n        [Obsolete(\" This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyTypographyScheme:toFeatureHighlightViewController:\")]\n        void ApplyTypographyScheme(ITypographyScheming typographyScheme, FeatureHighlightViewController featureHighlightViewController);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCFlexibleHeaderColorThemer\")]\n    interface FlexibleHeaderColorThemer\n    {\n        [Obsolete(\" This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toFlexibleHeaderView:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, FlexibleHeaderView flexibleHeaderView);\n\n        [Obsolete(\" This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySurfaceVariantWithColorScheme:toFlexibleHeaderView:\")]\n        void ApplySurfaceVariant (IColorScheming colorScheme, FlexibleHeaderView flexibleHeaderView);\n\n        [Obsolete(\"This method will soon be deprecated. Consider using ApplySemanticColorScheme method instead.\")]\n        [Static]\n        [Export(\"applyColorScheme:toFlexibleHeaderView:\")]\n        void ApplyColorScheme (IColorScheme colorScheme, FlexibleHeaderView flexibleHeaderView);\n\n        [Obsolete(\"This method will soon be deprecated. Consider using ApplySemanticColorScheme method instead.\")]\n        [Static]\n        [Export(\"applyColorScheme:toMDCFlexibleHeaderController:\")]\n        void ApplyColorScheme(IColorScheme colorScheme, FlexibleHeaderViewController flexibleHeaderController);\n    }\n\n    [Obsolete(\"This class will soon be deprecated. There will be no replacement API. Consider theming your flexible header view or app bar instead.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCHeaderStackViewColorThemer\")]\n    interface HeaderStackViewColorThemer\n    {\n        [Static]\n        [Export(\"applyColorScheme:toHeaderStackView:\")]\n        void ApplyColorScheme(IColorScheme colorScheme, HeaderStackView headerStackView);\n    }\n\n    [Obsolete(\"This class will soon be deprecated. There is no direct replacement. Ink color needs to be set by the owning component in a context - specific manner.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCInkColorThemer\")]\n    interface InkColorThemer\n    {\n        [Static]\n        [Export(\"applyColorScheme:toInkView:\")]\n        void ApplyColorScheme(IColorScheme colorScheme, InkView inkView);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCLibraryInfo\")]\n    interface LibraryInfo\n    {\n        [Static]\n        [Export(\"versionString\")]\n        string VersionString { get; }\n    }\n\n    [BaseType(typeof(UICollectionViewCell),\n        Name = \"MDCBaseCell\")]\n    interface BaseCell : IElevatable, IElevationOverriding\n\n    {\n        [Export(\"elevation\")]\n        nfloat Elevation { get; set; }\n\n        [Export(\"enableRippleBehavior\")]\n        bool EnableRippleBehavior { get; set; }\n\n        [NullAllowed]\n        [Export(\"rippleColor\", ArgumentSemantic.Strong)]\n        UIColor RippleColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<BaseCell, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Obsolete(\" This property will soon be deprecated.\")]\n        [Export(\"inkColor\", ArgumentSemantic.Strong)]\n        UIColor InkColor { get; set; }\n    }\n\n    [BaseType(typeof(BaseCell),\n        Name = \"MDCSelfSizingStereoCell\")]\n    interface SelfSizingStereoCell\n    {\n        [Export(\"leadingImageView\", ArgumentSemantic.Strong)]\n        UIImageView LeadingImageView { get; }\n\n        [Export(\"trailingImageView\", ArgumentSemantic.Strong)]\n        UIImageView TrailingImageView { get; }\n\n        [Export(\"titleLabel\", ArgumentSemantic.Strong)]\n        UILabel TitleLabel { get; }\n\n        [Export(\"detailLabel\", ArgumentSemantic.Strong)]\n        UILabel DetailLabel { get; }\n\n        [Export(\"adjustsFontForContentSizeCategoryWhenScaledFontIsUnavailable\")]\n        bool AdjustsFontForContentSizeCategoryWhenScaledFontIsUnavailable { get; set; }\n\n        [Export(\"mdc_adjustsFontForContentSizeCategory\")]\n        bool AdjustsFontForContentSizeCategory { get; [Bind(\"mdc_setAdjustsFontForContentSizeCategory:\")]set; }\n\n        [Obsolete(\"Use AdjustsFontForContentSizeCategory instead\")]\n        [Wrap(\"AdjustsFontForContentSizeCategory\")]\n        bool MdcAdjustsFontForContentSizeCategory { get; set; }\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCListColorThemer\")]\n    interface ListColorThemer\n    {\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toSelfSizingStereoCell:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, SelfSizingStereoCell cell);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toBaseCell:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, BaseCell cell);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCListScheming\")]\n    interface ListScheming\n    {\n        [Abstract]\n        [Export(\"colorScheme\")]\n        IColorScheming ColorScheme { get; }\n\n        [Abstract]\n        [Export(\"typographyScheme\")]\n        ITypographyScheming TypographyScheme { get; }\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCListScheme\")]\n    interface ListScheme : ListScheming\n\n    {\n        [Export(\"colorScheme\", ArgumentSemantic.Assign)]\n        IColorScheming ColorScheme { get; set; }\n\n        [Export(\"typographyScheme\", ArgumentSemantic.Assign)]\n        ITypographyScheming TypographyScheme { get; set; }\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCListThemer\")]\n    interface ListThemer\n    {\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyScheme:toSelfSizingStereoCell:\")]\n        void ApplyScheme (IListScheming scheme, SelfSizingStereoCell cell);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyScheme:toBaseCell:\")]\n        void ApplyScheme (IListScheming scheme, BaseCell cell);\n    }\n\n    [Category]\n    [BaseType(typeof(BaseCell),\n        Name = \"MDCBaseCell_MaterialTheming\")]\n    interface BaseCell_MaterialTheming\n    {\n        [Export(\"applyThemeWithScheme:\")]\n        void ApplyTheme(IContainerScheming scheme);\n    }\n\n    [Category]\n    [BaseType(typeof(SelfSizingStereoCell),\n        Name = \"MDCSelfSizingStereoCell_MaterialTheming\")]\n    interface SelfSizingStereoCell_MaterialTheming\n    {\n        [Export(\"applyThemeWithScheme:\")]\n        void ApplyTheme(IContainerScheming scheme);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCListTypographyThemer\")]\n    interface ListTypographyThemer\n    {\n        [Obsolete(\"This property has been deprecated.\")]\n        [Static]\n        [Export(\"applyTypographyScheme:toSelfSizingStereoCell:\")]\n        void ApplyTypographyScheme (ITypographyScheming typographyScheme, SelfSizingStereoCell cell);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCMaskedTransitionController\")]\n    interface MaskedTransitionController : IUIViewControllerTransitioningDelegate\n\n    {\n        [NullAllowed]\n        [Export(\"sourceView\", ArgumentSemantic.Strong)]\n        UIView SourceView { get; }\n\n        [NullAllowed]\n        [Export(\"calculateFrameOfPresentedView\", ArgumentSemantic.Copy)]\n        Func<UIPresentationController, CGRect> CalculateFrameOfPresentedView { get; set; }\n\n        [Export(\"initWithSourceView:\")]\n        IntPtr Constructor([NullAllowed] UIView sourceView);\n\n        [DesignatedInitializer]\n        [Export(\"init\")]\n        IntPtr Constructor();\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCNavigationBarColorThemer\")]\n    interface NavigationBarColorThemer\n    {\n        [Obsolete(\"This method will soon be deprecated. Consider using ApplySemanticColorScheme instead.\")]\n        [Static]\n        [Export(\"applyColorScheme:toNavigationBar:\")]\n        void ApplyColorScheme (IColorScheme colorScheme, NavigationBar navigationBar);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toNavigationBar:\")]\n        void ApplySemanticColorScheme (IColorScheming colorScheme, NavigationBar navigationBar);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySurfaceVariantWithColorScheme:toNavigationBar:\")]\n        void ApplySurfaceVariant (IColorScheming colorScheme, NavigationBar navigationBar);\n\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCNavigationBarTypographyThemer\")]\n    interface NavigationBarTypographyThemer\n    {\n        [Static]\n        [Export(\"applyTypographyScheme:toNavigationBar:\")]\n        void ApplyTypographyScheme (ITypographyScheming typographyScheme, NavigationBar navigationBar);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCBottomDrawerHeader\")]\n    interface BottomDrawerHeader\n    {\n        [Export(\"updateDrawerHeaderTransitionRatio:\")]\n        void UpdateDrawerHeaderTransitionRatio(nfloat transitionToTopRatio);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCBottomDrawerPresentationControllerDelegate\")]\n    interface BottomDrawerPresentationControllerDelegate : IUIAdaptivePresentationControllerDelegate\n\n    {\n        [EventArgs(\"BottomDrawerPresentationControllerWillChangeState\")]\n        [Abstract]\n        [Export(\"bottomDrawerWillChangeState:drawerState:\")]\n        void WillChangeState(BottomDrawerPresentationController presentationController, BottomDrawerState drawerState);\n\n        [EventArgs(\"BottomDrawerPresentationControllerTopTransitionRatio\")]\n        [Abstract]\n        [Export(\"bottomDrawerTopTransitionRatio:transitionRatio:\")]\n        void TopTransitionRatio(BottomDrawerPresentationController presentationController, nfloat transitionRatio);\n    }\n\n    [BaseType(typeof(UIPresentationController),\n        Name = \"MDCBottomDrawerPresentationController\",\n        Delegates = new[] { \"Delegate\" },\n        Events = new[] { typeof(BottomDrawerPresentationControllerDelegate) })]\n    interface BottomDrawerPresentationController\n    {\n        [NullAllowed]\n        [Export(\"trackingScrollView\", ArgumentSemantic.Weak)]\n        UIScrollView TrackingScrollView { get; set; }\n\n        [NullAllowed]\n        [Export(\"scrimColor\", ArgumentSemantic.Strong)]\n        UIColor ScrimColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        IBottomDrawerPresentationControllerDelegate Delegate { get; set; }\n\n        [Export(\"topHandleHidden\")]\n        bool TopHandleHidden { [Bind(\"isTopHandleHidden\")] get; set; }\n\n        [NullAllowed]\n        [Export(\"topHandleColor\", ArgumentSemantic.Strong)]\n        UIColor TopHandleColor { get; set; }\n\n        [Export(\"maximumInitialDrawerHeight\")]\n        nfloat MaximumInitialDrawerHeight { get; set; }\n\n        [Export(\"shouldIncludeSafeAreaInContentHeight\")]\n        bool ShouldIncludeSafeAreaInContentHeight { get; set; }\n\n        [Export(\"contentReachesFullscreen\")]\n        bool ContentReachesFullscreen { get; }\n\n        [Export(\"drawerShadowColor\", ArgumentSemantic.Strong)]\n        UIColor DrawerShadowColor { get; set; }\n\n        [Export(\"elevation\")]\n        double Elevation { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<BottomDrawerPresentationController, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"setContentOffsetY:animated:\")]\n        void SetContentOffsetY(nfloat contentOffsetY, bool animated);\n\n        [Export(\"expandToFullscreenWithDuration:completion:\")]\n        void ExpandToFullscreenWithDuration(nfloat duration, [NullAllowed]  Action<bool> completion);\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCBottomDrawerTransitionController\")]\n    interface BottomDrawerTransitionController : IUIViewControllerAnimatedTransitioning, IUIViewControllerTransitioningDelegate\n\n    {\n        [NullAllowed]\n        [Export(\"trackingScrollView\", ArgumentSemantic.Weak)]\n        UIScrollView TrackingScrollView { get; set; }\n    }\n\n    [BaseType(typeof(UIViewController),\n        Name = \"MDCBottomDrawerViewController\",\n        Delegates = new[] { \"Delegate\" },\n        Events = new[] { typeof(BottomDrawerViewControllerDelegate) })]\n    interface BottomDrawerViewController : IBottomDrawerPresentationControllerDelegate\n\n    {\n        [NullAllowed]\n        [Export(\"contentViewController\", ArgumentSemantic.Assign)]\n        UIViewController ContentViewController { get; set; }\n\n        [NullAllowed]\n        [Export(\"headerViewController\", ArgumentSemantic.Assign)]\n        BottomDrawerHeader HeaderViewController { get; set; }\n\n        [NullAllowed]\n        [Export(\"trackingScrollView\", ArgumentSemantic.Weak)]\n        UIScrollView TrackingScrollView { get; set; }\n\n        [Export(\"drawerState\")]\n        BottomDrawerState DrawerState { get; }\n\n        [NullAllowed]\n        [Export(\"scrimColor\", ArgumentSemantic.Strong)]\n        UIColor ScrimColor { get; set; }\n\n        [Export(\"topHandleHidden\")]\n        bool TopHandleHidden { [Bind(\"isTopHandleHidden\")] get; set; }\n\n        [NullAllowed]\n        [Export(\"topHandleColor\", ArgumentSemantic.Strong)]\n        UIColor TopHandleColor { get; set; }\n\n        [Export(\"maximumInitialDrawerHeight\")]\n        nfloat MaximumInitialDrawerHeight { get; set; }\n\n        [Export(\"shouldIncludeSafeAreaInContentHeight\")]\n        bool ShouldIncludeSafeAreaInContentHeight { get; set; }\n\n        [Export(\"drawerShadowColor\", ArgumentSemantic.Strong)]\n        UIColor DrawerShadowColor { get; set; }\n\n        [Export(\"elevation\")]\n        double Elevation { get; set; }\n\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        IBottomDrawerViewControllerDelegate Delegate { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<BottomDrawerViewController, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"setTopCornersRadius:forDrawerState:\")]\n        void SetTopCornersRadius(nfloat radius, BottomDrawerState drawerState);\n\n        [Export(\"topCornersRadiusForDrawerState:\")]\n        nfloat GetTopCornersRadius(BottomDrawerState drawerState);\n\n        [Export(\"setContentOffsetY:animated:\")]\n        void SetContentOffsetY(nfloat contentOffsetY, bool animated);\n\n        [Export(\"expandToFullscreenWithDuration:completion:\")]\n        void ExpandToFullscreenWithDuration(nfloat duration, [NullAllowed]  Action<bool> completion);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCBottomDrawerViewControllerDelegate\")]\n    interface BottomDrawerViewControllerDelegate\n    {\n        [EventArgs(\"BottomDrawerViewControllerDidChangeTopInset\")]\n        [EventName(\"TopInsetChanged\")]\n        [Abstract]\n        [Export(\"bottomDrawerControllerDidChangeTopInset:topInset:\")]\n        void DidChangeTopInset(BottomDrawerViewController controller, nfloat topInset);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCBottomDrawerColorThemer\")]\n    interface BottomDrawerColorThemer\n    {\n        [Obsolete(\"The method will shortly be deprecated.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toBottomDrawer:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, BottomDrawerViewController bottomDrawer);\n    }\n\n    [BaseType(typeof(UIWindow),\n        Name = \"MDCOverlayWindow\")]\n    interface OverlayWindow\n    {\n        [Export(\"activateOverlay:withLevel:\")]\n        void ActivateOverlay(UIView overlay, double level);\n\n        [Export(\"deactivateOverlay:\")]\n        void DeactivateOverlay(UIView overlay);\n\n        [Export(\"initWithFrame:\")]\n        IntPtr Constructor(CGRect frame);\n    }\n\n    [BaseType(typeof(UIControl),\n        Name = \"MDCPageControl\")]\n    interface PageControl : IUIScrollViewDelegate\n\n    {\n        [Export(\"numberOfPages\")]\n        nint NumberOfPages { get; set; }\n\n        [Export(\"currentPage\")]\n        nint CurrentPage { get; set; }\n\n        [Export(\"hidesForSinglePage\")]\n        bool HidesForSinglePage { get; set; }\n\n        [NullAllowed]\n        [Export(\"pageIndicatorTintColor\", ArgumentSemantic.Strong)]\n        UIColor PageIndicatorTintColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"currentPageIndicatorTintColor\", ArgumentSemantic.Strong)]\n        UIColor CurrentPageIndicatorTintColor { get; set; }\n\n        [Export(\"defersCurrentPageDisplay\")]\n        bool DefersCurrentPageDisplay { get; set; }\n\n        [Export(\"respectsUserInterfaceLayoutDirection\")]\n        bool RespectsUserInterfaceLayoutDirection { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<PageControl, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"setCurrentPage:animated:\")]\n        void SetCurrentPage(nint currentPage, bool animated);\n\n        [Export(\"updateCurrentPageDisplay\")]\n        void UpdateCurrentPageDisplay();\n\n        [Static]\n        [Export(\"sizeForNumberOfPages:\")]\n        CGSize GetSizeForNumberOfPages(nint pageCount);\n\n        [Export(\"scrollViewDidScroll:\")]\n        void ScrollViewDidScroll(UIScrollView scrollView);\n\n        [Export(\"scrollViewDidEndDecelerating:\")]\n        void ScrollViewDidEndDecelerating(UIScrollView scrollView);\n\n        [Export(\"scrollViewDidEndScrollingAnimation:\")]\n        void ScrollViewDidEndScrollingAnimation(UIScrollView scrollView);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCPageControlColorThemer\")]\n    interface PageControlColorThemer\n    {\n        [Obsolete(\"This method will soon be deprecated. There is no replacement yet.\")]\n        [Static]\n        [Export(\"applyColorScheme:toPageControl:\")]\n        void ApplyColorScheme(IColorScheme colorScheme, PageControl pageControl);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCPalette\")]\n    interface Palette\n    {\n        [Static]\n        [Export(\"redPalette\", ArgumentSemantic.Strong)]\n        Palette RedPalette { get; }\n\n        [Static]\n        [Export(\"pinkPalette\", ArgumentSemantic.Strong)]\n        Palette PinkPalette { get; }\n\n        [Static]\n        [Export(\"purplePalette\", ArgumentSemantic.Strong)]\n        Palette PurplePalette { get; }\n\n        [Static]\n        [Export(\"deepPurplePalette\", ArgumentSemantic.Strong)]\n        Palette DeepPurplePalette { get; }\n\n        [Static]\n        [Export(\"indigoPalette\", ArgumentSemantic.Strong)]\n        Palette IndigoPalette { get; }\n\n        [Static]\n        [Export(\"bluePalette\", ArgumentSemantic.Strong)]\n        Palette BluePalette { get; }\n\n        [Static]\n        [Export(\"lightBluePalette\", ArgumentSemantic.Strong)]\n        Palette LightBluePalette { get; }\n\n        [Static]\n        [Export(\"cyanPalette\", ArgumentSemantic.Strong)]\n        Palette CyanPalette { get; }\n\n        [Static]\n        [Export(\"tealPalette\", ArgumentSemantic.Strong)]\n        Palette TealPalette { get; }\n\n        [Static]\n        [Export(\"greenPalette\", ArgumentSemantic.Strong)]\n        Palette GreenPalette { get; }\n\n        [Static]\n        [Export(\"lightGreenPalette\", ArgumentSemantic.Strong)]\n        Palette LightGreenPalette { get; }\n\n        [Static]\n        [Export(\"limePalette\", ArgumentSemantic.Strong)]\n        Palette LimePalette { get; }\n\n        [Static]\n        [Export(\"yellowPalette\", ArgumentSemantic.Strong)]\n        Palette YellowPalette { get; }\n\n        [Static]\n        [Export(\"amberPalette\", ArgumentSemantic.Strong)]\n        Palette AmberPalette { get; }\n\n        [Static]\n        [Export(\"orangePalette\", ArgumentSemantic.Strong)]\n        Palette OrangePalette { get; }\n\n        [Static]\n        [Export(\"deepOrangePalette\", ArgumentSemantic.Strong)]\n        Palette DeepOrangePalette { get; }\n\n        [Static]\n        [Export(\"brownPalette\", ArgumentSemantic.Strong)]\n        Palette BrownPalette { get; }\n\n        [Static]\n        [Export(\"greyPalette\", ArgumentSemantic.Strong)]\n        Palette GreyPalette { get; }\n\n        [Static]\n        [Export(\"blueGreyPalette\", ArgumentSemantic.Strong)]\n        Palette BlueGreyPalette { get; }\n\n        [Export(\"tint50\")]\n        UIColor Tint50 { get; }\n\n        [Export(\"tint100\")]\n        UIColor Tint100 { get; }\n\n        [Export(\"tint200\")]\n        UIColor Tint200 { get; }\n\n        [Export(\"tint300\")]\n        UIColor Tint300 { get; }\n\n        [Export(\"tint400\")]\n        UIColor Tint400 { get; }\n\n        [Export(\"tint500\")]\n        UIColor Tint500 { get; }\n\n        [Export(\"tint600\")]\n        UIColor Tint600 { get; }\n\n        [Export(\"tint700\")]\n        UIColor Tint700 { get; }\n\n        [Export(\"tint800\")]\n        UIColor Tint800 { get; }\n\n        [Export(\"tint900\")]\n        UIColor Tint900 { get; }\n\n        [NullAllowed]\n        [Export(\"accent100\")]\n        UIColor Accent100 { get; }\n\n        [NullAllowed]\n        [Export(\"accent200\")]\n        UIColor Accent200 { get; }\n\n        [NullAllowed]\n        [Export(\"accent400\")]\n        UIColor Accent400 { get; }\n\n        [NullAllowed]\n        [Export(\"accent700\")]\n        UIColor Accent700 { get; }\n\n        [Field(\"MDCPaletteTint50Name\", \"__Internal\")]\n        NSString Tint50Name { get; }\n\n        [Field(\"MDCPaletteTint100Name\", \"__Internal\")]\n        NSString Tint100Name { get; }\n\n        [Field(\"MDCPaletteTint200Name\", \"__Internal\")]\n        NSString Tint200Name { get; }\n\n        [Field(\"MDCPaletteTint300Name\", \"__Internal\")]\n        NSString Tint300Name { get; }\n\n        [Field(\"MDCPaletteTint400Name\", \"__Internal\")]\n        NSString Tint400Name { get; }\n\n        [Field(\"MDCPaletteTint500Name\", \"__Internal\")]\n        NSString Tint500Name { get; }\n\n        [Field(\"MDCPaletteTint600Name\", \"__Internal\")]\n        NSString Tint600Name { get; }\n\n        [Field(\"MDCPaletteTint700Name\", \"__Internal\")]\n        NSString Tint700Name { get; }\n\n        [Field(\"MDCPaletteTint800Name\", \"__Internal\")]\n        NSString Tint800Name { get; }\n\n        [Field(\"MDCPaletteTint900Name\", \"__Internal\")]\n        NSString Tint900Name { get; }\n\n        [Field(\"MDCPaletteAccent100Name\", \"__Internal\")]\n        NSString Accent100Name { get; }\n\n        [Field(\"MDCPaletteAccent200Name\", \"__Internal\")]\n        NSString Accent200Name { get; }\n\n        [Field(\"MDCPaletteAccent400Name\", \"__Internal\")]\n        NSString Accent400Name { get; }\n\n        [Field(\"MDCPaletteAccent700Name\", \"__Internal\")]\n        NSString Accent700Name { get; }\n\n        [Static]\n        [Export(\"paletteGeneratedFromColor:\")]\n        Palette FromColor(UIColor target500Color);\n\n        [Static]\n        [Export(\"paletteWithTints:accents:\")]\n        Palette FromTints(NSDictionary<NSString, UIColor> tints, [NullAllowed]  NSDictionary<NSString, UIColor> accents);\n\n        [Export(\"initWithTints:accents:\")]\n        IntPtr Constructor(NSDictionary<NSString, UIColor> tints, [NullAllowed]  NSDictionary<NSString, UIColor> accents);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCProgressView\")]\n    interface ProgressView\n    {\n        [Export(\"progressTintColor\", ArgumentSemantic.Strong)]\n        UIColor ProgressTintColor { get; set; }\n\n        [Export(\"trackTintColor\", ArgumentSemantic.Strong)]\n        UIColor TrackTintColor { get; set; }\n\n        [Export(\"cornerRadius\")]\n        nfloat CornerRadius { get; set; }\n\n        [Export(\"progress\")]\n        float Progress { get; set; }\n\n        [Export(\"backwardProgressAnimationMode\", ArgumentSemantic.Assign)]\n        ProgressViewBackwardAnimationMode BackwardProgressAnimationMode { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<ProgressView, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"setProgress:animated:completion:\")]\n        void SetProgress(float progress, bool animated, [NullAllowed]  Action<bool> completion);\n\n        [Export(\"setHidden:animated:completion:\")]\n        void SetHidden(bool hidden, bool animated, [NullAllowed]  Action<bool> completion);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCProgressViewColorThemer\")]\n    interface ProgressViewColorThemer\n    {\n        [Obsolete(\"This method will soon be deprecated. There is no replacement yet.\")]\n        [Static]\n        [Export(\"applyColorScheme:toProgressView:\")]\n        void ApplyColorScheme(IColorScheme colorScheme, ProgressView progressView);\n    }\n\n    [Category]\n    [BaseType(typeof(ProgressView),\n        Name = \"MDCProgressView_MaterialTheming\")]\n    interface ProgressView_MaterialTheming\n    {\n        [Export(\"applyThemeWithScheme:\")]\n        void ApplyTheme(IContainerScheming scheme);\n    }\n\n    [BaseType(typeof(UIControl),\n        Name = \"MDCSlider\")]\n    interface Slider : IElevatable, IElevationOverriding\n\n    {\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        ISliderDelegate Delegate { get; set; }\n\n        [Export(\"enableRippleBehavior\")]\n        bool EnableRippleBehavior { get; set; }\n\n        [NullAllowed]\n        [Export(\"rippleColor\", ArgumentSemantic.Strong)]\n        UIColor RippleColor { get; set; }\n\n        [Export(\"thumbRadius\")]\n        nfloat ThumbRadius { get; set; }\n\n        [Export(\"thumbElevation\")]\n        nfloat ThumbElevation { get; set; }\n\n        [Export(\"thumbShadowColor\", ArgumentSemantic.Strong)]\n        UIColor ThumbShadowColor { get; set; }\n\n        [Export(\"numberOfDiscreteValues\")]\n        nuint NumberOfDiscreteValues { get; set; }\n\n        [Export(\"value\")]\n        nfloat Value { get; set; }\n\n        [Export(\"minimumValue\")]\n        nfloat MinimumValue { get; set; }\n\n        [Export(\"maximumValue\")]\n        nfloat MaximumValue { get; set; }\n\n        [Export(\"continuous\")]\n        bool Continuous { [Bind(\"isContinuous\")] get; set; }\n\n        [Export(\"filledTrackAnchorValue\")]\n        nfloat FilledTrackAnchorValue { get; set; }\n\n        [Export(\"shouldDisplayDiscreteValueLabel\")]\n        bool ShouldDisplayDiscreteValueLabel { get; set; }\n\n        [Export(\"valueLabelTextColor\", ArgumentSemantic.Strong)]\n        UIColor ValueLabelTextColor { get; set; }\n\n        [Export(\"valueLabelBackgroundColor\", ArgumentSemantic.Strong)]\n        UIColor ValueLabelBackgroundColor { get; set; }\n\n        [Export(\"thumbHollowAtStart\")]\n        bool ThumbHollowAtStart { [Bind(\"isThumbHollowAtStart\")] get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<Slider, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Obsolete(\"This API is planned for deprecation. Use SetThumbColor and SetTrackBackgroundColor methods instead.\")]\n        [Export(\"disabledColor\", ArgumentSemantic.Strong)]\n        UIColor DisabledColor { get; set; }\n\n        [Obsolete(\"This API is planned for deprecation. Use InkColor property, SetThumbColor and SetTrackFillColor methods instead.\")]\n        [Export(\"color\", ArgumentSemantic.Strong)]\n        UIColor Color { get; set; }\n\n        [Obsolete(\"This API is planned for deprecation. Use SetTrackBackgroundColor method instead.\")]\n        [Export(\"trackBackgroundColor\", ArgumentSemantic.Strong)]\n        UIColor TrackBackgroundColor { get; set; }\n\n        [Export(\"hapticsEnabled\")]\n        bool HapticsEnabled { get; set; }\n\n        [Export(\"shouldEnableHapticsForAllDiscreteValues\")]\n        bool ShouldEnableHapticsForAllDiscreteValues { get; set; }\n\n        [Export(\"statefulAPIEnabled\")]\n        bool StatefulApiEnabled { [Bind(\"isStatefulAPIEnabled\")] get; set; }\n\n        [Export(\"setThumbColor:forState:\")]\n        void SetThumbColor([NullAllowed] UIColor thumbColor, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"thumbColorForState:\")]\n        UIColor GetThumbColor(UIControlState state);\n\n        [Export(\"setTrackFillColor:forState:\")]\n        void SetTrackFillColor([NullAllowed] UIColor fillColor, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"trackFillColorForState:\")]\n        UIColor GetTrackFillColor(UIControlState state);\n\n        [Export(\"setTrackBackgroundColor:forState:\")]\n        void SetTrackBackgroundColor([NullAllowed] UIColor backgroundColor, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"trackBackgroundColorForState:\")]\n        UIColor GetTrackBackgroundColor(UIControlState state);\n\n        [Export(\"setFilledTrackTickColor:forState:\")]\n        void SetFilledTrackTickColor([NullAllowed] UIColor tickColor, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"filledTrackTickColorForState:\")]\n        UIColor GetFilledTrackTickColor(UIControlState state);\n\n        [Export(\"setBackgroundTrackTickColor:forState:\")]\n        void SetBackgroundTrackTickColor([NullAllowed] UIColor tickColor, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"backgroundTrackTickColorForState:\")]\n        UIColor GetBackgroundTrackTickColor(UIControlState state);\n\n        [Export(\"setValue:animated:\")]\n        void SetValue(nfloat value, bool animated);\n\n        [Obsolete(\"This property will be deprecated soon.\")]\n        [NullAllowed]\n        [Export(\"inkColor\", ArgumentSemantic.Strong)]\n        UIColor InkColor { get; set; }\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCSliderDelegate\")]\n    interface SliderDelegate\n    {\n        [Export(\"slider:shouldJumpToValue:\")]\n        bool ShouldJumpToValue(Slider slider, nfloat value);\n\n        [Export(\"slider:displayedStringForValue:\")]\n        string DisplayedStringForValue(Slider slider, nfloat value);\n\n        [Export(\"slider:accessibilityLabelForValue:\")]\n        string AccessibilityLabelForValue(Slider slider, nfloat value);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCSliderColorThemer\")]\n    interface SliderColorThemer\n    {\n        [Obsolete(\"This property will soon be deprecated. Consider using SemanticColorScheme class instead.\")]\n        [Static]\n        [Export(\"defaultSliderLightColorScheme\")]\n        BasicColorScheme DefaultSliderLightColorScheme { get; }\n\n        [Obsolete(\"This property will soon be deprecated. Consider using SemanticColorScheme class instead.\")]\n        [Static]\n        [Export(\"defaultSliderDarkColorScheme\")]\n        BasicColorScheme DefaultSliderDarkColorScheme { get; }\n\n        [Obsolete(\"This property will soon be deprecated. Consider using ApplySemanticColorScheme method instead.\")]\n        [Static]\n        [Export(\"applyColorScheme:toSlider:\")]\n        void ApplyColorScheme(IColorScheme colorScheme, Slider slider);\n\n        [Obsolete(\"This property will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toSlider:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, Slider slider);\n\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCSnackbarManagerDelegate\")]\n    interface SnackbarManagerDelegate\n    {\n        [Abstract]\n        [Export(\"willPresentSnackbarWithMessageView:\")]\n        void WillPresentSnackbar([NullAllowed] SnackbarMessageView messageView);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCSnackbarManager\")]\n    interface SnackbarManager : IElevationOverriding\n\n    {\n        [Static]\n        [Export(\"defaultManager\", ArgumentSemantic.Strong)]\n        SnackbarManager DefaultManager { get; }\n\n        [Export(\"alignment\", ArgumentSemantic.Assign)]\n        SnackbarAlignment Alignment { get; set; }\n\n\n        [Export(\"hasMessagesShowingOrQueued\")]\n        bool HasMessagesShowingOrQueued { get; }\n\n        [NullAllowed]\n        [Export(\"snackbarMessageViewBackgroundColor\", ArgumentSemantic.Strong)]\n        UIColor SnackbarMessageViewBackgroundColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"snackbarMessageViewShadowColor\", ArgumentSemantic.Strong)]\n        UIColor SnackbarMessageViewShadowColor { get; set; }\n\n        [Export(\"messageElevation\")]\n        double MessageElevation { get; set; }\n\n        [NullAllowed]\n        [Export(\"messageTextColor\", ArgumentSemantic.Strong)]\n        UIColor MessageTextColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"messageFont\", ArgumentSemantic.Strong)]\n        UIFont MessageFont { get; set; }\n\n        [NullAllowed]\n        [Export(\"buttonFont\", ArgumentSemantic.Strong)]\n        UIFont ButtonFont { get; set; }\n\n        [Export(\"uppercaseButtonTitle\")]\n        bool UppercaseButtonTitle { get; set; }\n\n        [Export(\"disabledButtonAlpha\")]\n        nfloat DisabledButtonAlpha { get; set; }\n\n        [NullAllowed]\n        [Export(\"buttonInkColor\", ArgumentSemantic.Strong)]\n        UIColor ButtonInkColor { get; set; }\n\n        [Export(\"shouldApplyStyleChangesToVisibleSnackbars\")]\n        bool ShouldApplyStyleChangesToVisibleSnackbars { get; set; }\n\n        [Export(\"adjustsFontForContentSizeCategoryWhenScaledFontIsUnavailable\")]\n        bool AdjustsFontForContentSizeCategoryWhenScaledFontIsUnavailable { get; set; }\n\n        [Export(\"shouldEnableAccessibilityViewIsModal\")]\n        bool ShouldEnableAccessibilityViewIsModal { get; set; }\n\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        ISnackbarManagerDelegate Delegate { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlockForMessageView\", ArgumentSemantic.Copy)]\n        Action<SnackbarMessageView, UITraitCollection> TraitCollectionDidChangeBlockForMessageView { get; set; }\n\n        [NullAllowed]\n        [Export(\"mdc_elevationDidChangeBlockForMessageView\", ArgumentSemantic.Copy)]\n        Action<IElevatable, nfloat> ElevationDidChangeBlockForMessageView { get; set; }\n\n        [Export(\"mdc_adjustsFontForContentSizeCategory\")]\n        bool AdjustsFontForContentSizeCategory { get; [Bind(\"mdc_setAdjustsFontForContentSizeCategory:\")]set; }\n\n        [Obsolete(\"Use AdjustsFontForContentSizeCategory instead\")]\n        [Wrap(\"AdjustsFontForContentSizeCategory\")]\n        bool MdcAdjustsFontForContentSizeCategory { get; set; }\n\n        [Export(\"showMessage:\")]\n        void ShowMessage([NullAllowed] SnackbarMessage message);\n\n        [Export(\"setPresentationHostView:\")]\n        void SetPresentationHostView([NullAllowed] UIView hostView);\n\n        [Export(\"dismissAndCallCompletionBlocksWithCategory:\")]\n        void DismissAndCallCompletionBlocks([NullAllowed] string category);\n\n        [Export(\"setBottomOffset:\")]\n        void SetBottomOffset(nfloat offset);\n\n        [return: NullAllowed]\n        [Export(\"suspendMessagesWithCategory:\")]\n        ISnackbarSuspensionToken SuspendMessages([NullAllowed] string category);\n\n        [Export(\"resumeMessagesWithToken:\")]\n        void ResumeMessages([NullAllowed] ISnackbarSuspensionToken token);\n\n        [return: NullAllowed]\n        [Export(\"buttonTitleColorForState:\")]\n        UIColor GetButtonTitleColor(UIControlState state);\n\n        [Export(\"setButtonTitleColor:forState:\")]\n        void SetButtonTitleColor([NullAllowed] UIColor titleColor, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"suspendAllMessages\")]\n        ISnackbarSuspensionToken SuspendAllMessages();\n    }\n\n    [Protocol(Name = \"MDCSnackbarSuspensionToken\")]\n    [BaseType(typeof(NSObject))]\n    interface SnackbarSuspensionToken\n    { }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCSnackbarMessage\")]\n    interface SnackbarMessage : INSCopying, IUIAccessibilityIdentification\n\n    {\n        [Static]\n        [Export(\"usesLegacySnackbar\")]\n        bool UsesLegacySnackbar { get; set; }\n\n        [NullAllowed]\n        [Export(\"text\")]\n        string Text { get; set; }\n\n        [NullAllowed]\n        [Export(\"attributedText\", ArgumentSemantic.Copy)]\n        NSAttributedString AttributedText { get; set; }\n\n        [NullAllowed]\n        [Export(\"action\", ArgumentSemantic.Strong)]\n        SnackbarMessageAction Action { get; set; }\n\n        [NullAllowed]\n        [Export(\"buttonTextColor\", ArgumentSemantic.Strong)]\n        UIColor ButtonTextColor { get; set; }\n\n        [Export(\"duration\")]\n        double Duration { get; set; }\n\n        [NullAllowed]\n        [Export(\"completionHandler\", ArgumentSemantic.Copy)]\n        SnackbarMessageCompletionHandler CompletionHandler { get; set; }\n\n        [NullAllowed]\n        [Export(\"category\")]\n        string Category { get; set; }\n\n        [NullAllowed]\n        [Export(\"accessibilityLabel\")]\n        string AccessibilityLabel { get; set; }\n\n        [NullAllowed]\n        [Export(\"accessibilityHint\")]\n        string AccessibilityHint { get; set; }\n\n        [NullAllowed]\n        [Export(\"voiceNotificationText\")]\n        string VoiceNotificationText { get; }\n\n        [Export(\"enableRippleBehavior\")]\n        bool EnableRippleBehavior { get; set; }\n\n        [Field(\"MDCSnackbarMessageDurationMax\", \"__Internal\")]\n        double DurationMax { get; }\n\n        [Field(\"MDCSnackbarMessageBoldAttributeName\", \"__Internal\")]\n        NSString BoldAttributeName { get; }\n\n        [Static]\n        [Export(\"messageWithText:\")]\n        SnackbarMessage Create(string text);\n\n        [Static]\n        [Export(\"messageWithAttributedText:\")]\n        SnackbarMessage Create(NSAttributedString attributedText);\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCSnackbarMessageAction\")]\n    interface SnackbarMessageAction : IUIAccessibilityIdentification, INSCopying\n\n    {\n        [NullAllowed]\n        [Export(\"title\")]\n        string Title { get; set; }\n\n        [NullAllowed]\n        [Export(\"handler\", ArgumentSemantic.Copy)]\n        SnackbarMessageActionHandler Handler { get; set; }\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCSnackbarMessageView\")]\n    interface SnackbarMessageView : IElevatable, IElevationOverriding\n\n    {\n        [NullAllowed]\n        [Export(\"snackbarMessageViewBackgroundColor\", ArgumentSemantic.Strong)]\n        UIColor SnackbarMessageViewBackgroundColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"snackbarMessageViewShadowColor\", ArgumentSemantic.Strong)]\n        UIColor SnackbarMessageViewShadowColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"messageTextColor\", ArgumentSemantic.Strong)]\n        UIColor MessageTextColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"messageFont\", ArgumentSemantic.Strong)]\n        UIFont MessageFont { get; set; }\n\n        [NullAllowed]\n        [Export(\"buttonFont\", ArgumentSemantic.Strong)]\n        UIFont ButtonFont { get; set; }\n\n        [NullAllowed]\n        [Export(\"actionButtons\", ArgumentSemantic.Strong)]\n        NSMutableArray<Button> ActionButtons { get; set; }\n\n        [Export(\"elevation\")]\n        double Elevation { get; set; }\n\n        [NullAllowed]\n        [Export(\"accessibilityLabel\")]\n        string AccessibilityLabel { get; set; }\n\n        [NullAllowed]\n        [Export(\"accessibilityHint\")]\n        string AccessibilityHint { get; set; }\n\n        [Export(\"adjustsFontForContentSizeCategoryWhenScaledFontIsUnavailable\")]\n        bool AdjustsFontForContentSizeCategoryWhenScaledFontIsUnavailable { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<SnackbarMessageView, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"mdc_adjustsFontForContentSizeCategory\")]\n        bool AdjustsFontForContentSizeCategory { get; [Bind(\"mdc_setAdjustsFontForContentSizeCategory:\")]set; }\n\n        [Obsolete(\"Use AdjustsFontForContentSizeCategory instead\")]\n        [Wrap(\"AdjustsFontForContentSizeCategory\")]\n        bool MdcAdjustsFontForContentSizeCategory { get; set; }\n\n        [return: NullAllowed]\n        [Export(\"buttonTitleColorForState:\")]\n        UIColor GetButtonTitleColor(UIControlState state);\n\n        [Export(\"setButtonTitleColor:forState:\")]\n        void SetButtonTitleColor([NullAllowed] UIColor titleColor, UIControlState state);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCSnackbarColorThemer\")]\n    interface SnackbarColorThemer\n    {\n        [Obsolete(\"This method will be deprecated soon.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme);\n\n        [Obsolete(\"This method will be deprecated soon.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toSnackbarManager:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, SnackbarManager snackbarManager);\n\n        [Obsolete(\"This method will be deprecated soon.\")]\n        [Static]\n        [Export(\"applyColorScheme:toSnackbarMessageView:\")]\n        void ApplyColorScheme(IColorScheme colorScheme, SnackbarMessageView snackbarMessageView);\n    }\n\n    [Obsolete(\"This class will soon be deprecated. Please consider using SnackbarTypographyThemer class instead.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCSnackbarFontThemer\")]\n    interface SnackbarFontThemer\n    {\n        [Obsolete(\"This method will be deprecated soon.\")]\n        [Static]\n        [Export(\"applyFontScheme:toSnackbarMessageView:\")]\n        void ApplyFontScheme (IFontScheme fontScheme, SnackbarMessageView snackbarMessageView);\n\n        [Obsolete(\"This method will be deprecated soon.\")]\n        [Static]\n        [Export(\"applyFontScheme:\")]\n        void ApplyFontScheme (IFontScheme fontScheme);\n\n    }\n\n    [Obsolete(\"This class will be deprecated soon.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCSnackbarTypographyThemer\")]\n    interface SnackbarTypographyThemer\n    {\n        [Obsolete(\"This method will be deprecated soon.\")]\n        [Static]\n        [Export(\"applyTypographyScheme:\")]\n        void ApplyTypographyScheme (ITypographyScheming typographyScheme);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCTabBar\",\n        Delegates = new[] { \"Delegate\" },\n        Events = new[] { typeof(TabBarDelegate) })]\n    interface TabBar : IUIBarPositioning, IElevatable, IElevationOverriding\n\n    {\n        [Export(\"items\", ArgumentSemantic.Copy)]\n        UITabBarItem[] Items { get; set; }\n\n        [NullAllowed]\n        [Export(\"selectedItem\", ArgumentSemantic.Strong)]\n        UITabBarItem SelectedItem { get; set; }\n\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        ITabBarDelegate Delegate { get; set; }\n\n        [New]\n        [Export(\"tintColor\", ArgumentSemantic.Strong)]\n        UIColor TintColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"selectedItemTintColor\", ArgumentSemantic.Assign)]\n        UIColor SelectedItemTintColor { get; set; }\n\n        [Export(\"unselectedItemTintColor\", ArgumentSemantic.Assign)]\n        UIColor UnselectedItemTintColor { get; set; }\n\n        [Export(\"enableRippleBehavior\")]\n        bool EnableRippleBehavior { get; set; }\n\n        [Export(\"rippleColor\", ArgumentSemantic.Assign)]\n        UIColor RippleColor { get; set; }\n\n        [Export(\"bottomDividerColor\", ArgumentSemantic.Assign)]\n        UIColor BottomDividerColor { get; set; }\n\n        [Export(\"selectedItemTitleFont\", ArgumentSemantic.Strong)]\n        UIFont SelectedItemTitleFont { get; set; }\n\n        [Export(\"unselectedItemTitleFont\", ArgumentSemantic.Strong)]\n        UIFont UnselectedItemTitleFont { get; set; }\n\n        [NullAllowed]\n        [Export(\"barTintColor\", ArgumentSemantic.Assign)]\n        UIColor BarTintColor { get; set; }\n\n        [Export(\"alignment\", ArgumentSemantic.Assign)]\n        TabBarAlignment Alignment { get; set; }\n\n        [Export(\"itemAppearance\", ArgumentSemantic.Assign)]\n        TabBarItemAppearance ItemAppearance { get; set; }\n\n        [Obsolete(\"This property will be deprecated in a future release. Use TitleTextTransform property instead.\")]\n        [Export(\"displaysUppercaseTitles\")]\n        bool DisplaysUppercaseTitles { get; set; }\n\n        [Export(\"titleTextTransform\", ArgumentSemantic.Assign)]\n        TabBarTextTransform TitleTextTransform { get; set; }\n\n        [Export(\"selectionIndicatorTemplate\", ArgumentSemantic.Assign)]\n        TabBarIndicatorTemplate SelectionIndicatorTemplate { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<TabBar, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Static]\n        [Export(\"defaultHeightForBarPosition:itemAppearance:\")]\n        nfloat GetDefaultHeight(UIBarPosition position, TabBarItemAppearance appearance);\n\n        [Static]\n        [Export(\"defaultHeightForItemAppearance:\")]\n        nfloat GetDefaultHeight(TabBarItemAppearance appearance);\n\n        [Export(\"setSelectedItem:animated:\")]\n        void SetSelectedItem([NullAllowed] UITabBarItem selectedItem, bool animated);\n\n        [Export(\"setAlignment:animated:\")]\n        void SetAlignment(TabBarAlignment alignment, bool animated);\n\n        [Export(\"setTitleColor:forState:\")]\n        void SetTitleColor([NullAllowed] UIColor color, TabBarItemState state);\n\n        [return: NullAllowed]\n        [Export(\"titleColorForState:\")]\n        UIColor GetTitleColor(TabBarItemState state);\n\n        [Export(\"setImageTintColor:forState:\")]\n        void SetImageTintColor([NullAllowed] UIColor color, TabBarItemState state);\n\n        [return: NullAllowed]\n        [Export(\"imageTintColorForState:\")]\n        UIColor GetImageTintColor(TabBarItemState state);\n\n        [return: NullAllowed]\n        [Export(\"accessibilityElementForItem:\")]\n        NSObject GetAccessibilityElement(UITabBarItem item);\n\n        [Wrap(\"WeakSizeClassDelegate\")]\n        [NullAllowed]\n        [Static]\n        ITabBarSizeClassDelegate SizeClassDelegate { get; set; }\n\n        [NullAllowed]\n        [Export(\"sizeClassDelegate\", ArgumentSemantic.Weak)]\n        [Static]\n        NSObject WeakSizeClassDelegate { get; set; }\n\n        [Wrap(\"WeakDisplayDelegate\")]\n        [NullAllowed]\n        [Static]\n        ITabBarDisplayDelegate DisplayDelegate { get; set; }\n\n        [NullAllowed]\n        [Export(\"displayDelegate\", ArgumentSemantic.Weak)]\n        [Static]\n        NSObject WeakDisplayDelegate { get; set; }\n\n        [Obsolete(\"This property will be deprecated soon.\")]\n        [Export(\"inkColor\", ArgumentSemantic.Assign)]\n        UIColor InkColor { get; set; }\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTabBarDelegate\")]\n    interface TabBarDelegate : IUIBarPositioningDelegate\n\n    {\n        [DefaultValue(true)]\n        [DelegateName(\"TabBarShouldSelectItem\")]\n        [Export(\"tabBar:shouldSelectItem:\")]\n        bool ShouldSelectItem(TabBar tabBar, UITabBarItem item);\n\n        [EventArgs(\"TabBarWillSelectItem\")]\n        [Obsolete(\"Will be deprecated. Use ShouldSelectItem method instead.\")]\n        [Export(\"tabBar:willSelectItem:\")]\n        void WillSelectItem(TabBar tabBar, UITabBarItem item);\n\n        [EventArgs(\"TabBarItemSelected\")]\n        [EventName(\"ItemSelected\")]\n        [Export(\"tabBar:didSelectItem:\")]\n        void DidSelectItem(TabBar tabBar, UITabBarItem item);\n\n        [Export(\"inkColor\", ArgumentSemantic.Assign)]\n        [Static]\n        UIColor InkColor { get; set; }\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTabBarIndicatorAttributes\")]\n    interface TabBarIndicatorAttributes : INSCopying\n\n    {\n        [NullAllowed]\n        [Export(\"path\", ArgumentSemantic.Assign)]\n        UIBezierPath Path { get; set; }\n    }\n\n    [Protocol(Name = \"MDCTabBarIndicatorContext\")]\n    [BaseType(typeof(NSObject))]\n    interface TabBarIndicatorContext\n    {\n        [Abstract]\n        [Export(\"item\")]\n        UITabBarItem Item { get; }\n\n        [Abstract]\n        [Export(\"bounds\")]\n        CGRect Bounds { get; }\n\n        [Abstract]\n        [Export(\"contentFrame\")]\n        CGRect ContentFrame { get; }\n    }\n\n    [Protocol(Name = \"MDCTabBarIndicatorTemplate\")]\n    [BaseType(typeof(NSObject))]\n    interface TabBarIndicatorTemplate\n    {\n        [Abstract]\n        [Export(\"indicatorAttributesForContext:\")]\n        TabBarIndicatorAttributes IndicatorAttributesForContext(ITabBarIndicatorContext context);\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTabBarUnderlineIndicatorTemplate\")]\n    interface TabBarUnderlineIndicatorTemplate : TabBarIndicatorTemplate\n\n    { }\n\n    [BaseType(typeof(UIViewController),\n        Name = \"MDCTabBarViewController\",\n        Delegates = new[] { \"Delegate\" },\n        Events = new[] { typeof(TabBarControllerDelegate) })]\n    interface TabBarViewController : TabBarDelegate, IUIBarPositioningDelegate\n\n    {\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        ITabBarControllerDelegate Delegate { get; set; }\n\n        [Export(\"viewControllers\", ArgumentSemantic.Copy)]\n        UIViewController[] ViewControllers { get; set; }\n\n        [NullAllowed]\n        [Export(\"selectedViewController\", ArgumentSemantic.Weak)]\n        UIViewController SelectedViewController { get; set; }\n\n        [NullAllowed]\n        [Export(\"tabBar\")]\n        TabBar TabBar { get; }\n\n        [Export(\"tabBarHidden\")]\n        bool TabBarHidden { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<TabBarViewController, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Field(\"MDCTabBarViewControllerAnimationDuration\", \"__Internal\")]\n        nfloat AnimationDuration { get; }\n\n        [Export(\"setTabBarHidden:animated:\")]\n        void SetTabBarHidden(bool hidden, bool animated);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTabBarControllerDelegate\")]\n    interface TabBarControllerDelegate\n    {\n        [DefaultValue(true)]\n        [DelegateName(\"TabBarControllerShouldSelectViewController\")]\n        [Export(\"tabBarController:shouldSelectViewController:\")]\n        bool ShouldSelectViewController(TabBarViewController tabBarController, UIViewController viewController);\n\n        [EventArgs(\"TabBarControllerViewControllerSelected\")]\n        [EventName(\"ViewControllerSelected\")]\n        [Export(\"tabBarController:didSelectViewController:\")]\n        void DidSelectViewController(TabBarViewController tabBarController, UIViewController viewController);\n    }\n\n    [Protocol(Name = \"MDCTabBarDisplayDelegate\")]\n    interface TabBarDisplayDelegate\n    {\n        [Abstract]\n        [Export(\"tabBar:willDisplayItem:\")]\n        void WillDisplayItem(TabBar tabBar, UITabBarItem item);\n\n        [Abstract]\n        [Export(\"tabBar:didEndDisplayingItem:\")]\n        void DidEndDisplayingItem(TabBar tabBar, UITabBarItem item);\n    }\n\n\n    [Protocol(Name = \"MDCTabBarSizeClassDelegate\")]\n    interface TabBarSizeClassDelegate\n    {\n        [Export(\"horizontalSizeClassForObject:\")]\n        long HorizontalSizeClassForObject(IUITraitEnvironment @object);\n    }\n\n    [Obsolete(\"This class will soon be deprecated.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTabBarColorThemer\")]\n    interface TabBarColorThemer\n    {\n        [Obsolete(\"This method will soon be deprecated. Consider using ApplySemanticColorScheme method instead.\")]\n        [Static]\n        [Export(\"applyColorScheme:toTabBar:\")]\n        void ApplyColorScheme (IColorScheme colorScheme, TabBar tabBar);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toTabs:\")]\n        void ApplySemanticColorScheme (IColorScheming colorScheme, TabBar tabBar);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySurfaceVariantWithColorScheme:toTabs:\")]\n        void ApplySurfaceVariant (IColorScheming colorScheme, TabBar tabBar);\n    }\n\n    [Obsolete(\"This class will soon be deprecated. Please consider using TabBarTypographyThemer class instead.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTabBarFontThemer\")]\n    interface TabBarFontThemer\n    {\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyFontScheme:toTabBar:\")]\n        void ApplyFontScheme (IFontScheme fontScheme, TabBar tabBar);\n    }\n\n    [Category]\n    [BaseType(typeof(TabBar),\n        Name = \"MDCTabBar_MaterialTheming\")]\n    interface TabBar_MaterialTheming\n    {\n        [Export(\"applyPrimaryThemeWithScheme:\")]\n        void ApplyPrimaryThemeWithScheme(IContainerScheming scheme);\n\n        [Export(\"applySurfaceThemeWithScheme:\")]\n        void ApplySurfaceThemeWithScheme(IContainerScheming scheme);\n    }\n\n    [Obsolete(\"This class will soon be deprecated.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTabBarTypographyThemer\")]\n    interface TabBarTypographyThemer\n    {\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyTypographyScheme:toTabBar:\")]\n        void ApplyTypographyScheme (ITypographyScheming typographyScheme, TabBar tabBar);\n    }\n\n    [Obsolete(\"This class will soon be deprecated.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCFilledTextFieldColorThemer\")]\n    interface FilledTextFieldColorThemer\n    {\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toTextInputControllerFilled:\")]\n        void ApplySemanticColorScheme (IColorScheming colorScheme, TextInputControllerFilled textInputControllerFilled);\n    }\n\n    [Obsolete(\"This class will soon be deprecated.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCOutlinedTextFieldColorThemer\")]\n    interface OutlinedTextFieldColorThemer\n    {\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toTextInputController:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, ITextInputController textInputController);\n    }\n\n    [Obsolete(\"This class will soon be deprecated.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTextFieldColorThemer\")]\n    interface TextFieldColorThemer\n    {\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toTextInputController:\")]\n        void ApplySemanticColorScheme (IColorScheming colorScheme, ITextInputController textInputController);\n\n        [Wrap(\"ApplySemanticColorScheme (colorScheme, textInputController)\")]\n        [Obsolete(\"Use ApplySemanticColorScheme instead.\")]\n        [Static]\n        void ApplySemanticColorSchemeToTextInput (IColorScheming colorScheme, ITextInputController textInputController);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toAllTextInputControllersOfClass:\")]\n        void ApplySemanticColorSchemeToAll (IColorScheming colorScheme, Class textInputControllerClass);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Wrap(\"ApplySemanticColorSchemeToAll (colorScheme, new Class (textInputControllerType))\")]\n        void ApplySemanticColorSchemeToAll (IColorScheming colorScheme, Type textInputControllerType);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toTextInput:\")]\n        void ApplySemanticColorScheme (IColorScheming colorScheme, ITextInput textInput);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyColorScheme:toTextInputController:\")]\n        void ApplyColorScheme (IColorScheme colorScheme, ITextInputController textInputController);\n\n        [Obsolete(\"This method will soon be deprecated. Consider using ApplySemanticColorScheme method instead.\")]\n        [Static]\n        [Wrap(\"ApplyColorScheme (colorScheme, textInputController)\")]\n        void ApplyColorSchemeToTextInputController(IColorScheme colorScheme, ITextInputController textInputController);\n\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyColorScheme:toAllTextInputControllersOfClass:\")]\n        void ApplyColorScheme (IColorScheme colorScheme, Class textInputControllerClass);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Wrap(\"ApplyColorScheme (colorScheme, new Class (textInputControllerType))\")]\n        void ApplyColorScheme (IColorScheme colorScheme, Type textInputControllerType);\n\n        [Static]\n        [Wrap(\"ApplySemanticColorScheme (colorScheme, textInputController)\")]\n        [Obsolete(\"Use ApplySemanticColorScheme instead.\")]\n        void ApplySemanticColorSchemeToTextInputController(IColorScheming colorScheme, ITextInputController textInputController);\n\n        [Obsolete(\"This method will soon be deprecated. Consider using ApplySemanticColorSchemeToAll method instead.\")]\n        [Static]\n        [Wrap(\"ApplyColorScheme (colorScheme, textInputControllerClass)\")]\n        void ApplyColorSchemeoAllTextInputControllersOfClass(IColorScheme colorScheme, Class textInputControllerClass);\n\n        [Static]\n        [Wrap(\"ApplySemanticColorScheme (colorScheme, textInput)\")]\n        [Obsolete(\"Use ApplySemanticColorScheme instead.\")]\n        void ApplySemanticColorSchemeToTextInput(IColorScheming colorScheme, ITextInput textInput);\n\n    }\n\n    [BaseType(typeof(UITextField),\n    Name = \"MDCBaseTextField\")]\n    interface BaseTextField\n    {\n        [Export(\"label\", ArgumentSemantic.Strong)]\n        UILabel Label { get; }\n\n        [Export(\"labelBehavior\", ArgumentSemantic.Assign)]\n        TextControlLabelBehavior LabelBehavior { get; set; }\n\n        [NullAllowed]\n        [Export(\"leadingView\", ArgumentSemantic.Strong)]\n        UIView LeadingView { get; set; }\n\n        [NullAllowed]\n        [Export(\"trailingView\", ArgumentSemantic.Strong)]\n        UIView TrailingView { get; set; }\n\n        [Export(\"leadingViewMode\", ArgumentSemantic.Assign)]\n        UITextFieldViewMode LeadingViewMode { get; set; }\n\n        [Export(\"trailingViewMode\", ArgumentSemantic.Assign)]\n        UITextFieldViewMode TrailingViewMode { get; set; }\n    }\n\n    [Obsolete(\" This class will soon be deprecated. Please consider using TextFieldTypographyThemer class instead.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTextFieldFontThemer\")]\n    interface TextFieldFontThemer\n    {\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyFontScheme:toTextInputController:\")]\n        void ApplyFontScheme(IFontScheme fontScheme, ITextInputController textInputController);\n\n        [Wrap(\"ApplyFontScheme (fontScheme, textInputController)\")]\n        [Obsolete(\"Use ApplyFontScheme instead.\")]\n        [Static]\n        void ApplyFontSchemeToTextInputController(IFontScheme fontScheme, ITextInputController textInputController);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyFontScheme:toAllTextInputControllersOfClass:\")]\n        void ApplyFontSchemeToAll(IFontScheme fontScheme, Class textInputControllerClass);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Wrap(\"ApplyFontSchemeToAll (fontScheme, new Class (textInputControllerType))\")]\n        void ApplyFontSchemeToAll(IFontScheme fontScheme, Type textInputControllerType);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyFontScheme:toTextField:\")]\n        void ApplyFontScheme(IFontScheme fontScheme, [NullAllowed]  TextField textField);\n\n        [Wrap(\"ApplyFontScheme (fontScheme, textField)\")]\n        [Obsolete(\"Use ApplyFontScheme instead.\")]\n        [Static]\n        void ApplyFontSchemeToTextField(IFontScheme fontScheme, TextField textField);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyFontScheme:toTextInputController:\")]\n        void ApplyFontScheme(FontScheme fontScheme, ITextInputController textInputController);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyFontScheme:toAllTextInputControllersOfClass:\")]\n        void ApplyFontSchemeToAll(FontScheme fontScheme, ITextInputController textInputControllerClass);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyFontScheme:toTextField:\")]\n        void ApplyFontScheme(FontScheme fontScheme, [NullAllowed]  TextField textField);\n    }\n\n    [Category]\n    [BaseType(typeof(TextInputControllerFilled),\n        Name = \"MDCTextInputControllerFilled_MaterialTheming\")]\n    interface TextInputControllerFilled_MaterialTheming\n    {\n        [Export(\"applyThemeWithScheme:\")]\n        void ApplyTheme(IContainerScheming scheme);\n    }\n\n    [Category]\n    [BaseType(typeof(TextInputControllerOutlined),\n        Name = \"MDCTextInputControllerOutlined_MaterialTheming\")]\n    interface TextInputControllerOutlined_MaterialTheming\n    {\n        [Export(\"applyThemeWithScheme:\")]\n        void ApplyTheme(IContainerScheming scheme);\n    }\n\n    [Obsolete(\" This class will soon be deprecated.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTextFieldTypographyThemer\")]\n    interface TextFieldTypographyThemer\n    {\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyTypographyScheme:toTextInputController:\")]\n        void ApplyTypographyScheme(ITypographyScheming typographyScheme, ITextInputController textInputController);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyTypographyScheme:toAllTextInputControllersOfClass:\")]\n        void ApplyTypographySchemeToAll(ITypographyScheming typographyScheme, Class textInputControllerClass);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Wrap(\"ApplyTypographySchemeToAll (typographyScheme, new Class (textInputControllerType))\")]\n        [Static]\n        void ApplyTypographySchemeToAll(ITypographyScheming typographyScheme, Type textInputControllerType);\n\n        [Wrap(\"ApplyTypographyScheme (typographyScheme, textInputController)\")]\n        [Obsolete(\"Use ApplyTypographyScheme instead.\")]\n        [Static]\n        void ApplyTypographySchemeToTextInputController(ITypographyScheming typographyScheme, ITextInputController textInputController);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyTypographyScheme:toTextInput:\")]\n        void ApplyTypographyScheme(ITypographyScheming typographyScheme, ITextInput textInput);\n\n        [Wrap(\"ApplyTypographyScheme (typographyScheme, textInput)\")]\n        [Obsolete(\"Use ApplyTypographyScheme instead.\")]\n        [Static]\n        void ApplyTypographySchemeToTextInput(ITypographyScheming typographyScheme, ITextInput textInput);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyTypographyScheme:toTextInputController:\")]\n        void ApplyTypographyScheme(TypographyScheming typographyScheme, ITextInputController textInputController);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyTypographyScheme:toAllTextInputControllersOfClass:\")]\n        void ApplyTypographySchemeToAll(TypographyScheming typographyScheme, ITextInputController textInputControllerClass);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyTypographyScheme:toTextInput:\")]\n        void ApplyTypographyScheme(TypographyScheming typographyScheme, ITextInput textInput);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCFontScaler\")]\n    interface FontScaler\n    {\n        [DesignatedInitializer]\n        [Export(\"initForMaterialTextStyle:\")]\n        IntPtr Constructor(string textStyle);\n\n        [Static]\n        [Export(\"scalerForMaterialTextStyle:\")]\n        FontScaler ScalerForMaterialTextStyle(string textStyle);\n\n        [Export(\"scaledFontWithFont:\")]\n        UIFont ScaledFontWithFont(UIFont font);\n\n        [Export(\"scaledValueForValue:\")]\n        nfloat ScaledValueForValue(nfloat value);\n    }\n\n    [Obsolete(\"This interface will soon be deprecated. Consider using TypographyScheme from the schemes\/Typography component instead.\")]\n    [Protocol(Name = \"MDCTypographyFontLoading\")]\n    [BaseType(typeof(NSObject))]\n    interface TypographyFontLoading\n    {\n        [return: NullAllowed]\n        [Abstract]\n        [Export(\"lightFontOfSize:\")]\n        UIFont GetLightFont(nfloat fontSize);\n\n        [Abstract]\n        [Export(\"regularFontOfSize:\")]\n        UIFont GetRegularFont(nfloat fontSize);\n\n        [return: NullAllowed]\n        [Abstract]\n        [Export(\"mediumFontOfSize:\")]\n        UIFont GetMediumFont(nfloat fontSize);\n\n        [Export(\"boldFontOfSize:\")]\n        UIFont GetBoldFont(nfloat fontSize);\n\n        [Export(\"italicFontOfSize:\")]\n        UIFont GetItalicFont(nfloat fontSize);\n\n        [return: NullAllowed]\n        [Export(\"boldItalicFontOfSize:\")]\n        UIFont GetBoldItalicFont(nfloat fontSize);\n\n        [Export(\"boldFontFromFont:\")]\n        UIFont GetBoldFont(UIFont font);\n\n        [Export(\"italicFontFromFont:\")]\n        UIFont GetItalicFont(UIFont font);\n\n        [Export(\"isLargeForContrastRatios:\")]\n        bool IsLargeForContrastRatios(UIFont font);\n    }\n\n    [Obsolete(\"This class will soon be deprecated. Consider using TypographyScheme from the schemes\/Typography component instead.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTypography\")]\n    interface Typography\n    {\n        [Static]\n\n        [Export(\"fontLoader\")]\n        ITypographyFontLoading FontLoader { get; set; }\n\n        [Static]\n\n        [Export(\"display4Font\")]\n        UIFont Display4Font { get; }\n\n        [Static]\n\n        [Export(\"display4FontOpacity\")]\n        nfloat Display4FontOpacity { get; }\n\n        [Static]\n\n        [Export(\"display3Font\")]\n        UIFont Display3Font { get; }\n\n        [Static]\n\n        [Export(\"display3FontOpacity\")]\n        nfloat Display3FontOpacity { get; }\n\n        [Static]\n\n        [Export(\"display2Font\")]\n        UIFont Display2Font { get; }\n\n        [Static]\n\n        [Export(\"display2FontOpacity\")]\n        nfloat Display2FontOpacity { get; }\n\n        [Static]\n\n        [Export(\"display1Font\")]\n        UIFont Display1Font { get; }\n\n        [Static]\n\n        [Export(\"display1FontOpacity\")]\n        nfloat Display1FontOpacity { get; }\n\n        [Static]\n\n        [Export(\"headlineFont\")]\n        UIFont HeadlineFont { get; }\n\n        [Static]\n\n        [Export(\"headlineFontOpacity\")]\n        nfloat HeadlineFontOpacity { get; }\n\n        [Static]\n\n        [Export(\"titleFont\")]\n        UIFont TitleFont { get; }\n\n        [Static]\n\n        [Export(\"titleFontOpacity\")]\n        nfloat TitleFontOpacity { get; }\n\n        [Static]\n\n        [Export(\"subheadFont\")]\n        UIFont SubheadFont { get; }\n\n        [Static]\n\n        [Export(\"subheadFontOpacity\")]\n        nfloat SubheadFontOpacity { get; }\n\n        [Static]\n\n        [Export(\"body2Font\")]\n        UIFont Body2Font { get; }\n\n        [Static]\n\n        [Export(\"body2FontOpacity\")]\n        nfloat Body2FontOpacity { get; }\n\n        [Static]\n\n        [Export(\"body1Font\")]\n        UIFont Body1Font { get; }\n\n        [Static]\n\n        [Export(\"body1FontOpacity\")]\n        nfloat Body1FontOpacity { get; }\n\n        [Static]\n\n        [Export(\"captionFont\")]\n        UIFont CaptionFont { get; }\n\n        [Static]\n\n        [Export(\"captionFontOpacity\")]\n        nfloat CaptionFontOpacity { get; }\n\n        [Static]\n\n        [Export(\"buttonFont\")]\n        UIFont ButtonFont { get; }\n\n        [Static]\n\n        [Export(\"buttonFontOpacity\")]\n        nfloat ButtonFontOpacity { get; }\n\n        [Static]\n        [Export(\"boldFontFromFont:\")]\n        UIFont GetBoldFont(UIFont font);\n\n        [Static]\n        [Export(\"italicFontFromFont:\")]\n        UIFont GetItalicFont(UIFont font);\n\n        [Static]\n        [Export(\"isLargeForContrastRatios:\")]\n        bool IsLargeForContrastRatios(UIFont font);\n    }\n\n    [Obsolete(\"This class will soon be deprecated. Consider using TypographyScheme from the schemes\/Typography component instead.\")]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCSystemFontLoader\")]\n    interface SystemFontLoader : TypographyFontLoading\n    { }\n\n    [Category]\n    [BaseType(typeof(UIFont))]\n    interface UIFont_MaterialScalable\n    {\n        [NullAllowed]\n        [Export(\"mdc_scalingCurve\", ArgumentSemantic.Copy)]\n        [Static]\n        NSDictionary<NSString, NSNumber> ScalingCurve { get; [Bind(\"mdc_setScalingCurve:\")]set; }\n\n        [Export(\"mdc_scaledFontAtDefaultSize\")]\n        [Static]\n        UIFont ScaledFontAtDefaultSize { get; }\n\n        [Export(\"mdc_scaledFontForCurrentSizeCategory\")]\n        [Static]\n        UIFont ScaledFontForCurrentSizeCategory { get; }\n\n        [Export(\"mdc_scaledFontForSizeCategory:\")]\n        UIFont ScaledFontForSizeCategory(string sizeCategory);\n\n        [Export(\"mdc_scaledFontForTraitEnvironment:\")]\n        UIFont ScaledFontForTraitEnvironment(IUITraitEnvironment traitEnvironment);\n    }\n\n    [Category]\n    [BaseType(typeof(UIFont))]\n    interface UIFont_MaterialSimpleEquality\n    {\n        [Export(\"mdc_isSimplyEqual:\")]\n        bool IsSimplyEqual(UIFont font);\n\n        [Wrap(\"IsSimplyEqual(This, font)\")]\n        bool MdcIsSimplyEqual(UIFont font);\n    }\n\n    [Category]\n    [BaseType(typeof(UIFont))]\n    interface UIFont_MaterialTypography\n    {\n        [Export(\"mdc_fontSizedForMaterialTextStyle:scaledForDynamicType:\")]\n        UIFont GetFontSized(FontTextStyle style, bool scaled);\n\n        [Wrap(\"GetFontSized(This, style,scaled)\")]\n        UIFont MdcGetFontSized(FontTextStyle style, bool scaled);\n    }\n\n    [Category]\n    [BaseType(typeof(UIColor))]\n    interface UIColor_MaterialBlending\n    {\n        [Static]\n        [Export(\"mdc_blendColor:withBackgroundColor:\")]\n        UIColor BlendColor(UIColor color, UIColor backgroundColor);\n    }\n\n    [Category]\n    [BaseType(typeof(UIColor))]\n    interface UIColor_MaterialDynamic\n    {\n        [Static]\n        [Export(\"colorWithUserInterfaceStyleDarkColor:defaultColor:\")]\n        UIColor ColorWithUserInterfaceStyleDarkColor(UIColor darkColor, UIColor defaultColor);\n\n        [Export(\"mdc_resolvedColorWithTraitCollection:\")]\n        UIColor ResolvedColorWithTraitCollection(UITraitCollection traitCollection);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCIcons\")]\n    interface Icons\n    {\n        [Static]\n        [Export(\"pathFor_ic_arrow_back\")]\n        string IcArrowBackPath { get; }\n\n        [NullAllowed]\n        [Static]\n        [Export(\"imageFor_ic_arrow_back\")]\n        UIImage IcArrowBackImage { get; }\n\n        [Static]\n        [Export(\"pathFor_ic_check_circle\")]\n        string IcCheckCirclePath { get; }\n\n        [NullAllowed]\n        [Static]\n        [Export(\"imageFor_ic_check_circle\")]\n        UIImage IcCheckCircleImage { get; }\n\n        [Static]\n        [Export(\"pathFor_ic_check\")]\n        string IcCheckPath { get; }\n\n        [NullAllowed]\n        [Static]\n        [Export(\"imageFor_ic_check\")]\n        UIImage IcCheckImage { get; }\n\n        [Static]\n        [Export(\"pathFor_ic_chevron_right\")]\n        string PathForIcChevronRight { get; }\n\n        [NullAllowed]\n        [Static]\n        [Export(\"imageFor_ic_chevron_right\")]\n        UIImage ImageForIcChevronRight { get; }\n\n        [Static]\n        [Export(\"pathFor_ic_color_lens\")]\n        string IcColorLensPath { get; }\n\n        [NullAllowed]\n        [Static]\n        [Export(\"imageFor_ic_color_lens\")]\n        UIImage IcColorLensImage { get; }\n\n        [Static]\n        [Export(\"pathFor_ic_help_outline\")]\n        string IcHelpOutlinePath { get; }\n\n        [NullAllowed]\n        [Static]\n        [Export(\"imageFor_ic_help_outline\")]\n        UIImage IcHelpOutlineImage { get; }\n\n        [Static]\n        [Export(\"pathFor_ic_info\")]\n        string IcInfoPath { get; }\n\n        [NullAllowed]\n        [Static]\n        [Export(\"imageFor_ic_info\")]\n        UIImage IcInfoImage { get; }\n\n        [Static]\n        [Export(\"pathFor_ic_more_horiz\")]\n        string IcMoreHorizPath { get; }\n\n        [NullAllowed]\n        [Static]\n        [Export(\"imageFor_ic_more_horiz\")]\n        UIImage IcMoreHorizImage { get; }\n\n        [Static]\n        [Export(\"pathFor_ic_radio_button_unchecked\")]\n        string IcRadioButtonUncheckedPath { get; }\n\n        [NullAllowed]\n        [Static]\n        [Export(\"imageFor_ic_radio_button_unchecked\")]\n        UIImage IcRadioButtonUncheckedImage { get; }\n\n        [Static]\n        [Export(\"pathFor_ic_reorder\")]\n        string IcReorderPath { get; }\n\n        [NullAllowed]\n        [Static]\n        [Export(\"imageFor_ic_reorder\")]\n        UIImage IcReorderImage { get; }\n\n        [Static]\n        [Export(\"pathFor_ic_settings\")]\n        string IcSettingsPath { get; }\n\n        [NullAllowed]\n        [Static]\n        [Export(\"imageFor_ic_settings\")]\n        UIImage IcSettingsImage { get; }\n\n        [Static]\n        [Export(\"ic_arrow_backUseNewStyle:\")]\n        void IcArrowBackUseNewStyle(bool useNewStyle);\n\n        [Static]\n        [Export(\"pathForIconName:withBundleName:\")]\n        string GetPath(string iconName, string bundleName);\n\n        [Static]\n        [return: NullAllowed]\n        [Export(\"bundleNamed:\")]\n        NSBundle GetBundleNamed(string bundleName);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCKeyboardWatcher\")]\n    interface KeyboardWatcher\n    {\n        [Export(\"visibleKeyboardHeight\")]\n        nfloat VisibleKeyboardHeight { get; }\n\n        [Notification]\n        [Field(\"MDCKeyboardWatcherKeyboardWillShowNotification\", \"__Internal\")]\n        NSString KeyboardWillShowNotification { get; }\n\n        [Notification]\n        [Field(\"MDCKeyboardWatcherKeyboardWillHideNotification\", \"__Internal\")]\n        NSString KeyboardWillHideNotification { get; }\n\n        [Notification]\n        [Field(\"MDCKeyboardWatcherKeyboardWillChangeFrameNotification\", \"__Internal\")]\n        NSString KeyboardWillChangeFrameNotification { get; }\n\n        [Static]\n        [Export(\"sharedKeyboardWatcher\")]\n        KeyboardWatcher SharedInstance { get; }\n\n        [Static]\n        [Export(\"animationDurationFromKeyboardNotification:\")]\n        double AnimationDurationFromNotification(NSNotification notification);\n\n        [Static]\n        [Export(\"animationCurveOptionFromKeyboardNotification:\")]\n        UIViewAnimationOptions AnimationCurveOptionFromNotification(NSNotification notification);\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCOverlayObserver\")]\n    interface OverlayObserver\n    {\n        [Static]\n        [Export(\"observerForScreen:\")]\n        OverlayObserver FromScreen(UIScreen screen);\n\n        [Export(\"addTarget:action:\")]\n        void AddTarget(NSObject target, Selector action);\n\n        [Export(\"removeTarget:action:\")]\n        void RemoveTarget(NSObject target, Selector action);\n\n        [Export(\"removeTarget:\")]\n        void RemoveTarget(NSObject target);\n    }\n\n    [Protocol(Name = \"MDCOverlay\")]\n    [BaseType(typeof(NSObject))]\n    interface Overlay\n    {\n        [Abstract]\n        [Export(\"identifier\")]\n        string Identifier { get; }\n\n        [Abstract]\n        [Export(\"frame\")]\n        CGRect Frame { get; }\n    }\n\n    [Protocol(Name = \"MDCOverlayTransitioning\")]\n    [BaseType(typeof(NSObject))]\n    interface OverlayTransitioning\n    {\n        [Abstract]\n        [Export(\"duration\")]\n        double Duration { get; }\n\n        [Abstract]\n        [Export(\"customTimingFunction\")]\n        CAMediaTimingFunction CustomTimingFunction { get; }\n\n        [Abstract]\n        [Export(\"animationCurve\")]\n        UIViewAnimationCurve AnimationCurve { get; }\n\n        [Abstract]\n        [Export(\"compositeFrame\")]\n        CGRect CompositeFrame { get; }\n\n        [Abstract]\n        [Export(\"compositeFrameInView:\")]\n        CGRect GetCompositeFrame(UIView targetView);\n\n        [Abstract]\n        [Export(\"enumerateOverlays:\")]\n        void EnumerateOverlays(EnumerateOverlaysHandler handler);\n\n        [Abstract]\n        [Export(\"animateAlongsideTransition:\")]\n        void AnimateAlongsideTransition(Action animations);\n\n        [Abstract]\n        [Export(\"animateAlongsideTransitionWithOptions:animations:completion:\")]\n        void AnimateAlongsideTransition(UIViewAnimationOptions options, Action animations, Action<bool> completion);\n    }\n\n    [BaseType(typeof(UIControl),\n        Name = \"MDCThumbTrack\")]\n    interface ThumbTrack\n    {\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        IThumbTrackDelegate Delegate { get; set; }\n\n        [Export(\"thumbEnabledColor\", ArgumentSemantic.Strong)]\n        UIColor ThumbEnabledColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"thumbDisabledColor\", ArgumentSemantic.Strong)]\n        UIColor ThumbDisabledColor { get; set; }\n\n        [Export(\"trackOnColor\", ArgumentSemantic.Strong)]\n        UIColor TrackOnColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"trackOffColor\", ArgumentSemantic.Strong)]\n        UIColor TrackOffColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"trackDisabledColor\", ArgumentSemantic.Strong)]\n        UIColor TrackDisabledColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"trackOnTickColor\", ArgumentSemantic.Strong)]\n        UIColor TrackOnTickColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"trackOffTickColor\", ArgumentSemantic.Strong)]\n        UIColor TrackOffTickColor { get; set; }\n\n        [Export(\"enableRippleBehavior\")]\n        bool EnableRippleBehavior { get; set; }\n\n        [NullAllowed]\n        [Export(\"rippleColor\", ArgumentSemantic.Strong)]\n        UIColor RippleColor { get; set; }\n\n        [Export(\"valueLabelTextColor\", ArgumentSemantic.Strong)]\n        UIColor ValueLabelTextColor { get; set; }\n\n        [Export(\"valueLabelBackgroundColor\", ArgumentSemantic.Strong)]\n        UIColor ValueLabelBackgroundColor { get; set; }\n\n        [Export(\"numDiscreteValues\")]\n        nuint NumDiscreteValues { get; set; }\n\n        [Export(\"value\")]\n        nfloat Value { get; set; }\n\n        [Export(\"minimumValue\")]\n        nfloat MinimumValue { get; set; }\n\n        [Export(\"maximumValue\")]\n        nfloat MaximumValue { get; set; }\n\n        [Export(\"thumbPosition\", ArgumentSemantic.Assign)]\n        CGPoint ThumbPosition { get; }\n\n        [Export(\"trackHeight\")]\n        nfloat TrackHeight { get; set; }\n\n        [Export(\"thumbRadius\")]\n        nfloat ThumbRadius { get; set; }\n\n        [Export(\"thumbElevation\")]\n        nfloat ThumbElevation { get; set; }\n\n        [Export(\"thumbShadowColor\", ArgumentSemantic.Strong)]\n        UIColor ThumbShadowColor { get; set; }\n\n        [Export(\"thumbIsSmallerWhenDisabled\")]\n        bool ThumbIsSmallerWhenDisabled { get; set; }\n\n        [Export(\"thumbIsHollowAtStart\")]\n        bool ThumbIsHollowAtStart { get; set; }\n\n        [Export(\"thumbGrowsWhenDragging\")]\n        bool ThumbGrowsWhenDragging { get; set; }\n\n        [Export(\"thumbRippleMaximumRadius\")]\n        nfloat ThumbRippleMaximumRadius { get; set; }\n\n        [Export(\"shouldDisplayRipple\")]\n        bool ShouldDisplayRipple { get; set; }\n\n        [Export(\"shouldDisplayDiscreteDots\")]\n        bool ShouldDisplayDiscreteDots { get; set; }\n\n        [Export(\"shouldDisplayDiscreteValueLabel\")]\n        bool ShouldDisplayDiscreteValueLabel { get; set; }\n\n        [Export(\"shouldDisplayFilledTrack\")]\n        bool ShouldDisplayFilledTrack { get; set; }\n\n        [Export(\"disabledTrackHasThumbGaps\")]\n        bool DisabledTrackHasThumbGaps { get; set; }\n\n        [Export(\"trackEndsAreRounded\")]\n        bool TrackEndsAreRounded { get; set; }\n\n        [Export(\"trackEndsAreInset\")]\n        bool TrackEndsAreInset { get; set; }\n\n        [Export(\"filledTrackAnchorValue\")]\n        nfloat FilledTrackAnchorValue { get; set; }\n\n        [NullAllowed]\n        [Export(\"thumbView\", ArgumentSemantic.Strong)]\n        ThumbView ThumbView { get; set; }\n\n        [Export(\"continuousUpdateEvents\")]\n        bool ContinuousUpdateEvents { get; set; }\n\n        [Export(\"panningAllowedOnEntireControl\")]\n        bool PanningAllowedOnEntireControl { get; set; }\n\n        [Export(\"tapsAllowedOnThumb\")]\n        bool TapsAllowedOnThumb { get; set; }\n\n        [Obsolete(\"This API will be deprecated. Use ThumbEnabledColor, TrackOnColor, and InkColor properties instead.\")]\n        [NullAllowed]\n        [Export(\"primaryColor\", ArgumentSemantic.Strong)]\n        UIColor PrimaryColor { get; set; }\n\n        [Export(\"initWithFrame:onTintColor:\")]\n        IntPtr Constructor(CGRect frame, [NullAllowed]  UIColor onTintColor);\n\n        [Export(\"setValue:animated:\")]\n        void SetValue(nfloat value, bool animated);\n\n        [Export(\"setValue:animated:animateThumbAfterMove:userGenerated:completion:\")]\n        void SetValue(nfloat value, bool animated, bool animateThumbAfterMove, bool userGenerated, [NullAllowed]  Action completion);\n\n        [Export(\"setIcon:\")]\n        void SetIcon([NullAllowed] UIImage icon);\n\n        [Obsolete(\"This property will be deprecated soon.\")]\n        [NullAllowed]\n        [Export(\"inkColor\", ArgumentSemantic.Strong)]\n        UIColor InkColor { get; set; }\n\n        [Obsolete(\"This property will be deprecated soon.\")]\n        [Export(\"shouldDisplayInk\")]\n        bool ShouldDisplayInk { get; set; }\n\n        [Obsolete(\"This property will be deprecated soon.\")]\n        [Export(\"thumbMaxRippleRadius\")]\n        nfloat ThumbMaxRippleRadius { get; set; }\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCThumbTrackDelegate\")]\n    interface ThumbTrackDelegate\n    {\n        [Export(\"thumbTrack:stringForValue:\")]\n        string GetStringForValue(ThumbTrack thumbTrack, nfloat value);\n\n        [Export(\"thumbTrack:shouldJumpToValue:\")]\n        bool ShouldJumpToValue(ThumbTrack thumbTrack, nfloat value);\n\n        [Export(\"thumbTrack:willJumpToValue:\")]\n        void WillJumpToValue(ThumbTrack thumbTrack, nfloat value);\n\n        [Export(\"thumbTrack:willAnimateToValue:\")]\n        void WillAnimateToValue(ThumbTrack thumbTrack, nfloat value);\n\n        [Export(\"thumbTrack:didAnimateToValue:\")]\n        void DidAnimateToValue(ThumbTrack thumbTrack, nfloat value);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCThumbView\")]\n    interface ThumbView\n    {\n        [Export(\"elevation\")]\n        nfloat Elevation { get; set; }\n\n        [Export(\"borderWidth\")]\n        nfloat BorderWidth { get; set; }\n\n        [Export(\"cornerRadius\")]\n        nfloat CornerRadius { get; set; }\n\n        [Export(\"shadowColor\", ArgumentSemantic.Strong)]\n        UIColor ShadowColor { get; set; }\n\n        [Export(\"setIcon:\")]\n        void SetIcon([NullAllowed] UIImage icon);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCNumericValueLabel\")]\n    interface NumericValueLabel\n    {\n        [New]\n        [Export(\"backgroundColor\", ArgumentSemantic.Retain)]\n        UIColor BackgroundColor { get; set; }\n\n        [Export(\"textColor\", ArgumentSemantic.Retain)]\n        UIColor TextColor { get; set; }\n\n        [Export(\"fontSize\")]\n        nfloat FontSize { get; set; }\n\n        [Export(\"text\")]\n        string Text { get; set; }\n    }\n\n    [Static]\n    interface CAMediaTimingFunctionAnimationTiming\n    {\n        [Static]\n        [return: NullAllowed]\n        [Export(\"mdc_functionWithType:\")]\n        CAMediaTimingFunction GetFunction(AnimationTimingFunction type);\n    }\n\n    [Static]\n    interface MaterialComponentsConstants\n    {\n        [Field(\"MaterialComponentsVersionNumber\", \"__Internal\")]\n        double VersionNumber { get; }\n\n        [Internal]\n        [Field(\"MaterialComponentsVersionString\", \"__Internal\")]\n        IntPtr _VersionString { get; }\n    }\n\n    interface IElevatable { }\n\n    interface IElevationOverriding { }\n\n    interface IRippleViewDelegate { }\n\n    interface IFlexibleHeaderSafeAreaDelegate { }\n\n    interface IActivityIndicatorDelegate\n    { }\n\n    interface ITabBarDisplayDelegate { }\n\n    interface ITabBarSizeClassDelegate { }\n\n    interface IRippleTouchControllerDelegate { }\n\n    interface IDialogPresentationControllerDelegate { }\n\n    interface IContainerScheming\n    { }\n\n    interface IShapeScheming\n    { }\n\n    interface IAlertScheming\n    { }\n\n    interface IAppBarNavigationControllerDelegate\n    { }\n\n    interface IListScheming\n    { }\n\n    interface IBottomDrawerHeader\n    { }\n\n    interface IBottomDrawerPresentationControllerDelegate\n    { }\n\n    interface IBottomDrawerViewControllerDelegate\n    { }\n\n    interface IBottomNavigationBarDelegate\n    { }\n\n    interface IBottomSheetControllerDelegate\n    { }\n\n    interface IBottomSheetPresentationControllerDelegate\n    { }\n\n    interface IButtonBarDelegate\n    { }\n\n    interface IButtonScheming\n    { }\n\n    interface ICardScheming\n    { }\n\n    interface IChipFieldDelegate\n    { }\n\n    interface IChipViewScheming\n    { }\n\n    [Protocol(Name = \"MDCChipViewScheming\")]\n    [BaseType(typeof(NSObject))]\n    interface ChipViewScheming\n    {\n        [Abstract]\n        [Export(\"colorScheme\")]\n        ColorScheming ColorScheme { get; }\n\n        [Abstract]\n        [Export(\"shapeScheme\")]\n        ShapeScheming ShapeScheme { get; }\n\n        [Abstract]\n        [Export(\"typographyScheme\")]\n        TypographyScheming TypographyScheme { get; }\n    }\n\n    interface ICollectionViewEditing\n    { }\n\n    interface ICollectionViewEditingDelegate\n    { }\n\n    interface ICollectionViewStyling\n    { }\n\n    interface ICollectionViewStylingDelegate\n    { }\n\n    interface IFlexibleHeaderViewDelegate\n    { }\n\n    interface IFlexibleHeaderViewLayoutDelegate\n    { }\n\n    interface IInkTouchControllerDelegate\n    { }\n\n    interface IInkViewDelegate\n    { }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject))]\n    interface InkViewDelegate\n    {\n        [EventArgs(\"InkViewInkAnimationStarted\")]\n        [EventName(\"InkAnimationStarted\")]\n        [Export(\"inkAnimationDidStart:\")]\n        void InkAnimationDidStart(InkView inkView);\n\n        [EventArgs(\"InkViewInkAnimationEnded\")]\n        [EventName(\"InkAnimationEnded\")]\n        [Export(\"inkAnimationDidEnd:\")]\n        void InkAnimationDidEnd(InkView inkView);\n    }\n\n    interface IColorScheme\n    { }\n\n    interface IFontScheme\n    { }\n\n    interface IMultilineTextInputLayoutDelegate\n    { }\n\n    interface IMultilineTextInputDelegate\n    { }\n\n    interface IUINavigationItemObservables\n    { }\n\n    interface IOverlay\n    { }\n\n    interface IOverlayTransitioning\n    { }\n\n    interface IColorScheming\n    { }\n\n    interface IShapeGenerating\n    { }\n\n    interface ISliderDelegate\n    { }\n\n    interface ISnackbarManagerDelegate\n    { }\n\n    interface ISnackbarSuspensionToken\n    { }\n\n    interface ITabBarDelegate\n    { }\n\n    interface ITabBarIndicatorContext\n    { }\n\n    interface ITabBarIndicatorTemplate\n    { }\n\n    interface ITabBarControllerDelegate\n    { }\n\n    [Static]\n    partial interface Constants11\n    { }\n\n    interface ITextInputPositioningDelegate\n    { }\n\n    interface ITextInput\n    { }\n\n    interface ILeadingViewTextInput\n    { }\n\n    interface IMultilineTextInput\n    { }\n\n    interface ITextInputCharacterCounter\n    { }\n\n    interface ITextInputController\n    { }\n\n    interface ITextInputControllerFloatingPlaceholder\n    { }\n\n    interface IThumbTrackDelegate\n    { }\n\n    interface ITypographyFontLoading\n    { }\n\n    interface ITypographyScheming\n    { }\n\n    [Static]\n    interface UIApplicationAppExtensions\n    {\n        [Static]\n        [Export(\"mdc_safeSharedApplication\")]\n        UIApplication SafeSharedApplication { get; }\n\n        [Static]\n        [Wrap(\"SafeSharedApplication\")]\n        UIApplication MdcSafeSharedApplication { get; }\n\n        [Static]\n        [Export(\"mdc_isAppExtension\")]\n        bool IsAppExtension { get; }\n\n        [Static]\n        [Wrap(\"IsAppExtension\")]\n        bool MdcIsAppExtension { get; }\n    }\n\n    [Static]\n    interface UIFontMaterialTypography\n    {\n        [Static]\n        [Export(\"mdc_preferredFontForMaterialTextStyle:\")]\n        UIFont GetPreferredFont(FontTextStyle style);\n\n        [Static]\n        [Wrap(\"GetPreferredFont(style)\")]\n        UIFont MdcGetPreferredFont(FontTextStyle style);\n\n        [Static]\n        [Export(\"mdc_standardFontForMaterialTextStyle:\")]\n        UIFont GetStandardFont(FontTextStyle style);\n\n        [Static]\n        [Wrap(\"GetStandardFont(style)\")]\n        UIFont MdcGetStandardFont(FontTextStyle style);\n    }\n\n    [Static]\n    interface UIFontDescriptorMaterialTypography\n    {\n        [Static]\n        [Export(\"mdc_preferredFontDescriptorForMaterialTextStyle:\")]\n        UIFontDescriptor GetPreferredFontDescriptor(FontTextStyle style);\n\n        [Static]\n        [Wrap(\"GetPreferredFontDescriptor(style)\")]\n        UIFontDescriptor MdcGetPreferredFontDescriptor(FontTextStyle style);\n\n        [Static]\n        [Export(\"mdc_standardFontDescriptorForMaterialTextStyle:\")]\n        UIFontDescriptor GetStandardFontDescriptor(FontTextStyle style);\n\n        [Static]\n        [Wrap(\"GetStandardFontDescriptor(style)\")]\n        UIFontDescriptor MdcGetStandardFontDescriptor(FontTextStyle style);\n    }\n\n    [Static]\n    interface UIViewMDCTimingFunction\n    {\n        [Static]\n        [Export(\"mdc_animateWithTimingFunction:duration:delay:options:animations:completion:\")]\n        void Animate([NullAllowed] CAMediaTimingFunction timingFunction, double duration, double delay, UIViewAnimationOptions options, Action animations, [NullAllowed]  Action<bool> completion);\n\n        [Wrap(\"Animate (timingFunction, duration, delay, options, animations, completion)\")]\n        [Obsolete(\"Use Animate instead.\")]\n        [Static]\n        void MdcAnimate([NullAllowed] CAMediaTimingFunction timingFunction, double duration, double delay, UIViewAnimationOptions options, Action animations, [NullAllowed] Action<bool> completion);\n    }\n\n    [Static]\n    interface NSLocaleMaterialRtl\n    {\n        [Static]\n        [Export(\"mdf_isDefaultLanguageLTR\")]\n        bool MdfIsDefaultLanguageLtr();\n\n        [Static]\n        [Export(\"mdf_isDefaultLanguageRTL\")]\n        bool MdfIsDefaultLanguageRtl();\n    }\n\n    [Category]\n    [BaseType(typeof(NSString))]\n    interface NSStringMaterialBidi\n    {\n        [Export(\"mdf_calculatedLanguageDirection\")]\n        NSLocaleLanguageDirection MdfCalculatedLanguageDirection();\n\n        [Export(\"mdf_stringWithBidiEmbedding:\")]\n        string MdfGetStringWithBidiEmbedding(NSLocaleLanguageDirection languageDirection);\n\n        [Export(\"mdf_stringWithBidiEmbedding\")]\n        string MdfGetStringWithBidiEmbedding();\n\n        [Export(\"mdf_stringWithStereoReset:context:\")]\n        string MdfGetStringWithStereoReset(NSLocaleLanguageDirection direction, NSLocaleLanguageDirection contextDirection);\n\n        [Export(\"mdf_stringWithBidiMarkersStripped\")]\n        string MdfGetStringWithBidiMarkersStripped();\n    }\n\n    [Category]\n    [BaseType(typeof(UIImage))]\n    interface UIImage_MaterialRtl\n    {\n        [Export(\"mdf_imageWithHorizontallyFlippedOrientation\")]\n        UIImage MdfGetImageWithHorizontallyFlippedOrientation();\n    }\n\n    [Category]\n    [BaseType(typeof(UIView))]\n    interface UIView_MaterialRtl\n    {\n        [Export(\"mdf_semanticContentAttribute\")]\n        UISemanticContentAttribute MdfGetSemanticContentAttribute();\n\n        [Export(\"mdf_setSemanticContentAttribute:\")]\n        void MdfSetSemanticContentAttribute(UISemanticContentAttribute value);\n\n        [Export(\"mdf_effectiveUserInterfaceLayoutDirection\")]\n        UIUserInterfaceLayoutDirection MdfGetEffectiveUserInterfaceLayoutDirection();\n    }\n\n    [Static]\n    interface UIViewMaterialRtl\n    {\n        [Static]\n        [Export(\"mdf_userInterfaceLayoutDirectionForSemanticContentAttribute:\")]\n        UIUserInterfaceLayoutDirection MdfGetUserInterfaceLayoutDirection(UISemanticContentAttribute semanticContentAttribute);\n\n        [Static]\n        [Export(\"mdf_userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:\")]\n        UIUserInterfaceLayoutDirection MdfGetUserInterfaceLayoutDirection(UISemanticContentAttribute semanticContentAttribute, UIUserInterfaceLayoutDirection layoutDirection);\n    }\n}","old_contents":"using System;\nusing CoreAnimation;\nusing CoreGraphics;\nusing Foundation;\nusing ObjCRuntime;\nusing UIKit;\nusing NSTextAlignment = UIKit.UITextAlignment;\n\nnamespace MaterialComponents\n{\n\n    delegate void ActionSheetHandler(ActionSheetAction arg0);\n\n    delegate void RippleCompletionBlock();\n\n    delegate void ActivityIndicatorAnimationHandler(nfloat strokeStart, nfloat strokeEnd);\n\n    delegate void ActionHandler(AlertAction action);\n\n    delegate void FeatureHighlightCompletionHandler(bool accepted);\n\n    delegate void FlexibleHeaderChangeContentInsetsHandler();\n\n    delegate void FlexibleHeaderShadowIntensityChangeHandler(CALayer shadowLayer, nfloat intensity);\n\n    delegate void InkCompletionHandler();\n\n    delegate void EnumerateOverlaysHandler(IOverlay overlay, nuint idx, ref bool stop);\n\n    delegate void SnackbarMessageCompletionHandler(bool arg0);\n\n    delegate void SnackbarMessageActionHandler();\n\n\n    [Protocol(Name = \"MDCElevatable\")]\n    interface Elevatable\n    {\n        [Abstract]\n        [Export(\"mdc_currentElevation\")]\n        nfloat CurrentElevation { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"mdc_elevationDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<IElevatable, nfloat> ElevationDidChangeBlock { get; set; }\n    }\n\n    [Protocol(Name = \"MDCElevationOverriding\")]\n    interface ElevationOverriding\n    {\n        [Abstract]\n        [Export(\"mdc_overrideBaseElevation\")]\n        nfloat OverrideBaseElevation { get; set; }\n    }\n\n    [Category]\n    [BaseType(typeof(UIColor))]\n    interface UIColor_MaterialElevation\n    {\n        [Export(\"mdc_resolvedColorWithElevation:\")]\n        UIColor ResolvedColorWithElevation(nfloat elevation);\n\n        [Export(\"mdc_resolvedColorWithTraitCollection:previousTraitCollection:elevation:\")]\n        UIColor ResolvedColorWithTraitCollection(UITraitCollection traitCollection, UITraitCollection previousTraitCollection, nfloat elevation);\n\n        [Export(\"mdc_resolvedColorWithTraitCollection:elevation:\")]\n        UIColor ResolvedColorWithTraitCollection(UITraitCollection traitCollection, nfloat elevation);\n    }\n\n    [Category]\n    [BaseType(typeof(UIView))]\n    interface UIView_MaterialElevationResponding\n    {\n        [Export(\"mdc_baseElevation\")]\n        [Static]\n        nfloat BaseElevation { get; }\n\n        [Export(\"mdc_absoluteElevation\")]\n        [Static]\n        nfloat AbsoluteElevation { get; }\n\n        [Export(\"mdc_elevationDidChange\")]\n        void ElevationDidChange();\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCCornerTreatment\")]\n    interface CornerTreatment : INSCopying\n\n    {\n        [Export(\"valueType\", ArgumentSemantic.Assign)]\n        CornerTreatmentValueType ValueType { get; set; }\n\n        [Export(\"pathGeneratorForCornerWithAngle:\")]\n        PathGenerator PathGeneratorForCornerWithAngle(nfloat angle);\n\n        [Export(\"pathGeneratorForCornerWithAngle:forViewSize:\")]\n        PathGenerator PathGeneratorForCornerWithAngle(nfloat angle, CGSize size);\n\n        [Static]\n        [Export(\"cornerWithRadius:\")]\n        RoundedCornerTreatment CreateCornerWithRadius(nfloat value);\n\n        [Static]\n        [Export(\"cornerWithRadius:valueType:\")]\n        RoundedCornerTreatment CreateCornerWithRadius(nfloat value, CornerTreatmentValueType valueType);\n\n        [Static]\n        [Export(\"cornerWithCut:\")]\n        CutCornerTreatment CreateCornerWithCut(nfloat value);\n\n        [Static]\n        [Export(\"cornerWithCut:valueType:\")]\n        CutCornerTreatment CreateCornerWithCut(nfloat value, CornerTreatmentValueType valueType);\n\n        [Static]\n        [Export(\"cornerWithCurve:\")]\n        CurvedCornerTreatment CreateCornerWithCurve(CGSize value);\n\n        [Static]\n        [Export(\"cornerWithCurve:valueType:\")]\n        CurvedCornerTreatment CreateCornerWithCurve(CGSize value, CornerTreatmentValueType valueType);\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCEdgeTreatment\")]\n    interface EdgeTreatment : INSCopying\n\n    {\n        [Export(\"pathGeneratorForEdgeWithLength:\")]\n        PathGenerator GetPathGeneratorForEdge(nfloat length);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCPathGenerator\")]\n    interface PathGenerator\n    {\n        [Export(\"startPoint\")]\n        CGPoint StartPoint { get; }\n\n        [Export(\"endPoint\")]\n        CGPoint EndPoint { get; }\n\n        [Static]\n        [Export(\"pathGenerator\")]\n        PathGenerator Create();\n\n        [Static]\n        [Export(\"pathGeneratorWithStartPoint:\")]\n        PathGenerator Create(CGPoint startPoint);\n\n        [Export(\"addLineToPoint:\")]\n        void AddLine(CGPoint point);\n\n        [Export(\"addArcWithCenter:radius:startAngle:endAngle:clockwise:\")]\n        void AddArc(CGPoint center, nfloat radius, nfloat startAngle, nfloat endAngle, bool clockwise);\n\n        [Export(\"addArcWithTangentPoint:toPoint:radius:\")]\n        void AddArc(CGPoint tangentPoint, CGPoint toPoint, nfloat radius);\n\n        [Export(\"addCurveWithControlPoint1:controlPoint2:toPoint:\")]\n        void AddCurve(CGPoint controlPoint1, CGPoint controlPoint2, CGPoint toPoint);\n\n        [Export(\"addQuadCurveWithControlPoint:toPoint:\")]\n        void AddQuadCurve(CGPoint controlPoint, CGPoint toPoint);\n\n        [Export(\"appendToCGPath:transform:\")]\n        void AppendTo(CGPath cgPath, [NullAllowed]  CGAffineTransform transform);\n    }\n\n    [Protocol(Name = \"MDCShapeGenerating\")]\n    interface ShapeGenerating : INSCopying\n\n    {\n        [return: NullAllowed]\n        [Abstract]\n        [Export(\"pathForSize:\")]\n        CGPath GetPath(CGSize size);\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCRectangleShapeGenerator\")]\n    interface RectangleShapeGenerator : ShapeGenerating\n\n    {\n        [Export(\"topLeftCorner\", ArgumentSemantic.Strong)]\n        CornerTreatment TopLeftCorner { get; set; }\n\n        [Export(\"topRightCorner\", ArgumentSemantic.Strong)]\n        CornerTreatment TopRightCorner { get; set; }\n\n        [Export(\"bottomLeftCorner\", ArgumentSemantic.Strong)]\n        CornerTreatment BottomLeftCorner { get; set; }\n\n        [Export(\"bottomRightCorner\", ArgumentSemantic.Strong)]\n        CornerTreatment BottomRightCorner { get; set; }\n\n        [Export(\"topLeftCornerOffset\", ArgumentSemantic.Assign)]\n        CGPoint TopLeftCornerOffset { get; set; }\n\n        [Export(\"topRightCornerOffset\", ArgumentSemantic.Assign)]\n        CGPoint TopRightCornerOffset { get; set; }\n\n        [Export(\"bottomLeftCornerOffset\", ArgumentSemantic.Assign)]\n        CGPoint BottomLeftCornerOffset { get; set; }\n\n        [Export(\"bottomRightCornerOffset\", ArgumentSemantic.Assign)]\n        CGPoint BottomRightCornerOffset { get; set; }\n\n        [Export(\"topEdge\", ArgumentSemantic.Strong)]\n        EdgeTreatment TopEdge { get; set; }\n\n        [Export(\"rightEdge\", ArgumentSemantic.Strong)]\n        EdgeTreatment RightEdge { get; set; }\n\n        [Export(\"bottomEdge\", ArgumentSemantic.Strong)]\n        EdgeTreatment BottomEdge { get; set; }\n\n        [Export(\"leftEdge\", ArgumentSemantic.Strong)]\n        EdgeTreatment LeftEdge { get; set; }\n\n        [Export(\"setCorners:\")]\n        void SetCorners(CornerTreatment cornerShape);\n\n        [Export(\"setEdges:\")]\n        void SetEdges(EdgeTreatment edgeShape);\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCShadowMetrics\")]\n    interface ShadowMetrics\n    {\n        [Export(\"topShadowRadius\")]\n        nfloat TopShadowRadius { get; }\n\n        [Export(\"topShadowOffset\")]\n        CGSize TopShadowOffset { get; }\n\n        [Export(\"topShadowOpacity\")]\n        float TopShadowOpacity { get; }\n\n        [Export(\"bottomShadowRadius\")]\n        nfloat BottomShadowRadius { get; }\n\n        [Export(\"bottomShadowOffset\")]\n        CGSize BottomShadowOffset { get; }\n\n        [Export(\"bottomShadowOpacity\")]\n        float BottomShadowOpacity { get; }\n\n        [Static]\n        [Export(\"metricsWithElevation:\")]\n        ShadowMetrics Create(nfloat elevation);\n    }\n\n    [BaseType(typeof(CALayer),\n        Name = \"MDCShadowLayer\")]\n    interface ShadowLayer : ICALayerDelegate\n\n    {\n        [Export(\"elevation\")]\n        nfloat Elevation { get; set; }\n\n        [Export(\"shadowMaskEnabled\")]\n        bool ShadowMaskEnabled { [Bind(\"isShadowMaskEnabled\")] get; set; }\n\n        [Export(\"animateCornerRadius:withTimingFunction:duration:\")]\n        void AnimateCornerRadius(nfloat cornerRadius, CAMediaTimingFunction timingFunction, double duration);\n    }\n\n    [BaseType(typeof(ShadowLayer),\n        Name = \"MDCShapedShadowLayer\")]\n    interface ShapedShadowLayer\n    {\n        [NullAllowed]\n        [Export(\"shapedBackgroundColor\", ArgumentSemantic.Strong)]\n        UIColor ShapedBackgroundColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"shapedBorderColor\", ArgumentSemantic.Strong)]\n        UIColor ShapedBorderColor { get; set; }\n\n        [Export(\"shapedBorderWidth\")]\n        nfloat ShapedBorderWidth { get; set; }\n\n        [NullAllowed]\n        [Export(\"shapeGenerator\", ArgumentSemantic.Strong)]\n        IShapeGenerating ShapeGenerator { get; set; }\n\n        [Export(\"shapeLayer\", ArgumentSemantic.Strong)]\n        CAShapeLayer ShapeLayer { get; set; }\n\n        [Export(\"colorLayer\", ArgumentSemantic.Strong)]\n        CAShapeLayer ColorLayer { get; set; }\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCShapedView\")]\n    interface ShapedView\n    {\n        [Export(\"elevation\")]\n        nfloat Elevation { get; set; }\n\n        [NullAllowed]\n        [Export(\"shapeGenerator\", ArgumentSemantic.Strong)]\n        IShapeGenerating ShapeGenerator { get; set; }\n\n        [DesignatedInitializer]\n        [Export(\"initWithFrame:shapeGenerator:\")]\n        IntPtr Constructor(CGRect frame, [NullAllowed]  IShapeGenerating shapeGenerator);\n\n        [Wrap(\"this (frame, null)\")]\n        IntPtr Constructor(CGRect frame);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(UIViewController),\n        Name = \"MDCBottomSheetController\",\n        Delegates = new[] { \"Delegate\" },\n        Events = new[] { typeof(BottomSheetControllerDelegate) })]\n    interface BottomSheetController : IElevatable, IElevationOverriding\n\n    {\n        [Export(\"contentViewController\", ArgumentSemantic.Strong)]\n        UIViewController ContentViewController { get; }\n\n        [NullAllowed]\n        [Export(\"trackingScrollView\", ArgumentSemantic.Weak)]\n        UIScrollView TrackingScrollView { get; set; }\n\n        [Export(\"shouldFlashScrollIndicatorsOnAppearance\")]\n        bool ShouldFlashScrollIndicatorsOnAppearance { get; set; }\n\n        [Export(\"dismissOnBackgroundTap\")]\n        bool DismissOnBackgroundTap { get; set; }\n\n        [NullAllowed]\n        [Export(\"scrimColor\", ArgumentSemantic.Strong)]\n        UIColor ScrimColor { get; set; }\n\n        [Export(\"isScrimAccessibilityElement\")]\n        bool IsScrimAccessibilityElement { get; set; }\n\n        [NullAllowed]\n        [Export(\"scrimAccessibilityLabel\")]\n        string ScrimAccessibilityLabel { get; set; }\n\n        [NullAllowed]\n        [Export(\"scrimAccessibilityHint\")]\n        string ScrimAccessibilityHint { get; set; }\n\n        [Export(\"scrimAccessibilityTraits\")]\n        ulong ScrimAccessibilityTraits { get; set; }\n\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        IBottomSheetControllerDelegate Delegate { get; set; }\n\n        [Export(\"state\")]\n        SheetState State { get; }\n\n        [Export(\"elevation\")]\n        double Elevation { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<BottomSheetController, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"initWithContentViewController:\")]\n        IntPtr Constructor(UIViewController contentViewController);\n\n        [Export(\"setShapeGenerator:forState:\")]\n        void SetShapeGenerator([NullAllowed] IShapeGenerating shapeGenerator, SheetState state);\n\n        [return: NullAllowed]\n        [Export(\"shapeGeneratorForState:\")]\n        IShapeGenerating ShapeGenerator(SheetState state);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCBottomSheetControllerDelegate\")]\n    interface BottomSheetControllerDelegate\n    {\n        [EventArgs(\"BottomSheetControllerBottomSheetDismissed\")]\n        [EventName(\"BottomSheetDismissed\")]\n        [Export(\"bottomSheetControllerDidDismissBottomSheet:\")]\n        void DidDismissBottomSheet(BottomSheetController controller);\n\n        [EventArgs(\"BottomSheetControllerBottomSheetStateChanged\")]\n        [EventName(\"BottomSheetStateChanged\")]\n        [Export(\"bottomSheetControllerStateChanged:state:\")]\n        void BottomSheetControllerStateChanged(BottomSheetController controller, SheetState state);\n\n        [EventArgs(\"BottomSheetControllerBottomSheetDidChangeYOffset\")]\n        [EventName(\"BottomSheetDidChangeYOffset\")]\n        [Export(\"bottomSheetControllerDidChangeYOffset:yOffset:\")]\n        void BottomSheetControllerDidChangeYOffset(BottomSheetController controller, nfloat yOffset);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCBottomSheetPresentationControllerDelegate\")]\n    interface BottomSheetPresentationControllerDelegate : IUIAdaptivePresentationControllerDelegate\n\n    {\n        [EventArgs(\"BottomSheetPresentationControllerPrepareForPresentation\")]\n        [Export(\"prepareForBottomSheetPresentation:\")]\n        void PrepareForPresentation(BottomSheetPresentationController bottomSheet);\n\n        [EventArgs(\"BottomSheetPresentationControllerDismissed\")]\n        [EventName(\"Dismissed\")]\n        [Export(\"bottomSheetPresentationControllerDidDismissBottomSheet:\")]\n        void DidDismiss(BottomSheetPresentationController bottomSheet);\n\n        [EventArgs(\"BottomSheetPresentationControllerWillChangeState\")]\n        [Export(\"bottomSheetWillChangeState:sheetState:\")]\n        void WillChangeState(BottomSheetPresentationController bottomSheet, SheetState sheetState);\n\n        [EventArgs(\"BottomSheetPresentationControllerDidChangeYOffset\")]\n        [EventName(\"DidChangeYOffset\")]\n        [Export(\"bottomSheetDidChangeYOffset:yOffset:\")]\n        void BottomSheetDidChangeYOffset(BottomSheetPresentationController bottomSheet, nfloat yOffset);\n    }\n\n    [BaseType(typeof(UIPresentationController),\n        Name = \"MDCBottomSheetPresentationController\",\n        Delegates = new[] { \"Delegate\" },\n        Events = new[] { typeof(BottomSheetPresentationControllerDelegate) })]\n    interface BottomSheetPresentationController\n    {\n        [NullAllowed]\n        [Export(\"trackingScrollView\", ArgumentSemantic.Weak)]\n        UIScrollView TrackingScrollView { get; set; }\n\n        [Export(\"dismissOnBackgroundTap\")]\n        bool DismissOnBackgroundTap { get; set; }\n\n        [Export(\"preferredSheetHeight\")]\n        nfloat PreferredSheetHeight { get; set; }\n\n        [NullAllowed]\n        [Export(\"scrimColor\", ArgumentSemantic.Strong)]\n        UIColor ScrimColor { get; set; }\n\n        [Export(\"isScrimAccessibilityElement\")]\n        bool IsScrimAccessibilityElement { get; set; }\n\n        [NullAllowed]\n        [Export(\"scrimAccessibilityLabel\")]\n        string ScrimAccessibilityLabel { get; set; }\n\n        [NullAllowed]\n        [Export(\"scrimAccessibilityHint\")]\n        string ScrimAccessibilityHint { get; set; }\n\n        [Export(\"scrimAccessibilityTraits\")]\n        ulong ScrimAccessibilityTraits { get; set; }\n\n        [New]\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        IBottomSheetPresentationControllerDelegate Delegate { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<BottomSheetPresentationController, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCBottomSheetTransitionController\")]\n    interface BottomSheetTransitionController : IUIViewControllerAnimatedTransitioning, IUIViewControllerTransitioningDelegate\n\n    {\n        [NullAllowed]\n        [Export(\"trackingScrollView\", ArgumentSemantic.Weak)]\n        UIScrollView TrackingScrollView { get; set; }\n\n        [Export(\"dismissOnBackgroundTap\")]\n        bool DismissOnBackgroundTap { get; set; }\n\n        [Export(\"preferredSheetHeight\")]\n        nfloat PreferredSheetHeight { get; set; }\n\n        [NullAllowed]\n        [Export(\"scrimColor\", ArgumentSemantic.Strong)]\n        UIColor ScrimColor { get; set; }\n\n        [Export(\"isScrimAccessibilityElement\")]\n        bool IsScrimAccessibilityElement { get; set; }\n\n        [NullAllowed]\n        [Export(\"scrimAccessibilityLabel\")]\n        string ScrimAccessibilityLabel { get; set; }\n\n        [NullAllowed]\n        [Export(\"scrimAccessibilityHint\")]\n        string ScrimAccessibilityHint { get; set; }\n\n        [Export(\"scrimAccessibilityTraits\")]\n        ulong ScrimAccessibilityTraits { get; set; }\n    }\n\n    [Category]\n    [BaseType(typeof(UIViewController))]\n    interface UIViewController_MaterialBottomSheet\n    {\n        [return: NullAllowed]\n        [Export(\"mdc_bottomSheetPresentationController\")]\n        BottomSheetPresentationController GetBottomSheetPresentationController();\n\n        [return: NullAllowed]\n        [Wrap(\"GetBottomSheetPresentationController(This)\")]\n        BottomSheetPresentationController MdcGetBottomSheetPresentationController();\n    }\n\n    [BaseType(typeof(UIViewController),\n        Name = \"MDCActionSheetController\")]\n    interface ActionSheetController : IElevatable, IElevationOverriding\n\n    {\n        [Export(\"actions\", ArgumentSemantic.Copy)]\n        ActionSheetAction Actions { get; }\n\n        [NullAllowed]\n        [Export(\"title\")]\n        string Title { get; set; }\n\n        [NullAllowed]\n        [Export(\"message\")]\n        string Message { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<ActionSheetController, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"mdc_adjustsFontForContentSizeCategory\")]\n        bool AdjustsFontForContentSizeCategory { get; [Bind(\"mdc_setAdjustsFontForContentSizeCategory:\")]set; }\n\n        [Obsolete(\"Use AdjustsFontForContentSizeCategory instead\")]\n        [Wrap(\"AdjustsFontForContentSizeCategory\")]\n        bool MdcAdjustsFontForContentSizeCategory { get; set; }\n\n        [Export(\"titleFont\", ArgumentSemantic.Strong)]\n        UIFont TitleFont { get; set; }\n\n        [Export(\"messageFont\", ArgumentSemantic.Strong)]\n        UIFont MessageFont { get; set; }\n\n        [NullAllowed]\n        [Export(\"actionFont\", ArgumentSemantic.Strong)]\n        UIFont ActionFont { get; set; }\n\n        [Export(\"backgroundColor\", ArgumentSemantic.Strong)]\n        UIColor BackgroundColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"titleTextColor\", ArgumentSemantic.Strong)]\n        UIColor TitleTextColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"messageTextColor\", ArgumentSemantic.Strong)]\n        UIColor MessageTextColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"actionTextColor\", ArgumentSemantic.Strong)]\n        UIColor ActionTextColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"actionTintColor\", ArgumentSemantic.Strong)]\n        UIColor ActionTintColor { get; set; }\n\n        [Export(\"enableRippleBehavior\")]\n        bool EnableRippleBehavior { get; set; }\n\n        [NullAllowed]\n        [Export(\"rippleColor\", ArgumentSemantic.Strong)]\n        UIColor RippleColor { get; set; }\n\n        [Export(\"imageRenderingMode\", ArgumentSemantic.Assign)]\n        UIImageRenderingMode ImageRenderingMode { get; set; }\n\n        [Export(\"showsHeaderDivider\")]\n        bool ShowsHeaderDivider { get; set; }\n\n        [Export(\"headerDividerColor\", ArgumentSemantic.Copy)]\n        UIColor HeaderDividerColor { get; set; }\n\n        [Export(\"elevation\")]\n        double Elevation { get; set; }\n\n        [Export(\"alwaysAlignTitleLeadingEdges\")]\n        bool AlwaysAlignTitleLeadingEdges { get; set; }\n\n        [Export(\"transitionController\", ArgumentSemantic.Strong)]\n        BottomSheetTransitionController TransitionController { get; }\n\n        [Static]\n        [Export(\"actionSheetControllerWithTitle:message:\")]\n        ActionSheetController ActionSheetControllerWithTitle([NullAllowed] string title, [NullAllowed]  string message);\n\n        [Static]\n        [Export(\"actionSheetControllerWithTitle:\")]\n        ActionSheetController ActionSheetControllerWithTitle([NullAllowed] string title);\n\n        [Export(\"addAction:\")]\n        void AddAction(ActionSheetAction action);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCActionSheetAction\")]\n    interface ActionSheetAction : INSCopying, IUIAccessibilityIdentification\n\n    {\n        [Export(\"title\")]\n        string Title { get; }\n\n        [NullAllowed]\n        [Export(\"image\")]\n        UIImage Image { get; }\n\n        [NullAllowed]\n        [Export(\"accessibilityIdentifier\")]\n        string AccessibilityIdentifier { get; set; }\n\n        [NullAllowed]\n        [Export(\"titleColor\", ArgumentSemantic.Copy)]\n        UIColor TitleColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"tintColor\", ArgumentSemantic.Copy)]\n        UIColor TintColor { get; set; }\n\n        [Static]\n        [Export(\"actionWithTitle:image:handler:\")]\n        ActionSheetAction ActionWithTitle(string title, [NullAllowed]  UIImage image, [NullAllowed]  ActionSheetHandler handler);\n\n        [NullAllowed]\n        [Export(\"inkColor\", ArgumentSemantic.Strong)]\n        [Static]\n        UIColor InkColor { get; set; }\n    }\n\n    [Advice(\"This class will soon be deprecated. Consider using IColorScheming interface instead.\")]\n    [Protocol(Name = \"MDCColorScheme\")]\n    [BaseType(typeof(NSObject))]\n    interface ColorScheme\n    {\n        [Abstract]\n        [Export(\"primaryColor\")]\n        UIColor PrimaryColor { get; }\n\n        [Export(\"primaryLightColor\")]\n        UIColor PrimaryLightColor { get; }\n\n        [Export(\"primaryDarkColor\")]\n        UIColor PrimaryDarkColor { get; }\n\n        [Export(\"secondaryColor\")]\n        UIColor SecondaryColor { get; }\n\n        [Export(\"secondaryLightColor\")]\n        UIColor SecondaryLightColor { get; }\n\n        [Export(\"secondaryDarkColor\")]\n        UIColor SecondaryDarkColor { get; }\n    }\n\n    [Obsolete(\"This class will soon be deprecated. Consider using SemanticColorScheme class instead.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCBasicColorScheme\")]\n    interface BasicColorScheme : ColorScheme, INSCopying\n\n    {\n        [Export(\"primaryColor\", ArgumentSemantic.Strong)]\n        UIColor PrimaryColor { get; }\n\n        [Export(\"primaryLightColor\", ArgumentSemantic.Strong)]\n        UIColor PrimaryLightColor { get; }\n\n        [Export(\"primaryDarkColor\", ArgumentSemantic.Strong)]\n        UIColor PrimaryDarkColor { get; }\n\n        [Export(\"secondaryColor\", ArgumentSemantic.Strong)]\n        UIColor SecondaryColor { get; }\n\n        [Export(\"secondaryLightColor\", ArgumentSemantic.Strong)]\n        UIColor SecondaryLightColor { get; }\n\n        [Export(\"secondaryDarkColor\", ArgumentSemantic.Strong)]\n        UIColor SecondaryDarkColor { get; }\n\n        [DesignatedInitializer]\n        [Export(\"initWithPrimaryColor:primaryLightColor:primaryDarkColor:secondaryColor:secondaryLightColor:secondaryDarkColor:\")]\n        IntPtr Constructor(UIColor primaryColor, UIColor primaryLightColor, UIColor primaryDarkColor, UIColor secondaryColor, UIColor secondaryLightColor, UIColor secondaryDarkColor);\n\n        [Export(\"initWithPrimaryColor:\")]\n        IntPtr Constructor(UIColor primaryColor);\n\n        [Export(\"initWithPrimaryColor:primaryLightColor:primaryDarkColor:\")]\n        IntPtr Constructor(UIColor primaryColor, UIColor primaryLightColor, UIColor primaryDarkColor);\n\n        [Export(\"initWithPrimaryColor:secondaryColor:\")]\n        IntPtr Constructor(UIColor primaryColor, UIColor secondaryColor);\n    }\n\n    [Obsolete(\"This class will soon be deprecated. Consider using IColorScheming interface instead.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTonalColorScheme\")]\n    interface TonalColorScheme : ColorScheme, INSCopying\n\n    {\n        [Export(\"primaryColor\", ArgumentSemantic.Strong)]\n        UIColor PrimaryColor { get; }\n\n        [Export(\"primaryLightColor\", ArgumentSemantic.Strong)]\n        UIColor PrimaryLightColor { get; }\n\n        [Export(\"primaryDarkColor\", ArgumentSemantic.Strong)]\n        UIColor PrimaryDarkColor { get; }\n\n        [Export(\"secondaryColor\", ArgumentSemantic.Strong)]\n        UIColor SecondaryColor { get; }\n\n        [Export(\"secondaryLightColor\", ArgumentSemantic.Strong)]\n        UIColor SecondaryLightColor { get; }\n\n        [Export(\"secondaryDarkColor\", ArgumentSemantic.Strong)]\n        UIColor SecondaryDarkColor { get; }\n\n        [Export(\"primaryTonalPalette\", ArgumentSemantic.Strong)]\n        TonalPalette PrimaryTonalPalette { get; }\n\n        [Export(\"secondaryTonalPalette\", ArgumentSemantic.Strong)]\n        TonalPalette SecondaryTonalPalette { get; }\n\n        [DesignatedInitializer]\n        [Export(\"initWithPrimaryTonalPalette:secondaryTonalPalette:\")]\n        IntPtr Constructor(TonalPalette primaryTonalPalette, TonalPalette secondaryTonalPalette);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTonalPalette\")]\n    interface TonalPalette : INSCopying\n\n    {\n        [Export(\"colors\", ArgumentSemantic.Copy)]\n        UIColor[] Colors { get; }\n\n        [Export(\"mainColorIndex\")]\n        nuint MainColorIndex { get; }\n\n        [Export(\"lightColorIndex\")]\n        nuint LightColorIndex { get; }\n\n        [Export(\"darkColorIndex\")]\n        nuint DarkColorIndex { get; }\n\n        [Export(\"mainColor\", ArgumentSemantic.Strong)]\n        UIColor MainColor { get; }\n\n        [Export(\"lightColor\", ArgumentSemantic.Strong)]\n        UIColor LightColor { get; }\n\n        [Export(\"darkColor\", ArgumentSemantic.Strong)]\n        UIColor DarkColor { get; }\n\n        [DesignatedInitializer]\n        [Export(\"initWithColors:mainColorIndex:lightColorIndex:darkColorIndex:\")]\n        IntPtr Constructor(UIColor colors, nuint mainColorIndex, nuint lightColorIndex, nuint darkColorIndex);\n    }\n\n    [Protocol(Name = \"MDCColorScheming\")]\n    [BaseType(typeof(NSObject))]\n    interface ColorScheming\n    {\n        [Abstract]\n        [Export(\"primaryColor\", ArgumentSemantic.Copy)]\n        UIColor PrimaryColor { get; }\n\n        [Abstract]\n        [Export(\"primaryColorVariant\", ArgumentSemantic.Copy)]\n        UIColor PrimaryColorVariant { get; }\n\n        [Abstract]\n        [Export(\"secondaryColor\", ArgumentSemantic.Copy)]\n        UIColor SecondaryColor { get; }\n\n        [Abstract]\n        [Export(\"errorColor\", ArgumentSemantic.Copy)]\n        UIColor ErrorColor { get; }\n\n        [Abstract]\n        [Export(\"surfaceColor\", ArgumentSemantic.Copy)]\n        UIColor SurfaceColor { get; }\n\n        [Abstract]\n        [Export(\"backgroundColor\", ArgumentSemantic.Copy)]\n        UIColor BackgroundColor { get; }\n\n        [Abstract]\n        [Export(\"onPrimaryColor\", ArgumentSemantic.Copy)]\n        UIColor OnPrimaryColor { get; }\n\n        [Abstract]\n        [Export(\"onSecondaryColor\", ArgumentSemantic.Copy)]\n        UIColor OnSecondaryColor { get; }\n\n        [Abstract]\n        [Export(\"onSurfaceColor\", ArgumentSemantic.Copy)]\n        UIColor OnSurfaceColor { get; }\n\n        [Abstract]\n        [Export(\"onBackgroundColor\", ArgumentSemantic.Copy)]\n        UIColor OnBackgroundColor { get; }\n\n        [Abstract]\n        [Export(\"elevationOverlayColor\", ArgumentSemantic.Copy)]\n        UIColor ElevationOverlayColor { get; }\n\n        [Abstract]\n        [Export(\"elevationOverlayEnabledForDarkMode\")]\n        bool ElevationOverlayEnabledForDarkMode { get; }\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCSemanticColorScheme\")]\n    interface SemanticColorScheme : ColorScheming, INSCopying\n\n    {\n        [Export(\"primaryColor\", ArgumentSemantic.Copy)]\n        UIColor PrimaryColor { get; set; }\n\n        [Export(\"primaryColorVariant\", ArgumentSemantic.Copy)]\n        UIColor PrimaryColorVariant { get; set; }\n\n        [Export(\"secondaryColor\", ArgumentSemantic.Copy)]\n        UIColor SecondaryColor { get; set; }\n\n        [Export(\"errorColor\", ArgumentSemantic.Copy)]\n        UIColor ErrorColor { get; set; }\n\n        [Export(\"surfaceColor\", ArgumentSemantic.Copy)]\n        UIColor SurfaceColor { get; set; }\n\n        [Export(\"backgroundColor\", ArgumentSemantic.Copy)]\n        UIColor BackgroundColor { get; set; }\n\n        [Export(\"onPrimaryColor\", ArgumentSemantic.Copy)]\n        UIColor OnPrimaryColor { get; set; }\n\n        [Export(\"onSecondaryColor\", ArgumentSemantic.Copy)]\n        UIColor OnSecondaryColor { get; set; }\n\n        [Export(\"onSurfaceColor\", ArgumentSemantic.Copy)]\n        UIColor OnSurfaceColor { get; set; }\n\n        [Export(\"onBackgroundColor\", ArgumentSemantic.Copy)]\n        UIColor OnBackgroundColor { get; set; }\n\n        [Export(\"elevationOverlayColor\", ArgumentSemantic.Copy)]\n        UIColor ElevationOverlayColor { get; set; }\n\n        [Export(\"elevationOverlayEnabledForDarkMode\")]\n        bool ElevationOverlayEnabledForDarkMode { get; set; }\n\n        [Export(\"initWithDefaults:\")]\n        IntPtr Constructor(ColorSchemeDefaults defaults);\n\n        [Static]\n        [Export(\"blendColor:withBackgroundColor:\")]\n        UIColor BlendColor(UIColor color, UIColor backgroundColor);\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCShapeCategory\")]\n    interface ShapeCategory : INSCopying\n\n    {\n        [Export(\"topLeftCorner\", ArgumentSemantic.Copy)]\n        CornerTreatment TopLeftCorner { get; set; }\n\n        [Export(\"topRightCorner\", ArgumentSemantic.Copy)]\n        CornerTreatment TopRightCorner { get; set; }\n\n        [Export(\"bottomLeftCorner\", ArgumentSemantic.Copy)]\n        CornerTreatment BottomLeftCorner { get; set; }\n\n        [Export(\"bottomRightCorner\", ArgumentSemantic.Copy)]\n        CornerTreatment BottomRightCorner { get; set; }\n\n        [Export(\"initCornersWithFamily:andSize:\")]\n        IntPtr Constructor(ShapeCornerFamily cornerFamily, nfloat cornerSize);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCShapeScheming\")]\n    interface ShapeScheming\n    {\n        [Abstract]\n        [Export(\"smallComponentShape\")]\n        ShapeCategory SmallComponentShape { get; }\n\n        [Abstract]\n        [Export(\"mediumComponentShape\")]\n        ShapeCategory MediumComponentShape { get; }\n\n        [Abstract]\n        [Export(\"largeComponentShape\")]\n        ShapeCategory LargeComponentShape { get; }\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCShapeScheme\")]\n    interface ShapeScheme : ShapeScheming\n\n    {\n        [Export(\"smallComponentShape\", ArgumentSemantic.Assign)]\n        ShapeCategory SmallComponentShape { get; set; }\n\n        [Export(\"mediumComponentShape\", ArgumentSemantic.Assign)]\n        ShapeCategory MediumComponentShape { get; set; }\n\n        [Export(\"largeComponentShape\", ArgumentSemantic.Assign)]\n        ShapeCategory LargeComponentShape { get; set; }\n\n        [Export(\"initWithDefaults:\")]\n        IntPtr Constructor(ShapeSchemeDefaults defaults);\n    }\n\n    [Obsolete(\"This class will soon be deprecated. Consider using ITypographyScheming interface instead.\")]\n    [Protocol(Name = \"MDCFontScheme\")]\n    [BaseType(typeof(NSObject))]\n    interface FontScheme\n    {\n        [Abstract]\n        [NullAllowed]\n        [Export(\"headline1\", ArgumentSemantic.Strong)]\n        UIFont Headline1 { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"headline2\", ArgumentSemantic.Strong)]\n        UIFont Headline2 { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"headline3\", ArgumentSemantic.Strong)]\n        UIFont Headline3 { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"headline4\", ArgumentSemantic.Strong)]\n        UIFont Headline4 { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"headline5\", ArgumentSemantic.Strong)]\n        UIFont Headline5 { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"headline6\", ArgumentSemantic.Strong)]\n        UIFont Headline6 { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"subtitle1\", ArgumentSemantic.Strong)]\n        UIFont Subtitle1 { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"subtitle2\", ArgumentSemantic.Strong)]\n        UIFont Subtitle2 { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"body1\", ArgumentSemantic.Strong)]\n        UIFont Body1 { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"body2\", ArgumentSemantic.Strong)]\n        UIFont Body2 { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"caption\", ArgumentSemantic.Strong)]\n        UIFont Caption { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"button\", ArgumentSemantic.Strong)]\n        UIFont Button { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"overline\", ArgumentSemantic.Strong)]\n        UIFont Overline { get; }\n    }\n\n    [Obsolete(\"This class will soon be deprecated. Consider using TypographyScheme class instead.\")]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCBasicFontScheme\")]\n    interface BasicFontScheme : FontScheme\n\n    {\n        [NullAllowed]\n        [Export(\"headline1\", ArgumentSemantic.Assign)]\n        UIFont Headline1 { get; set; }\n\n        [NullAllowed]\n        [Export(\"headline2\", ArgumentSemantic.Assign)]\n        UIFont Headline2 { get; set; }\n\n        [NullAllowed]\n        [Export(\"headline3\", ArgumentSemantic.Assign)]\n        UIFont Headline3 { get; set; }\n\n        [NullAllowed]\n        [Export(\"headline4\", ArgumentSemantic.Assign)]\n        UIFont Headline4 { get; set; }\n\n        [NullAllowed]\n        [Export(\"headline5\", ArgumentSemantic.Assign)]\n        UIFont Headline5 { get; set; }\n\n        [NullAllowed]\n        [Export(\"headline6\", ArgumentSemantic.Assign)]\n        UIFont Headline6 { get; set; }\n\n        [NullAllowed]\n        [Export(\"subtitle1\", ArgumentSemantic.Assign)]\n        UIFont Subtitle1 { get; set; }\n\n        [NullAllowed]\n        [Export(\"subtitle2\", ArgumentSemantic.Assign)]\n        UIFont Subtitle2 { get; set; }\n\n        [NullAllowed]\n        [Export(\"body1\", ArgumentSemantic.Assign)]\n        UIFont Body1 { get; set; }\n\n        [NullAllowed]\n        [Export(\"body2\", ArgumentSemantic.Assign)]\n        UIFont Body2 { get; set; }\n\n        [NullAllowed]\n        [Export(\"caption\", ArgumentSemantic.Assign)]\n        UIFont Caption { get; set; }\n\n        [NullAllowed]\n        [Export(\"button\", ArgumentSemantic.Assign)]\n        UIFont Button { get; set; }\n\n        [NullAllowed]\n        [Export(\"overline\", ArgumentSemantic.Assign)]\n        UIFont Overline { get; set; }\n    }\n\n    [Protocol(Name = \"MDCTypographyScheming\")]\n    [BaseType(typeof(NSObject))]\n    interface TypographyScheming\n    {\n        [Abstract]\n        [Export(\"headline1\", ArgumentSemantic.Copy)]\n        UIFont Headline1 { get; }\n\n        [Abstract]\n        [Export(\"headline2\", ArgumentSemantic.Copy)]\n        UIFont Headline2 { get; }\n\n        [Abstract]\n        [Export(\"headline3\", ArgumentSemantic.Copy)]\n        UIFont Headline3 { get; }\n\n        [Abstract]\n        [Export(\"headline4\", ArgumentSemantic.Copy)]\n        UIFont Headline4 { get; }\n\n        [Abstract]\n        [Export(\"headline5\", ArgumentSemantic.Copy)]\n        UIFont Headline5 { get; }\n\n        [Abstract]\n        [Export(\"headline6\", ArgumentSemantic.Copy)]\n        UIFont Headline6 { get; }\n\n        [Abstract]\n        [Export(\"subtitle1\", ArgumentSemantic.Copy)]\n        UIFont Subtitle1 { get; }\n\n        [Abstract]\n        [Export(\"subtitle2\", ArgumentSemantic.Copy)]\n        UIFont Subtitle2 { get; }\n\n        [Abstract]\n        [Export(\"body1\", ArgumentSemantic.Copy)]\n        UIFont Body1 { get; }\n\n        [Abstract]\n        [Export(\"body2\", ArgumentSemantic.Copy)]\n        UIFont Body2 { get; }\n\n        [Abstract]\n        [Export(\"caption\", ArgumentSemantic.Copy)]\n        UIFont Caption { get; }\n\n        [Abstract]\n        [Export(\"button\", ArgumentSemantic.Copy)]\n        UIFont Button { get; }\n\n        [Abstract]\n        [Export(\"overline\", ArgumentSemantic.Copy)]\n        UIFont Overline { get; }\n\n        [Abstract]\n        [Export(\"useCurrentContentSizeCategoryWhenApplied\")]\n        bool UseCurrentContentSizeCategoryWhenApplied { get; }\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTypographyScheme\")]\n    interface TypographyScheme : TypographyScheming, INSCopying\n\n    {\n        [Export(\"headline1\", ArgumentSemantic.Copy)]\n        UIFont Headline1 { get; set; }\n\n        [Export(\"headline2\", ArgumentSemantic.Copy)]\n        UIFont Headline2 { get; set; }\n\n        [Export(\"headline3\", ArgumentSemantic.Copy)]\n        UIFont Headline3 { get; set; }\n\n        [Export(\"headline4\", ArgumentSemantic.Copy)]\n        UIFont Headline4 { get; set; }\n\n        [Export(\"headline5\", ArgumentSemantic.Copy)]\n        UIFont Headline5 { get; set; }\n\n        [Export(\"headline6\", ArgumentSemantic.Copy)]\n        UIFont Headline6 { get; set; }\n\n        [Export(\"subtitle1\", ArgumentSemantic.Copy)]\n        UIFont Subtitle1 { get; set; }\n\n        [Export(\"subtitle2\", ArgumentSemantic.Copy)]\n        UIFont Subtitle2 { get; set; }\n\n        [Export(\"body1\", ArgumentSemantic.Copy)]\n        UIFont Body1 { get; set; }\n\n        [Export(\"body2\", ArgumentSemantic.Copy)]\n        UIFont Body2 { get; set; }\n\n        [Export(\"caption\", ArgumentSemantic.Copy)]\n        UIFont Caption { get; set; }\n\n        [Export(\"button\", ArgumentSemantic.Copy)]\n        UIFont Button { get; set; }\n\n        [Export(\"overline\", ArgumentSemantic.Copy)]\n        UIFont Overline { get; set; }\n\n        [Export(\"useCurrentContentSizeCategoryWhenApplied\")]\n        bool UseCurrentContentSizeCategoryWhenApplied { get; set; }\n\n        [Export(\"initWithDefaults:\")]\n        IntPtr Constructor(TypographySchemeDefaults defaults);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCContainerScheming\")]\n    interface ContainerScheming\n    {\n        [Abstract]\n        [Export(\"colorScheme\")]\n        ColorScheming ColorScheme { get; }\n\n        [Abstract]\n        [Export(\"typographyScheme\")]\n        TypographyScheming TypographyScheme { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"shapeScheme\")]\n        ShapeScheming ShapeScheme { get; }\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCContainerScheme\")]\n    interface ContainerScheme : ContainerScheming\n\n    {\n        [Export(\"colorScheme\", ArgumentSemantic.Assign)]\n        SemanticColorScheme ColorScheme { get; set; }\n\n        [Export(\"typographyScheme\", ArgumentSemantic.Assign)]\n        TypographyScheme TypographyScheme { get; set; }\n\n        [NullAllowed]\n        [Export(\"shapeScheme\", ArgumentSemantic.Assign)]\n        ShapeScheme ShapeScheme { get; set; }\n    }\n\n    [Category]\n    [BaseType(typeof(ActionSheetController),\n        Name = \"MDCActionSheetController_MaterialTheming\")]\n    interface ActionSheetController_MaterialTheming\n    {\n        [Export(\"applyThemeWithScheme:\")]\n        void ApplyTheme(IContainerScheming scheme);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCActivityIndicator\",\n        Delegates = new[] { \"Delegate\" },\n        Events = new[] { typeof(ActivityIndicatorDelegate) })]\n    interface ActivityIndicator\n    {\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        IActivityIndicatorDelegate Delegate { get; set; }\n\n        [Export(\"animating\")]\n        bool Animating { [Bind(\"isAnimating\")] get; set; }\n\n        [Export(\"radius\")]\n        nfloat Radius { get; set; }\n\n        [Export(\"strokeWidth\")]\n        nfloat StrokeWidth { get; set; }\n\n        [Export(\"trackEnabled\")]\n        bool TrackEnabled { get; set; }\n\n        [Export(\"indicatorMode\", ArgumentSemantic.Assign)]\n        ActivityIndicatorMode IndicatorMode { get; set; }\n\n        [Export(\"progress\")]\n        float Progress { get; set; }\n\n        [Export(\"cycleColors\", ArgumentSemantic.Copy)]\n        UIColor[] CycleColors { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<ActivityIndicator, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"setIndicatorMode:animated:\")]\n        void SetIndicatorMode(ActivityIndicatorMode mode, bool animated);\n\n        [Export(\"setProgress:animated:\")]\n        void SetProgress(float progress, bool animated);\n\n        [Export(\"startAnimating\")]\n        void StartAnimating();\n\n        [Export(\"startAnimatingWithTransition:cycleStartIndex:\")]\n        void StartAnimating(ActivityIndicatorTransition startTransition, nint cycleStartIndex);\n\n        [Export(\"stopAnimating\")]\n        void StopAnimating();\n\n        [Export(\"stopAnimatingWithTransition:\")]\n        void StopAnimatingWithTransition(ActivityIndicatorTransition stopTransition);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCActivityIndicatorDelegate\")]\n    interface ActivityIndicatorDelegate\n    {\n        [EventArgs(\"ActivityIndicatorFinished\")]\n        [EventName(\"AnimationFinished\")]\n        [Export(\"activityIndicatorAnimationDidFinish:\")]\n        void AnimationDidFinish(ActivityIndicator activityIndicator);\n\n        [EventArgs(\"ActivityIndicatorFinished\")]\n        [EventName(\"ModeTransitionFinished\")]\n        [Export(\"activityIndicatorModeTransitionDidFinish:\")]\n        void ModeTransitionDidFinish(ActivityIndicator activityIndicator);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCActivityIndicatorTransition\")]\n    interface ActivityIndicatorTransition\n    {\n        [Export(\"animation\", ArgumentSemantic.Copy)]\n        ActivityIndicatorAnimationHandler Animation { get; set; }\n\n        [NullAllowed]\n        [Export(\"completion\", ArgumentSemantic.Copy)]\n        Action Completion { get; set; }\n\n        [Export(\"duration\")]\n        double Duration { get; set; }\n\n        [DesignatedInitializer]\n        [Export(\"initWithAnimation:\")]\n        IntPtr Constructor(ActivityIndicatorAnimationHandler animation);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCActivityIndicatorColorThemer\")]\n    interface ActivityIndicatorColorThemer\n    {\n        [Static]\n        [Export(\"applySemanticColorScheme:toActivityIndicator:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, ActivityIndicator activityIndicator);\n\n        [Obsolete(\"This method will soon be deprecated. Consider using ApplySemanticColorScheme method instead.\")]\n        [Static]\n        [Export(\"applyColorScheme:toActivityIndicator:\")]\n        void ApplyColorScheme(IColorScheme colorScheme, ActivityIndicator activityIndicator);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(UIViewController),\n        Name = \"MDCAppBarContainerViewController\")]\n    interface AppBarContainerViewController\n    {\n        [Export(\"appBarViewController\", ArgumentSemantic.Strong)]\n        AppBarViewController AppBarViewController { get; }\n\n        [Export(\"contentViewController\", ArgumentSemantic.Strong)]\n        UIViewController ContentViewController { get; }\n\n        [Export(\"topLayoutGuideAdjustmentEnabled\")]\n        bool TopLayoutGuideAdjustmentEnabled { [Bind(\"isTopLayoutGuideAdjustmentEnabled\")] get; set; }\n\n        [Obsolete(\"This API will eventually be deprecated. Use AppBarViewController property instead.\")]\n        [Export(\"appBar\", ArgumentSemantic.Strong)]\n        AppBar AppBar { get; }\n\n        [DesignatedInitializer]\n        [Export(\"initWithContentViewController:\")]\n        IntPtr Constructor(UIViewController contentViewController);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCAppBarNavigationControllerDelegate\")]\n    interface AppBarNavigationControllerDelegate : IUINavigationControllerDelegate\n\n    {\n        [EventArgs(\"AppBarNavigationControllerWillAddAppBarViewController\")]\n        [Export(\"appBarNavigationController:willAddAppBarViewController:asChildOfViewController:\")]\n        void WillAddAppBarViewController(AppBarNavigationController navigationController, AppBarViewController appBarViewController, UIViewController viewController);\n\n        [return: NullAllowed]\n        [Export(\"appBarNavigationController:trackingScrollViewForViewController:suggestedTrackingScrollView:\")]\n        UIScrollView TrackScrollView(AppBarNavigationController navigationController, UIViewController viewController, [NullAllowed]  UIScrollView scrollView);\n\n        [EventArgs(\"AppBarNavigationControllerWillAddAppBar\")]\n        [Obsolete(\"This method will soon be deprecated. Please use WillAddAppBarViewController method instead.\")]\n        [Export(\"appBarNavigationController:willAddAppBar:asChildOfViewController:\")]\n        void WillAddAppBar(AppBarNavigationController navigationController, AppBar appBar, UIViewController viewController);\n    }\n\n    [BaseType(typeof(UINavigationController),\n        Name = \"MDCAppBarNavigationController\")]\n    interface AppBarNavigationController\n    {\n        [New]\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        IAppBarNavigationControllerDelegate Delegate { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlockForAppBarController\", ArgumentSemantic.Copy)]\n        Action<FlexibleHeaderViewController, UITraitCollection> TraitCollectionDidChangeBlockForAppBarController { get; set; }\n\n        [return: NullAllowed]\n        [Export(\"appBarViewControllerForViewController:\")]\n        AppBarViewController GetAppBarViewController(UIViewController viewController);\n\n        [Obsolete(\"This method will eventually be deprecated. Use GetAppBarViewController method instead.\")]\n        [return: NullAllowed]\n        [Export(\"appBarForViewController:\")]\n        AppBar GetAppBar(UIViewController viewController);\n    }\n\n    [BaseType(typeof(UIViewController),\n        Name = \"MDCFlexibleHeaderContainerViewController\")]\n    interface FlexibleHeaderContainerViewController\n    {\n        [Export(\"headerViewController\", ArgumentSemantic.Strong)]\n        FlexibleHeaderViewController HeaderViewController { get; }\n\n        [NullAllowed]\n        [Export(\"contentViewController\", ArgumentSemantic.Strong)]\n        UIViewController ContentViewController { get; set; }\n\n        [Export(\"topLayoutGuideAdjustmentEnabled\")]\n        bool TopLayoutGuideAdjustmentEnabled { [Bind(\"isTopLayoutGuideAdjustmentEnabled\")] get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<FlexibleHeaderContainerViewController, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [DesignatedInitializer]\n        [Export(\"initWithContentViewController:\")]\n        IntPtr Constructor([NullAllowed] UIViewController contentViewController);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCFlexibleHeaderView\",\n        Delegates = new[] { \"Delegate\" },\n        Events = new[] { typeof(FlexibleHeaderViewDelegate) })]\n    interface FlexibleHeaderView : IElevatable, IElevationOverriding\n\n    {\n        [Export(\"shadowLayer\", ArgumentSemantic.Strong)]\n        CALayer ShadowLayer { get; set; }\n\n        [Export(\"shadowColor\", ArgumentSemantic.Copy)]\n        UIColor ShadowColor { get; set; }\n\n        [Export(\"prefersStatusBarHidden\")]\n        bool PrefersStatusBarHidden { get; }\n\n        [Export(\"scrollPhase\")]\n        FlexibleHeaderScrollPhase ScrollPhase { get; }\n\n        [Export(\"scrollPhaseValue\")]\n        nfloat ScrollPhaseValue { get; }\n\n        [Export(\"scrollPhasePercentage\")]\n        nfloat ScrollPhasePercentage { get; }\n\n        [Export(\"minimumHeight\")]\n        nfloat MinimumHeight { get; set; }\n\n        [Export(\"maximumHeight\")]\n        nfloat MaximumHeight { get; set; }\n\n        [Export(\"minMaxHeightIncludesSafeArea\")]\n        bool MinMaxHeightIncludesSafeArea { get; set; }\n\n        [Export(\"topSafeAreaGuide\")]\n        NSObject TopSafeAreaGuide { get; }\n\n        [Export(\"canOverExtend\")]\n        bool CanOverExtend { get; set; }\n\n        [Export(\"visibleShadowOpacity\")]\n        float VisibleShadowOpacity { get; set; }\n\n        [Export(\"resetShadowAfterTrackingScrollViewIsReset\")]\n        bool ResetShadowAfterTrackingScrollViewIsReset { get; set; }\n\n        [NullAllowed]\n        [Export(\"trackingScrollView\", ArgumentSemantic.Weak)]\n        UIScrollView TrackingScrollView { get; set; }\n\n        [Export(\"observesTrackingScrollViewScrollEvents\")]\n        bool ObservesTrackingScrollViewScrollEvents { get; set; }\n\n        [Export(\"inFrontOfInfiniteContent\")]\n        bool InFrontOfInfiniteContent { [Bind(\"isInFrontOfInfiniteContent\")] get; set; }\n\n        [Export(\"sharedWithManyScrollViews\")]\n        bool SharedWithManyScrollViews { get; set; }\n\n        [Introduced(PlatformName.iOS, 11, 0)]\n        [Introduced(PlatformName.TvOS, 11, 0)]\n        [Export(\"disableContentInsetAdjustmentWhenContentInsetAdjustmentBehaviorIsNever\")]\n        bool DisableContentInsetAdjustmentWhenContentInsetAdjustmentBehaviorIsNever { get; set; }\n\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        IFlexibleHeaderViewDelegate Delegate { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<FlexibleHeaderView, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"elevation\")]\n        double Elevation { get; set; }\n\n        [Export(\"canAlwaysExpandToMaximumHeight\")]\n        bool CanAlwaysExpandToMaximumHeight { get; set; }\n\n        [Export(\"shiftBehavior\", ArgumentSemantic.Assign)]\n        FlexibleHeaderShiftBehavior ShiftBehavior { get; set; }\n\n        [Export(\"headerContentImportance\", ArgumentSemantic.Assign)]\n        FlexibleHeaderContentImportance HeaderContentImportance { get; set; }\n\n        [Export(\"trackingScrollViewIsBeingScrubbed\")]\n        bool TrackingScrollViewIsBeingScrubbed { get; set; }\n\n        [Export(\"contentIsTranslucent\")]\n        bool ContentIsTranslucent { get; set; }\n\n        [Export(\"statusBarHintCanOverlapHeader\")]\n        bool StatusBarHintCanOverlapHeader { get; set; }\n\n        [Export(\"setShadowLayer:intensityDidChangeBlock:\")]\n        void SetShadowLayer(CALayer shadowLayer, FlexibleHeaderShadowIntensityChangeHandler block);\n\n        [Advice(\"Do not invoke this method if ObservesTrackingScrollViewScrollEvents property is set to true.\")]\n        [Export(\"trackingScrollViewDidScroll\")]\n        void TrackingScrollViewDidScroll();\n\n        [Export(\"trackingScrollViewDidChangeAdjustedContentInset:\")]\n        void TrackingScrollViewDidChangeAdjustedContentInset([NullAllowed] UIScrollView trackingScrollView);\n\n        [Export(\"trackingScrollWillChangeToScrollView:\")]\n        void TrackingScrollWillChangeToScrollView([NullAllowed] UIScrollView scrollView);\n\n        [Export(\"interfaceOrientationWillChange\")]\n        void InterfaceOrientationWillChange();\n\n        [Export(\"interfaceOrientationIsChanging\")]\n        void InterfaceOrientationIsChanging();\n\n        [Export(\"interfaceOrientationDidChange\")]\n        void InterfaceOrientationDidChange();\n\n        [Export(\"viewWillTransitionToSize:withTransitionCoordinator:\")]\n        void ViewWillTransitionToSize(CGSize size, IUIViewControllerTransitionCoordinator coordinator);\n\n        [Export(\"changeContentInsets:\")]\n        void ChangeContentInsets(FlexibleHeaderChangeContentInsetsHandler block);\n\n        [Export(\"forwardTouchEventsForView:\")]\n        void ForwardTouchEventsForView(UIView view);\n\n        [Export(\"stopForwardingTouchEventsForView:\")]\n        void StopForwardingTouchEventsForView(UIView view);\n\n        [Export(\"hideViewWhenShifted:\")]\n        void HideViewWhenShifted(UIView view);\n\n        [Export(\"stopHidingViewWhenShifted:\")]\n        void StopHidingViewWhenShifted(UIView view);\n\n        [Export(\"shiftHeaderOnScreenAnimated:\")]\n        void ShiftHeaderOnScreen(bool animated);\n\n        [Export(\"shiftHeaderOffScreenAnimated:\")]\n        void ShiftHeaderOffScreen(bool animated);\n\n        [Advice(\"Do not invoke this method if ObservesTrackingScrollViewScrollEvents property is set to true.\")]\n        [Export(\"trackingScrollViewDidEndDraggingWillDecelerate:\")]\n        void TrackingScrollViewDidEndDragging(bool willDecelerate);\n\n        [Advice(\"Do not invoke this method if ObservesTrackingScrollViewScrollEvents property is set to true.\")]\n        [Export(\"trackingScrollViewDidEndDecelerating\")]\n        void TrackingScrollViewDidEndDecelerating();\n\n        [Advice(\"Do not invoke this method if ObservesTrackingScrollViewScrollEvents property is set to true.\")]\n        [Export(\"trackingScrollViewWillEndDraggingWithVelocity:targetContentOffset:\")]\n        bool TrackingScrollViewWillEndDragging(CGPoint velocity, ref CGPoint targetContentOffset);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCFlexibleHeaderViewDelegate\")]\n    interface FlexibleHeaderViewDelegate\n    {\n        [EventArgs(\"FlexibleHeaderView\")]\n        [Abstract]\n        [Export(\"flexibleHeaderViewNeedsStatusBarAppearanceUpdate:\")]\n        void NeedsStatusBarAppearanceUpdate(FlexibleHeaderView headerView);\n\n        [EventArgs(\"FlexibleHeaderView\")]\n        [EventName(\"FrameChanged\")]\n        [Abstract]\n        [Export(\"flexibleHeaderViewFrameDidChange:\")]\n        void FrameDidChange(FlexibleHeaderView headerView);\n    }\n\n    [BaseType(typeof(UIViewController),\n        Name = \"MDCFlexibleHeaderViewController\",\n        Delegates = new[] { \"LayoutDelegate\" },\n        Events = new[] { typeof(FlexibleHeaderViewLayoutDelegate) })]\n    interface FlexibleHeaderViewController : IUIScrollViewDelegate, IUITableViewDelegate\n\n    {\n        [Export(\"headerView\", ArgumentSemantic.Strong)]\n        FlexibleHeaderView HeaderView { get; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<FlexibleHeaderViewController, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [NullAllowed]\n        [Export(\"layoutDelegate\", ArgumentSemantic.Weak)]\n        IFlexibleHeaderViewLayoutDelegate LayoutDelegate { get; set; }\n\n        [Wrap(\"WeakSafeAreaDelegate\")]\n        [NullAllowed]\n        IFlexibleHeaderSafeAreaDelegate SafeAreaDelegate { get; set; }\n\n        [NullAllowed]\n        [Export(\"safeAreaDelegate\", ArgumentSemantic.Weak)]\n        NSObject WeakSafeAreaDelegate { get; set; }\n\n        [Export(\"topLayoutGuideAdjustmentEnabled\")]\n        bool TopLayoutGuideAdjustmentEnabled { [Bind(\"isTopLayoutGuideAdjustmentEnabled\")] get; set; }\n\n        [NullAllowed]\n        [Export(\"topLayoutGuideViewController\", ArgumentSemantic.Weak)]\n        UIViewController TopLayoutGuideViewController { get; set; }\n\n        [Export(\"inferTopSafeAreaInsetFromViewController\")]\n        bool InferTopSafeAreaInsetFromViewController { get; set; }\n\n        [Export(\"useAdditionalSafeAreaInsetsForWebKitScrollViews\")]\n        bool UseAdditionalSafeAreaInsetsForWebKitScrollViews { get; set; }\n\n        [New]\n        [Export(\"prefersStatusBarHidden\")]\n        bool PrefersStatusBarHidden { get; }\n\n        [New]\n        [Export(\"preferredStatusBarStyle\")]\n        UIStatusBarStyle PreferredStatusBarStyle { get; }\n\n        [Export(\"inferPreferredStatusBarStyle\")]\n        bool InferPreferredStatusBarStyle { get; set; }\n\n        [Export(\"updateTopLayoutGuide\")]\n        void UpdateTopLayoutGuide();\n    }\n\n    [Protocol(Name = \"MDCFlexibleHeaderSafeAreaDelegate\")]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject))]\n    interface FlexibleHeaderSafeAreaDelegate\n    {\n        [return: NullAllowed]\n        [Abstract]\n        [Export(\"flexibleHeaderViewControllerTopSafeAreaInsetViewController:\")]\n        UIViewController FlexibleHeaderViewControllerTopSafeAreaInsetViewController(FlexibleHeaderViewController flexibleHeaderViewController);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCFlexibleHeaderViewLayoutDelegate\")]\n    interface FlexibleHeaderViewLayoutDelegate\n    {\n        [EventArgs(\"FlexibleHeaderViewLayoutFrameChanged\")]\n        [EventName(\"FrameChanged\")]\n        [Abstract]\n        [Export(\"flexibleHeaderViewController:flexibleHeaderViewFrameDidChange:\")]\n        void FrameDidChange(FlexibleHeaderViewController flexibleHeaderViewController, FlexibleHeaderView flexibleHeaderView);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCHeaderStackView\")]\n    interface HeaderStackView\n    {\n        [NullAllowed]\n        [Export(\"topBar\", ArgumentSemantic.Strong)]\n        UIView TopBar { get; set; }\n\n        [NullAllowed]\n        [Export(\"bottomBar\", ArgumentSemantic.Strong)]\n        UIView BottomBar { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<HeaderStackView, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n    }\n\n    [Protocol(Name = \"MDCUINavigationItemObservables\")]\n    [BaseType(typeof(NSObject))]\n    interface UINavigationItemObservables\n    {\n        [Abstract]\n        [NullAllowed]\n        [Export(\"title\")]\n        string Title { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"titleView\", ArgumentSemantic.Strong)]\n        UIView TitleView { get; set; }\n\n        [Abstract]\n        [Export(\"hidesBackButton\")]\n        bool HidesBackButton { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"leftBarButtonItems\", ArgumentSemantic.Copy)]\n        UIBarButtonItem[] LeftBarButtonItems { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"rightBarButtonItems\", ArgumentSemantic.Copy)]\n        UIBarButtonItem[] RightBarButtonItems { get; set; }\n\n        [Abstract]\n        [Export(\"leftItemsSupplementBackButton\")]\n        bool LeftItemsSupplementBackButton { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"leftBarButtonItem\", ArgumentSemantic.Strong)]\n        UIBarButtonItem LeftBarButtonItem { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"rightBarButtonItem\", ArgumentSemantic.Strong)]\n        UIBarButtonItem RightBarButtonItem { get; set; }\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCNavigationBarTextColorAccessibilityMutator\")]\n    interface NavigationBarTextColorAccessibilityMutator\n    {\n        [Export(\"mutate:\")]\n        void Mutate(NavigationBar navBar);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCNavigationBar\")]\n    interface NavigationBar : IElevatable, IElevationOverriding\n\n    {\n        [NullAllowed]\n        [Export(\"title\")]\n        string Title { get; set; }\n\n        [NullAllowed]\n        [Export(\"titleView\", ArgumentSemantic.Strong)]\n        UIView TitleView { get; set; }\n\n        [Export(\"titleViewLayoutBehavior\", ArgumentSemantic.Assign)]\n        NavigationBarTitleViewLayoutBehavior TitleViewLayoutBehavior { get; set; }\n\n        [Export(\"titleInsets\", ArgumentSemantic.Assign)]\n        UIEdgeInsets TitleInsets { get; set; }\n\n        [Export(\"titleFont\", ArgumentSemantic.Strong)]\n        UIFont TitleFont { get; set; }\n\n        [Export(\"allowAnyTitleFontSize\")]\n        bool AllowAnyTitleFontSize { get; set; }\n\n        [NullAllowed]\n        [Export(\"titleTextColor\", ArgumentSemantic.Strong)]\n        UIColor TitleTextColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"rippleColor\", ArgumentSemantic.Strong)]\n        UIColor RippleColor { get; set; }\n\n        [Export(\"enableRippleBehavior\")]\n        bool EnableRippleBehavior { get; set; }\n\n        [Export(\"uppercasesButtonTitles\")]\n        bool UppercasesButtonTitles { get; set; }\n\n        [NullAllowed]\n        [Export(\"leadingBarItemsTintColor\", ArgumentSemantic.Strong)]\n        UIColor LeadingBarItemsTintColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"trailingBarItemsTintColor\", ArgumentSemantic.Strong)]\n        UIColor TrailingBarItemsTintColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"backItem\", ArgumentSemantic.Strong)]\n        UIBarButtonItem BackItem { get; set; }\n\n        [Export(\"hidesBackButton\")]\n        bool HidesBackButton { get; set; }\n\n        [NullAllowed]\n        [Export(\"leadingBarButtonItems\", ArgumentSemantic.Copy)]\n        UIBarButtonItem[] LeadingBarButtonItems { get; set; }\n\n        [NullAllowed]\n        [Export(\"trailingBarButtonItems\", ArgumentSemantic.Copy)]\n        UIBarButtonItem[] TrailingBarButtonItems { get; set; }\n\n        [Export(\"leadingItemsSupplementBackButton\")]\n        bool LeadingItemsSupplementBackButton { get; set; }\n\n        [NullAllowed]\n        [Export(\"leadingBarButtonItem\", ArgumentSemantic.Strong)]\n        UIBarButtonItem LeadingBarButtonItem { get; set; }\n\n        [NullAllowed]\n        [Export(\"trailingBarButtonItem\", ArgumentSemantic.Strong)]\n        UIBarButtonItem TrailingBarButtonItem { get; set; }\n\n        [Export(\"titleAlignment\", ArgumentSemantic.Assign)]\n        NavigationBarTitleAlignment TitleAlignment { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<NavigationBar, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [NullAllowed]\n        [Export(\"leftBarButtonItems\", ArgumentSemantic.Copy)]\n        UIBarButtonItem[] LeftBarButtonItems { get; set; }\n\n        [NullAllowed]\n        [Export(\"rightBarButtonItems\", ArgumentSemantic.Copy)]\n        UIBarButtonItem[] RightBarButtonItems { get; set; }\n\n        [NullAllowed]\n        [Export(\"leftBarButtonItem\", ArgumentSemantic.Strong)]\n        UIBarButtonItem LeftBarButtonItem { get; set; }\n\n        [NullAllowed]\n        [Export(\"rightBarButtonItem\", ArgumentSemantic.Strong)]\n        UIBarButtonItem RightBarButtonItem { get; set; }\n\n        [Export(\"leftItemsSupplementBackButton\")]\n        bool LeftItemsSupplementBackButton { get; set; }\n\n        [Obsolete(\"This property will be deprecated in future, please use TitleFont and TitleTextColor properties instead.\")]\n        [NullAllowed]\n        [Export(\"titleTextAttributes\", ArgumentSemantic.Copy)]\n        NSDictionary<NSString, NSObject> TitleTextAttributes { get; set; }\n\n        [Export(\"setButtonsTitleFont:forState:\")]\n        void SetButtonsTitleFont([NullAllowed] UIFont font, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"buttonsTitleFontForState:\")]\n        UIFont GetButtonsTitleFont(UIControlState state);\n\n        [Export(\"setButtonsTitleColor:forState:\")]\n        void SetButtonsTitleColor([NullAllowed] UIColor color, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"buttonsTitleColorForState:\")]\n        UIColor GetButtonsTitleColor(UIControlState state);\n\n        [Export(\"rectForLeadingBarButtonItem:inCoordinateSpace:\")]\n        CGRect RectForLeadingBarButtonItem(UIBarButtonItem item, UICoordinateSpace coordinateSpace);\n\n        [Export(\"rectForTrailingBarButtonItem:inCoordinateSpace:\")]\n        CGRect RectForTrailingBarButtonItem(UIBarButtonItem item, UICoordinateSpace coordinateSpace);\n\n        [Export(\"observeNavigationItem:\")]\n        void ObserveNavigationItem(UINavigationItem navigationItem);\n\n        [Export(\"unobserveNavigationItem\")]\n        void UnobserveNavigationItem();\n\n        [NullAllowed]\n        [Export(\"inkColor\", ArgumentSemantic.Strong)]\n        UIColor InkColor { get; set; }\n    }\n\n    [BaseType(typeof(FlexibleHeaderViewController),\n        Name = \"MDCAppBarViewController\")]\n    interface AppBarViewController\n    {\n        [Export(\"navigationBar\", ArgumentSemantic.Strong)]\n        NavigationBar NavigationBar { get; set; }\n\n        [Export(\"headerStackView\", ArgumentSemantic.Strong)]\n        HeaderStackView HeaderStackView { get; set; }\n    }\n\n    [Obsolete(\"This API will be deprecated in favor of AppBarViewController class.\")]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCAppBar\")]\n    interface AppBar\n    {\n        [Export(\"headerViewController\", ArgumentSemantic.Strong)]\n        FlexibleHeaderViewController HeaderViewController { get; }\n\n        [Export(\"appBarViewController\", ArgumentSemantic.Strong)]\n        AppBarViewController AppBarViewController { get; }\n\n        [Export(\"navigationBar\", ArgumentSemantic.Strong)]\n        NavigationBar NavigationBar { get; }\n\n        [Export(\"headerStackView\", ArgumentSemantic.Strong)]\n        HeaderStackView HeaderStackView { get; }\n\n        [Export(\"inferTopSafeAreaInsetFromViewController\")]\n        bool InferTopSafeAreaInsetFromViewController { get; set; }\n\n        [Export(\"addSubviewsToParent\")]\n        void AddSubviewsToParent();\n    }\n\n    [Obsolete(\"This class will soon be deprecated.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCAppBarColorThemer\")]\n    interface AppBarColorThemer\n    {\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Export(\"applySemanticColorScheme:toAppBar:\")]\n        [Static]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, AppBar appBar);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Export(\"applySurfaceVariantWithColorScheme:toAppBar:\")]\n        [Static]\n        void ApplySurfaceVariant(IColorScheming colorScheme, AppBar appBar);\n\n        [Obsolete(\"This method will soon be deprecated. Consider using ApplySemanticColorScheme method instead.\")]\n        [Export(\"applyColorScheme:toAppBar:\")]\n        [Static]\n        void ApplyColorScheme(IColorScheme colorScheme, AppBar appBar);\n\n        [Obsolete(\"This method will soon be deprecated. Consider using ApplySemanticColorScheme method instead.\")]\n        [Static]\n        [Export(\"applyColorScheme:toAppBarViewController:\")]\n        void ApplyColorScheme(IColorScheming colorScheme, AppBarViewController appBarViewController);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Export(\"applySurfaceVariantWithColorScheme:toAppBarViewController:\")]\n        [Static]\n        void ApplySurfaceVariant(IColorScheming colorScheme, AppBarViewController appBarViewController);\n    }\n\n    [Category]\n    [BaseType(typeof(AppBarViewController),\n        Name = \"MDCAppBarViewController_MaterialTheming\")]\n    interface AppBarViewController_MaterialTheming\n    {\n        [Export(\"applyPrimaryThemeWithScheme:\")]\n        void ApplyPrimaryThemeWithScheme(IContainerScheming containerScheme);\n\n        [Export(\"applySurfaceThemeWithScheme:\")]\n        void ApplySurfaceThemeWithScheme(IContainerScheming containerScheme);\n    }\n\n    [Obsolete(\"This class will soon be deprecated.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCAppBarTypographyThemer\")]\n    interface AppBarTypographyThemer\n    {\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyTypographyScheme:toAppBar:\")]\n        void ApplyTypographyScheme(ITypographyScheming typographyScheme, AppBar appBar);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyTypographyScheme:toAppBarViewController:\")]\n        void ApplyTypographyScheme(ITypographyScheming typographyScheme, AppBarViewController appBarViewController);\n    }\n\n    [BaseType(typeof(UIGestureRecognizer),\n        Name = \"MDCInkGestureRecognizer\")]\n    interface InkGestureRecognizer\n    {\n        [Export(\"dragCancelDistance\")]\n        nfloat DragCancelDistance { get; set; }\n\n        [Export(\"cancelOnDragOut\")]\n        bool CancelOnDragOut { get; set; }\n\n        [Export(\"targetBounds\", ArgumentSemantic.Assign)]\n        CGRect TargetBounds { get; set; }\n\n\n        [Export(\"isTouchWithinTargetBounds\")]\n        bool IsTouchWithinTargetBounds { get; }\n\n        [Export(\"touchStartLocationInView:\")]\n        CGPoint GetTouchStartLocation(UIView view);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCInkTouchController\",\n        Delegates = new[] { \"Delegate\" },\n        Events = new[] { typeof(InkTouchControllerDelegate) })]\n    interface InkTouchController : IUIGestureRecognizerDelegate\n\n    {\n        [NullAllowed]\n        [Export(\"view\", ArgumentSemantic.Weak)]\n        UIView View { get; }\n\n        [Export(\"defaultInkView\", ArgumentSemantic.Strong)]\n        InkView DefaultInkView { get; }\n\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        IInkTouchControllerDelegate Delegate { get; set; }\n\n        [Export(\"delaysInkSpread\")]\n        bool DelaysInkSpread { get; set; }\n\n        [Export(\"dragCancelDistance\")]\n        nfloat DragCancelDistance { get; set; }\n\n        [Export(\"cancelsOnDragOut\")]\n        bool CancelsOnDragOut { get; set; }\n\n        [Export(\"requiresFailureOfScrollViewGestures\")]\n        bool RequiresFailureOfScrollViewGestures { get; set; }\n\n        [Export(\"targetBounds\", ArgumentSemantic.Assign)]\n        CGRect TargetBounds { get; set; }\n\n        [Export(\"gestureRecognizer\", ArgumentSemantic.Strong)]\n        InkGestureRecognizer GestureRecognizer { get; }\n\n        [DesignatedInitializer]\n        [Export(\"initWithView:\")]\n        IntPtr Constructor(UIView view);\n\n        [Export(\"addInkView\")]\n        void AddInkView();\n\n        [Export(\"cancelInkTouchProcessing\")]\n        void CancelInkTouchProcessing();\n\n        [return: NullAllowed]\n        [Export(\"inkViewAtTouchLocation:\")]\n        InkView GetInkView(CGPoint location);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCInkTouchControllerDelegate\")]\n    interface InkTouchControllerDelegate\n    {\n        [EventArgs(\"InkTouchControllerInsertInkView\")]\n        [Export(\"inkTouchController:insertInkView:intoView:\")]\n        void InsertInkView(InkTouchController inkTouchController, UIView inkView, UIView view);\n\n        [NoDefaultValue]\n        [DelegateName(\"InkTouchControllerGetInkViewAtTouchLocation\")]\n        [return: NullAllowed]\n        [Export(\"inkTouchController:inkViewAtTouchLocation:\")]\n        InkView GetInkViewAtTouchLocation(InkTouchController inkTouchController, CGPoint location);\n\n        [DefaultValue(true)]\n        [DelegateName(\"InkTouchControllerShouldProcessInkTouches\")]\n        [Export(\"inkTouchController:shouldProcessInkTouchesAtTouchLocation:\")]\n        bool ShouldProcessInkTouches(InkTouchController inkTouchController, CGPoint location);\n\n        [EventArgs(\"InkTouchControllerInkViewProcessed\")]\n        [EventName(\"InkViewProcessed\")]\n        [Export(\"inkTouchController:didProcessInkView:atTouchLocation:\")]\n        void DidProcessInkView(InkTouchController inkTouchController, InkView inkView, CGPoint location);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCInkView\",\n        Delegates = new[] { \"AnimationDelegate\" },\n        Events = new[] { typeof(InkViewDelegate) })]\n    interface InkView\n    {\n        [NullAllowed]\n        [Export(\"animationDelegate\", ArgumentSemantic.Weak)]\n        IInkViewDelegate AnimationDelegate { get; set; }\n\n        [Export(\"inkStyle\", ArgumentSemantic.Assign)]\n        InkStyle InkStyle { get; set; }\n\n        [Export(\"inkColor\", ArgumentSemantic.Strong)]\n        UIColor InkColor { get; set; }\n\n        [Export(\"defaultInkColor\", ArgumentSemantic.Strong)]\n        UIColor DefaultInkColor { get; }\n\n        [Export(\"maxRippleRadius\")]\n        nfloat MaxRippleRadius { get; set; }\n\n        [Export(\"usesLegacyInkRipple\")]\n        bool UsesLegacyInkRipple { get; set; }\n\n        [Export(\"usesCustomInkCenter\")]\n        bool UsesCustomInkCenter { get; set; }\n\n        [Export(\"customInkCenter\", ArgumentSemantic.Assign)]\n        CGPoint CustomInkCenter { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<InkView, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"startTouchBeganAnimationAtPoint:completion:\")]\n        void StartTouchBeganAnimation(CGPoint point, [NullAllowed]  InkCompletionHandler completionBlock);\n\n        [Export(\"startTouchEndedAnimationAtPoint:completion:\")]\n        void StartTouchEndedAnimation(CGPoint point, [NullAllowed]  InkCompletionHandler completionBlock);\n\n        [Export(\"cancelAllAnimationsAnimated:\")]\n        void CancelAllAnimations(bool animated);\n\n        [Export(\"startTouchBeganAtPoint:animated:withCompletion:\")]\n        void StartTouchBegan(CGPoint point, bool animated, [NullAllowed]  InkCompletionHandler completionBlock);\n\n        [Export(\"startTouchEndAtPoint:animated:withCompletion:\")]\n        void StartTouchEnd(CGPoint point, bool animated, [NullAllowed]  InkCompletionHandler completionBlock);\n\n        [Static]\n        [Export(\"injectedInkViewForView:\")]\n        InkView GetInjectedInkView(UIView view);\n    }\n\n    [BaseType(typeof(UIButton),\n        Name = \"MDCButton\")]\n    interface Button : INativeObject\n\n    {\n        [Export(\"inkStyle\", ArgumentSemantic.Assign)]\n        InkStyle InkStyle { get; set; }\n\n        [Export(\"inkColor\", ArgumentSemantic.Strong)]\n        UIColor InkColor { get; set; }\n\n        [Export(\"inkMaxRippleRadius\")]\n        nfloat InkMaxRippleRadius { get; set; }\n\n        [Export(\"enableRippleBehavior\")]\n        bool EnableRippleBehavior { get; set; }\n\n        [Export(\"disabledAlpha\")]\n        nfloat DisabledAlpha { get; set; }\n\n        [Export(\"uppercaseTitle\")]\n        bool UppercaseTitle { [Bind(\"isUppercaseTitle\")] get; set; }\n\n        [Export(\"hitAreaInsets\", ArgumentSemantic.Assign)]\n        UIEdgeInsets HitAreaInsets { get; set; }\n\n        [Export(\"minimumSize\", ArgumentSemantic.Assign)]\n        CGSize MinimumSize { get; set; }\n\n        [Export(\"maximumSize\", ArgumentSemantic.Assign)]\n        CGSize MaximumSize { get; set; }\n\n        [NullAllowed]\n        [Export(\"underlyingColorHint\", ArgumentSemantic.Strong)]\n        UIColor UnderlyingColorHint { get; set; }\n\n        [Export(\"adjustsFontForContentSizeCategoryWhenScaledFontIsUnavailable\")]\n        bool AdjustsFontForContentSizeCategoryWhenScaledFontIsUnavailable { get; set; }\n\n        [NullAllowed]\n        [Export(\"shapeGenerator\", ArgumentSemantic.Strong)]\n        IShapeGenerating ShapeGenerator { get; set; }\n\n        [Export(\"accessibilityTraitsIncludesButton\")]\n        bool AccessibilityTraitsIncludesButton { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<Button, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"mdc_adjustsFontForContentSizeCategory\")]\n        bool AdjustsFontForContentSizeCategory { get; [Bind(\"mdc_setAdjustsFontForContentSizeCategory:\")]set; }\n\n        [Obsolete(\"Use AdjustsFontForContentSizeCategory instead\")]\n        [Wrap(\"AdjustsFontForContentSizeCategory\")]\n        bool MdcAdjustsFontForContentSizeCategory { get; set; }\n\n        [return: NullAllowed]\n        [Export(\"backgroundColorForState:\")]\n        UIColor GetBackgroundColor(UIControlState state);\n\n        [Export(\"setBackgroundColor:forState:\")]\n        void SetBackgroundColor([NullAllowed] UIColor backgroundColor, UIControlState state);\n\n        [Export(\"setBackgroundColor:\")]\n        void SetBackgroundColor([NullAllowed] UIColor backgroundColor);\n\n        [return: NullAllowed]\n        [Export(\"titleFontForState:\")]\n        UIFont GetTitleFont(UIControlState state);\n\n        [Export(\"setTitleFont:forState:\")]\n        void SetTitleFont([NullAllowed] UIFont font, UIControlState state);\n\n        [Export(\"setEnabled:animated:\")]\n        void SetEnabled(bool enabled, bool animated);\n\n        [Export(\"elevationForState:\")]\n        nfloat GetElevation(UIControlState state);\n\n        [Export(\"setElevation:forState:\")]\n        void SetElevation(nfloat elevation, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"borderColorForState:\")]\n        UIColor GetBorderColor(UIControlState state);\n\n        [Export(\"setBorderColor:forState:\")]\n        void SetBorderColor([NullAllowed] UIColor borderColor, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"imageTintColorForState:\")]\n        UIColor GetImageTintColor(UIControlState state);\n\n        [Export(\"setImageTintColor:forState:\")]\n        void SetImageTintColor([NullAllowed] UIColor imageTintColor, UIControlState state);\n\n        [Export(\"borderWidthForState:\")]\n        nfloat GetBorderWidth(UIControlState state);\n\n        [Export(\"setBorderWidth:forState:\")]\n        void SetBorderWidth(nfloat borderWidth, UIControlState state);\n\n        [Export(\"setShadowColor:forState:\")]\n        void SetShadowColor([NullAllowed] UIColor shadowColor, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"shadowColorForState:\")]\n        UIColor GetShadowColor(UIControlState state);\n\n        [Wrap(\"SetElevation ((nfloat)elevation, state)\")]\n        void SetElevation(double elevation, UIControlState state);\n    }\n\n    [Obsolete(\"This class will be deprecated soon. Consider using TextButtonThemer with a Button instead.\")]\n    [BaseType(typeof(Button),\n        Name = \"MDCFlatButton\")]\n    interface FlatButton\n    {\n        [Export(\"hasOpaqueBackground\")]\n        bool HasOpaqueBackground { get; set; }\n    }\n\n    [BaseType(typeof(Button),\n        Name = \"MDCFloatingButton\")]\n    interface FloatingButton\n    {\n        [Export(\"mode\", ArgumentSemantic.Assign)]\n        FloatingButtonMode Mode { get; set; }\n\n        [Export(\"imageLocation\", ArgumentSemantic.Assign)]\n        FloatingButtonImageLocation ImageLocation { get; set; }\n\n        [Export(\"imageTitleSpace\")]\n        nfloat ImageTitleSpace { get; set; }\n\n        [Static]\n\n        [Export(\"defaultDimension\")]\n        nfloat DefaultDimension { get; }\n\n        [Static]\n\n        [Export(\"miniDimension\")]\n        nfloat MiniDimension { get; }\n\n        [Static]\n        [Export(\"floatingButtonWithShape:\")]\n        FloatingButton Create(FloatingButtonShape shape);\n\n        [DesignatedInitializer]\n        [Export(\"initWithFrame:shape:\")]\n        IntPtr Constructor(CGRect frame, FloatingButtonShape shape);\n\n        [Export(\"initWithFrame:\")]\n        IntPtr Constructor(CGRect frame);\n\n        [Export(\"setMinimumSize:forShape:inMode:\")]\n        void SetMinimumSize(CGSize minimumSize, FloatingButtonShape shape, FloatingButtonMode mode);\n\n        [Export(\"setMaximumSize:forShape:inMode:\")]\n        void SetMaximumSize(CGSize maximumSize, FloatingButtonShape shape, FloatingButtonMode mode);\n\n        [Export(\"setContentEdgeInsets:forShape:inMode:\")]\n        void SetContentEdgeInsets(UIEdgeInsets contentEdgeInsets, FloatingButtonShape shape, FloatingButtonMode mode);\n\n        [Export(\"setHitAreaInsets:forShape:inMode:\")]\n        void SetHitAreaInsets(UIEdgeInsets hitAreaInsets, FloatingButtonShape shape, FloatingButtonMode mode);\n\n        [Export(\"expand:completion:\")]\n        void Expand(bool animated, [NullAllowed]  Action completion);\n\n        [Export(\"collapse:completion:\")]\n        void Collapse(bool animated, [NullAllowed]  Action completion);\n    }\n\n    [Obsolete(\"This class will be deprecated soon. Consider using ContainedButtonThemer with a Button instead.\")]\n    [BaseType(typeof(Button),\n        Name = \"MDCRaisedButton\")]\n    interface RaisedButton\n    { }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCBannerView\")]\n    interface BannerView : IElevatable, IElevationOverriding\n\n    {\n        [Export(\"bannerViewLayoutStyle\", ArgumentSemantic.Assign)]\n        BannerViewLayoutStyle BannerViewLayoutStyle { get; set; }\n\n        [Export(\"textView\", ArgumentSemantic.Strong)]\n        UITextView TextView { get; }\n\n        [Export(\"imageView\", ArgumentSemantic.Strong)]\n        UIImageView ImageView { get; }\n\n        [Export(\"leadingButton\", ArgumentSemantic.Strong)]\n        Button LeadingButton { get; }\n\n        [Export(\"trailingButton\", ArgumentSemantic.Strong)]\n        Button TrailingButton { get; }\n\n        [Export(\"showsDivider\")]\n        bool ShowsDivider { get; set; }\n\n        [Export(\"dividerColor\", ArgumentSemantic.Strong)]\n        UIColor DividerColor { get; set; }\n\n        [Export(\"mdc_adjustsFontForContentSizeCategory\")]\n        bool AdjustsFontForContentSizeCategory { get; [Bind(\"mdc_setAdjustsFontForContentSizeCategory:\")]set; }\n\n        [Obsolete(\"Use AdjustsFontForContentSizeCategory instead\")]\n        [Wrap(\"AdjustsFontForContentSizeCategory\")]\n        bool MdcAdjustsFontForContentSizeCategory { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<BannerView, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n    }\n\n    [Category]\n    [BaseType(typeof(BannerView),\n        Name = \"MDCBannerView_MaterialTheming\")]\n    interface BannerView_MaterialTheming\n    {\n        [Export(\"applyThemeWithScheme:\")]\n        void ApplyTheme(IContainerScheming scheme);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCBottomAppBarView\")]\n    interface BottomAppBarView : IElevatable, IElevationOverriding\n\n    {\n        [Export(\"floatingButtonHidden\")]\n        bool FloatingButtonHidden { [Bind(\"isFloatingButtonHidden\")] get; set; }\n\n        [Export(\"floatingButtonElevation\", ArgumentSemantic.Assign)]\n        BottomAppBarFloatingButtonElevation FloatingButtonElevation { get; set; }\n\n        [Export(\"floatingButtonPosition\", ArgumentSemantic.Assign)]\n        BottomAppBarFloatingButtonPosition FloatingButtonPosition { get; set; }\n\n        [Export(\"floatingButton\", ArgumentSemantic.Strong)]\n        FloatingButton FloatingButton { get; }\n\n        [Export(\"floatingButtonVerticalOffset\")]\n        nfloat FloatingButtonVerticalOffset { get; set; }\n\n        [NullAllowed]\n        [Export(\"leadingBarButtonItems\", ArgumentSemantic.Copy)]\n        UIBarButtonItem[] LeadingBarButtonItems { get; set; }\n\n        [NullAllowed]\n        [Export(\"trailingBarButtonItems\", ArgumentSemantic.Copy)]\n        UIBarButtonItem[] TrailingBarButtonItems { get; set; }\n\n        [NullAllowed]\n        [Export(\"barTintColor\", ArgumentSemantic.Strong)]\n        UIColor BarTintColor { get; set; }\n\n        [Export(\"leadingBarItemsTintColor\", ArgumentSemantic.Strong)]\n        UIColor LeadingBarItemsTintColor { get; set; }\n\n        [Export(\"trailingBarItemsTintColor\", ArgumentSemantic.Strong)]\n        UIColor TrailingBarItemsTintColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"shadowColor\", ArgumentSemantic.Strong)]\n        UIColor ShadowColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<BottomAppBarView, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"elevation\")]\n        double Elevation { get; set; }\n\n        [Export(\"setFloatingButtonHidden:animated:\")]\n        void SetFloatingButtonHidden(bool floatingButtonHidden, bool animated);\n\n        [Export(\"setFloatingButtonElevation:animated:\")]\n        void SetFloatingButtonElevation(BottomAppBarFloatingButtonElevation floatingButtonElevation, bool animated);\n\n        [Export(\"setFloatingButtonPosition:animated:\")]\n        void SetFloatingButtonPosition(BottomAppBarFloatingButtonPosition floatingButtonPosition, bool animated);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCBottomAppBarColorThemer\")]\n    interface BottomAppBarColorThemer\n    {\n        [Static]\n        [Export(\"applySurfaceVariantWithSemanticColorScheme:toBottomAppBarView:\")]\n        void ApplySurfaceVariant(IColorScheming colorScheme, BottomAppBarView bottomAppBarView);\n\n        [Wrap(\"ApplySurfaceVariant (colorScheme, bottomAppBarView)\")]\n        [Obsolete(\"Use ApplySurfaceVariant instead.\")]\n        [Static]\n        void ApplySurfaceVariantWithSemanticColorScheme(IColorScheming colorScheme, BottomAppBarView bottomAppBarView);\n\n        [Obsolete(\"This method will soon be deprecated. Use ApplySurfaceVariantWithSemanticColorScheme instead.\")]\n        [Static]\n        [Export(\"applyColorScheme:toBottomAppBarView:\")]\n        void ApplyColorScheme(IColorScheme colorScheme, BottomAppBarView bottomAppBarView);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCBottomNavigationBar\",\n        Delegates = new[] { \"Delegate\" },\n        Events = new[] { typeof(BottomNavigationBarDelegate) })]\n    interface BottomNavigationBar : IElevatable, IElevationOverriding\n\n    {\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        IBottomNavigationBarDelegate Delegate { get; set; }\n\n        [Export(\"titleVisibility\", ArgumentSemantic.Assign)]\n        BottomNavigationBarTitleVisibility TitleVisibility { get; set; }\n\n        [Export(\"alignment\", ArgumentSemantic.Assign)]\n        BottomNavigationBarAlignment Alignment { get; set; }\n\n        [Export(\"items\", ArgumentSemantic.Copy)]\n        UITabBarItem[] Items { get; set; }\n\n        [NullAllowed]\n        [Export(\"selectedItem\", ArgumentSemantic.Weak)]\n        UITabBarItem SelectedItem { get; set; }\n\n        [Export(\"itemTitleFont\", ArgumentSemantic.Strong)]\n        UIFont ItemTitleFont { get; set; }\n\n        [Export(\"selectedItemTintColor\", ArgumentSemantic.Strong)]\n        UIColor SelectedItemTintColor { get; set; }\n\n        [Export(\"selectedItemTitleColor\", ArgumentSemantic.Strong)]\n        UIColor SelectedItemTitleColor { get; set; }\n\n        [Export(\"unselectedItemTintColor\", ArgumentSemantic.Strong)]\n        UIColor UnselectedItemTintColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"barTintColor\", ArgumentSemantic.Strong)]\n        UIColor BarTintColor { get; set; }\n\n        [New]\n        [NullAllowed]\n        [Export(\"backgroundColor\", ArgumentSemantic.Copy)]\n        UIColor BackgroundColor { get; set; }\n\n        [Export(\"backgroundBlurEffectStyle\", ArgumentSemantic.Assign)]\n        UIBlurEffectStyle BackgroundBlurEffectStyle { get; set; }\n\n        [Export(\"backgroundBlurEnabled\")]\n        bool BackgroundBlurEnabled { [Bind(\"isBackgroundBlurEnabled\")] get; set; }\n\n        [Export(\"itemsContentVerticalMargin\")]\n        nfloat ItemsContentVerticalMargin { get; set; }\n\n        [Export(\"itemsContentHorizontalMargin\")]\n        nfloat ItemsContentHorizontalMargin { get; set; }\n\n        [iOS(9, 0)]\n        [Export(\"barItemsBottomAnchor\")]\n        NSLayoutYAxisAnchor BarItemsBottomAnchor { get; }\n\n        [Export(\"truncatesLongTitles\")]\n        bool TruncatesLongTitles { get; set; }\n\n        [Export(\"elevation\")]\n        nfloat Elevation { get; set; }\n\n        [Export(\"shadowColor\", ArgumentSemantic.Copy)]\n        UIColor ShadowColor { get; set; }\n\n        [Export(\"titlesNumberOfLines\")]\n        nint TitlesNumberOfLines { get; set; }\n\n        [Export(\"enableRippleBehavior\")]\n        bool EnableRippleBehavior { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<BottomNavigationBar, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [return: NullAllowed]\n        [Export(\"viewForItem:\")]\n        UIView GetView(UITabBarItem item);\n\n        [Export(\"sizeThatFitsIncludesSafeArea\")]\n        [Static]\n        bool SizeThatFitsIncludesSafeArea { get; set; }\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCBottomNavigationBarDelegate\")]\n    interface BottomNavigationBarDelegate : IUINavigationBarDelegate\n\n    {\n        [DefaultValue(true)]\n        [DelegateName(\"BottomNavigationBarShouldSelectItem\")]\n        [Export(\"bottomNavigationBar:shouldSelectItem:\")]\n        bool ShouldSelectItem(BottomNavigationBar bottomNavigationBar, UITabBarItem item);\n\n        [EventArgs(\"BottomNavigationBarItemSelected\")]\n        [EventName(\"ItemSelected\")]\n        [Export(\"bottomNavigationBar:didSelectItem:\")]\n        void DidSelectItem(BottomNavigationBar bottomNavigationBar, UITabBarItem item);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCBottomNavigationBarColorThemer\")]\n    interface BottomNavigationBarColorThemer\n    {\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toBottomNavigation:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, BottomNavigationBar bottomNavigation);\n\n        [Obsolete(\"This method will soon be deprecated. Consider using ApplySemanticColorScheme method instead.\")]\n        [Static]\n        [Export(\"applyColorScheme:toBottomNavigationBar:\")]\n        void ApplyColorScheme(IColorScheme colorScheme, BottomNavigationBar bottomNavigationBar);\n    }\n\n    [Category]\n    [BaseType(typeof(BottomNavigationBar),\n        Name = \"MDCBottomNavigationBar_MaterialTheming\")]\n    interface BottomNavigationBar_MaterialTheming\n    {\n        [Export(\"applyPrimaryThemeWithScheme:\")]\n        void ApplyPrimaryThemeWithScheme(IContainerScheming scheme);\n\n        [Export(\"applySurfaceThemeWithScheme:\")]\n        void ApplySurfaceThemeWithScheme(IContainerScheming scheme);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCBottomNavigationBarTypographyThemer\")]\n    interface BottomNavigationBarTypographyThemer\n    {\n        [Static]\n        [Export(\"applyTypographyScheme:toBottomNavigationBar:\")]\n        void ApplyTypographyScheme (ITypographyScheming typographyScheme, BottomNavigationBar bottomNavigationBar);\n    }\n\n    [BaseType(typeof(CornerTreatment),\n        Name = \"MDCCurvedCornerTreatment\")]\n    interface CurvedCornerTreatment\n    {\n        [Export(\"size\", ArgumentSemantic.Assign)]\n        CGSize Size { get; set; }\n\n        [DesignatedInitializer]\n        [Export(\"initWithSize:\")]\n        IntPtr Constructor(CGSize size);\n    }\n\n    [BaseType(typeof(CornerTreatment),\n        Name = \"MDCCutCornerTreatment\")]\n    interface CutCornerTreatment\n    {\n        [Export(\"cut\")]\n        nfloat Cut { get; set; }\n\n        [DesignatedInitializer]\n        [Export(\"initWithCut:\")]\n        IntPtr Constructor(nfloat cut);\n    }\n\n    [BaseType(typeof(CornerTreatment),\n        Name = \"MDCRoundedCornerTreatment\")]\n    interface RoundedCornerTreatment\n    {\n        [Export(\"radius\")]\n        nfloat Radius { get; set; }\n\n        [DesignatedInitializer]\n        [Export(\"initWithRadius:\")]\n        IntPtr Constructor(nfloat radius);\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCCurvedRectShapeGenerator\")]\n    interface CurvedRectShapeGenerator : ShapeGenerating\n\n    {\n        [Export(\"cornerSize\", ArgumentSemantic.Assign)]\n        CGSize CornerSize { get; set; }\n\n        [DesignatedInitializer]\n        [Export(\"initWithCornerSize:\")]\n        IntPtr Constructor(CGSize cornerSize);\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCPillShapeGenerator\")]\n    interface PillShapeGenerator : ShapeGenerating\n\n    { }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCSlantedRectShapeGenerator\")]\n    interface SlantedRectShapeGenerator : ShapeGenerating\n\n    {\n        [Export(\"slant\")]\n        nfloat Slant { get; set; }\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(EdgeTreatment),\n        Name = \"MDCTriangleEdgeTreatment\")]\n    interface TriangleEdgeTreatment\n    {\n        [Export(\"size\")]\n        nfloat Size { get; set; }\n\n        [Export(\"style\", ArgumentSemantic.Assign)]\n        TriangleEdgeStyle Style { get; set; }\n\n        [DesignatedInitializer]\n        [Export(\"initWithSize:style:\")]\n        IntPtr Constructor(nfloat size, TriangleEdgeStyle style);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCBottomSheetControllerShapeThemer\")]\n    interface BottomSheetControllerShapeThemer\n    {\n        [Static]\n        [Export(\"applyShapeScheme:toBottomSheetController:\")]\n        void ApplyShapeScheme(IShapeScheming shapeScheme, BottomSheetController bottomSheetController);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCButtonBar\",\n        Delegates = new[] { \"Delegate\" },\n        Events = new[] { typeof(ButtonBarDelegate) })]\n    interface ButtonBar\n    {\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        IButtonBarDelegate Delegate { get; set; }\n\n        [NullAllowed]\n        [Export(\"items\", ArgumentSemantic.Copy)]\n        UIBarButtonItem[] Items { get; set; }\n\n        [Export(\"buttonTitleBaseline\")]\n        nfloat ButtonTitleBaseline { get; set; }\n\n        [Export(\"uppercasesButtonTitles\")]\n        bool UppercasesButtonTitles { get; set; }\n\n        [Export(\"layoutPosition\", ArgumentSemantic.Assign)]\n        ButtonBarLayoutPosition LayoutPosition { get; set; }\n\n        [NullAllowed]\n        [Export(\"rippleColor\", ArgumentSemantic.Strong)]\n        UIColor RippleColor { get; set; }\n\n        [Export(\"enableRippleBehavior\")]\n        bool EnableRippleBehavior { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<ButtonBar, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"rectForItem:inCoordinateSpace:\")]\n        CGRect RectForItem(UIBarButtonItem item, UICoordinateSpace coordinateSpace);\n\n        [Export(\"setButtonsTitleFont:forState:\")]\n        void SetButtonsTitleFont([NullAllowed] UIFont font, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"buttonsTitleFontForState:\")]\n        UIFont GetButtonsTitleFont(UIControlState state);\n\n        [Export(\"setButtonsTitleColor:forState:\")]\n        void SetButtonsTitleColor([NullAllowed] UIColor color, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"buttonsTitleColorForState:\")]\n        UIColor GetButtonsTitleColor(UIControlState state);\n\n        [New]\n        [Export(\"sizeThatFits:\")]\n        CGSize SizeThatFits(CGSize size);\n\n        [NullAllowed]\n        [Export(\"inkColor\", ArgumentSemantic.Strong)]\n        UIColor InkColor { get; set; }\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCButtonBarDelegate\")]\n    interface ButtonBarDelegate\n    {\n        [EventArgs(\"ButtonBarDidInvalidateIntrinsicContentSize\")]\n        [EventName(\"IntrinsicContentSizeInvalidated\")]\n        [Export(\"buttonBarDidInvalidateIntrinsicContentSize:\")]\n        void DidInvalidateIntrinsicContentSize(ButtonBar buttonBar);\n\n        [DefaultValue(null)]\n        [DelegateName(\"ButtonBarViewForItem\")]\n        [Abstract]\n        [Export(\"buttonBar:viewForItem:layoutHints:\")]\n        UIView ViewForItem(ButtonBar buttonBar, UIBarButtonItem barButtonItem, BarButtonItemLayoutHints layoutHints);\n    }\n\n    [BaseType(typeof(FlatButton),\n        Name = \"MDCButtonBarButton\")]\n    interface ButtonBarButton\n    {\n        [New]\n        [Export(\"setTitleFont:forState:\")]\n        void SetTitleFont([NullAllowed] UIFont font, UIControlState state);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCButtonBarColorThemer\")]\n    interface ButtonBarColorThemer\n    {\n        [Static]\n        [Export(\"applyColorScheme:toButtonBar:\")]\n        void ApplyColorScheme(IColorScheme colorScheme, ButtonBar buttonBar);\n\n        [Static]\n        [Export(\"applySemanticColorScheme:toButtonBar:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, ButtonBar buttonBar);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCButtonBarTypographyThemer\")]\n    interface ButtonBarTypographyThemer\n    {\n        [Static]\n        [Export(\"applyTypographyScheme:toButtonBar:\")]\n        void ApplyTypographyScheme(ITypographyScheming typographyScheme, ButtonBar buttonBar);\n    }\n\n    [Protocol(Name = \"MDCButtonScheming\")]\n    interface ButtonScheming\n    {\n        [Abstract]\n        [Export(\"colorScheme\")]\n        IColorScheming ColorScheme { get; }\n\n        [Abstract]\n        [Export(\"shapeScheme\")]\n        IShapeScheming ShapeScheme { get; }\n\n        [Abstract]\n        [Export(\"typographyScheme\")]\n        ITypographyScheming TypographyScheme { get; }\n\n        [Abstract]\n        [Export(\"cornerRadius\")]\n        nfloat CornerRadius { get; }\n\n        [Abstract]\n        [Export(\"minimumHeight\")]\n        nfloat MinimumHeight { get; }\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCButtonScheme\")]\n    interface ButtonScheme : ButtonScheming\n\n    {\n        [Export(\"colorScheme\", ArgumentSemantic.Assign)]\n        IColorScheming ColorScheme { get; set; }\n\n        [Export(\"shapeScheme\", ArgumentSemantic.Assign)]\n        IShapeScheming ShapeScheme { get; set; }\n\n        [Export(\"typographyScheme\", ArgumentSemantic.Assign)]\n        ITypographyScheming TypographyScheme { get; set; }\n\n        [Export(\"cornerRadius\")]\n        nfloat CornerRadius { get; set; }\n\n        [Export(\"minimumHeight\")]\n        nfloat MinimumHeight { get; set; }\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCContainedButtonThemer\")]\n    interface ContainedButtonThemer\n    {\n        [Static]\n        [Export(\"applyScheme:toButton:\")]\n        void ApplyScheme(IButtonScheming scheme, Button button);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCFloatingActionButtonThemer\")]\n    interface FloatingActionButtonThemer\n    {\n        [Static]\n        [Export(\"applyScheme:toButton:\")]\n        void ApplyScheme(IButtonScheming scheme, FloatingButton button);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCOutlinedButtonThemer\")]\n    interface OutlinedButtonThemer\n    {\n        [Static]\n        [Export(\"applyScheme:toButton:\")]\n        void ApplyScheme(IButtonScheming scheme, Button button);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTextButtonThemer\")]\n    interface TextButtonThemer\n    {\n        [Static]\n        [Export(\"applyScheme:toButton:\")]\n        void ApplyScheme(IButtonScheming scheme, Button button);\n    }\n\n    [Obsolete(\"This class will soon be deprecated. Please consider using one of the more specific ButtonColorThemer classes instead.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCButtonColorThemer\")]\n    interface ButtonColorThemer\n    {\n        [Static]\n        [Export(\"applySemanticColorScheme:toButton:\")]\n        void ApplySemanticColorSchemeToButton(IColorScheming colorScheme, Button button);\n\n        [Static]\n        [Export(\"applySemanticColorScheme:toFlatButton:\")]\n        void ApplySemanticColorSchemeToFlatButton(IColorScheming colorScheme, Button flatButton);\n\n        [Static]\n        [Export(\"applySemanticColorScheme:toRaisedButton:\")]\n        void ApplySemanticColorSchemeToRaisedButton(IColorScheming colorScheme, Button raisedButton);\n\n        [Static]\n        [Export(\"applySemanticColorScheme:toFloatingButton:\")]\n        void ApplySemanticColorSchemeToFloatingButton(IColorScheming colorScheme, FloatingButton floatingButton);\n\n        [Static]\n        [Export(\"applyColorScheme:toButton:\")]\n        void ApplyColorScheme(IColorScheme colorScheme, Button button);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCContainedButtonColorThemer\")]\n    interface ContainedButtonColorThemer\n    {\n        [Static]\n        [Export(\"applySemanticColorScheme:toButton:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, Button button);\n    }\n\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCFloatingButtonColorThemer\")]\n    interface FloatingButtonColorThemer\n    {\n        [Static]\n        [Export(\"applySemanticColorScheme:toButton:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, FloatingButton button);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCOutlinedButtonColorThemer\")]\n    interface OutlinedButtonColorThemer\n    {\n        [Static]\n        [Export(\"applySemanticColorScheme:toButton:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, Button button);\n    }\n\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTextButtonColorThemer\")]\n    interface TextButtonColorThemer\n    {\n        [Static]\n        [Export(\"applySemanticColorScheme:toButton:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, Button button);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCButtonShapeThemer\")]\n    interface ButtonShapeThemer\n    {\n        [Static]\n        [Export(\"applyShapeScheme:toButton:\")]\n        void ApplyShapeScheme(IShapeScheming shapeScheme, Button button);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCFloatingButtonShapeThemer\")]\n    interface FloatingButtonShapeThemer\n    {\n        [Static]\n        [Export(\"applyShapeScheme:toButton:\")]\n        void ApplyShapeScheme (IShapeScheming shapeScheme, FloatingButton button);\n    }\n\n\n    [Category]\n    [BaseType(typeof(Button),\n        Name = \"MDCButton_MaterialTheming\")]\n    interface Button_MaterialTheming\n    {\n        [Export(\"applyContainedThemeWithScheme:\")]\n        void ApplyContainedThemeWithScheme(IContainerScheming scheme);\n\n        [Export(\"applyOutlinedThemeWithScheme:\")]\n        void ApplyOutlinedThemeWithScheme(IContainerScheming scheme);\n\n        [Export(\"applyTextThemeWithScheme:\")]\n        void ApplyTextThemeWithScheme(IContainerScheming scheme);\n    }\n\n    [Category]\n    [BaseType(typeof(FloatingButton),\n        Name = \"MDCFloatingButton_MaterialTheming\")]\n    interface FloatingButton_MaterialTheming\n    {\n        [Export(\"applySecondaryThemeWithScheme:\")]\n        void ApplySecondaryThemeWithScheme(IContainerScheming scheme);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCButtonTitleColorAccessibilityMutator\")]\n    interface ButtonTitleColorAccessibilityMutator\n    {\n        [Static]\n        [Export(\"changeTitleColorOfButton:\")]\n        void ChangeTitleColor(Button button);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCButtonTypographyThemer\")]\n    interface ButtonTypographyThemer\n    {\n        [Static]\n        [Export(\"applyTypographyScheme:toButton:\")]\n        void ApplyTypographyScheme(ITypographyScheming typographyScheme, Button button);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCRippleView\")]\n    interface RippleView\n    {\n        [Wrap(\"WeakRippleViewDelegate\")]\n        [NullAllowed]\n        IRippleViewDelegate RippleViewDelegate { get; set; }\n\n        [NullAllowed]\n        [Export(\"rippleViewDelegate\", ArgumentSemantic.Weak)]\n        NSObject WeakRippleViewDelegate { get; set; }\n\n        [Export(\"rippleStyle\", ArgumentSemantic.Assign)]\n        RippleStyle RippleStyle { get; set; }\n\n        [Export(\"rippleColor\", ArgumentSemantic.Strong)]\n        UIColor RippleColor { get; set; }\n\n        [Export(\"maximumRadius\")]\n        nfloat MaximumRadius { get; set; }\n\n        [Export(\"activeRippleColor\", ArgumentSemantic.Strong)]\n        UIColor ActiveRippleColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<RippleView, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"cancelAllRipplesAnimated:completion:\")]\n        void CancelAllRipplesAnimated(bool animated, [NullAllowed]  RippleCompletionBlock completion);\n\n        [Export(\"fadeInRippleAnimated:completion:\")]\n        void FadeInRippleAnimated(bool animated, [NullAllowed]  RippleCompletionBlock completion);\n\n        [Export(\"fadeOutRippleAnimated:completion:\")]\n        void FadeOutRippleAnimated(bool animated, [NullAllowed]  RippleCompletionBlock completion);\n\n        [Export(\"beginRippleTouchDownAtPoint:animated:completion:\")]\n        void BeginRippleTouchDownAtPoint(CGPoint point, bool animated, [NullAllowed]  RippleCompletionBlock completion);\n\n        [Export(\"beginRippleTouchUpAnimated:completion:\")]\n        void BeginRippleTouchUpAnimated(bool animated, [NullAllowed]  RippleCompletionBlock completion);\n    }\n\n    [Protocol(Name = \"MDCRippleViewDelegate\")]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject))]\n    interface RippleViewDelegate\n    {\n        [Export(\"rippleTouchDownAnimationDidBegin:\")]\n        void RippleTouchDownAnimationDidBegin(RippleView rippleView);\n\n        [Export(\"rippleTouchDownAnimationDidEnd:\")]\n        void RippleTouchDownAnimationDidEnd(RippleView rippleView);\n\n        [Export(\"rippleTouchUpAnimationDidBegin:\")]\n        void RippleTouchUpAnimationDidBegin(RippleView rippleView);\n\n        [Export(\"rippleTouchUpAnimationDidEnd:\")]\n        void RippleTouchUpAnimationDidEnd(RippleView rippleView);\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCRippleTouchController\")]\n    interface RippleTouchController : IUIGestureRecognizerDelegate\n\n    {\n        [NullAllowed]\n        [Export(\"view\", ArgumentSemantic.Weak)]\n        UIView View { get; }\n\n        [Export(\"rippleView\", ArgumentSemantic.Strong)]\n        RippleView RippleView { get; }\n\n        [Wrap(\"WeakDelegate\")]\n        [NullAllowed]\n        IRippleTouchControllerDelegate Delegate { get; set; }\n\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        NSObject WeakDelegate { get; set; }\n\n        [Export(\"gestureRecognizer\", ArgumentSemantic.Strong)]\n        UILongPressGestureRecognizer GestureRecognizer { get; }\n\n        [Export(\"shouldProcessRippleWithScrollViewGestures\")]\n        bool ShouldProcessRippleWithScrollViewGestures { get; set; }\n\n        [Export(\"initWithView:\")]\n        IntPtr Constructor(UIView view);\n\n        [Export(\"addRippleToView:\")]\n        void AddRippleToView(UIView view);\n    }\n\n    [Protocol(Name = \"MDCRippleTouchControllerDelegate\")]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject))]\n    interface RippleTouchControllerDelegate\n    {\n        [Export(\"rippleTouchController:shouldProcessRippleTouchesAtTouchLocation:\")]\n        bool RippleTouchController(RippleTouchController rippleTouchController, CGPoint location);\n\n        [Export(\"rippleTouchController:didProcessRippleView:atTouchLocation:\")]\n        void RippleTouchController(RippleTouchController rippleTouchController, RippleView rippleView, CGPoint location);\n\n        [Export(\"rippleTouchController:insertRippleView:intoView:\")]\n        void RippleTouchController(RippleTouchController rippleTouchController, RippleView rippleView, UIView view);\n    }\n\n    [BaseType(typeof(RippleView),\n        Name = \"MDCStatefulRippleView\")]\n    interface StatefulRippleView\n    {\n        [Export(\"selected\")]\n        bool Selected { [Bind(\"isSelected\")] get; set; }\n\n        [Export(\"rippleHighlighted\")]\n        bool RippleHighlighted { [Bind(\"isRippleHighlighted\")] get; set; }\n\n        [Export(\"dragged\")]\n        bool Dragged { [Bind(\"isDragged\")] get; set; }\n\n        [Export(\"allowsSelection\")]\n        bool AllowsSelection { get; set; }\n\n        [Export(\"setRippleColor:forState:\")]\n        void SetRippleColor([NullAllowed] UIColor rippleColor, RippleState state);\n\n        [return: NullAllowed]\n        [Export(\"rippleColorForState:\")]\n        UIColor RippleColorForState(RippleState state);\n\n        [Export(\"touchesBegan:withEvent:\")]\n        void TouchesBegan([NullAllowed] NSSet<UITouch> touches, [NullAllowed]  UIEvent @event);\n\n        [Export(\"touchesMoved:withEvent:\")]\n        void TouchesMoved([NullAllowed] NSSet<UITouch> touches, [NullAllowed]  UIEvent @event);\n\n        [Export(\"touchesEnded:withEvent:\")]\n        void TouchesEnded([NullAllowed] NSSet<UITouch> touches, [NullAllowed]  UIEvent @event);\n\n        [Export(\"touchesCancelled:withEvent:\")]\n        void TouchesCancelled([NullAllowed] NSSet<UITouch> touches, [NullAllowed]  UIEvent @event);\n    }\n\n    [BaseType(typeof(UIControl),\n        Name = \"MDCCard\")]\n    interface Card : IElevatable, IElevationOverriding\n\n    {\n        [Export(\"cornerRadius\")]\n        nfloat CornerRadius { get; set; }\n\n        [Export(\"inkView\", ArgumentSemantic.Strong)]\n        InkView InkView { get; }\n\n        [Export(\"rippleView\", ArgumentSemantic.Strong)]\n        StatefulRippleView RippleView { get; }\n\n        [Export(\"interactable\")]\n        bool Interactable { [Bind(\"isInteractable\")] get; set; }\n\n        [Export(\"enableRippleBehavior\")]\n        bool EnableRippleBehavior { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<Card, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [NullAllowed]\n        [Export(\"shapeGenerator\", ArgumentSemantic.Strong)]\n        IShapeGenerating ShapeGenerator { get; set; }\n\n        [Export(\"setShadowElevation:forState:\")]\n        void SetShadowElevation(nfloat shadowElevation, UIControlState state);\n\n        [Export(\"shadowElevationForState:\")]\n        nfloat GetShadowElevation(UIControlState state);\n\n        [Export(\"setBorderWidth:forState:\")]\n        void SetBorderWidth(nfloat borderWidth, UIControlState state);\n\n        [Export(\"borderWidthForState:\")]\n        nfloat GetBorderWidth(UIControlState state);\n\n        [Export(\"setBorderColor:forState:\")]\n        void SetBorderColor([NullAllowed] UIColor borderColor, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"borderColorForState:\")]\n        UIColor GetBorderColorForState(UIControlState state);\n\n        [Export(\"setShadowColor:forState:\")]\n        void SetShadowColor([NullAllowed] UIColor shadowColor, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"shadowColorForState:\")]\n        UIColor GetShadowColor(UIControlState state);\n\n        [Wrap(\"SetShadowElevation ((nfloat)shadowElevation, state)\")]\n        void SetShadowElevation(double shadowElevation, UIControlState state);\n    }\n\n    [BaseType(typeof(UICollectionViewCell),\n        Name = \"MDCCardCollectionCell\")]\n    interface CardCollectionCell : IElevatable, IElevationOverriding\n\n    {\n        [Export(\"selectable\")]\n        bool Selectable { [Bind(\"isSelectable\")] get; set; }\n\n        [Export(\"dragged\")]\n        bool Dragged { [Bind(\"isDragged\")] get; set; }\n\n        [Export(\"cornerRadius\")]\n        nfloat CornerRadius { get; set; }\n\n        [Export(\"inkView\", ArgumentSemantic.Strong)]\n        InkView InkView { get; }\n\n        [Export(\"rippleView\", ArgumentSemantic.Strong)]\n        StatefulRippleView RippleView { get; }\n\n        [Export(\"interactable\")]\n        bool Interactable { [Bind(\"isInteractable\")] get; set; }\n\n        [NullAllowed]\n        [Export(\"shapeGenerator\", ArgumentSemantic.Strong)]\n        IShapeGenerating ShapeGenerator { get; set; }\n\n        [Export(\"enableRippleBehavior\")]\n        bool EnableRippleBehavior { get; set; }\n\n        [Export(\"state\")]\n        CardCellState State { get; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<CardCollectionCell, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"setShadowElevation:forState:\")]\n        void SetShadowElevation(nfloat shadowElevation, CardCellState state);\n\n        [Export(\"shadowElevationForState:\")]\n        nfloat GetShadowElevation(CardCellState state);\n\n        [Export(\"setBorderWidth:forState:\")]\n        void SetBorderWidth(nfloat borderWidth, CardCellState state);\n\n        [Export(\"borderWidthForState:\")]\n        nfloat GetBorderWidth(CardCellState state);\n\n        [Export(\"setBorderColor:forState:\")]\n        void SetBorderColor([NullAllowed] UIColor borderColor, CardCellState state);\n\n        [return: NullAllowed]\n        [Export(\"borderColorForState:\")]\n        UIColor GetBorderColor(CardCellState state);\n\n        [Export(\"setShadowColor:forState:\")]\n        void SetShadowColor([NullAllowed] UIColor shadowColor, CardCellState state);\n\n        [return: NullAllowed]\n        [Export(\"shadowColorForState:\")]\n        UIColor GetShadowColor(CardCellState state);\n\n        [return: NullAllowed]\n        [Export(\"imageForState:\")]\n        UIImage GetImage(CardCellState state);\n\n        [Export(\"setImage:forState:\")]\n        void SetImage([NullAllowed] UIImage image, CardCellState state);\n\n        [Export(\"horizontalImageAlignmentForState:\")]\n        CardCellHorizontalImageAlignment GetHorizontalImageAlignment(CardCellState state);\n\n        [Export(\"setHorizontalImageAlignment:forState:\")]\n        void SetHorizontalImageAlignment(CardCellHorizontalImageAlignment horizontalImageAlignment, CardCellState state);\n\n        [Export(\"verticalImageAlignmentForState:\")]\n        CardCellVerticalImageAlignment GetVerticalImageAlignment(CardCellState state);\n\n        [Export(\"setVerticalImageAlignment:forState:\")]\n        void SetVerticalImageAlignment(CardCellVerticalImageAlignment verticalImageAlignment, CardCellState state);\n\n        [return: NullAllowed]\n        [Export(\"imageTintColorForState:\")]\n        UIColor GetImageTintColor(CardCellState state);\n\n        [Export(\"setImageTintColor:forState:\")]\n        void SetImageTintColor([NullAllowed] UIColor imageTintColor, CardCellState state);\n\n        [Wrap(\"SetShadowElevation ((nfloat)shadowElevation, state)\")]\n        void SetShadowElevation(double shadowElevation, CardCellState state);\n    }\n\n    [Category]\n    [BaseType(typeof(UICollectionViewController))]\n    interface UICollectionViewController_MDCCardReordering\n    {\n        [Export(\"mdc_setupCardReordering\")]\n        void SetupCardReordering();\n\n        [Wrap(\"SetupCardReordering(This)\")]\n        void MdcSetupCardReordering();\n    }\n\n    [Protocol(Name = \"MDCCardScheming\")]\n    interface CardScheming\n    {\n        [Abstract]\n        [Export(\"colorScheme\")]\n        IColorScheming ColorScheme { get; }\n\n        [Abstract]\n        [Export(\"shapeScheme\")]\n        IShapeScheming ShapeScheme { get; }\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCCardScheme\")]\n    interface CardScheme : CardScheming\n\n    {\n        [Export(\"colorScheme\", ArgumentSemantic.Assign)]\n        IColorScheming ColorScheme { get; set; }\n\n        [Export(\"shapeScheme\", ArgumentSemantic.Assign)]\n        IShapeScheming ShapeScheme { get; set; }\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCCardThemer\")]\n    interface CardThemer\n    {\n        [Static]\n        [Export(\"applyScheme:toCard:\")]\n        void ApplyScheme(ICardScheming scheme, Card card);\n\n        [Static]\n        [Export(\"applyScheme:toCardCell:\")]\n        void ApplyScheme(ICardScheming scheme, CardCollectionCell cardCell);\n\n        [Static]\n        [Export(\"applyOutlinedVariantWithScheme:toCard:\")]\n        void ApplyOutlinedVariant(ICardScheming scheme, Card card);\n\n        [Static]\n        [Export(\"applyOutlinedVariantWithScheme:toCardCell:\")]\n        void ApplyOutlinedVariantWithScheme(ICardScheming scheme, CardCollectionCell cardCell);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCCardsColorThemer\")]\n    interface CardsColorThemer\n    {\n        [Static]\n        [Export(\"applySemanticColorScheme:toCard:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, Card card);\n\n        [Static]\n        [Export(\"applySemanticColorScheme:toCardCell:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, CardCollectionCell cardCell);\n\n        [Static]\n        [Export(\"applyOutlinedVariantWithColorScheme:toCard:\")]\n        void ApplyOutlinedVariant(IColorScheming colorScheme, Card card);\n\n        [Static]\n        [Export(\"applyOutlinedVariantWithColorScheme:toCardCell:\")]\n        void ApplyOutlinedVariant(IColorScheming colorScheme, CardCollectionCell cardCell);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCCardsShapeThemer\")]\n    interface CardsShapeThemer\n    {\n        [Static]\n        [Export(\"applyShapeScheme:toCard:\")]\n        void ApplyShapeScheme(IShapeScheming shapeScheme, Card card);\n\n        [Static]\n        [Export(\"applyShapeScheme:toCardCell:\")]\n        void ApplyShapeScheme(IShapeScheming shapeScheme, CardCollectionCell cardCell);\n    }\n\n    [Category]\n    [BaseType(typeof(Card),\n        Name = \"MDCCard_MaterialTheming\")]\n    interface Card_MaterialTheming\n    {\n        [Export(\"applyThemeWithScheme:\")]\n        void ApplyTheme(IContainerScheming scheme);\n\n        [Export(\"applyOutlinedThemeWithScheme:\")]\n        void ApplyOutlinedThemeWithScheme(IContainerScheming scheme);\n    }\n\n    [Category]\n    [BaseType(typeof(CardCollectionCell),\n        Name = \"MDCCardCollectionCell_MaterialTheming\")]\n    interface CardCollectionCell_MaterialTheming\n    {\n        [Export(\"applyThemeWithScheme:\")]\n        void ApplyTheme(IContainerScheming scheme);\n\n        [Export(\"applyOutlinedThemeWithScheme:\")]\n        void ApplyOutlinedThemeWithScheme(IContainerScheming scheme);\n    }\n\n    [BaseType(typeof(UICollectionViewCell),\n        Name = \"MDCChipCollectionViewCell\")]\n    interface ChipCollectionViewCell\n    {\n        [Export(\"chipView\", ArgumentSemantic.Strong)]\n        ChipView ChipView { get; }\n\n        [Export(\"alwaysAnimateResize\")]\n        bool AlwaysAnimateResize { get; set; }\n\n        [Export(\"createChipView\")]\n        ChipView CreateChipView();\n    }\n\n    [BaseType(typeof(UICollectionViewFlowLayout),\n        Name = \"MDCChipCollectionViewFlowLayout\")]\n    interface ChipCollectionViewFlowLayout\n    { }\n\n    [BaseType(typeof(UIControl),\n        Name = \"MDCChipView\")]\n    interface ChipView : IElevatable, IElevationOverriding\n\n    {\n        [Export(\"imageView\")]\n        UIImageView ImageView { get; }\n\n        [Export(\"selectedImageView\")]\n        UIImageView SelectedImageView { get; }\n\n        [NullAllowed]\n        [Export(\"accessoryView\", ArgumentSemantic.Strong)]\n        UIView AccessoryView { get; set; }\n\n        [Export(\"titleLabel\")]\n        UILabel TitleLabel { get; }\n\n        [Export(\"contentPadding\", ArgumentSemantic.Assign)]\n        UIEdgeInsets ContentPadding { get; set; }\n\n        [Export(\"imagePadding\", ArgumentSemantic.Assign)]\n        UIEdgeInsets ImagePadding { get; set; }\n\n        [Export(\"accessoryPadding\", ArgumentSemantic.Assign)]\n        UIEdgeInsets AccessoryPadding { get; set; }\n\n        [Export(\"titlePadding\", ArgumentSemantic.Assign)]\n        UIEdgeInsets TitlePadding { get; set; }\n\n        [NullAllowed]\n        [Export(\"titleFont\", ArgumentSemantic.Strong)]\n        UIFont TitleFont { get; set; }\n\n        [Export(\"enableRippleBehavior\")]\n        bool EnableRippleBehavior { get; set; }\n\n        [Export(\"rippleAllowsSelection\")]\n        bool RippleAllowsSelection { get; set; }\n\n        [NullAllowed]\n        [Export(\"shapeGenerator\", ArgumentSemantic.Strong)]\n        IShapeGenerating ShapeGenerator { get; set; }\n\n        [Export(\"adjustsFontForContentSizeCategoryWhenScaledFontIsUnavailable\")]\n        bool AdjustsFontForContentSizeCategoryWhenScaledFontIsUnavailable { get; set; }\n\n        [Export(\"minimumSize\", ArgumentSemantic.Assign)]\n        CGSize MinimumSize { get; set; }\n\n        [Export(\"hitAreaInsets\", ArgumentSemantic.Assign)]\n        UIEdgeInsets HitAreaInsets { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<ChipView, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"mdc_adjustsFontForContentSizeCategory\")]\n        bool AdjustsFontForContentSizeCategory { get; [Bind(\"mdc_setAdjustsFontForContentSizeCategory:\")]set; }\n\n        [Obsolete(\"Use AdjustsFontForContentSizeCategory instead\")]\n        [Wrap(\"AdjustsFontForContentSizeCategory\")]\n        bool MdcAdjustsFontForContentSizeCategory { get; set; }\n\n        [return: NullAllowed]\n        [Export(\"backgroundColorForState:\")]\n        UIColor GetBackgroundColor(UIControlState state);\n\n        [Export(\"setBackgroundColor:forState:\")]\n        void SetBackgroundColor([NullAllowed] UIColor backgroundColor, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"borderColorForState:\")]\n        UIColor GetBorderColor(UIControlState state);\n\n        [Export(\"setBorderColor:forState:\")]\n        void SetBorderColor([NullAllowed] UIColor borderColor, UIControlState state);\n\n        [Export(\"borderWidthForState:\")]\n        nfloat GetBorderWidth(UIControlState state);\n\n        [Export(\"setBorderWidth:forState:\")]\n        void SetBorderWidth(nfloat borderWidth, UIControlState state);\n\n        [Export(\"elevationForState:\")]\n        nfloat GetElevation(UIControlState state);\n\n        [Export(\"setElevation:forState:\")]\n        void SetElevation(nfloat elevation, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"inkColorForState:\")]\n        UIColor GetInkColor(UIControlState state);\n\n        [Export(\"setInkColor:forState:\")]\n        void SetInkColor([NullAllowed] UIColor inkColor, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"shadowColorForState:\")]\n        UIColor GetShadowColor(UIControlState state);\n\n        [Export(\"setShadowColor:forState:\")]\n        void SetShadowColor([NullAllowed] UIColor shadowColor, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"titleColorForState:\")]\n        UIColor GetTitleColor(UIControlState state);\n\n        [Export(\"setTitleColor:forState:\")]\n        void SetTitleColor([NullAllowed] UIColor titleColor, UIControlState state);\n\n        [Wrap(\"SetElevation ((nfloat)elevation, state)\")]\n        void SetElevation(double elevation, UIControlState state);\n    }\n\n    [BaseType(typeof(UITextView),\n        Name = \"MDCIntrinsicHeightTextView\")]\n    interface IntrinsicHeightTextView\n    { }\n\n    [Protocol(Name = \"MDCTextInput\")]\n    interface TextInput\n    {\n        [Abstract]\n        [NullAllowed]\n        [Export(\"attributedPlaceholder\", ArgumentSemantic.Copy)]\n        NSAttributedString AttributedPlaceholder { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"attributedText\", ArgumentSemantic.Copy)]\n        NSAttributedString AttributedText { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"borderPath\", ArgumentSemantic.Copy)]\n        UIBezierPath BorderPath { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"borderView\", ArgumentSemantic.Strong)]\n        TextInputBorderView BorderView { get; set; }\n\n        [Abstract]\n        [Export(\"clearButton\", ArgumentSemantic.Strong)]\n        UIButton ClearButton { get; }\n\n        [Abstract]\n        [Export(\"clearButtonMode\", ArgumentSemantic.Assign)]\n        UITextFieldViewMode ClearButtonMode { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"cursorColor\", ArgumentSemantic.Strong)]\n        UIColor CursorColor { get; set; }\n\n        [Abstract]\n        [Export(\"editing\")]\n        bool Editing { [Bind(\"isEditing\")] get; }\n\n        [Abstract]\n        [Export(\"enabled\")]\n        bool Enabled { [Bind(\"isEnabled\")] get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"font\", ArgumentSemantic.Strong)]\n        UIFont Font { get; set; }\n\n        [Abstract]\n        [Export(\"hidesPlaceholderOnInput\")]\n        bool HidesPlaceholderOnInput { get; set; }\n\n        [Abstract]\n        [Export(\"leadingUnderlineLabel\", ArgumentSemantic.Strong)]\n        UILabel LeadingUnderlineLabel { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"placeholder\")]\n        string Placeholder { get; set; }\n\n        [Abstract]\n        [Export(\"placeholderLabel\", ArgumentSemantic.Strong)]\n        UILabel PlaceholderLabel { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"positioningDelegate\", ArgumentSemantic.Weak)]\n        ITextInputPositioningDelegate PositioningDelegate { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"text\")]\n        string Text { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"textColor\", ArgumentSemantic.Strong)]\n        UIColor TextColor { get; set; }\n\n        [Abstract]\n        [Export(\"textInsets\", ArgumentSemantic.Assign)]\n        UIEdgeInsets TextInsets { get; }\n\n        [Abstract]\n        [Export(\"textInsetsMode\", ArgumentSemantic.Assign)]\n        TextInputTextInsetsMode TextInsetsMode { get; set; }\n\n        [Abstract]\n        [Export(\"trailingUnderlineLabel\", ArgumentSemantic.Strong)]\n        UILabel TrailingUnderlineLabel { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"trailingView\", ArgumentSemantic.Strong)]\n        UIView TrailingView { get; set; }\n\n        [Abstract]\n        [Export(\"trailingViewMode\", ArgumentSemantic.Assign)]\n        UITextFieldViewMode TrailingViewMode { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"underline\", ArgumentSemantic.Strong)]\n        TextInputUnderlineView Underline { get; }\n\n        [Abstract]\n        [Export(\"hasTextContent\")]\n        bool HasTextContent { get; }\n\n        [Abstract]\n        [Export(\"mdc_adjustsFontForContentSizeCategory\")]\n        bool AdjustsFontForContentSizeCategory { get; [Bind(\"mdc_setAdjustsFontForContentSizeCategory:\")]set; }\n\n        [Abstract]\n        [Obsolete(\"Use AdjustsFontForContentSizeCategory instead\")]\n        [Wrap(\"AdjustsFontForContentSizeCategory\")]\n        bool MdcAdjustsFontForContentSizeCategory { get; set; }\n\n        [Abstract]\n        [Export(\"clearText\")]\n        void ClearText();\n    }\n\n    [Protocol(Name = \"MDCLeadingViewTextInput\")]\n    interface LeadingViewTextInput : TextInput\n\n    {\n        [Abstract]\n        [NullAllowed]\n        [Export(\"leadingView\", ArgumentSemantic.Strong)]\n        UIView LeadingView { get; set; }\n\n        [Abstract]\n        [Export(\"leadingViewMode\", ArgumentSemantic.Assign)]\n        UITextFieldViewMode LeadingViewMode { get; set; }\n    }\n\n    [Protocol(Name = \"MDCMultilineTextInput\")]\n    interface MultilineTextInput : TextInput\n\n    {\n        [Abstract]\n        [Export(\"expandsOnOverflow\")]\n        bool ExpandsOnOverflow { get; set; }\n\n        [Abstract]\n        [Export(\"minimumLines\")]\n        nuint MinimumLines { get; set; }\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCMultilineTextField\")]\n    interface MultilineTextField : TextInput, MultilineTextInput\n\n    {\n        [Export(\"adjustsFontForContentSizeCategory\")]\n        bool AdjustsFontForContentSizeCategory { get; set; }\n\n        [Obsolete(\"Use AdjustsFontForContentSizeCategory instead\")]\n        [Wrap(\"AdjustsFontForContentSizeCategory\")]\n        bool MdcAdjustsFontForContentSizeCategory { get; set; }\n\n        [Export(\"expandsOnOverflow\")]\n        bool ExpandsOnOverflow { get; set; }\n\n        [NullAllowed]\n        [Export(\"layoutDelegate\", ArgumentSemantic.Weak)]\n        IMultilineTextInputLayoutDelegate LayoutDelegate { get; set; }\n\n        [NullAllowed]\n        [Export(\"multilineDelegate\", ArgumentSemantic.Weak)]\n        IMultilineTextInputDelegate MultilineDelegate { get; set; }\n\n        [NullAllowed]\n        [Export(\"placeholder\")]\n        string Placeholder { get; set; }\n\n        [Export(\"textInsets\", ArgumentSemantic.Assign)]\n        UIEdgeInsets TextInsets { get; }\n\n        [NullAllowed]\n        [Export(\"textView\", ArgumentSemantic.Strong)]\n        IntrinsicHeightTextView TextView { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<MultilineTextField, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCMultilineTextInputLayoutDelegate\")]\n    interface MultilineTextInputLayoutDelegate\n    {\n        [Export(\"multilineTextField:didChangeContentSize:\")]\n        void DidChangeContentSize(IMultilineTextInput multilineTextField, CGSize size);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCMultilineTextInputDelegate\")]\n    interface MultilineTextInputDelegate\n    {\n        [Export(\"multilineTextFieldShouldClear:\")]\n        bool MultilineTextFieldShouldClear(ITextInput textField);\n    }\n\n    [BaseType(typeof(UITextField),\n        Name = \"MDCTextField\")]\n    interface TextField : TextInput, LeadingViewTextInput\n\n    {\n        [Export(\"inputLayoutStrut\", ArgumentSemantic.Strong)]\n        UILabel InputLayoutStrut { get; }\n\n        [NullAllowed]\n        [Export(\"leadingView\", ArgumentSemantic.Strong)]\n        UIView LeadingView { get; set; }\n\n        [Export(\"leadingViewMode\", ArgumentSemantic.Assign)]\n        UITextFieldViewMode LeadingViewMode { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<TextField, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Notification]\n        [Field(\"MDCTextFieldTextDidSetTextNotification\", \"__Internal\")]\n        NSString TextDidSetTextNotification { get; }\n\n        [Notification]\n        [Field(\"MDCTextInputDidToggleEnabledNotification\", \"__Internal\")]\n        NSString TextInputDidToggleEnabledNotification { get; }\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTextInputPositioningDelegate\")]\n    interface TextInputPositioningDelegate\n    {\n        [Export(\"textInsets:\")]\n        UIEdgeInsets TextInsets(UIEdgeInsets defaultInsets);\n\n        [Export(\"editingRectForBounds:defaultRect:\")]\n        CGRect GetEditingRect(CGRect bounds, CGRect defaultRect);\n\n        [Export(\"leadingViewRectForBounds:defaultRect:\")]\n        CGRect GetLeadingViewRect(CGRect bounds, CGRect defaultRect);\n\n        [Export(\"textInputDidLayoutSubviews\")]\n        void DidLayoutSubviews();\n\n        [Export(\"textInputDidUpdateConstraints\")]\n        void DidUpdateConstraints();\n\n        [Export(\"trailingViewRectForBounds:defaultRect:\")]\n        CGRect GetTrailingViewRect(CGRect bounds, CGRect defaultRect);\n\n        [Export(\"leadingViewTrailingPaddingConstant\")]\n        nfloat GetLeadingViewTrailingPaddingConstant();\n\n        [Export(\"trailingViewTrailingPaddingConstant\")]\n        nfloat GetTrailingViewTrailingPaddingConstant();\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCTextInputBorderView\")]\n    interface TextInputBorderView : INSCopying\n\n    {\n        [NullAllowed]\n        [Export(\"borderFillColor\", ArgumentSemantic.Strong)]\n        UIColor BorderFillColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"borderPath\", ArgumentSemantic.Strong)]\n        UIBezierPath BorderPath { get; set; }\n\n        [NullAllowed]\n        [Export(\"borderStrokeColor\", ArgumentSemantic.Strong)]\n        UIColor BorderStrokeColor { get; set; }\n    }\n\n    [Protocol(Name = \"MDCTextInputCharacterCounter\")]\n    [BaseType(typeof(NSObject))]\n    interface TextInputCharacterCounter\n    {\n        [Abstract]\n        [Export(\"characterCountForTextInput:\")]\n        nuint CharacterCount([NullAllowed] ITextInput textInput);\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTextInputAllCharactersCounter\")]\n    interface TextInputAllCharactersCounter : TextInputCharacterCounter\n\n    { }\n\n    [Protocol(Name = \"MDCTextInputController\")]\n    interface TextInputController : INSCopying, TextInputPositioningDelegate\n\n    {\n        [Abstract]\n        [Export(\"activeColor\", ArgumentSemantic.Strong)]\n        UIColor ActiveColor { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"activeColorDefault\", ArgumentSemantic.Strong)]\n        UIColor ActiveColorDefault { get; set; }\n\n        [Abstract]\n        [Export(\"characterCounter\", ArgumentSemantic.Weak)]\n        ITextInputCharacterCounter CharacterCounter { get; set; }\n\n        [Abstract]\n        [Export(\"characterCountMax\")]\n        nuint CharacterCountMax { get; set; }\n\n        [Abstract]\n        [Export(\"characterCountViewMode\", ArgumentSemantic.Assign)]\n        UITextFieldViewMode CharacterCountViewMode { get; set; }\n\n        [Abstract]\n        [Export(\"disabledColor\", ArgumentSemantic.Strong)]\n        UIColor DisabledColor { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"disabledColorDefault\", ArgumentSemantic.Strong)]\n        UIColor DisabledColorDefault { get; set; }\n\n        [Abstract]\n        [Export(\"errorColor\", ArgumentSemantic.Strong)]\n        UIColor ErrorColor { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"errorColorDefault\", ArgumentSemantic.Strong)]\n        UIColor ErrorColorDefault { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"errorText\")]\n        string ErrorText { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"helperText\")]\n        string HelperText { get; set; }\n\n        [Abstract]\n        [Export(\"inlinePlaceholderColor\", ArgumentSemantic.Strong)]\n        UIColor InlinePlaceholderColor { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"inlinePlaceholderColorDefault\", ArgumentSemantic.Strong)]\n        UIColor InlinePlaceholderColorDefault { get; set; }\n\n        [Abstract]\n        [Export(\"textInputFont\", ArgumentSemantic.Strong)]\n        UIFont TextInputFont { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Static]\n        [Export(\"textInputFontDefault\", ArgumentSemantic.Strong)]\n        UIFont TextInputFontDefault { get; set; }\n\n        [Abstract]\n        [Export(\"inlinePlaceholderFont\", ArgumentSemantic.Strong)]\n        UIFont InlinePlaceholderFont { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"inlinePlaceholderFontDefault\", ArgumentSemantic.Strong)]\n        UIFont InlinePlaceholderFontDefault { get; set; }\n\n        [Abstract]\n        [Export(\"leadingUnderlineLabelFont\", ArgumentSemantic.Strong)]\n        UIFont LeadingUnderlineLabelFont { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"leadingUnderlineLabelFontDefault\", ArgumentSemantic.Strong)]\n        UIFont LeadingUnderlineLabelFontDefault { get; set; }\n\n        [Abstract]\n        [Export(\"leadingUnderlineLabelTextColor\", ArgumentSemantic.Strong)]\n        UIColor LeadingUnderlineLabelTextColor { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"leadingUnderlineLabelTextColorDefault\", ArgumentSemantic.Strong)]\n        UIColor LeadingUnderlineLabelTextColorDefault { get; set; }\n\n        [Abstract]\n        [Export(\"normalColor\", ArgumentSemantic.Strong)]\n        UIColor NormalColor { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"normalColorDefault\", ArgumentSemantic.Strong)]\n        UIColor NormalColorDefault { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"placeholderText\")]\n        string PlaceholderText { get; set; }\n\n        [Abstract]\n        [Export(\"roundedCorners\", ArgumentSemantic.Assign)]\n        UIRectCorner RoundedCorners { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"roundedCornersDefault\", ArgumentSemantic.Assign)]\n        UIRectCorner RoundedCornersDefault { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"textInput\", ArgumentSemantic.Strong)]\n        ITextInput TextInput { get; set; }\n\n        [Abstract]\n        [Export(\"textInputClearButtonTintColor\", ArgumentSemantic.Strong)]\n        UIColor TextInputClearButtonTintColor { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Static]\n        [Export(\"textInputClearButtonTintColorDefault\", ArgumentSemantic.Strong)]\n        UIColor TextInputClearButtonTintColorDefault { get; set; }\n\n        [Abstract]\n        [Export(\"trailingUnderlineLabelFont\", ArgumentSemantic.Strong)]\n        UIFont TrailingUnderlineLabelFont { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"trailingUnderlineLabelFontDefault\", ArgumentSemantic.Strong)]\n        UIFont TrailingUnderlineLabelFontDefault { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"trailingUnderlineLabelTextColor\", ArgumentSemantic.Strong)]\n        UIColor TrailingUnderlineLabelTextColor { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Static]\n        [Export(\"trailingUnderlineLabelTextColorDefault\", ArgumentSemantic.Strong)]\n        UIColor TrailingUnderlineLabelTextColorDefault { get; set; }\n\n        [Abstract]\n        [Export(\"underlineHeightActive\")]\n        nfloat UnderlineHeightActive { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"underlineHeightActiveDefault\")]\n        nfloat UnderlineHeightActiveDefault { get; set; }\n\n        [Abstract]\n        [Export(\"underlineHeightNormal\")]\n        nfloat UnderlineHeightNormal { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"underlineHeightNormalDefault\")]\n        nfloat UnderlineHeightNormalDefault { get; set; }\n\n        [Abstract]\n        [Export(\"underlineViewMode\", ArgumentSemantic.Assign)]\n        UITextFieldViewMode UnderlineViewMode { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"underlineViewModeDefault\", ArgumentSemantic.Assign)]\n        UITextFieldViewMode UnderlineViewModeDefault { get; set; }\n\n        [Abstract]\n        [Export(\"mdc_adjustsFontForContentSizeCategory\")]\n        bool AdjustsFontForContentSizeCategory { get; [Bind(\"mdc_setAdjustsFontForContentSizeCategory:\")]set; }\n\n        [Obsolete(\"Use AdjustsFontForContentSizeCategory instead\")]\n        [Abstract]\n        [Wrap(\"AdjustsFontForContentSizeCategory\")]\n        bool MdcAdjustsFontForContentSizeCategory { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"mdc_adjustsFontForContentSizeCategoryDefault\")]\n        bool AdjustsFontForContentSizeCategoryDefault { get; set; }\n\n        [Obsolete(\"Use AdjustsFontForContentSizeCategoryDefault instead\")]\n        [Static]\n        [Wrap(\"AdjustsFontForContentSizeCategoryDefault\")]\n        bool MdcAdjustsFontForContentSizeCategoryDefault { get; set; }\n\n        [Abstract]\n        [Export(\"setErrorText:errorAccessibilityValue:\")]\n        void SetErrorText([NullAllowed] string errorText, [NullAllowed]  string errorAccessibilityValue);\n\n        [Abstract]\n        [Export(\"setHelperText:helperAccessibilityLabel:\")]\n        void SetHelperText([NullAllowed] string helperText, [NullAllowed]  string helperAccessibilityLabel);\n    }\n\n    [Protocol(Name = \"MDCTextInputControllerFloatingPlaceholder\")]\n    interface TextInputControllerFloatingPlaceholder : TextInputController\n\n    {\n        [Abstract]\n        [Export(\"floatingPlaceholderActiveColor\", ArgumentSemantic.Strong)]\n        UIColor FloatingPlaceholderActiveColor { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"floatingPlaceholderActiveColorDefault\", ArgumentSemantic.Strong)]\n        UIColor FloatingPlaceholderActiveColorDefault { get; set; }\n\n        [Abstract]\n        [Export(\"floatingPlaceholderNormalColor\", ArgumentSemantic.Strong)]\n        UIColor FloatingPlaceholderNormalColor { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"floatingPlaceholderNormalColorDefault\", ArgumentSemantic.Strong)]\n        UIColor FloatingPlaceholderNormalColorDefault { get; set; }\n\n        [Abstract]\n        [Export(\"floatingPlaceholderOffset\")]\n        UIOffset FloatingPlaceholderOffset { get; }\n\n        [Abstract]\n        [Export(\"floatingPlaceholderScale\", ArgumentSemantic.Strong)]\n        NSNumber FloatingPlaceholderScale { get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"floatingPlaceholderScaleDefault\")]\n        nfloat FloatingPlaceholderScaleDefault { get; set; }\n\n        [Abstract]\n        [Export(\"floatingEnabled\")]\n        bool FloatingEnabled { [Bind(\"isFloatingEnabled\")] get; set; }\n\n        [Abstract]\n        [Static]\n        [Export(\"floatingEnabledDefault\")]\n        bool FloatingEnabledDefault { [Bind(\"isFloatingEnabledDefault\")] get; set; }\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTextInputControllerBase\")]\n    interface TextInputControllerBase : TextInputControllerFloatingPlaceholder\n\n    {\n        [NullAllowed]\n        [Export(\"borderFillColor\", ArgumentSemantic.Strong)]\n        UIColor BorderFillColor { get; set; }\n\n        [Static]\n        [Export(\"borderFillColorDefault\", ArgumentSemantic.Strong)]\n        UIColor BorderFillColorDefault { get; set; }\n\n        [Export(\"expandsOnOverflow\")]\n        bool ExpandsOnOverflow { get; set; }\n\n        [Export(\"minimumLines\")]\n        nuint MinimumLines { get; set; }\n\n        [Field(\"MDCTextInputControllerBaseDefaultBorderRadius\", \"__Internal\")]\n        nfloat DefaultBorderRadius { get; }\n\n        [Export(\"initWithTextInput:\")]\n        IntPtr Constructor([NullAllowed] ITextInput input);\n    }\n\n    [BaseType(typeof(TextInputControllerBase),\n        Name = \"MDCTextInputControllerFilled\")]\n    interface TextInputControllerFilled\n    {\n        [Export(\"initWithTextInput:\")]\n        IntPtr Constructor([NullAllowed] ITextInput input);\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTextInputControllerFullWidth\")]\n    interface TextInputControllerFullWidth : TextInputController\n\n    {\n        [Export(\"backgroundColor\", ArgumentSemantic.Strong)]\n        UIColor BackgroundColor { get; set; }\n\n        [Static]\n        [Export(\"backgroundColorDefault\", ArgumentSemantic.Strong)]\n        UIColor BackgroundColorDefault { get; set; }\n\n        [Export(\"initWithTextInput:\")]\n        IntPtr Constructor([NullAllowed] ITextInput input);\n    }\n\n    [BaseType(typeof(TextInputControllerBase),\n        Name = \"MDCTextInputControllerLegacyDefault\")]\n    interface TextInputControllerLegacyDefault : TextInputController\n\n    {\n        [Export(\"initWithTextInput:\")]\n        IntPtr Constructor([NullAllowed] ITextInput input);\n    }\n\n    [BaseType(typeof(TextInputControllerFullWidth),\n        Name = \"MDCTextInputControllerLegacyFullWidth\")]\n    interface TextInputControllerLegacyFullWidth : TextInputController\n\n    {\n        [Export(\"initWithTextInput:\")]\n        IntPtr Constructor([NullAllowed] ITextInput input);\n    }\n\n    [BaseType(typeof(TextInputControllerBase),\n        Name = \"MDCTextInputControllerOutlined\")]\n    interface TextInputControllerOutlined\n    {\n        [Export(\"initWithTextInput:\")]\n        IntPtr Constructor([NullAllowed] ITextInput input);\n    }\n\n    [BaseType(typeof(TextInputControllerBase),\n        Name = \"MDCTextInputControllerOutlinedTextArea\")]\n    interface TextInputControllerOutlinedTextArea\n    {\n        [Export(\"initWithTextInput:\")]\n        IntPtr Constructor([NullAllowed] ITextInput input);\n    }\n\n    [BaseType(typeof(TextInputControllerBase),\n        Name = \"MDCTextInputControllerUnderline\")]\n    interface TextInputControllerUnderline\n    {\n        [Export(\"initWithTextInput:\")]\n        IntPtr Constructor([NullAllowed] ITextInput input);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCTextInputUnderlineView\")]\n    interface TextInputUnderlineView : INSCopying\n\n    {\n        [Export(\"color\", ArgumentSemantic.Strong)]\n        UIColor Color { get; set; }\n\n        [Export(\"disabledColor\", ArgumentSemantic.Strong)]\n        UIColor DisabledColor { get; set; }\n\n        [Export(\"enabled\")]\n        bool Enabled { get; set; }\n\n        [Export(\"lineHeight\")]\n        nfloat LineHeight { get; set; }\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCChipField\",\n        Delegates = new[] { \"Delegate\" },\n        Events = new[] { typeof(ChipFieldDelegate) })]\n    interface ChipField\n    {\n        [Export(\"textField\")]\n        TextField TextField { get; }\n\n        [Export(\"chipHeight\")]\n        nfloat ChipHeight { get; set; }\n\n        [Export(\"showPlaceholderWithChips\")]\n        bool ShowPlaceholderWithChips { get; set; }\n\n        [Export(\"showChipsDeleteButton\")]\n        bool ShowChipsDeleteButton { get; set; }\n\n        [Export(\"delimiter\", ArgumentSemantic.Assign)]\n        ChipFieldDelimiter Delimiter { get; set; }\n\n        [Export(\"minTextFieldWidth\")]\n        nfloat MinTextFieldWidth { get; set; }\n\n        [Export(\"chips\", ArgumentSemantic.Copy)]\n        ChipView[] Chips { get; set; }\n\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        IChipFieldDelegate Delegate { get; set; }\n\n        [Export(\"contentEdgeInsets\", ArgumentSemantic.Assign)]\n        UIEdgeInsets ContentEdgeInsets { get; set; }\n\n        [Field(\"MDCChipFieldDefaultMinTextFieldWidth\", \"__Internal\")]\n        nfloat DefaultMinTextFieldWidth { get; }\n\n        [Internal]\n        [Field(\"MDCChipFieldDefaultContentEdgeInsets\", \"__Internal\")]\n        IntPtr _DefaultContentEdgeInsets { get; }\n\n        [Export(\"addChip:\")]\n        void AddChip(ChipView chip);\n\n        [Export(\"removeChip:\")]\n        void RemoveChip(ChipView chip);\n\n        [Export(\"removeSelectedChips\")]\n        void RemoveSelectedChips();\n\n        [Export(\"clearTextInput\")]\n        void ClearTextInput();\n\n        [Export(\"selectChip:\")]\n        void SelectChip(ChipView chip);\n\n        [Export(\"deselectAllChips\")]\n        void DeselectAllChips();\n\n        [Export(\"focusTextFieldForAccessibility\")]\n        void FocusTextFieldForAccessibility();\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCChipFieldDelegate\")]\n    interface ChipFieldDelegate\n    {\n        [EventArgs(\"ChipFieldEditingStarted\")]\n        [EventName(\"EditingStarted\")]\n        [Export(\"chipFieldDidBeginEditing:\")]\n        void DidBeginEditing(ChipField chipField);\n\n        [EventArgs(\"ChipFieldEditingEnded\")]\n        [EventName(\"EditingEnded\")]\n        [Export(\"chipFieldDidEndEditing:\")]\n        void DidEndEditing(ChipField chipField);\n\n        [EventArgs(\"ChipFieldChipAdded\")]\n        [EventName(\"ChipAdded\")]\n        [Export(\"chipField:didAddChip:\")]\n        void DidAddChip(ChipField chipField, ChipView chip);\n\n        [DefaultValue(true)]\n        [DelegateName(\"ChipFieldShouldAddChip\")]\n        [Export(\"chipField:shouldAddChip:\")]\n        bool ShouldAddChip(ChipField chipField, ChipView chip);\n\n        [EventArgs(\"ChipFieldChipRemoved\")]\n        [EventName(\"ChipRemoved\")]\n        [Export(\"chipField:didRemoveChip:\")]\n        void DidRemoveChip(ChipField chipField, ChipView chip);\n\n        [EventArgs(\"ChipFieldHeightChanged\")]\n        [EventName(\"HeightChanged\")]\n        [Export(\"chipFieldHeightDidChange:\")]\n        void HeightDidChange(ChipField chipField);\n\n        [EventArgs(\"ChipFieldInputChanged\")]\n        [EventName(\"InputChanged\")]\n        [Export(\"chipField:didChangeInput:\")]\n        void DidChangeInput(ChipField chipField, [NullAllowed]  string input);\n\n        [EventArgs(\"ChipFieldChipTapped\")]\n        [EventName(\"ChipTapped\")]\n        [Export(\"chipField:didTapChip:\")]\n        void DidTapChip(ChipField chipField, ChipView chip);\n\n        [DefaultValue(true)]\n        [DelegateName(\"ChipFieldShouldReturn\")]\n        [Export(\"chipFieldShouldReturn:\")]\n        bool ShouldReturn(ChipField chipField);\n\n        [DefaultValue(true)]\n        [DelegateName(\"ChipFieldShouldBecomeFirstResponder\")]\n        [Export(\"chipFieldShouldBecomeFirstResponder:\")]\n        bool ShouldBecomeFirstResponder(ChipField chipField);\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCChipViewScheme\")]\n    interface ChipViewScheme : ChipViewScheming\n\n    {\n        [Export(\"colorScheme\", ArgumentSemantic.Assign)]\n        IColorScheming ColorScheme { get; set; }\n\n        [Export(\"shapeScheme\", ArgumentSemantic.Assign)]\n        IShapeScheming ShapeScheme { get; set; }\n\n        [Export(\"typographyScheme\", ArgumentSemantic.Assign)]\n        ITypographyScheming TypographyScheme { get; set; }\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCChipViewThemer\")]\n    interface ChipViewThemer\n    {\n        [Static]\n        [Export(\"applyScheme:toChipView:\")]\n        void ApplyScheme(IChipViewScheming scheme, ChipView chip);\n\n        [Static]\n        [Export(\"applyOutlinedVariantWithScheme:toChipView:\")]\n        void ApplyOutlinedVariant(IChipViewScheming scheme, ChipView chip);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCChipViewColorThemer\")]\n    interface ChipViewColorThemer\n    {\n        [Obsolete(\"This method will soon be deprecated\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toChipView:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, ChipView chipView);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toStrokedChipView:\")]\n        void ApplySemanticColorSchemeToStrokedChipView(IColorScheming colorScheme, ChipView strokedChipView);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyOutlinedVariantWithColorScheme:toChipView:\")]\n        void ApplyOutlinedVariant(IColorScheming colorScheme, ChipView chipView);\n\n    }\n\n    [Obsolete(\"This class will soon be deprecated. Please consider using ChipViewTypographyThemer class instead.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCChipViewFontThemer\")]\n    interface ChipViewFontThemer\n    {\n        [Static]\n        [Export(\"applyFontScheme:toChipView:\")]\n        void ApplyFontScheme(IFontScheme fontScheme, ChipView chipView);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCChipViewShapeThemer\")]\n    interface ChipViewShapeThemer\n    {\n        [Static]\n        [Export(\"applyShapeScheme:toChipView:\")]\n        void ApplyShapeScheme(IShapeScheming shapeScheme, ChipView chipView);\n    }\n\n    [Category]\n    [BaseType(typeof(ChipView),\n        Name = \"MDCChipView_MaterialTheming\")]\n    interface ChipView_MaterialTheming\n    {\n        [Export(\"applyThemeWithScheme:\")]\n        void ApplyTheme(IContainerScheming scheme);\n\n        [Export(\"applyOutlinedThemeWithScheme:\")]\n        void ApplyOutlinedThemeWithScheme(IContainerScheming scheme);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCChipViewTypographyThemer\")]\n    interface ChipViewTypographyThemer\n    {\n        [Static]\n        [Export(\"applyTypographyScheme:toChipView:\")]\n        void ApplyTypographyScheme(ITypographyScheming typographyScheme, ChipView chipView);\n    }\n\n    [BaseType(typeof(UICollectionViewCell),\n        Name = \"MDCCollectionViewCell\")]\n    interface CollectionViewCell\n    {\n        [Export(\"accessoryType\", ArgumentSemantic.Assign)]\n        CollectionViewCellAccessoryType AccessoryType { get; set; }\n\n        [NullAllowed]\n        [Export(\"accessoryView\", ArgumentSemantic.Strong)]\n        UIView AccessoryView { get; set; }\n\n        [Export(\"accessoryInset\", ArgumentSemantic.Assign)]\n        UIEdgeInsets AccessoryInset { get; set; }\n\n        [Export(\"shouldHideSeparator\")]\n        bool ShouldHideSeparator { get; set; }\n\n        [Export(\"separatorInset\", ArgumentSemantic.Assign)]\n        UIEdgeInsets SeparatorInset { get; set; }\n\n        [Export(\"allowsCellInteractionsWhileEditing\")]\n        bool AllowsCellInteractionsWhileEditing { get; set; }\n\n        [Export(\"editing\")]\n        bool Editing { [Bind(\"isEditing\")] get; set; }\n\n        [Export(\"editingSelectorColor\", ArgumentSemantic.Strong)]\n        UIColor EditingSelectorColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"inkView\", ArgumentSemantic.Strong)]\n        InkView InkView { get; set; }\n\n        [Field(\"kSelectedCellAccessibilityHintKey\", \"__Internal\")]\n        NSString SelectedCellAccessibilityHintKey { get; }\n\n        [Field(\"kDeselectedCellAccessibilityHintKey\", \"__Internal\")]\n        NSString DeselectedCellAccessibilityHintKey { get; }\n\n        [Field(\"MDCCollectionViewCellStyleCardSectionInset\", \"__Internal\")]\n        nfloat StyleCardSectionInset { get; }\n\n        [Export(\"setEditing:animated:\")]\n        void SetEditing(bool editing, bool animated);\n    }\n\n    [BaseType(typeof(CollectionViewCell),\n        Name = \"MDCCollectionViewTextCell\")]\n    interface CollectionViewTextCell\n    {\n        [NullAllowed]\n        [Export(\"textLabel\", ArgumentSemantic.Strong)]\n        UILabel TextLabel { get; }\n\n        [NullAllowed]\n        [Export(\"detailTextLabel\", ArgumentSemantic.Strong)]\n        UILabel DetailTextLabel { get; }\n\n        [NullAllowed]\n        [Export(\"imageView\", ArgumentSemantic.Strong)]\n        UIImageView ImageView { get; }\n\n        [Field(\"MDCCellDefaultOneLineHeight\", \"__Internal\")]\n        nfloat DefaultOneLineHeight { get; }\n\n        [Field(\"MDCCellDefaultOneLineWithAvatarHeight\", \"__Internal\")]\n        nfloat DefaultOneLineWithAvatarHeight { get; }\n\n        [Field(\"MDCCellDefaultTwoLineHeight\", \"__Internal\")]\n        nfloat DefaultTwoLineHeight { get; }\n\n        [Field(\"MDCCellDefaultThreeLineHeight\", \"__Internal\")]\n        nfloat DefaultThreeLineHeight { get; }\n    }\n\n    [BaseType(typeof(UICollectionViewLayoutAttributes),\n        Name = \"MDCCollectionViewLayoutAttributes\")]\n    interface CollectionViewLayoutAttributes : INSCopying\n\n    {\n        [Export(\"editing\")]\n        bool Editing { [Bind(\"isEditing\")] get; set; }\n\n        [Export(\"shouldShowReorderStateMask\")]\n        bool ShouldShowReorderStateMask { get; set; }\n\n        [Export(\"shouldShowSelectorStateMask\")]\n        bool ShouldShowSelectorStateMask { get; set; }\n\n        [Export(\"shouldShowGridBackground\")]\n        bool ShouldShowGridBackground { get; set; }\n\n        [NullAllowed]\n        [Export(\"backgroundImage\", ArgumentSemantic.Strong)]\n        UIImage BackgroundImage { get; set; }\n\n        [Export(\"backgroundImageViewInsets\", ArgumentSemantic.Assign)]\n        UIEdgeInsets BackgroundImageViewInsets { get; set; }\n\n        [Export(\"isGridLayout\")]\n        bool IsGridLayout { get; set; }\n\n        [Export(\"sectionOrdinalPosition\", ArgumentSemantic.Assign)]\n        CollectionViewOrdinalPosition SectionOrdinalPosition { get; set; }\n\n        [NullAllowed]\n        [Export(\"separatorColor\", ArgumentSemantic.Strong)]\n        UIColor SeparatorColor { get; set; }\n\n        [Export(\"separatorInset\", ArgumentSemantic.Assign)]\n        UIEdgeInsets SeparatorInset { get; set; }\n\n        [Export(\"separatorLineHeight\")]\n        nfloat SeparatorLineHeight { get; set; }\n\n        [Export(\"shouldHideSeparators\")]\n        bool ShouldHideSeparators { get; set; }\n\n        [Export(\"willAnimateCellsOnAppearance\")]\n        bool WillAnimateCellsOnAppearance { get; set; }\n\n        [Export(\"animateCellsOnAppearanceDuration\")]\n        double AnimateCellsOnAppearanceDuration { get; set; }\n\n        [Export(\"animateCellsOnAppearanceDelay\")]\n        double AnimateCellsOnAppearanceDelay { get; set; }\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCCollectionViewEditingDelegate\")]\n    interface CollectionViewEditingDelegate\n    {\n        [Export(\"collectionViewAllowsEditing:\")]\n        bool AllowsEditing(UICollectionView collectionView);\n\n        [Export(\"collectionViewWillBeginEditing:\")]\n        void WillBeginEditing(UICollectionView collectionView);\n\n        [Export(\"collectionViewDidBeginEditing:\")]\n        void EditingStarted(UICollectionView collectionView);\n\n        [Export(\"collectionViewWillEndEditing:\")]\n        void WillEndEditing(UICollectionView collectionView);\n\n        [Export(\"collectionViewDidEndEditing:\")]\n        void EditingEnded(UICollectionView collectionView);\n\n        [Export(\"collectionView:canEditItemAtIndexPath:\")]\n        bool CanEditItem(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [Export(\"collectionView:canSelectItemDuringEditingAtIndexPath:\")]\n        bool CanSelectItemDuringEditing(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [Export(\"collectionViewAllowsReordering:\")]\n        bool AllowsReordering(UICollectionView collectionView);\n\n        [Export(\"collectionView:canMoveItemAtIndexPath:\")]\n        bool CanMoveItem(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [Export(\"collectionView:canMoveItemAtIndexPath:toIndexPath:\")]\n        bool CanMoveItem(UICollectionView collectionView, NSIndexPath indexPath, NSIndexPath newIndexPath);\n\n        [Export(\"collectionView:willMoveItemAtIndexPath:toIndexPath:\")]\n        void WillMoveItem(UICollectionView collectionView, NSIndexPath indexPath, NSIndexPath newIndexPath);\n\n        [Export(\"collectionView:didMoveItemAtIndexPath:toIndexPath:\")]\n        void ItemMoved(UICollectionView collectionView, NSIndexPath indexPath, NSIndexPath newIndexPath);\n\n        [Export(\"collectionView:willBeginDraggingItemAtIndexPath:\")]\n        void WillBeginDraggingItem(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [Export(\"collectionView:didEndDraggingItemAtIndexPath:\")]\n        void DraggingItemEnded(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [Export(\"collectionView:willDeleteItemsAtIndexPaths:\")]\n        void WillDeleteItems(UICollectionView collectionView, NSIndexPath indexPaths);\n\n        [Export(\"collectionView:didDeleteItemsAtIndexPaths:\")]\n        void ItemsDeleted(UICollectionView collectionView, NSIndexPath indexPaths);\n\n        [Export(\"collectionView:willDeleteSections:\")]\n        void WillDeleteSections(UICollectionView collectionView, NSIndexSet sections);\n\n        [Export(\"collectionView:didDeleteSections:\")]\n        void SectionsDeleted(UICollectionView collectionView, NSIndexSet sections);\n\n        [Export(\"collectionViewAllowsSwipeToDismissItem:\")]\n        bool AllowsSwipeToDismissItem(UICollectionView collectionView);\n\n        [Export(\"collectionView:canSwipeToDismissItemAtIndexPath:\")]\n        bool CanSwipeToDismissItem(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [Export(\"collectionView:canSwipeInDirection:toDismissItemAtIndexPath:\")]\n        bool CollectionView(UICollectionView collectionView, UISwipeGestureRecognizerDirection swipeDirection, NSIndexPath indexPath);\n\n        [Export(\"collectionView:willBeginSwipeToDismissItemAtIndexPath:\")]\n        void WillBeginSwipeToDismissItem(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [Export(\"collectionView:didEndSwipeToDismissItemAtIndexPath:\")]\n        void SwipeToDismissItemEnded(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [Export(\"collectionView:didCancelSwipeToDismissItemAtIndexPath:\")]\n        void SwipeToDismissItemCanceled(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [Export(\"collectionViewAllowsSwipeToDismissSection:\")]\n        bool AllowsSwipeToDismissSection(UICollectionView collectionView);\n\n        [Export(\"collectionView:canSwipeToDismissSection:\")]\n        bool CanSwipeToDismissSection(UICollectionView collectionView, nint section);\n\n        [Export(\"collectionView:willBeginSwipeToDismissSection:\")]\n        void WillBeginSwipeToDismissSection(UICollectionView collectionView, nint section);\n\n        [Export(\"collectionView:didEndSwipeToDismissSection:\")]\n        void SwipeToDismissSectionEnded(UICollectionView collectionView, nint section);\n\n        [Export(\"collectionView:didCancelSwipeToDismissSection:\")]\n        void SwipeToDismissSectionCanceled(UICollectionView collectionView, nint section);\n    }\n\n    [Protocol(Name = \"MDCCollectionViewStyling\")]\n    [BaseType(typeof(NSObject))]\n    interface CollectionViewStyling\n    {\n        [Abstract]\n        [NullAllowed]\n        [Export(\"collectionView\", ArgumentSemantic.Weak)]\n        UICollectionView CollectionView { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        ICollectionViewStylingDelegate Delegate { get; set; }\n\n        [Abstract]\n        [Export(\"shouldInvalidateLayout\")]\n        bool ShouldInvalidateLayout { get; set; }\n\n        [Abstract]\n        [Export(\"cellBackgroundColor\", ArgumentSemantic.Strong)]\n        UIColor CellBackgroundColor { get; set; }\n\n        [Abstract]\n        [Export(\"cellLayoutType\", ArgumentSemantic.Assign)]\n        CollectionViewCellLayoutType CellLayoutType { get; set; }\n\n        [Abstract]\n        [Export(\"gridColumnCount\")]\n        nint GridColumnCount { get; set; }\n\n        [Abstract]\n        [Export(\"gridPadding\")]\n        nfloat GridPadding { get; set; }\n\n        [Abstract]\n        [Export(\"cellStyle\", ArgumentSemantic.Assign)]\n        CollectionViewCellStyle CellStyle { get; set; }\n\n        [Abstract]\n        [Export(\"cardBorderRadius\")]\n        nfloat CardBorderRadius { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"separatorColor\", ArgumentSemantic.Strong)]\n        UIColor SeparatorColor { get; set; }\n\n        [Abstract]\n        [Export(\"separatorInset\", ArgumentSemantic.Assign)]\n        UIEdgeInsets SeparatorInset { get; set; }\n\n        [Abstract]\n        [Export(\"separatorLineHeight\")]\n        nfloat SeparatorLineHeight { get; set; }\n\n        [Abstract]\n        [Export(\"shouldHideSeparators\")]\n        bool ShouldHideSeparators { get; set; }\n\n        [Abstract]\n        [Export(\"allowsItemInlay\")]\n        bool AllowsItemInlay { get; set; }\n\n        [Abstract]\n        [Export(\"allowsMultipleItemInlays\")]\n        bool AllowsMultipleItemInlays { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n\n        [Export(\"indexPathsForInlaidItems\")]\n        NSIndexPath[] IndexPathsForInlaidItems { get; }\n\n        [Abstract]\n        [Export(\"shouldAnimateCellsOnAppearance\")]\n        bool ShouldAnimateCellsOnAppearance { get; set; }\n\n        [Abstract]\n        [Export(\"willAnimateCellsOnAppearance\")]\n        bool WillAnimateCellsOnAppearance { get; }\n\n        [Abstract]\n        [Export(\"animateCellsOnAppearancePadding\")]\n        nfloat AnimateCellsOnAppearancePadding { get; }\n\n        [Abstract]\n        [Export(\"animateCellsOnAppearanceDuration\")]\n        double AnimateCellsOnAppearanceDuration { get; }\n\n        [Abstract]\n        [Export(\"setCellStyle:animated:\")]\n        void SetCellStyle(CollectionViewCellStyle cellStyle, bool animated);\n\n        [Abstract]\n        [Export(\"cellStyleAtSectionIndex:\")]\n        CollectionViewCellStyle GetCellStyle(nint section);\n\n        [Abstract]\n        [Export(\"backgroundImageViewOutsetsForCellWithAttribute:\")]\n        UIEdgeInsets GetBackgroundImageViewOutsetsForCell(CollectionViewLayoutAttributes attr);\n\n        [return: NullAllowed]\n        [Abstract]\n        [Export(\"backgroundImageForCellLayoutAttributes:\")]\n        UIImage GetBackgroundImageForCell(CollectionViewLayoutAttributes attr);\n\n        [Abstract]\n        [Export(\"shouldHideSeparatorForCellLayoutAttributes:\")]\n        bool ShouldHideSeparatorForCellLayoutAttributes(CollectionViewLayoutAttributes attr);\n\n        [Abstract]\n        [Export(\"isItemInlaidAtIndexPath:\")]\n        bool IsItemInlaid(NSIndexPath indexPath);\n\n        [Abstract]\n        [Export(\"applyInlayToItemAtIndexPath:animated:\")]\n        void ApplyInlayToItem(NSIndexPath indexPath, bool animated);\n\n        [Abstract]\n        [Export(\"removeInlayFromItemAtIndexPath:animated:\")]\n        void RemoveInlayFromItem(NSIndexPath indexPath, bool animated);\n\n        [Abstract]\n        [Export(\"applyInlayToAllItemsAnimated:\")]\n        void ApplyInlayToAllItems(bool animated);\n\n        [Abstract]\n        [Export(\"removeInlayFromAllItemsAnimated:\")]\n        void RemoveInlayFromAllItems(bool animated);\n\n        [Abstract]\n        [Export(\"resetIndexPathsForInlaidItems\")]\n        void ResetIndexPathsForInlaidItems();\n\n        [Abstract]\n        [Export(\"beginCellAppearanceAnimation\")]\n        void BeginCellAppearanceAnimation();\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCCollectionViewStylingDelegate\")]\n    interface CollectionViewStylingDelegate\n    {\n        [Export(\"collectionView:cellHeightAtIndexPath:\")]\n        nfloat GetCellHeight(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [Export(\"collectionView:cellStyleForSection:\")]\n        CollectionViewCellStyle CellStyleForSection(UICollectionView collectionView, nint section);\n\n        [return: NullAllowed]\n        [Export(\"collectionView:cellBackgroundColorAtIndexPath:\")]\n        UIColor GetCellBackgroundColor(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [Export(\"collectionView:shouldHideItemBackgroundAtIndexPath:\")]\n        bool ShouldHideItemBackground(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [Export(\"collectionView:shouldHideHeaderBackgroundForSection:\")]\n        bool ShouldHideHeaderBackground(UICollectionView collectionView, nint section);\n\n        [Export(\"collectionView:shouldHideFooterBackgroundForSection:\")]\n        bool ShouldHideFooterBackground(UICollectionView collectionView, nint section);\n\n        [Export(\"collectionView:shouldHideItemSeparatorAtIndexPath:\")]\n        bool ShouldHideItemSeparator(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [Export(\"collectionView:shouldHideHeaderSeparatorForSection:\")]\n        bool ShouldHideHeaderSeparator(UICollectionView collectionView, nint section);\n\n        [Export(\"collectionView:shouldHideFooterSeparatorForSection:\")]\n        bool ShouldHideFooterSeparator(UICollectionView collectionView, nint section);\n\n        [Export(\"collectionView:didApplyInlayToItemAtIndexPaths:\")]\n        void InlayToItemApplied(UICollectionView collectionView, NSIndexPath indexPaths);\n\n        [Export(\"collectionView:didRemoveInlayFromItemAtIndexPaths:\")]\n        void InlayFromItemRemoved(UICollectionView collectionView, NSIndexPath indexPaths);\n\n        [Export(\"collectionView:hidesInkViewAtIndexPath:\")]\n        bool HidesInkView(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [return: NullAllowed]\n        [Export(\"collectionView:inkColorAtIndexPath:\")]\n        UIColor GetInkColor(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [Export(\"collectionView:inkTouchController:inkViewAtIndexPath:\")]\n        InkView GetInkView(UICollectionView collectionView, InkTouchController inkTouchController, NSIndexPath indexPath);\n    }\n\n    [BaseType(typeof(UICollectionViewController),\n        Name = \"MDCCollectionViewController\")]\n    interface CollectionViewController : CollectionViewEditingDelegate, CollectionViewStylingDelegate, IUICollectionViewDelegateFlowLayout\n\n    {\n        [Export(\"styler\", ArgumentSemantic.Strong)]\n        ICollectionViewStyling Styler { get; }\n\n        [Export(\"editor\", ArgumentSemantic.Strong)]\n        ICollectionViewEditing Editor { get; }\n\n        [New]\n        [RequiresSuper]\n        [Export(\"collectionView:didHighlightItemAtIndexPath:\")]\n        void ItemHighlighted(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [New]\n        [RequiresSuper]\n        [Export(\"collectionView:didUnhighlightItemAtIndexPath:\")]\n        void ItemUnhighlighted(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [New]\n        [RequiresSuper]\n        [Export(\"collectionView:didSelectItemAtIndexPath:\")]\n        void ItemSelected(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [New]\n        [RequiresSuper]\n        [Export(\"collectionView:didDeselectItemAtIndexPath:\")]\n        void ItemDeselected(UICollectionView collectionView, NSIndexPath indexPath);\n\n        [RequiresSuper]\n        [Export(\"collectionViewWillBeginEditing:\")]\n        void WillBeginEditing(UICollectionView collectionView);\n\n        [RequiresSuper]\n        [Export(\"collectionViewWillEndEditing:\")]\n        void WillEndEditing(UICollectionView collectionView);\n\n        [Export(\"cellWidthAtSectionIndex:\")]\n        nfloat GetCellWidth(nint section);\n    }\n\n    [Protocol(Name = \"MDCCollectionViewEditing\")]\n    [BaseType(typeof(NSObject))]\n    interface CollectionViewEditing\n    {\n        [Abstract]\n        [NullAllowed]\n        [Export(\"collectionView\", ArgumentSemantic.Weak)]\n        UICollectionView CollectionView { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        ICollectionViewEditingDelegate Delegate { get; set; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"reorderingCellIndexPath\", ArgumentSemantic.Strong)]\n        NSIndexPath ReorderingCellIndexPath { get; }\n\n        [Abstract]\n        [NullAllowed]\n        [Export(\"dismissingCellIndexPath\", ArgumentSemantic.Strong)]\n        NSIndexPath DismissingCellIndexPath { get; }\n\n        [Abstract]\n        [Export(\"dismissingSection\")]\n        nint DismissingSection { get; }\n\n        [Abstract]\n        [Export(\"minimumPressDuration\")]\n        double MinimumPressDuration { get; set; }\n\n        [Abstract]\n        [Export(\"editing\")]\n        bool Editing { [Bind(\"isEditing\")] get; set; }\n\n        [Abstract]\n        [Export(\"setEditing:animated:\")]\n        void SetEditing(bool editing, bool animated);\n\n        [Abstract]\n        [Export(\"updateReorderCellPosition\")]\n        void UpdateReorderCellPosition();\n    }\n\n    [BaseType(typeof(UICollectionViewFlowLayout),\n        Name = \"MDCCollectionViewFlowLayout\")]\n    interface CollectionViewFlowLayout\n    { }\n\n    [BaseType(typeof(UIViewController),\n        Name = \"MDCAlertController\")]\n    interface AlertController : IElevatable, IElevationOverriding\n\n    {\n        [NullAllowed]\n        [Export(\"titleFont\", ArgumentSemantic.Strong)]\n        UIFont TitleFont { get; set; }\n\n        [NullAllowed]\n        [Export(\"titleColor\", ArgumentSemantic.Strong)]\n        UIColor TitleColor { get; set; }\n\n        [Export(\"titleAlignment\", ArgumentSemantic.Assign)]\n        NSTextAlignment TitleAlignment { get; set; }\n\n        [NullAllowed]\n        [Export(\"titleIcon\", ArgumentSemantic.Strong)]\n        UIImage TitleIcon { get; set; }\n\n        [NullAllowed]\n        [Export(\"titleIconTintColor\", ArgumentSemantic.Strong)]\n        UIColor TitleIconTintColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"messageFont\", ArgumentSemantic.Strong)]\n        UIFont MessageFont { get; set; }\n\n        [NullAllowed]\n        [Export(\"messageColor\", ArgumentSemantic.Strong)]\n        UIColor MessageColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"buttonFont\", ArgumentSemantic.Strong)]\n        UIFont ButtonFont { get; set; }\n\n        [NullAllowed]\n        [Export(\"buttonTitleColor\", ArgumentSemantic.Strong)]\n        UIColor ButtonTitleColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"scrimColor\", ArgumentSemantic.Strong)]\n        UIColor ScrimColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"backgroundColor\", ArgumentSemantic.Strong)]\n        UIColor BackgroundColor { get; set; }\n\n        [Export(\"cornerRadius\")]\n        nfloat CornerRadius { get; set; }\n\n        [Export(\"elevation\")]\n        nfloat Elevation { get; set; }\n\n        [Export(\"shadowColor\", ArgumentSemantic.Copy)]\n        UIColor ShadowColor { get; set; }\n\n        [New]\n        [NullAllowed]\n        [Export(\"title\")]\n        string Title { get; set; }\n\n        [NullAllowed]\n        [Export(\"message\")]\n        string Message { get; set; }\n\n        [Export(\"enableRippleBehavior\")]\n        bool EnableRippleBehavior { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<AlertController, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"adjustsFontForContentSizeCategoryWhenScaledFontIsUnavailable\")]\n        bool AdjustsFontForContentSizeCategoryWhenScaledFontIsUnavailable { get; set; }\n\n        [Export(\"actions\")]\n        AlertAction[] Actions { get; }\n\n        [Export(\"mdc_adjustsFontForContentSizeCategory\")]\n        bool AdjustsFontForContentSizeCategory { get; [Bind(\"mdc_setAdjustsFontForContentSizeCategory:\")]set; }\n\n        [Obsolete(\"Use AdjustsFontForContentSizeCategory instead\")]\n        [Wrap(\"AdjustsFontForContentSizeCategory\")]\n        bool MdcAdjustsFontForContentSizeCategory { get; set; }\n\n        [Static]\n        [Export(\"alertControllerWithTitle:message:\")]\n        AlertController Create([NullAllowed] string title, [NullAllowed]  string message);\n\n        [Export(\"addAction:\")]\n        void AddAction(AlertAction action);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCAlertAction\")]\n    interface AlertAction : INSCopying, IUIAccessibilityIdentification\n\n    {\n        [NullAllowed]\n        [Export(\"title\")]\n        string Title { get; }\n\n        [Export(\"emphasis\")]\n        ActionEmphasis Emphasis { get; }\n\n        [NullAllowed]\n        [Export(\"accessibilityIdentifier\")]\n        string AccessibilityIdentifier { get; set; }\n\n        [Static]\n        [Export(\"actionWithTitle:handler:\")]\n        AlertAction Create(string title, [NullAllowed]  ActionHandler handler);\n\n        [Static]\n        [Export(\"actionWithTitle:emphasis:handler:\")]\n        AlertAction Create(string title, ActionEmphasis emphasis, [NullAllowed]  ActionHandler handler);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCAlertControllerView\")]\n    interface AlertControllerView\n    {\n        [NullAllowed]\n        [Export(\"titleFont\", ArgumentSemantic.Strong)]\n        UIFont TitleFont { get; set; }\n\n        [NullAllowed]\n        [Export(\"titleColor\", ArgumentSemantic.Strong)]\n        UIColor TitleColor { get; set; }\n\n        [Export(\"titleAlignment\", ArgumentSemantic.Assign)]\n        NSTextAlignment TitleAlignment { get; set; }\n\n        [NullAllowed]\n        [Export(\"titleIcon\", ArgumentSemantic.Strong)]\n        UIImage TitleIcon { get; set; }\n\n        [NullAllowed]\n        [Export(\"titleIconTintColor\", ArgumentSemantic.Strong)]\n        UIColor TitleIconTintColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"messageFont\", ArgumentSemantic.Strong)]\n        UIFont MessageFont { get; set; }\n\n        [NullAllowed]\n        [Export(\"messageColor\", ArgumentSemantic.Strong)]\n        UIColor MessageColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"buttonFont\", ArgumentSemantic.Strong)]\n        UIFont ButtonFont { get; set; }\n\n        [NullAllowed]\n        [Export(\"buttonColor\", ArgumentSemantic.Strong)]\n        UIColor ButtonColor { get; set; }\n\n        [Export(\"cornerRadius\")]\n        nfloat CornerRadius { get; set; }\n\n        [Export(\"enableRippleBehavior\")]\n        bool EnableRippleBehavior { get; set; }\n\n        [Export(\"mdc_adjustsFontForContentSizeCategory\")]\n        bool AdjustsFontForContentSizeCategory { get; [Bind(\"mdc_setAdjustsFontForContentSizeCategory:\")]set; }\n\n        [Obsolete(\"Use AdjustsFontForContentSizeCategory instead\")]\n        [Wrap(\"AdjustsFontForContentSizeCategory\")]\n        bool MdcAdjustsFontForContentSizeCategory { get; set; }\n\n        [return: NullAllowed]\n        [Export(\"buttonForAction:\")]\n        Button GetButton(AlertAction action);\n    }\n\n    [Protocol(Name = \"MDCDialogPresentationControllerDelegate\")]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject))]\n    interface DialogPresentationControllerDelegate\n    {\n        [Export(\"dialogPresentationControllerDidDismiss:\")]\n        void DialogPresentationControllerDidDismiss(DialogPresentationController dialogPresentationController);\n    }\n\n    [BaseType(typeof(UIPresentationController),\n        Name = \"MDCDialogPresentationController\")]\n    interface DialogPresentationController\n    {\n        [Wrap(\"WeakDialogPresentationControllerDelegate\")]\n        [NullAllowed]\n        IDialogPresentationControllerDelegate DialogPresentationControllerDelegate { get; set; }\n\n        [NullAllowed]\n        [Export(\"dialogPresentationControllerDelegate\", ArgumentSemantic.Weak)]\n        NSObject WeakDialogPresentationControllerDelegate { get; set; }\n\n        [Export(\"dismissOnBackgroundTap\")]\n        bool DismissOnBackgroundTap { get; set; }\n\n        [Export(\"dialogCornerRadius\")]\n        nfloat DialogCornerRadius { get; set; }\n\n        [Export(\"dialogElevation\")]\n        nfloat DialogElevation { get; set; }\n\n        [Export(\"dialogShadowColor\", ArgumentSemantic.Copy)]\n        UIColor DialogShadowColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"scrimColor\", ArgumentSemantic.Strong)]\n        UIColor ScrimColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<DialogPresentationController, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [New]\n        [Export(\"sizeForChildContentContainer:withParentContainerSize:\")]\n        CGSize GetSizeForChildContentContainer(IUIContentContainer container, CGSize parentSize);\n\n        [Export(\"frameOfPresentedViewInContainerView\")]\n        CGRect GetFrameOfPresentedViewInContainerView();\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCDialogTransitionController\")]\n    interface DialogTransitionController : IUIViewControllerAnimatedTransitioning, IUIViewControllerTransitioningDelegate\n    { }\n\n    [Category]\n    [BaseType(typeof(UIViewController))]\n    interface UIViewController_MaterialDialogs\n    {\n        [return: NullAllowed]\n        [Export(\"mdc_dialogPresentationController\")]\n        DialogPresentationController GetDialogPresentationController();\n\n        [return: NullAllowed]\n        [Wrap(\"GetDialogPresentationController(This)\")]\n        DialogPresentationController MdcGetDialogPresentationController();\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCAlertColorThemer\")]\n    interface AlertColorThemer\n    {\n        [Obsolete(\"This method will soon be deprecated. Consider using ApplySemanticColorScheme method instead.\")]\n        [Static]\n        [Export(\"applyColorScheme:\")]\n        void ApplyColorScheme(IColorScheme colorScheme);\n\n        [Static]\n        [Export(\"applySemanticColorScheme:toAlertController:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, AlertController alertController);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCAlertScheming\")]\n    interface AlertScheming\n    {\n        [Abstract]\n        [Export(\"colorScheme\")]\n        IColorScheming ColorScheme { get; }\n\n        [Abstract]\n        [Export(\"typographyScheme\")]\n        ITypographyScheming TypographyScheme { get; }\n\n        [Abstract]\n        [Export(\"buttonScheme\")]\n        IButtonScheming ButtonScheme { get; }\n\n        [Abstract]\n        [Export(\"cornerRadius\")]\n        nfloat CornerRadius { get; }\n\n        [Abstract]\n        [Export(\"elevation\")]\n        nfloat Elevation { get; }\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCAlertScheme\")]\n    interface AlertScheme : AlertScheming\n\n    {\n        [Export(\"colorScheme\", ArgumentSemantic.Assign)]\n        IColorScheming ColorScheme { get; set; }\n\n        [Export(\"typographyScheme\", ArgumentSemantic.Assign)]\n        ITypographyScheming TypographyScheme { get; set; }\n\n        [Export(\"buttonScheme\", ArgumentSemantic.Assign)]\n        IButtonScheming ButtonScheme { get; set; }\n\n        [Export(\"cornerRadius\")]\n        nfloat CornerRadius { get; set; }\n\n        [Export(\"elevation\")]\n        nfloat Elevation { get; set; }\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCAlertControllerThemer\")]\n    interface AlertControllerThemer\n    {\n        [Static]\n        [Export(\"applyScheme:toAlertController:\")]\n        void ApplyScheme(IAlertScheming alertScheme, AlertController alertController);\n    }\n\n    [Category]\n    [BaseType(typeof(AlertController),\n        Name = \"MDCAlertController_MaterialTheming\")]\n    interface AlertController_MaterialTheming\n    {\n        [Export(\"applyThemeWithScheme:\")]\n        void ApplyTheme(IContainerScheming scheme);\n    }\n\n    [Category]\n    [BaseType(typeof(DialogPresentationController),\n        Name = \"MDCDialogPresentationController_MaterialTheming\")]\n    interface DialogPresentationController_MaterialTheming\n    {\n        [Export(\"applyThemeWithScheme:\")]\n        void ApplyTheme(IContainerScheming scheme);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCAlertTypographyThemer\")]\n    interface AlertTypographyThemer\n    {\n        [Static]\n        [Export(\"applyTypographyScheme:toAlertController:\")]\n        void ApplyTypographyScheme(ITypographyScheming typographyScheme, AlertController alertController);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCFeatureHighlightView\")]\n    interface FeatureHighlightView\n    {\n        [NullAllowed]\n        [Export(\"innerHighlightColor\", ArgumentSemantic.Strong)]\n        UIColor InnerHighlightColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"outerHighlightColor\", ArgumentSemantic.Strong)]\n        UIColor OuterHighlightColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"titleFont\", ArgumentSemantic.Strong)]\n        UIFont TitleFont { get; set; }\n\n        [NullAllowed]\n        [Export(\"titleColor\", ArgumentSemantic.Strong)]\n        UIColor TitleColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"bodyFont\", ArgumentSemantic.Strong)]\n        UIFont BodyFont { get; set; }\n\n        [NullAllowed]\n        [Export(\"bodyColor\", ArgumentSemantic.Strong)]\n        UIColor BodyColor { get; set; }\n\n        [Export(\"mdc_legacyFontScaling\")]\n        bool LegacyFontScaling { get; [Bind(\"mdc_setLegacyFontScaling:\")]set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<FeatureHighlightView, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"mdc_adjustsFontForContentSizeCategory\")]\n        bool AdjustsFontForContentSizeCategory { get; [Bind(\"mdc_setAdjustsFontForContentSizeCategory:\")]set; }\n\n        [Obsolete(\"Use AdjustsFontForContentSizeCategory instead\")]\n        [Wrap(\"AdjustsFontForContentSizeCategory\")]\n        bool MdcAdjustsFontForContentSizeCategory { get; set; }\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(UIViewController),\n        Name = \"MDCFeatureHighlightViewController\")]\n    interface FeatureHighlightViewController\n    {\n        [NullAllowed]\n        [Export(\"titleText\")]\n        string TitleText { get; set; }\n\n        [NullAllowed]\n        [Export(\"bodyText\")]\n        string BodyText { get; set; }\n\n        [Export(\"outerHighlightColor\", ArgumentSemantic.Strong)]\n        UIColor OuterHighlightColor { get; set; }\n\n        [Export(\"innerHighlightColor\", ArgumentSemantic.Strong)]\n        UIColor InnerHighlightColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"titleColor\", ArgumentSemantic.Strong)]\n        UIColor TitleColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"bodyColor\", ArgumentSemantic.Strong)]\n        UIColor BodyColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"titleFont\", ArgumentSemantic.Strong)]\n        UIFont TitleFont { get; set; }\n\n        [NullAllowed]\n        [Export(\"bodyFont\", ArgumentSemantic.Strong)]\n        UIFont BodyFont { get; set; }\n\n        [Export(\"mdc_legacyFontScaling\")]\n        bool LegacyFontScaling { get; [Bind(\"mdc_setLegacyFontScaling:\")]set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<FeatureHighlightViewController, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Field(\"kMDCFeatureHighlightOuterHighlightAlpha\", \"__Internal\")]\n        nfloat FeatureHighlightOuterHighlightAlpha { get; }\n\n        [Export(\"mdc_adjustsFontForContentSizeCategory\")]\n        bool AdjustsFontForContentSizeCategory { get; [Bind(\"mdc_setAdjustsFontForContentSizeCategory:\")]set; }\n\n        [Obsolete(\"Use AdjustsFontForContentSizeCategory instead\")]\n        [Wrap(\"AdjustsFontForContentSizeCategory\")]\n        bool MdcAdjustsFontForContentSizeCategory { get; set; }\n\n        [DesignatedInitializer]\n        [Export(\"initWithHighlightedView:andShowView:completion:\")]\n        IntPtr Constructor(UIView highlightedView, UIView displayedView, [NullAllowed]  FeatureHighlightCompletionHandler completion);\n\n        [Export(\"initWithHighlightedView:completion:\")]\n        IntPtr Constructor(UIView highlightedView, [NullAllowed]  FeatureHighlightCompletionHandler completion);\n\n        [Export(\"acceptFeature\")]\n        void AcceptFeature();\n\n        [Export(\"rejectFeature\")]\n        void RejectFeature();\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCFeatureHighlightColorThemer\")]\n    interface FeatureHighlightColorThemer\n    {\n        [Obsolete(\" This method will soon be deprecated. Consider using ApplySemanticColorScheme method instead.\")]\n        [Static]\n        [Export(\"applyColorScheme:toFeatureHighlightView:\")]\n        void ApplyColorScheme(IColorScheme colorScheme, FeatureHighlightView featureHighlightView);\n\n        [Obsolete(\" This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toFeatureHighlightViewController:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, FeatureHighlightViewController featureHighlightViewController);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCFeatureHighlightAccessibilityMutator\")]\n    interface FeatureHighlightAccessibilityMutator\n    {\n        [Static]\n        [Export(\"mutate:\")]\n        void Mutate(FeatureHighlightViewController featureHighlightViewController);\n    }\n\n    [Obsolete(\"This class will soon be deprecated. Please consider using FeatureHighlightTypographyThemer class instead.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCFeatureHighlightFontThemer\")]\n    interface FeatureHighlightFontThemer\n    {\n        [Obsolete(\" This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyFontScheme:toFeatureHighlightView:\")]\n        void ApplyFontScheme(IFontScheme fontScheme, FeatureHighlightView featureHighlightView);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCFeatureHighlightTypographyThemer\")]\n    interface FeatureHighlightTypographyThemer\n    {\n        [Obsolete(\" This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyTypographyScheme:toFeatureHighlightViewController:\")]\n        void ApplyTypographyScheme(ITypographyScheming typographyScheme, FeatureHighlightViewController featureHighlightViewController);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCFlexibleHeaderColorThemer\")]\n    interface FlexibleHeaderColorThemer\n    {\n        [Obsolete(\" This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toFlexibleHeaderView:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, FlexibleHeaderView flexibleHeaderView);\n\n        [Obsolete(\" This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySurfaceVariantWithColorScheme:toFlexibleHeaderView:\")]\n        void ApplySurfaceVariant (IColorScheming colorScheme, FlexibleHeaderView flexibleHeaderView);\n\n        [Obsolete(\"This method will soon be deprecated. Consider using ApplySemanticColorScheme method instead.\")]\n        [Static]\n        [Export(\"applyColorScheme:toFlexibleHeaderView:\")]\n        void ApplyColorScheme (IColorScheme colorScheme, FlexibleHeaderView flexibleHeaderView);\n\n        [Obsolete(\"This method will soon be deprecated. Consider using ApplySemanticColorScheme method instead.\")]\n        [Static]\n        [Export(\"applyColorScheme:toMDCFlexibleHeaderController:\")]\n        void ApplyColorScheme(IColorScheme colorScheme, FlexibleHeaderViewController flexibleHeaderController);\n    }\n\n    [Obsolete(\"This class will soon be deprecated. There will be no replacement API. Consider theming your flexible header view or app bar instead.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCHeaderStackViewColorThemer\")]\n    interface HeaderStackViewColorThemer\n    {\n        [Static]\n        [Export(\"applyColorScheme:toHeaderStackView:\")]\n        void ApplyColorScheme(IColorScheme colorScheme, HeaderStackView headerStackView);\n    }\n\n    [Obsolete(\"This class will soon be deprecated. There is no direct replacement. Ink color needs to be set by the owning component in a context - specific manner.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCInkColorThemer\")]\n    interface InkColorThemer\n    {\n        [Static]\n        [Export(\"applyColorScheme:toInkView:\")]\n        void ApplyColorScheme(IColorScheme colorScheme, InkView inkView);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCLibraryInfo\")]\n    interface LibraryInfo\n    {\n        [Static]\n        [Export(\"versionString\")]\n        string VersionString { get; }\n    }\n\n    [BaseType(typeof(UICollectionViewCell),\n        Name = \"MDCBaseCell\")]\n    interface BaseCell : IElevatable, IElevationOverriding\n\n    {\n        [Export(\"elevation\")]\n        nfloat Elevation { get; set; }\n\n        [Export(\"enableRippleBehavior\")]\n        bool EnableRippleBehavior { get; set; }\n\n        [NullAllowed]\n        [Export(\"rippleColor\", ArgumentSemantic.Strong)]\n        UIColor RippleColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<BaseCell, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Obsolete(\" This property will soon be deprecated.\")]\n        [Export(\"inkColor\", ArgumentSemantic.Strong)]\n        UIColor InkColor { get; set; }\n    }\n\n    [BaseType(typeof(BaseCell),\n        Name = \"MDCSelfSizingStereoCell\")]\n    interface SelfSizingStereoCell\n    {\n        [Export(\"leadingImageView\", ArgumentSemantic.Strong)]\n        UIImageView LeadingImageView { get; }\n\n        [Export(\"trailingImageView\", ArgumentSemantic.Strong)]\n        UIImageView TrailingImageView { get; }\n\n        [Export(\"titleLabel\", ArgumentSemantic.Strong)]\n        UILabel TitleLabel { get; }\n\n        [Export(\"detailLabel\", ArgumentSemantic.Strong)]\n        UILabel DetailLabel { get; }\n\n        [Export(\"adjustsFontForContentSizeCategoryWhenScaledFontIsUnavailable\")]\n        bool AdjustsFontForContentSizeCategoryWhenScaledFontIsUnavailable { get; set; }\n\n        [Export(\"mdc_adjustsFontForContentSizeCategory\")]\n        bool AdjustsFontForContentSizeCategory { get; [Bind(\"mdc_setAdjustsFontForContentSizeCategory:\")]set; }\n\n        [Obsolete(\"Use AdjustsFontForContentSizeCategory instead\")]\n        [Wrap(\"AdjustsFontForContentSizeCategory\")]\n        bool MdcAdjustsFontForContentSizeCategory { get; set; }\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCListColorThemer\")]\n    interface ListColorThemer\n    {\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toSelfSizingStereoCell:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, SelfSizingStereoCell cell);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toBaseCell:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, BaseCell cell);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCListScheming\")]\n    interface ListScheming\n    {\n        [Abstract]\n        [Export(\"colorScheme\")]\n        IColorScheming ColorScheme { get; }\n\n        [Abstract]\n        [Export(\"typographyScheme\")]\n        ITypographyScheming TypographyScheme { get; }\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCListScheme\")]\n    interface ListScheme : ListScheming\n\n    {\n        [Export(\"colorScheme\", ArgumentSemantic.Assign)]\n        IColorScheming ColorScheme { get; set; }\n\n        [Export(\"typographyScheme\", ArgumentSemantic.Assign)]\n        ITypographyScheming TypographyScheme { get; set; }\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCListThemer\")]\n    interface ListThemer\n    {\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyScheme:toSelfSizingStereoCell:\")]\n        void ApplyScheme (IListScheming scheme, SelfSizingStereoCell cell);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyScheme:toBaseCell:\")]\n        void ApplyScheme (IListScheming scheme, BaseCell cell);\n    }\n\n    [Category]\n    [BaseType(typeof(BaseCell),\n        Name = \"MDCBaseCell_MaterialTheming\")]\n    interface BaseCell_MaterialTheming\n    {\n        [Export(\"applyThemeWithScheme:\")]\n        void ApplyTheme(IContainerScheming scheme);\n    }\n\n    [Category]\n    [BaseType(typeof(SelfSizingStereoCell),\n        Name = \"MDCSelfSizingStereoCell_MaterialTheming\")]\n    interface SelfSizingStereoCell_MaterialTheming\n    {\n        [Export(\"applyThemeWithScheme:\")]\n        void ApplyTheme(IContainerScheming scheme);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCListTypographyThemer\")]\n    interface ListTypographyThemer\n    {\n        [Obsolete(\"This property has been deprecated.\")]\n        [Static]\n        [Export(\"applyTypographyScheme:toSelfSizingStereoCell:\")]\n        void ApplyTypographyScheme (ITypographyScheming typographyScheme, SelfSizingStereoCell cell);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCMaskedTransitionController\")]\n    interface MaskedTransitionController : IUIViewControllerTransitioningDelegate\n\n    {\n        [NullAllowed]\n        [Export(\"sourceView\", ArgumentSemantic.Strong)]\n        UIView SourceView { get; }\n\n        [NullAllowed]\n        [Export(\"calculateFrameOfPresentedView\", ArgumentSemantic.Copy)]\n        Func<UIPresentationController, CGRect> CalculateFrameOfPresentedView { get; set; }\n\n        [Export(\"initWithSourceView:\")]\n        IntPtr Constructor([NullAllowed] UIView sourceView);\n\n        [DesignatedInitializer]\n        [Export(\"init\")]\n        IntPtr Constructor();\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCNavigationBarColorThemer\")]\n    interface NavigationBarColorThemer\n    {\n        [Obsolete(\"This method will soon be deprecated. Consider using ApplySemanticColorScheme instead.\")]\n        [Static]\n        [Export(\"applyColorScheme:toNavigationBar:\")]\n        void ApplyColorScheme (IColorScheme colorScheme, NavigationBar navigationBar);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toNavigationBar:\")]\n        void ApplySemanticColorScheme (IColorScheming colorScheme, NavigationBar navigationBar);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySurfaceVariantWithColorScheme:toNavigationBar:\")]\n        void ApplySurfaceVariant (IColorScheming colorScheme, NavigationBar navigationBar);\n\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCNavigationBarTypographyThemer\")]\n    interface NavigationBarTypographyThemer\n    {\n        [Static]\n        [Export(\"applyTypographyScheme:toNavigationBar:\")]\n        void ApplyTypographyScheme (ITypographyScheming typographyScheme, NavigationBar navigationBar);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCBottomDrawerHeader\")]\n    interface BottomDrawerHeader\n    {\n        [Export(\"updateDrawerHeaderTransitionRatio:\")]\n        void UpdateDrawerHeaderTransitionRatio(nfloat transitionToTopRatio);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCBottomDrawerPresentationControllerDelegate\")]\n    interface BottomDrawerPresentationControllerDelegate : IUIAdaptivePresentationControllerDelegate\n\n    {\n        [EventArgs(\"BottomDrawerPresentationControllerWillChangeState\")]\n        [Abstract]\n        [Export(\"bottomDrawerWillChangeState:drawerState:\")]\n        void WillChangeState(BottomDrawerPresentationController presentationController, BottomDrawerState drawerState);\n\n        [EventArgs(\"BottomDrawerPresentationControllerTopTransitionRatio\")]\n        [Abstract]\n        [Export(\"bottomDrawerTopTransitionRatio:transitionRatio:\")]\n        void TopTransitionRatio(BottomDrawerPresentationController presentationController, nfloat transitionRatio);\n    }\n\n    [BaseType(typeof(UIPresentationController),\n        Name = \"MDCBottomDrawerPresentationController\",\n        Delegates = new[] { \"Delegate\" },\n        Events = new[] { typeof(BottomDrawerPresentationControllerDelegate) })]\n    interface BottomDrawerPresentationController\n    {\n        [NullAllowed]\n        [Export(\"trackingScrollView\", ArgumentSemantic.Weak)]\n        UIScrollView TrackingScrollView { get; set; }\n\n        [NullAllowed]\n        [Export(\"scrimColor\", ArgumentSemantic.Strong)]\n        UIColor ScrimColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        IBottomDrawerPresentationControllerDelegate Delegate { get; set; }\n\n        [Export(\"topHandleHidden\")]\n        bool TopHandleHidden { [Bind(\"isTopHandleHidden\")] get; set; }\n\n        [NullAllowed]\n        [Export(\"topHandleColor\", ArgumentSemantic.Strong)]\n        UIColor TopHandleColor { get; set; }\n\n        [Export(\"maximumInitialDrawerHeight\")]\n        nfloat MaximumInitialDrawerHeight { get; set; }\n\n        [Export(\"shouldIncludeSafeAreaInContentHeight\")]\n        bool ShouldIncludeSafeAreaInContentHeight { get; set; }\n\n        [Export(\"contentReachesFullscreen\")]\n        bool ContentReachesFullscreen { get; }\n\n        [Export(\"drawerShadowColor\", ArgumentSemantic.Strong)]\n        UIColor DrawerShadowColor { get; set; }\n\n        [Export(\"elevation\")]\n        double Elevation { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<BottomDrawerPresentationController, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"setContentOffsetY:animated:\")]\n        void SetContentOffsetY(nfloat contentOffsetY, bool animated);\n\n        [Export(\"expandToFullscreenWithDuration:completion:\")]\n        void ExpandToFullscreenWithDuration(nfloat duration, [NullAllowed]  Action<bool> completion);\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCBottomDrawerTransitionController\")]\n    interface BottomDrawerTransitionController : IUIViewControllerAnimatedTransitioning, IUIViewControllerTransitioningDelegate\n\n    {\n        [NullAllowed]\n        [Export(\"trackingScrollView\", ArgumentSemantic.Weak)]\n        UIScrollView TrackingScrollView { get; set; }\n    }\n\n    [BaseType(typeof(UIViewController),\n        Name = \"MDCBottomDrawerViewController\",\n        Delegates = new[] { \"Delegate\" },\n        Events = new[] { typeof(BottomDrawerViewControllerDelegate) })]\n    interface BottomDrawerViewController : IBottomDrawerPresentationControllerDelegate\n\n    {\n        [NullAllowed]\n        [Export(\"contentViewController\", ArgumentSemantic.Assign)]\n        UIViewController ContentViewController { get; set; }\n\n        [NullAllowed]\n        [Export(\"headerViewController\", ArgumentSemantic.Assign)]\n        BottomDrawerHeader HeaderViewController { get; set; }\n\n        [NullAllowed]\n        [Export(\"trackingScrollView\", ArgumentSemantic.Weak)]\n        UIScrollView TrackingScrollView { get; set; }\n\n        [Export(\"drawerState\")]\n        BottomDrawerState DrawerState { get; }\n\n        [NullAllowed]\n        [Export(\"scrimColor\", ArgumentSemantic.Strong)]\n        UIColor ScrimColor { get; set; }\n\n        [Export(\"topHandleHidden\")]\n        bool TopHandleHidden { [Bind(\"isTopHandleHidden\")] get; set; }\n\n        [NullAllowed]\n        [Export(\"topHandleColor\", ArgumentSemantic.Strong)]\n        UIColor TopHandleColor { get; set; }\n\n        [Export(\"maximumInitialDrawerHeight\")]\n        nfloat MaximumInitialDrawerHeight { get; set; }\n\n        [Export(\"shouldIncludeSafeAreaInContentHeight\")]\n        bool ShouldIncludeSafeAreaInContentHeight { get; set; }\n\n        [Export(\"drawerShadowColor\", ArgumentSemantic.Strong)]\n        UIColor DrawerShadowColor { get; set; }\n\n        [Export(\"elevation\")]\n        double Elevation { get; set; }\n\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        IBottomDrawerViewControllerDelegate Delegate { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<BottomDrawerViewController, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"setTopCornersRadius:forDrawerState:\")]\n        void SetTopCornersRadius(nfloat radius, BottomDrawerState drawerState);\n\n        [Export(\"topCornersRadiusForDrawerState:\")]\n        nfloat GetTopCornersRadius(BottomDrawerState drawerState);\n\n        [Export(\"setContentOffsetY:animated:\")]\n        void SetContentOffsetY(nfloat contentOffsetY, bool animated);\n\n        [Export(\"expandToFullscreenWithDuration:completion:\")]\n        void ExpandToFullscreenWithDuration(nfloat duration, [NullAllowed]  Action<bool> completion);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCBottomDrawerViewControllerDelegate\")]\n    interface BottomDrawerViewControllerDelegate\n    {\n        [EventArgs(\"BottomDrawerViewControllerDidChangeTopInset\")]\n        [EventName(\"TopInsetChanged\")]\n        [Abstract]\n        [Export(\"bottomDrawerControllerDidChangeTopInset:topInset:\")]\n        void DidChangeTopInset(BottomDrawerViewController controller, nfloat topInset);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCBottomDrawerColorThemer\")]\n    interface BottomDrawerColorThemer\n    {\n        [Obsolete(\"The method will shortly be deprecated.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toBottomDrawer:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, BottomDrawerViewController bottomDrawer);\n    }\n\n    [BaseType(typeof(UIWindow),\n        Name = \"MDCOverlayWindow\")]\n    interface OverlayWindow\n    {\n        [Export(\"activateOverlay:withLevel:\")]\n        void ActivateOverlay(UIView overlay, double level);\n\n        [Export(\"deactivateOverlay:\")]\n        void DeactivateOverlay(UIView overlay);\n\n        [Export(\"initWithFrame:\")]\n        IntPtr Constructor(CGRect frame);\n    }\n\n    [BaseType(typeof(UIControl),\n        Name = \"MDCPageControl\")]\n    interface PageControl : IUIScrollViewDelegate\n\n    {\n        [Export(\"numberOfPages\")]\n        nint NumberOfPages { get; set; }\n\n        [Export(\"currentPage\")]\n        nint CurrentPage { get; set; }\n\n        [Export(\"hidesForSinglePage\")]\n        bool HidesForSinglePage { get; set; }\n\n        [NullAllowed]\n        [Export(\"pageIndicatorTintColor\", ArgumentSemantic.Strong)]\n        UIColor PageIndicatorTintColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"currentPageIndicatorTintColor\", ArgumentSemantic.Strong)]\n        UIColor CurrentPageIndicatorTintColor { get; set; }\n\n        [Export(\"defersCurrentPageDisplay\")]\n        bool DefersCurrentPageDisplay { get; set; }\n\n        [Export(\"respectsUserInterfaceLayoutDirection\")]\n        bool RespectsUserInterfaceLayoutDirection { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<PageControl, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"setCurrentPage:animated:\")]\n        void SetCurrentPage(nint currentPage, bool animated);\n\n        [Export(\"updateCurrentPageDisplay\")]\n        void UpdateCurrentPageDisplay();\n\n        [Static]\n        [Export(\"sizeForNumberOfPages:\")]\n        CGSize GetSizeForNumberOfPages(nint pageCount);\n\n        [Export(\"scrollViewDidScroll:\")]\n        void ScrollViewDidScroll(UIScrollView scrollView);\n\n        [Export(\"scrollViewDidEndDecelerating:\")]\n        void ScrollViewDidEndDecelerating(UIScrollView scrollView);\n\n        [Export(\"scrollViewDidEndScrollingAnimation:\")]\n        void ScrollViewDidEndScrollingAnimation(UIScrollView scrollView);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCPageControlColorThemer\")]\n    interface PageControlColorThemer\n    {\n        [Obsolete(\"This method will soon be deprecated. There is no replacement yet.\")]\n        [Static]\n        [Export(\"applyColorScheme:toPageControl:\")]\n        void ApplyColorScheme(IColorScheme colorScheme, PageControl pageControl);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCPalette\")]\n    interface Palette\n    {\n        [Static]\n        [Export(\"redPalette\", ArgumentSemantic.Strong)]\n        Palette RedPalette { get; }\n\n        [Static]\n        [Export(\"pinkPalette\", ArgumentSemantic.Strong)]\n        Palette PinkPalette { get; }\n\n        [Static]\n        [Export(\"purplePalette\", ArgumentSemantic.Strong)]\n        Palette PurplePalette { get; }\n\n        [Static]\n        [Export(\"deepPurplePalette\", ArgumentSemantic.Strong)]\n        Palette DeepPurplePalette { get; }\n\n        [Static]\n        [Export(\"indigoPalette\", ArgumentSemantic.Strong)]\n        Palette IndigoPalette { get; }\n\n        [Static]\n        [Export(\"bluePalette\", ArgumentSemantic.Strong)]\n        Palette BluePalette { get; }\n\n        [Static]\n        [Export(\"lightBluePalette\", ArgumentSemantic.Strong)]\n        Palette LightBluePalette { get; }\n\n        [Static]\n        [Export(\"cyanPalette\", ArgumentSemantic.Strong)]\n        Palette CyanPalette { get; }\n\n        [Static]\n        [Export(\"tealPalette\", ArgumentSemantic.Strong)]\n        Palette TealPalette { get; }\n\n        [Static]\n        [Export(\"greenPalette\", ArgumentSemantic.Strong)]\n        Palette GreenPalette { get; }\n\n        [Static]\n        [Export(\"lightGreenPalette\", ArgumentSemantic.Strong)]\n        Palette LightGreenPalette { get; }\n\n        [Static]\n        [Export(\"limePalette\", ArgumentSemantic.Strong)]\n        Palette LimePalette { get; }\n\n        [Static]\n        [Export(\"yellowPalette\", ArgumentSemantic.Strong)]\n        Palette YellowPalette { get; }\n\n        [Static]\n        [Export(\"amberPalette\", ArgumentSemantic.Strong)]\n        Palette AmberPalette { get; }\n\n        [Static]\n        [Export(\"orangePalette\", ArgumentSemantic.Strong)]\n        Palette OrangePalette { get; }\n\n        [Static]\n        [Export(\"deepOrangePalette\", ArgumentSemantic.Strong)]\n        Palette DeepOrangePalette { get; }\n\n        [Static]\n        [Export(\"brownPalette\", ArgumentSemantic.Strong)]\n        Palette BrownPalette { get; }\n\n        [Static]\n        [Export(\"greyPalette\", ArgumentSemantic.Strong)]\n        Palette GreyPalette { get; }\n\n        [Static]\n        [Export(\"blueGreyPalette\", ArgumentSemantic.Strong)]\n        Palette BlueGreyPalette { get; }\n\n        [Export(\"tint50\")]\n        UIColor Tint50 { get; }\n\n        [Export(\"tint100\")]\n        UIColor Tint100 { get; }\n\n        [Export(\"tint200\")]\n        UIColor Tint200 { get; }\n\n        [Export(\"tint300\")]\n        UIColor Tint300 { get; }\n\n        [Export(\"tint400\")]\n        UIColor Tint400 { get; }\n\n        [Export(\"tint500\")]\n        UIColor Tint500 { get; }\n\n        [Export(\"tint600\")]\n        UIColor Tint600 { get; }\n\n        [Export(\"tint700\")]\n        UIColor Tint700 { get; }\n\n        [Export(\"tint800\")]\n        UIColor Tint800 { get; }\n\n        [Export(\"tint900\")]\n        UIColor Tint900 { get; }\n\n        [NullAllowed]\n        [Export(\"accent100\")]\n        UIColor Accent100 { get; }\n\n        [NullAllowed]\n        [Export(\"accent200\")]\n        UIColor Accent200 { get; }\n\n        [NullAllowed]\n        [Export(\"accent400\")]\n        UIColor Accent400 { get; }\n\n        [NullAllowed]\n        [Export(\"accent700\")]\n        UIColor Accent700 { get; }\n\n        [Field(\"MDCPaletteTint50Name\", \"__Internal\")]\n        NSString Tint50Name { get; }\n\n        [Field(\"MDCPaletteTint100Name\", \"__Internal\")]\n        NSString Tint100Name { get; }\n\n        [Field(\"MDCPaletteTint200Name\", \"__Internal\")]\n        NSString Tint200Name { get; }\n\n        [Field(\"MDCPaletteTint300Name\", \"__Internal\")]\n        NSString Tint300Name { get; }\n\n        [Field(\"MDCPaletteTint400Name\", \"__Internal\")]\n        NSString Tint400Name { get; }\n\n        [Field(\"MDCPaletteTint500Name\", \"__Internal\")]\n        NSString Tint500Name { get; }\n\n        [Field(\"MDCPaletteTint600Name\", \"__Internal\")]\n        NSString Tint600Name { get; }\n\n        [Field(\"MDCPaletteTint700Name\", \"__Internal\")]\n        NSString Tint700Name { get; }\n\n        [Field(\"MDCPaletteTint800Name\", \"__Internal\")]\n        NSString Tint800Name { get; }\n\n        [Field(\"MDCPaletteTint900Name\", \"__Internal\")]\n        NSString Tint900Name { get; }\n\n        [Field(\"MDCPaletteAccent100Name\", \"__Internal\")]\n        NSString Accent100Name { get; }\n\n        [Field(\"MDCPaletteAccent200Name\", \"__Internal\")]\n        NSString Accent200Name { get; }\n\n        [Field(\"MDCPaletteAccent400Name\", \"__Internal\")]\n        NSString Accent400Name { get; }\n\n        [Field(\"MDCPaletteAccent700Name\", \"__Internal\")]\n        NSString Accent700Name { get; }\n\n        [Static]\n        [Export(\"paletteGeneratedFromColor:\")]\n        Palette FromColor(UIColor target500Color);\n\n        [Static]\n        [Export(\"paletteWithTints:accents:\")]\n        Palette FromTints(NSDictionary<NSString, UIColor> tints, [NullAllowed]  NSDictionary<NSString, UIColor> accents);\n\n        [Export(\"initWithTints:accents:\")]\n        IntPtr Constructor(NSDictionary<NSString, UIColor> tints, [NullAllowed]  NSDictionary<NSString, UIColor> accents);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCProgressView\")]\n    interface ProgressView\n    {\n        [Export(\"progressTintColor\", ArgumentSemantic.Strong)]\n        UIColor ProgressTintColor { get; set; }\n\n        [Export(\"trackTintColor\", ArgumentSemantic.Strong)]\n        UIColor TrackTintColor { get; set; }\n\n        [Export(\"cornerRadius\")]\n        nfloat CornerRadius { get; set; }\n\n        [Export(\"progress\")]\n        float Progress { get; set; }\n\n        [Export(\"backwardProgressAnimationMode\", ArgumentSemantic.Assign)]\n        ProgressViewBackwardAnimationMode BackwardProgressAnimationMode { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<ProgressView, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"setProgress:animated:completion:\")]\n        void SetProgress(float progress, bool animated, [NullAllowed]  Action<bool> completion);\n\n        [Export(\"setHidden:animated:completion:\")]\n        void SetHidden(bool hidden, bool animated, [NullAllowed]  Action<bool> completion);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCProgressViewColorThemer\")]\n    interface ProgressViewColorThemer\n    {\n        [Obsolete(\"This method will soon be deprecated. There is no replacement yet.\")]\n        [Static]\n        [Export(\"applyColorScheme:toProgressView:\")]\n        void ApplyColorScheme(IColorScheme colorScheme, ProgressView progressView);\n    }\n\n    [Category]\n    [BaseType(typeof(ProgressView),\n        Name = \"MDCProgressView_MaterialTheming\")]\n    interface ProgressView_MaterialTheming\n    {\n        [Export(\"applyThemeWithScheme:\")]\n        void ApplyTheme(IContainerScheming scheme);\n    }\n\n    [BaseType(typeof(UIControl),\n        Name = \"MDCSlider\")]\n    interface Slider : IElevatable, IElevationOverriding\n\n    {\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        ISliderDelegate Delegate { get; set; }\n\n        [Export(\"enableRippleBehavior\")]\n        bool EnableRippleBehavior { get; set; }\n\n        [NullAllowed]\n        [Export(\"rippleColor\", ArgumentSemantic.Strong)]\n        UIColor RippleColor { get; set; }\n\n        [Export(\"thumbRadius\")]\n        nfloat ThumbRadius { get; set; }\n\n        [Export(\"thumbElevation\")]\n        nfloat ThumbElevation { get; set; }\n\n        [Export(\"thumbShadowColor\", ArgumentSemantic.Strong)]\n        UIColor ThumbShadowColor { get; set; }\n\n        [Export(\"numberOfDiscreteValues\")]\n        nuint NumberOfDiscreteValues { get; set; }\n\n        [Export(\"value\")]\n        nfloat Value { get; set; }\n\n        [Export(\"minimumValue\")]\n        nfloat MinimumValue { get; set; }\n\n        [Export(\"maximumValue\")]\n        nfloat MaximumValue { get; set; }\n\n        [Export(\"continuous\")]\n        bool Continuous { [Bind(\"isContinuous\")] get; set; }\n\n        [Export(\"filledTrackAnchorValue\")]\n        nfloat FilledTrackAnchorValue { get; set; }\n\n        [Export(\"shouldDisplayDiscreteValueLabel\")]\n        bool ShouldDisplayDiscreteValueLabel { get; set; }\n\n        [Export(\"valueLabelTextColor\", ArgumentSemantic.Strong)]\n        UIColor ValueLabelTextColor { get; set; }\n\n        [Export(\"valueLabelBackgroundColor\", ArgumentSemantic.Strong)]\n        UIColor ValueLabelBackgroundColor { get; set; }\n\n        [Export(\"thumbHollowAtStart\")]\n        bool ThumbHollowAtStart { [Bind(\"isThumbHollowAtStart\")] get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<Slider, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Obsolete(\"This API is planned for deprecation. Use SetThumbColor and SetTrackBackgroundColor methods instead.\")]\n        [Export(\"disabledColor\", ArgumentSemantic.Strong)]\n        UIColor DisabledColor { get; set; }\n\n        [Obsolete(\"This API is planned for deprecation. Use InkColor property, SetThumbColor and SetTrackFillColor methods instead.\")]\n        [Export(\"color\", ArgumentSemantic.Strong)]\n        UIColor Color { get; set; }\n\n        [Obsolete(\"This API is planned for deprecation. Use SetTrackBackgroundColor method instead.\")]\n        [Export(\"trackBackgroundColor\", ArgumentSemantic.Strong)]\n        UIColor TrackBackgroundColor { get; set; }\n\n        [Export(\"hapticsEnabled\")]\n        bool HapticsEnabled { get; set; }\n\n        [Export(\"shouldEnableHapticsForAllDiscreteValues\")]\n        bool ShouldEnableHapticsForAllDiscreteValues { get; set; }\n\n        [Export(\"statefulAPIEnabled\")]\n        bool StatefulApiEnabled { [Bind(\"isStatefulAPIEnabled\")] get; set; }\n\n        [Export(\"setThumbColor:forState:\")]\n        void SetThumbColor([NullAllowed] UIColor thumbColor, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"thumbColorForState:\")]\n        UIColor GetThumbColor(UIControlState state);\n\n        [Export(\"setTrackFillColor:forState:\")]\n        void SetTrackFillColor([NullAllowed] UIColor fillColor, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"trackFillColorForState:\")]\n        UIColor GetTrackFillColor(UIControlState state);\n\n        [Export(\"setTrackBackgroundColor:forState:\")]\n        void SetTrackBackgroundColor([NullAllowed] UIColor backgroundColor, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"trackBackgroundColorForState:\")]\n        UIColor GetTrackBackgroundColor(UIControlState state);\n\n        [Export(\"setFilledTrackTickColor:forState:\")]\n        void SetFilledTrackTickColor([NullAllowed] UIColor tickColor, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"filledTrackTickColorForState:\")]\n        UIColor GetFilledTrackTickColor(UIControlState state);\n\n        [Export(\"setBackgroundTrackTickColor:forState:\")]\n        void SetBackgroundTrackTickColor([NullAllowed] UIColor tickColor, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"backgroundTrackTickColorForState:\")]\n        UIColor GetBackgroundTrackTickColor(UIControlState state);\n\n        [Export(\"setValue:animated:\")]\n        void SetValue(nfloat value, bool animated);\n\n        [Obsolete(\"This property will be deprecated soon.\")]\n        [NullAllowed]\n        [Export(\"inkColor\", ArgumentSemantic.Strong)]\n        UIColor InkColor { get; set; }\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCSliderDelegate\")]\n    interface SliderDelegate\n    {\n        [Export(\"slider:shouldJumpToValue:\")]\n        bool ShouldJumpToValue(Slider slider, nfloat value);\n\n        [Export(\"slider:displayedStringForValue:\")]\n        string DisplayedStringForValue(Slider slider, nfloat value);\n\n        [Export(\"slider:accessibilityLabelForValue:\")]\n        string AccessibilityLabelForValue(Slider slider, nfloat value);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCSliderColorThemer\")]\n    interface SliderColorThemer\n    {\n        [Obsolete(\"This property will soon be deprecated. Consider using SemanticColorScheme class instead.\")]\n        [Static]\n        [Export(\"defaultSliderLightColorScheme\")]\n        BasicColorScheme DefaultSliderLightColorScheme { get; }\n\n        [Obsolete(\"This property will soon be deprecated. Consider using SemanticColorScheme class instead.\")]\n        [Static]\n        [Export(\"defaultSliderDarkColorScheme\")]\n        BasicColorScheme DefaultSliderDarkColorScheme { get; }\n\n        [Obsolete(\"This property will soon be deprecated. Consider using ApplySemanticColorScheme method instead.\")]\n        [Static]\n        [Export(\"applyColorScheme:toSlider:\")]\n        void ApplyColorScheme(IColorScheme colorScheme, Slider slider);\n\n        [Obsolete(\"This property will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toSlider:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, Slider slider);\n\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCSnackbarManagerDelegate\")]\n    interface SnackbarManagerDelegate\n    {\n        [Abstract]\n        [Export(\"willPresentSnackbarWithMessageView:\")]\n        void WillPresentSnackbar([NullAllowed] SnackbarMessageView messageView);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCSnackbarManager\")]\n    interface SnackbarManager : IElevationOverriding\n\n    {\n        [Static]\n        [Export(\"defaultManager\", ArgumentSemantic.Strong)]\n        SnackbarManager DefaultManager { get; }\n\n        [Export(\"alignment\", ArgumentSemantic.Assign)]\n        SnackbarAlignment Alignment { get; set; }\n\n\n        [Export(\"hasMessagesShowingOrQueued\")]\n        bool HasMessagesShowingOrQueued { get; }\n\n        [NullAllowed]\n        [Export(\"snackbarMessageViewBackgroundColor\", ArgumentSemantic.Strong)]\n        UIColor SnackbarMessageViewBackgroundColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"snackbarMessageViewShadowColor\", ArgumentSemantic.Strong)]\n        UIColor SnackbarMessageViewShadowColor { get; set; }\n\n        [Export(\"messageElevation\")]\n        double MessageElevation { get; set; }\n\n        [NullAllowed]\n        [Export(\"messageTextColor\", ArgumentSemantic.Strong)]\n        UIColor MessageTextColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"messageFont\", ArgumentSemantic.Strong)]\n        UIFont MessageFont { get; set; }\n\n        [NullAllowed]\n        [Export(\"buttonFont\", ArgumentSemantic.Strong)]\n        UIFont ButtonFont { get; set; }\n\n        [Export(\"uppercaseButtonTitle\")]\n        bool UppercaseButtonTitle { get; set; }\n\n        [Export(\"disabledButtonAlpha\")]\n        nfloat DisabledButtonAlpha { get; set; }\n\n        [NullAllowed]\n        [Export(\"buttonInkColor\", ArgumentSemantic.Strong)]\n        UIColor ButtonInkColor { get; set; }\n\n        [Export(\"shouldApplyStyleChangesToVisibleSnackbars\")]\n        bool ShouldApplyStyleChangesToVisibleSnackbars { get; set; }\n\n        [Export(\"adjustsFontForContentSizeCategoryWhenScaledFontIsUnavailable\")]\n        bool AdjustsFontForContentSizeCategoryWhenScaledFontIsUnavailable { get; set; }\n\n        [Export(\"shouldEnableAccessibilityViewIsModal\")]\n        bool ShouldEnableAccessibilityViewIsModal { get; set; }\n\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        ISnackbarManagerDelegate Delegate { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlockForMessageView\", ArgumentSemantic.Copy)]\n        Action<SnackbarMessageView, UITraitCollection> TraitCollectionDidChangeBlockForMessageView { get; set; }\n\n        [NullAllowed]\n        [Export(\"mdc_elevationDidChangeBlockForMessageView\", ArgumentSemantic.Copy)]\n        Action<IElevatable, nfloat> ElevationDidChangeBlockForMessageView { get; set; }\n\n        [Export(\"mdc_adjustsFontForContentSizeCategory\")]\n        bool AdjustsFontForContentSizeCategory { get; [Bind(\"mdc_setAdjustsFontForContentSizeCategory:\")]set; }\n\n        [Obsolete(\"Use AdjustsFontForContentSizeCategory instead\")]\n        [Wrap(\"AdjustsFontForContentSizeCategory\")]\n        bool MdcAdjustsFontForContentSizeCategory { get; set; }\n\n        [Export(\"showMessage:\")]\n        void ShowMessage([NullAllowed] SnackbarMessage message);\n\n        [Export(\"setPresentationHostView:\")]\n        void SetPresentationHostView([NullAllowed] UIView hostView);\n\n        [Export(\"dismissAndCallCompletionBlocksWithCategory:\")]\n        void DismissAndCallCompletionBlocks([NullAllowed] string category);\n\n        [Export(\"setBottomOffset:\")]\n        void SetBottomOffset(nfloat offset);\n\n        [return: NullAllowed]\n        [Export(\"suspendMessagesWithCategory:\")]\n        ISnackbarSuspensionToken SuspendMessages([NullAllowed] string category);\n\n        [Export(\"resumeMessagesWithToken:\")]\n        void ResumeMessages([NullAllowed] ISnackbarSuspensionToken token);\n\n        [return: NullAllowed]\n        [Export(\"buttonTitleColorForState:\")]\n        UIColor GetButtonTitleColor(UIControlState state);\n\n        [Export(\"setButtonTitleColor:forState:\")]\n        void SetButtonTitleColor([NullAllowed] UIColor titleColor, UIControlState state);\n\n        [return: NullAllowed]\n        [Export(\"suspendAllMessages\")]\n        ISnackbarSuspensionToken SuspendAllMessages();\n    }\n\n    [Protocol(Name = \"MDCSnackbarSuspensionToken\")]\n    [BaseType(typeof(NSObject))]\n    interface SnackbarSuspensionToken\n    { }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCSnackbarMessage\")]\n    interface SnackbarMessage : INSCopying, IUIAccessibilityIdentification\n\n    {\n        [Static]\n        [Export(\"usesLegacySnackbar\")]\n        bool UsesLegacySnackbar { get; set; }\n\n        [NullAllowed]\n        [Export(\"text\")]\n        string Text { get; set; }\n\n        [NullAllowed]\n        [Export(\"attributedText\", ArgumentSemantic.Copy)]\n        NSAttributedString AttributedText { get; set; }\n\n        [NullAllowed]\n        [Export(\"action\", ArgumentSemantic.Strong)]\n        SnackbarMessageAction Action { get; set; }\n\n        [NullAllowed]\n        [Export(\"buttonTextColor\", ArgumentSemantic.Strong)]\n        UIColor ButtonTextColor { get; set; }\n\n        [Export(\"duration\")]\n        double Duration { get; set; }\n\n        [NullAllowed]\n        [Export(\"completionHandler\", ArgumentSemantic.Copy)]\n        SnackbarMessageCompletionHandler CompletionHandler { get; set; }\n\n        [NullAllowed]\n        [Export(\"category\")]\n        string Category { get; set; }\n\n        [NullAllowed]\n        [Export(\"accessibilityLabel\")]\n        string AccessibilityLabel { get; set; }\n\n        [NullAllowed]\n        [Export(\"accessibilityHint\")]\n        string AccessibilityHint { get; set; }\n\n        [NullAllowed]\n        [Export(\"voiceNotificationText\")]\n        string VoiceNotificationText { get; }\n\n        [Export(\"enableRippleBehavior\")]\n        bool EnableRippleBehavior { get; set; }\n\n        [Field(\"MDCSnackbarMessageDurationMax\", \"__Internal\")]\n        double DurationMax { get; }\n\n        [Field(\"MDCSnackbarMessageBoldAttributeName\", \"__Internal\")]\n        NSString BoldAttributeName { get; }\n\n        [Static]\n        [Export(\"messageWithText:\")]\n        SnackbarMessage Create(string text);\n\n        [Static]\n        [Export(\"messageWithAttributedText:\")]\n        SnackbarMessage Create(NSAttributedString attributedText);\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCSnackbarMessageAction\")]\n    interface SnackbarMessageAction : IUIAccessibilityIdentification, INSCopying\n\n    {\n        [NullAllowed]\n        [Export(\"title\")]\n        string Title { get; set; }\n\n        [NullAllowed]\n        [Export(\"handler\", ArgumentSemantic.Copy)]\n        SnackbarMessageActionHandler Handler { get; set; }\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCSnackbarMessageView\")]\n    interface SnackbarMessageView : IElevatable, IElevationOverriding\n\n    {\n        [NullAllowed]\n        [Export(\"snackbarMessageViewBackgroundColor\", ArgumentSemantic.Strong)]\n        UIColor SnackbarMessageViewBackgroundColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"snackbarMessageViewShadowColor\", ArgumentSemantic.Strong)]\n        UIColor SnackbarMessageViewShadowColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"messageTextColor\", ArgumentSemantic.Strong)]\n        UIColor MessageTextColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"messageFont\", ArgumentSemantic.Strong)]\n        UIFont MessageFont { get; set; }\n\n        [NullAllowed]\n        [Export(\"buttonFont\", ArgumentSemantic.Strong)]\n        UIFont ButtonFont { get; set; }\n\n        [NullAllowed]\n        [Export(\"actionButtons\", ArgumentSemantic.Strong)]\n        NSMutableArray<Button> ActionButtons { get; set; }\n\n        [Export(\"elevation\")]\n        double Elevation { get; set; }\n\n        [NullAllowed]\n        [Export(\"accessibilityLabel\")]\n        string AccessibilityLabel { get; set; }\n\n        [NullAllowed]\n        [Export(\"accessibilityHint\")]\n        string AccessibilityHint { get; set; }\n\n        [Export(\"adjustsFontForContentSizeCategoryWhenScaledFontIsUnavailable\")]\n        bool AdjustsFontForContentSizeCategoryWhenScaledFontIsUnavailable { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<SnackbarMessageView, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Export(\"mdc_adjustsFontForContentSizeCategory\")]\n        bool AdjustsFontForContentSizeCategory { get; [Bind(\"mdc_setAdjustsFontForContentSizeCategory:\")]set; }\n\n        [Obsolete(\"Use AdjustsFontForContentSizeCategory instead\")]\n        [Wrap(\"AdjustsFontForContentSizeCategory\")]\n        bool MdcAdjustsFontForContentSizeCategory { get; set; }\n\n        [return: NullAllowed]\n        [Export(\"buttonTitleColorForState:\")]\n        UIColor GetButtonTitleColor(UIControlState state);\n\n        [Export(\"setButtonTitleColor:forState:\")]\n        void SetButtonTitleColor([NullAllowed] UIColor titleColor, UIControlState state);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCSnackbarColorThemer\")]\n    interface SnackbarColorThemer\n    {\n        [Obsolete(\"This method will be deprecated soon.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme);\n\n        [Obsolete(\"This method will be deprecated soon.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toSnackbarManager:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, SnackbarManager snackbarManager);\n\n        [Obsolete(\"This method will be deprecated soon.\")]\n        [Static]\n        [Export(\"applyColorScheme:toSnackbarMessageView:\")]\n        void ApplyColorScheme(IColorScheme colorScheme, SnackbarMessageView snackbarMessageView);\n    }\n\n    [Obsolete(\"This class will soon be deprecated. Please consider using SnackbarTypographyThemer class instead.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCSnackbarFontThemer\")]\n    interface SnackbarFontThemer\n    {\n        [Obsolete(\"This method will be deprecated soon.\")]\n        [Static]\n        [Export(\"applyFontScheme:toSnackbarMessageView:\")]\n        void ApplyFontScheme (IFontScheme fontScheme, SnackbarMessageView snackbarMessageView);\n\n        [Obsolete(\"This method will be deprecated soon.\")]\n        [Static]\n        [Export(\"applyFontScheme:\")]\n        void ApplyFontScheme (IFontScheme fontScheme);\n\n    }\n\n    [Obsolete(\"This class will be deprecated soon.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCSnackbarTypographyThemer\")]\n    interface SnackbarTypographyThemer\n    {\n        [Obsolete(\"This method will be deprecated soon.\")]\n        [Static]\n        [Export(\"applyTypographyScheme:\")]\n        void ApplyTypographyScheme (ITypographyScheming typographyScheme);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCTabBar\",\n        Delegates = new[] { \"Delegate\" },\n        Events = new[] { typeof(TabBarDelegate) })]\n    interface TabBar : IUIBarPositioning, IElevatable, IElevationOverriding\n\n    {\n        [Export(\"items\", ArgumentSemantic.Copy)]\n        UITabBarItem[] Items { get; set; }\n\n        [NullAllowed]\n        [Export(\"selectedItem\", ArgumentSemantic.Strong)]\n        UITabBarItem SelectedItem { get; set; }\n\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        ITabBarDelegate Delegate { get; set; }\n\n        [New]\n        [Export(\"tintColor\", ArgumentSemantic.Strong)]\n        UIColor TintColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"selectedItemTintColor\", ArgumentSemantic.Assign)]\n        UIColor SelectedItemTintColor { get; set; }\n\n        [Export(\"unselectedItemTintColor\", ArgumentSemantic.Assign)]\n        UIColor UnselectedItemTintColor { get; set; }\n\n        [Export(\"enableRippleBehavior\")]\n        bool EnableRippleBehavior { get; set; }\n\n        [Export(\"rippleColor\", ArgumentSemantic.Assign)]\n        UIColor RippleColor { get; set; }\n\n        [Export(\"bottomDividerColor\", ArgumentSemantic.Assign)]\n        UIColor BottomDividerColor { get; set; }\n\n        [Export(\"selectedItemTitleFont\", ArgumentSemantic.Strong)]\n        UIFont SelectedItemTitleFont { get; set; }\n\n        [Export(\"unselectedItemTitleFont\", ArgumentSemantic.Strong)]\n        UIFont UnselectedItemTitleFont { get; set; }\n\n        [NullAllowed]\n        [Export(\"barTintColor\", ArgumentSemantic.Assign)]\n        UIColor BarTintColor { get; set; }\n\n        [Export(\"alignment\", ArgumentSemantic.Assign)]\n        TabBarAlignment Alignment { get; set; }\n\n        [Export(\"itemAppearance\", ArgumentSemantic.Assign)]\n        TabBarItemAppearance ItemAppearance { get; set; }\n\n        [Obsolete(\"This property will be deprecated in a future release. Use TitleTextTransform property instead.\")]\n        [Export(\"displaysUppercaseTitles\")]\n        bool DisplaysUppercaseTitles { get; set; }\n\n        [Export(\"titleTextTransform\", ArgumentSemantic.Assign)]\n        TabBarTextTransform TitleTextTransform { get; set; }\n\n        [Export(\"selectionIndicatorTemplate\", ArgumentSemantic.Assign)]\n        TabBarIndicatorTemplate SelectionIndicatorTemplate { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<TabBar, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Static]\n        [Export(\"defaultHeightForBarPosition:itemAppearance:\")]\n        nfloat GetDefaultHeight(UIBarPosition position, TabBarItemAppearance appearance);\n\n        [Static]\n        [Export(\"defaultHeightForItemAppearance:\")]\n        nfloat GetDefaultHeight(TabBarItemAppearance appearance);\n\n        [Export(\"setSelectedItem:animated:\")]\n        void SetSelectedItem([NullAllowed] UITabBarItem selectedItem, bool animated);\n\n        [Export(\"setAlignment:animated:\")]\n        void SetAlignment(TabBarAlignment alignment, bool animated);\n\n        [Export(\"setTitleColor:forState:\")]\n        void SetTitleColor([NullAllowed] UIColor color, TabBarItemState state);\n\n        [return: NullAllowed]\n        [Export(\"titleColorForState:\")]\n        UIColor GetTitleColor(TabBarItemState state);\n\n        [Export(\"setImageTintColor:forState:\")]\n        void SetImageTintColor([NullAllowed] UIColor color, TabBarItemState state);\n\n        [return: NullAllowed]\n        [Export(\"imageTintColorForState:\")]\n        UIColor GetImageTintColor(TabBarItemState state);\n\n        [return: NullAllowed]\n        [Export(\"accessibilityElementForItem:\")]\n        NSObject GetAccessibilityElement(UITabBarItem item);\n\n        [Wrap(\"WeakSizeClassDelegate\")]\n        [NullAllowed]\n        [Static]\n        ITabBarSizeClassDelegate SizeClassDelegate { get; set; }\n\n        [NullAllowed]\n        [Export(\"sizeClassDelegate\", ArgumentSemantic.Weak)]\n        [Static]\n        NSObject WeakSizeClassDelegate { get; set; }\n\n        [Wrap(\"WeakDisplayDelegate\")]\n        [NullAllowed]\n        [Static]\n        ITabBarDisplayDelegate DisplayDelegate { get; set; }\n\n        [NullAllowed]\n        [Export(\"displayDelegate\", ArgumentSemantic.Weak)]\n        [Static]\n        NSObject WeakDisplayDelegate { get; set; }\n\n        [Obsolete(\"This property will be deprecated soon.\")]\n        [Export(\"inkColor\", ArgumentSemantic.Assign)]\n        UIColor InkColor { get; set; }\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTabBarDelegate\")]\n    interface TabBarDelegate : IUIBarPositioningDelegate\n\n    {\n        [DefaultValue(true)]\n        [DelegateName(\"TabBarShouldSelectItem\")]\n        [Export(\"tabBar:shouldSelectItem:\")]\n        bool ShouldSelectItem(TabBar tabBar, UITabBarItem item);\n\n        [EventArgs(\"TabBarWillSelectItem\")]\n        [Obsolete(\"Will be deprecated. Use ShouldSelectItem method instead.\")]\n        [Export(\"tabBar:willSelectItem:\")]\n        void WillSelectItem(TabBar tabBar, UITabBarItem item);\n\n        [EventArgs(\"TabBarItemSelected\")]\n        [EventName(\"ItemSelected\")]\n        [Export(\"tabBar:didSelectItem:\")]\n        void DidSelectItem(TabBar tabBar, UITabBarItem item);\n\n        [Export(\"inkColor\", ArgumentSemantic.Assign)]\n        [Static]\n        UIColor InkColor { get; set; }\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTabBarIndicatorAttributes\")]\n    interface TabBarIndicatorAttributes : INSCopying\n\n    {\n        [NullAllowed]\n        [Export(\"path\", ArgumentSemantic.Assign)]\n        UIBezierPath Path { get; set; }\n    }\n\n    [Protocol(Name = \"MDCTabBarIndicatorContext\")]\n    [BaseType(typeof(NSObject))]\n    interface TabBarIndicatorContext\n    {\n        [Abstract]\n        [Export(\"item\")]\n        UITabBarItem Item { get; }\n\n        [Abstract]\n        [Export(\"bounds\")]\n        CGRect Bounds { get; }\n\n        [Abstract]\n        [Export(\"contentFrame\")]\n        CGRect ContentFrame { get; }\n    }\n\n    [Protocol(Name = \"MDCTabBarIndicatorTemplate\")]\n    [BaseType(typeof(NSObject))]\n    interface TabBarIndicatorTemplate\n    {\n        [Abstract]\n        [Export(\"indicatorAttributesForContext:\")]\n        TabBarIndicatorAttributes IndicatorAttributesForContext(ITabBarIndicatorContext context);\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTabBarUnderlineIndicatorTemplate\")]\n    interface TabBarUnderlineIndicatorTemplate : TabBarIndicatorTemplate\n\n    { }\n\n    [BaseType(typeof(UIViewController),\n        Name = \"MDCTabBarViewController\",\n        Delegates = new[] { \"Delegate\" },\n        Events = new[] { typeof(TabBarControllerDelegate) })]\n    interface TabBarViewController : TabBarDelegate, IUIBarPositioningDelegate\n\n    {\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        ITabBarControllerDelegate Delegate { get; set; }\n\n        [Export(\"viewControllers\", ArgumentSemantic.Copy)]\n        UIViewController[] ViewControllers { get; set; }\n\n        [NullAllowed]\n        [Export(\"selectedViewController\", ArgumentSemantic.Weak)]\n        UIViewController SelectedViewController { get; set; }\n\n        [NullAllowed]\n        [Export(\"tabBar\")]\n        TabBar TabBar { get; }\n\n        [Export(\"tabBarHidden\")]\n        bool TabBarHidden { get; set; }\n\n        [NullAllowed]\n        [Export(\"traitCollectionDidChangeBlock\", ArgumentSemantic.Copy)]\n        Action<TabBarViewController, UITraitCollection> TraitCollectionDidChangeBlock { get; set; }\n\n        [Field(\"MDCTabBarViewControllerAnimationDuration\", \"__Internal\")]\n        nfloat AnimationDuration { get; }\n\n        [Export(\"setTabBarHidden:animated:\")]\n        void SetTabBarHidden(bool hidden, bool animated);\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTabBarControllerDelegate\")]\n    interface TabBarControllerDelegate\n    {\n        [DefaultValue(true)]\n        [DelegateName(\"TabBarControllerShouldSelectViewController\")]\n        [Export(\"tabBarController:shouldSelectViewController:\")]\n        bool ShouldSelectViewController(TabBarViewController tabBarController, UIViewController viewController);\n\n        [EventArgs(\"TabBarControllerViewControllerSelected\")]\n        [EventName(\"ViewControllerSelected\")]\n        [Export(\"tabBarController:didSelectViewController:\")]\n        void DidSelectViewController(TabBarViewController tabBarController, UIViewController viewController);\n    }\n\n    [Protocol(Name = \"MDCTabBarDisplayDelegate\")]\n    interface TabBarDisplayDelegate\n    {\n        [Abstract]\n        [Export(\"tabBar:willDisplayItem:\")]\n        void WillDisplayItem(TabBar tabBar, UITabBarItem item);\n\n        [Abstract]\n        [Export(\"tabBar:didEndDisplayingItem:\")]\n        void DidEndDisplayingItem(TabBar tabBar, UITabBarItem item);\n    }\n\n\n    [Protocol(Name = \"MDCTabBarSizeClassDelegate\")]\n    interface TabBarSizeClassDelegate\n    {\n        [Export(\"horizontalSizeClassForObject:\")]\n        long HorizontalSizeClassForObject(IUITraitEnvironment @object);\n    }\n\n    [Obsolete(\"This class will soon be deprecated.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTabBarColorThemer\")]\n    interface TabBarColorThemer\n    {\n        [Obsolete(\"This method will soon be deprecated. Consider using ApplySemanticColorScheme method instead.\")]\n        [Static]\n        [Export(\"applyColorScheme:toTabBar:\")]\n        void ApplyColorScheme (IColorScheme colorScheme, TabBar tabBar);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toTabs:\")]\n        void ApplySemanticColorScheme (IColorScheming colorScheme, TabBar tabBar);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySurfaceVariantWithColorScheme:toTabs:\")]\n        void ApplySurfaceVariant (IColorScheming colorScheme, TabBar tabBar);\n    }\n\n    [Obsolete(\"This class will soon be deprecated. Please consider using TabBarTypographyThemer class instead.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTabBarFontThemer\")]\n    interface TabBarFontThemer\n    {\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyFontScheme:toTabBar:\")]\n        void ApplyFontScheme (IFontScheme fontScheme, TabBar tabBar);\n    }\n\n    [Category]\n    [BaseType(typeof(TabBar),\n        Name = \"MDCTabBar_MaterialTheming\")]\n    interface TabBar_MaterialTheming\n    {\n        [Export(\"applyPrimaryThemeWithScheme:\")]\n        void ApplyPrimaryThemeWithScheme(IContainerScheming scheme);\n\n        [Export(\"applySurfaceThemeWithScheme:\")]\n        void ApplySurfaceThemeWithScheme(IContainerScheming scheme);\n    }\n\n    [Obsolete(\"This class will soon be deprecated.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTabBarTypographyThemer\")]\n    interface TabBarTypographyThemer\n    {\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyTypographyScheme:toTabBar:\")]\n        void ApplyTypographyScheme (ITypographyScheming typographyScheme, TabBar tabBar);\n    }\n\n    [Obsolete(\"This class will soon be deprecated.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCFilledTextFieldColorThemer\")]\n    interface FilledTextFieldColorThemer\n    {\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toTextInputControllerFilled:\")]\n        void ApplySemanticColorScheme (IColorScheming colorScheme, TextInputControllerFilled textInputControllerFilled);\n    }\n\n    [Obsolete(\"This class will soon be deprecated.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCOutlinedTextFieldColorThemer\")]\n    interface OutlinedTextFieldColorThemer\n    {\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toTextInputController:\")]\n        void ApplySemanticColorScheme(IColorScheming colorScheme, ITextInputController textInputController);\n    }\n\n    [Obsolete(\"This class will soon be deprecated.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTextFieldColorThemer\")]\n    interface TextFieldColorThemer\n    {\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toTextInputController:\")]\n        void ApplySemanticColorScheme (IColorScheming colorScheme, ITextInputController textInputController);\n\n        [Wrap(\"ApplySemanticColorScheme (colorScheme, textInputController)\")]\n        [Obsolete(\"Use ApplySemanticColorScheme instead.\")]\n        [Static]\n        void ApplySemanticColorSchemeToTextInput (IColorScheming colorScheme, ITextInputController textInputController);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toAllTextInputControllersOfClass:\")]\n        void ApplySemanticColorSchemeToAll (IColorScheming colorScheme, Class textInputControllerClass);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Wrap(\"ApplySemanticColorSchemeToAll (colorScheme, new Class (textInputControllerType))\")]\n        void ApplySemanticColorSchemeToAll (IColorScheming colorScheme, Type textInputControllerType);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applySemanticColorScheme:toTextInput:\")]\n        void ApplySemanticColorScheme (IColorScheming colorScheme, ITextInput textInput);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyColorScheme:toTextInputController:\")]\n        void ApplyColorScheme (IColorScheme colorScheme, ITextInputController textInputController);\n\n        [Obsolete(\"This method will soon be deprecated. Consider using ApplySemanticColorScheme method instead.\")]\n        [Static]\n        [Wrap(\"ApplyColorScheme (colorScheme, textInputController)\")]\n        void ApplyColorSchemeToTextInputController(IColorScheme colorScheme, ITextInputController textInputController);\n\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyColorScheme:toAllTextInputControllersOfClass:\")]\n        void ApplyColorScheme (IColorScheme colorScheme, Class textInputControllerClass);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Wrap(\"ApplyColorScheme (colorScheme, new Class (textInputControllerType))\")]\n        void ApplyColorScheme (IColorScheme colorScheme, Type textInputControllerType);\n\n        [Static]\n        [Wrap(\"ApplySemanticColorScheme (colorScheme, textInputController)\")]\n        [Obsolete(\"Use ApplySemanticColorScheme instead.\")]\n        void ApplySemanticColorSchemeToTextInputController(IColorScheming colorScheme, ITextInputController textInputController);\n\n        [Obsolete(\"This method will soon be deprecated. Consider using ApplySemanticColorSchemeToAll method instead.\")]\n        [Static]\n        [Wrap(\"ApplyColorScheme (colorScheme, textInputControllerClass)\")]\n        void ApplyColorSchemeoAllTextInputControllersOfClass(IColorScheme colorScheme, Class textInputControllerClass);\n\n        [Static]\n        [Wrap(\"ApplySemanticColorScheme (colorScheme, textInput)\")]\n        [Obsolete(\"Use ApplySemanticColorScheme instead.\")]\n        void ApplySemanticColorSchemeToTextInput(IColorScheming colorScheme, ITextInput textInput);\n\n    }\n\n    [BaseType(typeof(UITextField),\n    Name = \"MDCBaseTextField\")]\n    interface BaseTextField\n    {\n        [Export(\"label\", ArgumentSemantic.Strong)]\n        UILabel Label { get; }\n\n        [Export(\"labelBehavior\", ArgumentSemantic.Assign)]\n        TextControlLabelBehavior LabelBehavior { get; set; }\n\n        [NullAllowed]\n        [Export(\"leadingView\", ArgumentSemantic.Strong)]\n        UIView LeadingView { get; set; }\n\n        [NullAllowed]\n        [Export(\"trailingView\", ArgumentSemantic.Strong)]\n        UIView TrailingView { get; set; }\n\n        [Export(\"leadingViewMode\", ArgumentSemantic.Assign)]\n        UITextFieldViewMode LeadingViewMode { get; set; }\n\n        [Export(\"trailingViewMode\", ArgumentSemantic.Assign)]\n        UITextFieldViewMode TrailingViewMode { get; set; }\n    }\n\n    [Obsolete(\" This class will soon be deprecated. Please consider using TextFieldTypographyThemer class instead.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTextFieldFontThemer\")]\n    interface TextFieldFontThemer\n    {\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyFontScheme:toTextInputController:\")]\n        void ApplyFontScheme(IFontScheme fontScheme, ITextInputController textInputController);\n\n        [Wrap(\"ApplyFontScheme (fontScheme, textInputController)\")]\n        [Obsolete(\"Use ApplyFontScheme instead.\")]\n        [Static]\n        void ApplyFontSchemeToTextInputController(IFontScheme fontScheme, ITextInputController textInputController);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyFontScheme:toAllTextInputControllersOfClass:\")]\n        void ApplyFontSchemeToAll(IFontScheme fontScheme, Class textInputControllerClass);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Wrap(\"ApplyFontSchemeToAll (fontScheme, new Class (textInputControllerType))\")]\n        void ApplyFontSchemeToAll(IFontScheme fontScheme, Type textInputControllerType);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyFontScheme:toTextField:\")]\n        void ApplyFontScheme(IFontScheme fontScheme, [NullAllowed]  TextField textField);\n\n        [Wrap(\"ApplyFontScheme (fontScheme, textField)\")]\n        [Obsolete(\"Use ApplyFontScheme instead.\")]\n        [Static]\n        void ApplyFontSchemeToTextField(IFontScheme fontScheme, TextField textField);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyFontScheme:toTextInputController:\")]\n        void ApplyFontScheme(FontScheme fontScheme, ITextInputController textInputController);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyFontScheme:toAllTextInputControllersOfClass:\")]\n        void ApplyFontSchemeToAll(FontScheme fontScheme, ITextInputController textInputControllerClass);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyFontScheme:toTextField:\")]\n        void ApplyFontScheme(FontScheme fontScheme, [NullAllowed]  TextField textField);\n    }\n\n    [Category]\n    [BaseType(typeof(TextInputControllerFilled),\n        Name = \"MDCTextInputControllerFilled_MaterialTheming\")]\n    interface TextInputControllerFilled_MaterialTheming\n    {\n        [Export(\"applyThemeWithScheme:\")]\n        void ApplyTheme(IContainerScheming scheme);\n    }\n\n    [Category]\n    [BaseType(typeof(TextInputControllerOutlined),\n        Name = \"MDCTextInputControllerOutlined_MaterialTheming\")]\n    interface TextInputControllerOutlined_MaterialTheming\n    {\n        [Export(\"applyThemeWithScheme:\")]\n        void ApplyTheme(IContainerScheming scheme);\n    }\n\n    [Obsolete(\" This class will soon be deprecated.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTextFieldTypographyThemer\")]\n    interface TextFieldTypographyThemer\n    {\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyTypographyScheme:toTextInputController:\")]\n        void ApplyTypographyScheme(ITypographyScheming typographyScheme, ITextInputController textInputController);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyTypographyScheme:toAllTextInputControllersOfClass:\")]\n        void ApplyTypographySchemeToAll(ITypographyScheming typographyScheme, Class textInputControllerClass);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Wrap(\"ApplyTypographySchemeToAll (typographyScheme, new Class (textInputControllerType))\")]\n        [Static]\n        void ApplyTypographySchemeToAll(ITypographyScheming typographyScheme, Type textInputControllerType);\n\n        [Wrap(\"ApplyTypographyScheme (typographyScheme, textInputController)\")]\n        [Obsolete(\"Use ApplyTypographyScheme instead.\")]\n        [Static]\n        void ApplyTypographySchemeToTextInputController(ITypographyScheming typographyScheme, ITextInputController textInputController);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyTypographyScheme:toTextInput:\")]\n        void ApplyTypographyScheme(ITypographyScheming typographyScheme, ITextInput textInput);\n\n        [Wrap(\"ApplyTypographyScheme (typographyScheme, textInput)\")]\n        [Obsolete(\"Use ApplyTypographyScheme instead.\")]\n        [Static]\n        void ApplyTypographySchemeToTextInput(ITypographyScheming typographyScheme, ITextInput textInput);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyTypographyScheme:toTextInputController:\")]\n        void ApplyTypographyScheme(TypographyScheming typographyScheme, ITextInputController textInputController);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyTypographyScheme:toAllTextInputControllersOfClass:\")]\n        void ApplyTypographySchemeToAll(TypographyScheming typographyScheme, ITextInputController textInputControllerClass);\n\n        [Obsolete(\"This method will soon be deprecated.\")]\n        [Static]\n        [Export(\"applyTypographyScheme:toTextInput:\")]\n        void ApplyTypographyScheme(TypographyScheming typographyScheme, ITextInput textInput);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCFontScaler\")]\n    interface FontScaler\n    {\n        [DesignatedInitializer]\n        [Export(\"initForMaterialTextStyle:\")]\n        IntPtr Constructor(string textStyle);\n\n        [Static]\n        [Export(\"scalerForMaterialTextStyle:\")]\n        FontScaler ScalerForMaterialTextStyle(string textStyle);\n\n        [Export(\"scaledFontWithFont:\")]\n        UIFont ScaledFontWithFont(UIFont font);\n\n        [Export(\"scaledValueForValue:\")]\n        nfloat ScaledValueForValue(nfloat value);\n    }\n\n    [Obsolete(\"This interface will soon be deprecated. Consider using TypographyScheme from the schemes\/Typography component instead.\")]\n    [Protocol(Name = \"MDCTypographyFontLoading\")]\n    [BaseType(typeof(NSObject))]\n    interface TypographyFontLoading\n    {\n        [return: NullAllowed]\n        [Abstract]\n        [Export(\"lightFontOfSize:\")]\n        UIFont GetLightFont(nfloat fontSize);\n\n        [Abstract]\n        [Export(\"regularFontOfSize:\")]\n        UIFont GetRegularFont(nfloat fontSize);\n\n        [return: NullAllowed]\n        [Abstract]\n        [Export(\"mediumFontOfSize:\")]\n        UIFont GetMediumFont(nfloat fontSize);\n\n        [Export(\"boldFontOfSize:\")]\n        UIFont GetBoldFont(nfloat fontSize);\n\n        [Export(\"italicFontOfSize:\")]\n        UIFont GetItalicFont(nfloat fontSize);\n\n        [return: NullAllowed]\n        [Export(\"boldItalicFontOfSize:\")]\n        UIFont GetBoldItalicFont(nfloat fontSize);\n\n        [Export(\"boldFontFromFont:\")]\n        UIFont GetBoldFont(UIFont font);\n\n        [Export(\"italicFontFromFont:\")]\n        UIFont GetItalicFont(UIFont font);\n\n        [Export(\"isLargeForContrastRatios:\")]\n        bool IsLargeForContrastRatios(UIFont font);\n    }\n\n    [Obsolete(\"This class will soon be deprecated. Consider using TypographyScheme from the schemes\/Typography component instead.\")]\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCTypography\")]\n    interface Typography\n    {\n        [Static]\n\n        [Export(\"fontLoader\")]\n        ITypographyFontLoading FontLoader { get; set; }\n\n        [Static]\n\n        [Export(\"display4Font\")]\n        UIFont Display4Font { get; }\n\n        [Static]\n\n        [Export(\"display4FontOpacity\")]\n        nfloat Display4FontOpacity { get; }\n\n        [Static]\n\n        [Export(\"display3Font\")]\n        UIFont Display3Font { get; }\n\n        [Static]\n\n        [Export(\"display3FontOpacity\")]\n        nfloat Display3FontOpacity { get; }\n\n        [Static]\n\n        [Export(\"display2Font\")]\n        UIFont Display2Font { get; }\n\n        [Static]\n\n        [Export(\"display2FontOpacity\")]\n        nfloat Display2FontOpacity { get; }\n\n        [Static]\n\n        [Export(\"display1Font\")]\n        UIFont Display1Font { get; }\n\n        [Static]\n\n        [Export(\"display1FontOpacity\")]\n        nfloat Display1FontOpacity { get; }\n\n        [Static]\n\n        [Export(\"headlineFont\")]\n        UIFont HeadlineFont { get; }\n\n        [Static]\n\n        [Export(\"headlineFontOpacity\")]\n        nfloat HeadlineFontOpacity { get; }\n\n        [Static]\n\n        [Export(\"titleFont\")]\n        UIFont TitleFont { get; }\n\n        [Static]\n\n        [Export(\"titleFontOpacity\")]\n        nfloat TitleFontOpacity { get; }\n\n        [Static]\n\n        [Export(\"subheadFont\")]\n        UIFont SubheadFont { get; }\n\n        [Static]\n\n        [Export(\"subheadFontOpacity\")]\n        nfloat SubheadFontOpacity { get; }\n\n        [Static]\n\n        [Export(\"body2Font\")]\n        UIFont Body2Font { get; }\n\n        [Static]\n\n        [Export(\"body2FontOpacity\")]\n        nfloat Body2FontOpacity { get; }\n\n        [Static]\n\n        [Export(\"body1Font\")]\n        UIFont Body1Font { get; }\n\n        [Static]\n\n        [Export(\"body1FontOpacity\")]\n        nfloat Body1FontOpacity { get; }\n\n        [Static]\n\n        [Export(\"captionFont\")]\n        UIFont CaptionFont { get; }\n\n        [Static]\n\n        [Export(\"captionFontOpacity\")]\n        nfloat CaptionFontOpacity { get; }\n\n        [Static]\n\n        [Export(\"buttonFont\")]\n        UIFont ButtonFont { get; }\n\n        [Static]\n\n        [Export(\"buttonFontOpacity\")]\n        nfloat ButtonFontOpacity { get; }\n\n        [Static]\n        [Export(\"boldFontFromFont:\")]\n        UIFont GetBoldFont(UIFont font);\n\n        [Static]\n        [Export(\"italicFontFromFont:\")]\n        UIFont GetItalicFont(UIFont font);\n\n        [Static]\n        [Export(\"isLargeForContrastRatios:\")]\n        bool IsLargeForContrastRatios(UIFont font);\n    }\n\n    [Obsolete(\"This class will soon be deprecated. Consider using TypographyScheme from the schemes\/Typography component instead.\")]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCSystemFontLoader\")]\n    interface SystemFontLoader : TypographyFontLoading\n    { }\n\n    [Category]\n    [BaseType(typeof(UIFont))]\n    interface UIFont_MaterialScalable\n    {\n        [NullAllowed]\n        [Export(\"mdc_scalingCurve\", ArgumentSemantic.Copy)]\n        [Static]\n        NSDictionary<NSString, NSNumber> ScalingCurve { get; [Bind(\"mdc_setScalingCurve:\")]set; }\n\n        [Export(\"mdc_scaledFontAtDefaultSize\")]\n        [Static]\n        UIFont ScaledFontAtDefaultSize { get; }\n\n        [Export(\"mdc_scaledFontForCurrentSizeCategory\")]\n        [Static]\n        UIFont ScaledFontForCurrentSizeCategory { get; }\n\n        [Export(\"mdc_scaledFontForSizeCategory:\")]\n        UIFont ScaledFontForSizeCategory(string sizeCategory);\n\n        [Export(\"mdc_scaledFontForTraitEnvironment:\")]\n        UIFont ScaledFontForTraitEnvironment(IUITraitEnvironment traitEnvironment);\n    }\n\n    [Category]\n    [BaseType(typeof(UIFont))]\n    interface UIFont_MaterialSimpleEquality\n    {\n        [Export(\"mdc_isSimplyEqual:\")]\n        bool IsSimplyEqual(UIFont font);\n\n        [Wrap(\"IsSimplyEqual(This, font)\")]\n        bool MdcIsSimplyEqual(UIFont font);\n    }\n\n    [Category]\n    [BaseType(typeof(UIFont))]\n    interface UIFont_MaterialTypography\n    {\n        [Export(\"mdc_fontSizedForMaterialTextStyle:scaledForDynamicType:\")]\n        UIFont GetFontSized(FontTextStyle style, bool scaled);\n\n        [Wrap(\"GetFontSized(This, style,scaled)\")]\n        UIFont MdcGetFontSized(FontTextStyle style, bool scaled);\n    }\n\n    [Category]\n    [BaseType(typeof(UIColor))]\n    interface UIColor_MaterialBlending\n    {\n        [Static]\n        [Export(\"mdc_blendColor:withBackgroundColor:\")]\n        UIColor BlendColor(UIColor color, UIColor backgroundColor);\n    }\n\n    [Category]\n    [BaseType(typeof(UIColor))]\n    interface UIColor_MaterialDynamic\n    {\n        [Static]\n        [Export(\"colorWithUserInterfaceStyleDarkColor:defaultColor:\")]\n        UIColor ColorWithUserInterfaceStyleDarkColor(UIColor darkColor, UIColor defaultColor);\n\n        [Export(\"mdc_resolvedColorWithTraitCollection:\")]\n        UIColor ResolvedColorWithTraitCollection(UITraitCollection traitCollection);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCIcons\")]\n    interface Icons\n    {\n        [Static]\n        [Export(\"pathFor_ic_arrow_back\")]\n        string IcArrowBackPath { get; }\n\n        [NullAllowed]\n        [Static]\n        [Export(\"imageFor_ic_arrow_back\")]\n        UIImage IcArrowBackImage { get; }\n\n        [Static]\n        [Export(\"pathFor_ic_check_circle\")]\n        string IcCheckCirclePath { get; }\n\n        [NullAllowed]\n        [Static]\n        [Export(\"imageFor_ic_check_circle\")]\n        UIImage IcCheckCircleImage { get; }\n\n        [Static]\n        [Export(\"pathFor_ic_check\")]\n        string IcCheckPath { get; }\n\n        [NullAllowed]\n        [Static]\n        [Export(\"imageFor_ic_check\")]\n        UIImage IcCheckImage { get; }\n\n        [Static]\n        [Export(\"pathFor_ic_chevron_right\")]\n        string PathForIcChevronRight { get; }\n\n        [NullAllowed]\n        [Static]\n        [Export(\"imageFor_ic_chevron_right\")]\n        UIImage ImageForIcChevronRight { get; }\n\n        [Static]\n        [Export(\"pathFor_ic_color_lens\")]\n        string IcColorLensPath { get; }\n\n        [NullAllowed]\n        [Static]\n        [Export(\"imageFor_ic_color_lens\")]\n        UIImage IcColorLensImage { get; }\n\n        [Static]\n        [Export(\"pathFor_ic_help_outline\")]\n        string IcHelpOutlinePath { get; }\n\n        [NullAllowed]\n        [Static]\n        [Export(\"imageFor_ic_help_outline\")]\n        UIImage IcHelpOutlineImage { get; }\n\n        [Static]\n        [Export(\"pathFor_ic_info\")]\n        string IcInfoPath { get; }\n\n        [NullAllowed]\n        [Static]\n        [Export(\"imageFor_ic_info\")]\n        UIImage IcInfoImage { get; }\n\n        [Static]\n        [Export(\"pathFor_ic_more_horiz\")]\n        string IcMoreHorizPath { get; }\n\n        [NullAllowed]\n        [Static]\n        [Export(\"imageFor_ic_more_horiz\")]\n        UIImage IcMoreHorizImage { get; }\n\n        [Static]\n        [Export(\"pathFor_ic_radio_button_unchecked\")]\n        string IcRadioButtonUncheckedPath { get; }\n\n        [NullAllowed]\n        [Static]\n        [Export(\"imageFor_ic_radio_button_unchecked\")]\n        UIImage IcRadioButtonUncheckedImage { get; }\n\n        [Static]\n        [Export(\"pathFor_ic_reorder\")]\n        string IcReorderPath { get; }\n\n        [NullAllowed]\n        [Static]\n        [Export(\"imageFor_ic_reorder\")]\n        UIImage IcReorderImage { get; }\n\n        [Static]\n        [Export(\"pathFor_ic_settings\")]\n        string IcSettingsPath { get; }\n\n        [NullAllowed]\n        [Static]\n        [Export(\"imageFor_ic_settings\")]\n        UIImage IcSettingsImage { get; }\n\n        [Static]\n        [Export(\"ic_arrow_backUseNewStyle:\")]\n        void IcArrowBackUseNewStyle(bool useNewStyle);\n\n        [Static]\n        [Export(\"pathForIconName:withBundleName:\")]\n        string GetPath(string iconName, string bundleName);\n\n        [Static]\n        [return: NullAllowed]\n        [Export(\"bundleNamed:\")]\n        NSBundle GetBundleNamed(string bundleName);\n    }\n\n    [DisableDefaultCtor]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCKeyboardWatcher\")]\n    interface KeyboardWatcher\n    {\n        [Export(\"visibleKeyboardHeight\")]\n        nfloat VisibleKeyboardHeight { get; }\n\n        [Notification]\n        [Field(\"MDCKeyboardWatcherKeyboardWillShowNotification\", \"__Internal\")]\n        NSString KeyboardWillShowNotification { get; }\n\n        [Notification]\n        [Field(\"MDCKeyboardWatcherKeyboardWillHideNotification\", \"__Internal\")]\n        NSString KeyboardWillHideNotification { get; }\n\n        [Notification]\n        [Field(\"MDCKeyboardWatcherKeyboardWillChangeFrameNotification\", \"__Internal\")]\n        NSString KeyboardWillChangeFrameNotification { get; }\n\n        [Static]\n        [Export(\"sharedKeyboardWatcher\")]\n        KeyboardWatcher SharedInstance { get; }\n\n        [Static]\n        [Export(\"animationDurationFromKeyboardNotification:\")]\n        double AnimationDurationFromNotification(NSNotification notification);\n\n        [Static]\n        [Export(\"animationCurveOptionFromKeyboardNotification:\")]\n        UIViewAnimationOptions AnimationCurveOptionFromNotification(NSNotification notification);\n    }\n\n    [BaseType(typeof(NSObject),\n        Name = \"MDCOverlayObserver\")]\n    interface OverlayObserver\n    {\n        [Static]\n        [Export(\"observerForScreen:\")]\n        OverlayObserver FromScreen(UIScreen screen);\n\n        [Export(\"addTarget:action:\")]\n        void AddTarget(NSObject target, Selector action);\n\n        [Export(\"removeTarget:action:\")]\n        void RemoveTarget(NSObject target, Selector action);\n\n        [Export(\"removeTarget:\")]\n        void RemoveTarget(NSObject target);\n    }\n\n    [Protocol(Name = \"MDCOverlay\")]\n    [BaseType(typeof(NSObject))]\n    interface Overlay\n    {\n        [Abstract]\n        [Export(\"identifier\")]\n        string Identifier { get; }\n\n        [Abstract]\n        [Export(\"frame\")]\n        CGRect Frame { get; }\n    }\n\n    [Protocol(Name = \"MDCOverlayTransitioning\")]\n    [BaseType(typeof(NSObject))]\n    interface OverlayTransitioning\n    {\n        [Abstract]\n        [Export(\"duration\")]\n        double Duration { get; }\n\n        [Abstract]\n        [Export(\"customTimingFunction\")]\n        CAMediaTimingFunction CustomTimingFunction { get; }\n\n        [Abstract]\n        [Export(\"animationCurve\")]\n        UIViewAnimationCurve AnimationCurve { get; }\n\n        [Abstract]\n        [Export(\"compositeFrame\")]\n        CGRect CompositeFrame { get; }\n\n        [Abstract]\n        [Export(\"compositeFrameInView:\")]\n        CGRect GetCompositeFrame(UIView targetView);\n\n        [Abstract]\n        [Export(\"enumerateOverlays:\")]\n        void EnumerateOverlays(EnumerateOverlaysHandler handler);\n\n        [Abstract]\n        [Export(\"animateAlongsideTransition:\")]\n        void AnimateAlongsideTransition(Action animations);\n\n        [Abstract]\n        [Export(\"animateAlongsideTransitionWithOptions:animations:completion:\")]\n        void AnimateAlongsideTransition(UIViewAnimationOptions options, Action animations, Action<bool> completion);\n    }\n\n    [BaseType(typeof(UIControl),\n        Name = \"MDCThumbTrack\")]\n    interface ThumbTrack\n    {\n        [NullAllowed]\n        [Export(\"delegate\", ArgumentSemantic.Weak)]\n        IThumbTrackDelegate Delegate { get; set; }\n\n        [Export(\"thumbEnabledColor\", ArgumentSemantic.Strong)]\n        UIColor ThumbEnabledColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"thumbDisabledColor\", ArgumentSemantic.Strong)]\n        UIColor ThumbDisabledColor { get; set; }\n\n        [Export(\"trackOnColor\", ArgumentSemantic.Strong)]\n        UIColor TrackOnColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"trackOffColor\", ArgumentSemantic.Strong)]\n        UIColor TrackOffColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"trackDisabledColor\", ArgumentSemantic.Strong)]\n        UIColor TrackDisabledColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"trackOnTickColor\", ArgumentSemantic.Strong)]\n        UIColor TrackOnTickColor { get; set; }\n\n        [NullAllowed]\n        [Export(\"trackOffTickColor\", ArgumentSemantic.Strong)]\n        UIColor TrackOffTickColor { get; set; }\n\n        [Export(\"enableRippleBehavior\")]\n        bool EnableRippleBehavior { get; set; }\n\n        [NullAllowed]\n        [Export(\"rippleColor\", ArgumentSemantic.Strong)]\n        UIColor RippleColor { get; set; }\n\n        [Export(\"valueLabelTextColor\", ArgumentSemantic.Strong)]\n        UIColor ValueLabelTextColor { get; set; }\n\n        [Export(\"valueLabelBackgroundColor\", ArgumentSemantic.Strong)]\n        UIColor ValueLabelBackgroundColor { get; set; }\n\n        [Export(\"numDiscreteValues\")]\n        nuint NumDiscreteValues { get; set; }\n\n        [Export(\"value\")]\n        nfloat Value { get; set; }\n\n        [Export(\"minimumValue\")]\n        nfloat MinimumValue { get; set; }\n\n        [Export(\"maximumValue\")]\n        nfloat MaximumValue { get; set; }\n\n        [Export(\"thumbPosition\", ArgumentSemantic.Assign)]\n        CGPoint ThumbPosition { get; }\n\n        [Export(\"trackHeight\")]\n        nfloat TrackHeight { get; set; }\n\n        [Export(\"thumbRadius\")]\n        nfloat ThumbRadius { get; set; }\n\n        [Export(\"thumbElevation\")]\n        nfloat ThumbElevation { get; set; }\n\n        [Export(\"thumbShadowColor\", ArgumentSemantic.Strong)]\n        UIColor ThumbShadowColor { get; set; }\n\n        [Export(\"thumbIsSmallerWhenDisabled\")]\n        bool ThumbIsSmallerWhenDisabled { get; set; }\n\n        [Export(\"thumbIsHollowAtStart\")]\n        bool ThumbIsHollowAtStart { get; set; }\n\n        [Export(\"thumbGrowsWhenDragging\")]\n        bool ThumbGrowsWhenDragging { get; set; }\n\n        [Export(\"thumbRippleMaximumRadius\")]\n        nfloat ThumbRippleMaximumRadius { get; set; }\n\n        [Export(\"shouldDisplayRipple\")]\n        bool ShouldDisplayRipple { get; set; }\n\n        [Export(\"shouldDisplayDiscreteDots\")]\n        bool ShouldDisplayDiscreteDots { get; set; }\n\n        [Export(\"shouldDisplayDiscreteValueLabel\")]\n        bool ShouldDisplayDiscreteValueLabel { get; set; }\n\n        [Export(\"shouldDisplayFilledTrack\")]\n        bool ShouldDisplayFilledTrack { get; set; }\n\n        [Export(\"disabledTrackHasThumbGaps\")]\n        bool DisabledTrackHasThumbGaps { get; set; }\n\n        [Export(\"trackEndsAreRounded\")]\n        bool TrackEndsAreRounded { get; set; }\n\n        [Export(\"trackEndsAreInset\")]\n        bool TrackEndsAreInset { get; set; }\n\n        [Export(\"filledTrackAnchorValue\")]\n        nfloat FilledTrackAnchorValue { get; set; }\n\n        [NullAllowed]\n        [Export(\"thumbView\", ArgumentSemantic.Strong)]\n        ThumbView ThumbView { get; set; }\n\n        [Export(\"continuousUpdateEvents\")]\n        bool ContinuousUpdateEvents { get; set; }\n\n        [Export(\"panningAllowedOnEntireControl\")]\n        bool PanningAllowedOnEntireControl { get; set; }\n\n        [Export(\"tapsAllowedOnThumb\")]\n        bool TapsAllowedOnThumb { get; set; }\n\n        [Obsolete(\"This API will be deprecated. Use ThumbEnabledColor, TrackOnColor, and InkColor properties instead.\")]\n        [NullAllowed]\n        [Export(\"primaryColor\", ArgumentSemantic.Strong)]\n        UIColor PrimaryColor { get; set; }\n\n        [Export(\"initWithFrame:onTintColor:\")]\n        IntPtr Constructor(CGRect frame, [NullAllowed]  UIColor onTintColor);\n\n        [Export(\"setValue:animated:\")]\n        void SetValue(nfloat value, bool animated);\n\n        [Export(\"setValue:animated:animateThumbAfterMove:userGenerated:completion:\")]\n        void SetValue(nfloat value, bool animated, bool animateThumbAfterMove, bool userGenerated, [NullAllowed]  Action completion);\n\n        [Export(\"setIcon:\")]\n        void SetIcon([NullAllowed] UIImage icon);\n\n        [Obsolete(\"This property will be deprecated soon.\")]\n        [NullAllowed]\n        [Export(\"inkColor\", ArgumentSemantic.Strong)]\n        UIColor InkColor { get; set; }\n\n        [Obsolete(\"This property will be deprecated soon.\")]\n        [Export(\"shouldDisplayInk\")]\n        bool ShouldDisplayInk { get; set; }\n\n        [Obsolete(\"This property will be deprecated soon.\")]\n        [Export(\"thumbMaxRippleRadius\")]\n        nfloat ThumbMaxRippleRadius { get; set; }\n    }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject),\n        Name = \"MDCThumbTrackDelegate\")]\n    interface ThumbTrackDelegate\n    {\n        [Export(\"thumbTrack:stringForValue:\")]\n        string GetStringForValue(ThumbTrack thumbTrack, nfloat value);\n\n        [Export(\"thumbTrack:shouldJumpToValue:\")]\n        bool ShouldJumpToValue(ThumbTrack thumbTrack, nfloat value);\n\n        [Export(\"thumbTrack:willJumpToValue:\")]\n        void WillJumpToValue(ThumbTrack thumbTrack, nfloat value);\n\n        [Export(\"thumbTrack:willAnimateToValue:\")]\n        void WillAnimateToValue(ThumbTrack thumbTrack, nfloat value);\n\n        [Export(\"thumbTrack:didAnimateToValue:\")]\n        void DidAnimateToValue(ThumbTrack thumbTrack, nfloat value);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCThumbView\")]\n    interface ThumbView\n    {\n        [Export(\"elevation\")]\n        nfloat Elevation { get; set; }\n\n        [Export(\"borderWidth\")]\n        nfloat BorderWidth { get; set; }\n\n        [Export(\"cornerRadius\")]\n        nfloat CornerRadius { get; set; }\n\n        [Export(\"shadowColor\", ArgumentSemantic.Strong)]\n        UIColor ShadowColor { get; set; }\n\n        [Export(\"setIcon:\")]\n        void SetIcon([NullAllowed] UIImage icon);\n    }\n\n    [BaseType(typeof(UIView),\n        Name = \"MDCNumericValueLabel\")]\n    interface NumericValueLabel\n    {\n        [New]\n        [Export(\"backgroundColor\", ArgumentSemantic.Retain)]\n        UIColor BackgroundColor { get; set; }\n\n        [Export(\"textColor\", ArgumentSemantic.Retain)]\n        UIColor TextColor { get; set; }\n\n        [Export(\"fontSize\")]\n        nfloat FontSize { get; set; }\n\n        [Export(\"text\")]\n        string Text { get; set; }\n    }\n\n    [Static]\n    interface CAMediaTimingFunctionAnimationTiming\n    {\n        [Static]\n        [return: NullAllowed]\n        [Export(\"mdc_functionWithType:\")]\n        CAMediaTimingFunction GetFunction(AnimationTimingFunction type);\n    }\n\n    [Static]\n    interface MaterialComponentsConstants\n    {\n        [Field(\"MaterialComponentsVersionNumber\", \"__Internal\")]\n        double VersionNumber { get; }\n\n        [Internal]\n        [Field(\"MaterialComponentsVersionString\", \"__Internal\")]\n        IntPtr _VersionString { get; }\n    }\n\n    interface IElevatable { }\n\n    interface IElevationOverriding { }\n\n    interface IRippleViewDelegate { }\n\n    interface IFlexibleHeaderSafeAreaDelegate { }\n\n    interface IActivityIndicatorDelegate\n    { }\n\n    interface ITabBarDisplayDelegate { }\n\n    interface ITabBarSizeClassDelegate { }\n\n    interface IRippleTouchControllerDelegate { }\n\n    interface IDialogPresentationControllerDelegate { }\n\n    interface IContainerScheming\n    { }\n\n    interface IShapeScheming\n    { }\n\n    interface IAlertScheming\n    { }\n\n    interface IAppBarNavigationControllerDelegate\n    { }\n\n    interface IListScheming\n    { }\n\n    interface IBottomDrawerHeader\n    { }\n\n    interface IBottomDrawerPresentationControllerDelegate\n    { }\n\n    interface IBottomDrawerViewControllerDelegate\n    { }\n\n    interface IBottomNavigationBarDelegate\n    { }\n\n    interface IBottomSheetControllerDelegate\n    { }\n\n    interface IBottomSheetPresentationControllerDelegate\n    { }\n\n    interface IButtonBarDelegate\n    { }\n\n    interface IButtonScheming\n    { }\n\n    interface ICardScheming\n    { }\n\n    interface IChipFieldDelegate\n    { }\n\n    interface IChipViewScheming\n    { }\n\n    [Protocol(Name = \"MDCChipViewScheming\")]\n    interface ChipViewScheming\n    {\n        [Abstract]\n        [Export(\"colorScheme\")]\n        IColorScheming ColorScheme { get; }\n\n        [Abstract]\n        [Export(\"shapeScheme\")]\n        IShapeScheming ShapeScheme { get; }\n\n        [Abstract]\n        [Export(\"typographyScheme\")]\n        ITypographyScheming TypographyScheme { get; }\n    }\n\n    interface ICollectionViewEditing\n    { }\n\n    interface ICollectionViewEditingDelegate\n    { }\n\n    interface ICollectionViewStyling\n    { }\n\n    interface ICollectionViewStylingDelegate\n    { }\n\n    interface IFlexibleHeaderViewDelegate\n    { }\n\n    interface IFlexibleHeaderViewLayoutDelegate\n    { }\n\n    interface IInkTouchControllerDelegate\n    { }\n\n    interface IInkViewDelegate\n    { }\n\n    [Protocol]\n    [Model(AutoGeneratedName = true)]\n    [BaseType(typeof(NSObject))]\n    interface InkViewDelegate\n    {\n        [EventArgs(\"InkViewInkAnimationStarted\")]\n        [EventName(\"InkAnimationStarted\")]\n        [Export(\"inkAnimationDidStart:\")]\n        void InkAnimationDidStart(InkView inkView);\n\n        [EventArgs(\"InkViewInkAnimationEnded\")]\n        [EventName(\"InkAnimationEnded\")]\n        [Export(\"inkAnimationDidEnd:\")]\n        void InkAnimationDidEnd(InkView inkView);\n    }\n\n    interface IColorScheme\n    { }\n\n    interface IFontScheme\n    { }\n\n    interface IMultilineTextInputLayoutDelegate\n    { }\n\n    interface IMultilineTextInputDelegate\n    { }\n\n    interface IUINavigationItemObservables\n    { }\n\n    interface IOverlay\n    { }\n\n    interface IOverlayTransitioning\n    { }\n\n    interface IColorScheming\n    { }\n\n    interface IShapeGenerating\n    { }\n\n    interface ISliderDelegate\n    { }\n\n    interface ISnackbarManagerDelegate\n    { }\n\n    interface ISnackbarSuspensionToken\n    { }\n\n    interface ITabBarDelegate\n    { }\n\n    interface ITabBarIndicatorContext\n    { }\n\n    interface ITabBarIndicatorTemplate\n    { }\n\n    interface ITabBarControllerDelegate\n    { }\n\n    [Static]\n    partial interface Constants11\n    { }\n\n    interface ITextInputPositioningDelegate\n    { }\n\n    interface ITextInput\n    { }\n\n    interface ILeadingViewTextInput\n    { }\n\n    interface IMultilineTextInput\n    { }\n\n    interface ITextInputCharacterCounter\n    { }\n\n    interface ITextInputController\n    { }\n\n    interface ITextInputControllerFloatingPlaceholder\n    { }\n\n    interface IThumbTrackDelegate\n    { }\n\n    interface ITypographyFontLoading\n    { }\n\n    interface ITypographyScheming\n    { }\n\n    [Static]\n    interface UIApplicationAppExtensions\n    {\n        [Static]\n        [Export(\"mdc_safeSharedApplication\")]\n        UIApplication SafeSharedApplication { get; }\n\n        [Static]\n        [Wrap(\"SafeSharedApplication\")]\n        UIApplication MdcSafeSharedApplication { get; }\n\n        [Static]\n        [Export(\"mdc_isAppExtension\")]\n        bool IsAppExtension { get; }\n\n        [Static]\n        [Wrap(\"IsAppExtension\")]\n        bool MdcIsAppExtension { get; }\n    }\n\n    [Static]\n    interface UIFontMaterialTypography\n    {\n        [Static]\n        [Export(\"mdc_preferredFontForMaterialTextStyle:\")]\n        UIFont GetPreferredFont(FontTextStyle style);\n\n        [Static]\n        [Wrap(\"GetPreferredFont(style)\")]\n        UIFont MdcGetPreferredFont(FontTextStyle style);\n\n        [Static]\n        [Export(\"mdc_standardFontForMaterialTextStyle:\")]\n        UIFont GetStandardFont(FontTextStyle style);\n\n        [Static]\n        [Wrap(\"GetStandardFont(style)\")]\n        UIFont MdcGetStandardFont(FontTextStyle style);\n    }\n\n    [Static]\n    interface UIFontDescriptorMaterialTypography\n    {\n        [Static]\n        [Export(\"mdc_preferredFontDescriptorForMaterialTextStyle:\")]\n        UIFontDescriptor GetPreferredFontDescriptor(FontTextStyle style);\n\n        [Static]\n        [Wrap(\"GetPreferredFontDescriptor(style)\")]\n        UIFontDescriptor MdcGetPreferredFontDescriptor(FontTextStyle style);\n\n        [Static]\n        [Export(\"mdc_standardFontDescriptorForMaterialTextStyle:\")]\n        UIFontDescriptor GetStandardFontDescriptor(FontTextStyle style);\n\n        [Static]\n        [Wrap(\"GetStandardFontDescriptor(style)\")]\n        UIFontDescriptor MdcGetStandardFontDescriptor(FontTextStyle style);\n    }\n\n    [Static]\n    interface UIViewMDCTimingFunction\n    {\n        [Static]\n        [Export(\"mdc_animateWithTimingFunction:duration:delay:options:animations:completion:\")]\n        void Animate([NullAllowed] CAMediaTimingFunction timingFunction, double duration, double delay, UIViewAnimationOptions options, Action animations, [NullAllowed]  Action<bool> completion);\n\n        [Wrap(\"Animate (timingFunction, duration, delay, options, animations, completion)\")]\n        [Obsolete(\"Use Animate instead.\")]\n        [Static]\n        void MdcAnimate([NullAllowed] CAMediaTimingFunction timingFunction, double duration, double delay, UIViewAnimationOptions options, Action animations, [NullAllowed] Action<bool> completion);\n    }\n\n    [Static]\n    interface NSLocaleMaterialRtl\n    {\n        [Static]\n        [Export(\"mdf_isDefaultLanguageLTR\")]\n        bool MdfIsDefaultLanguageLtr();\n\n        [Static]\n        [Export(\"mdf_isDefaultLanguageRTL\")]\n        bool MdfIsDefaultLanguageRtl();\n    }\n\n    [Category]\n    [BaseType(typeof(NSString))]\n    interface NSStringMaterialBidi\n    {\n        [Export(\"mdf_calculatedLanguageDirection\")]\n        NSLocaleLanguageDirection MdfCalculatedLanguageDirection();\n\n        [Export(\"mdf_stringWithBidiEmbedding:\")]\n        string MdfGetStringWithBidiEmbedding(NSLocaleLanguageDirection languageDirection);\n\n        [Export(\"mdf_stringWithBidiEmbedding\")]\n        string MdfGetStringWithBidiEmbedding();\n\n        [Export(\"mdf_stringWithStereoReset:context:\")]\n        string MdfGetStringWithStereoReset(NSLocaleLanguageDirection direction, NSLocaleLanguageDirection contextDirection);\n\n        [Export(\"mdf_stringWithBidiMarkersStripped\")]\n        string MdfGetStringWithBidiMarkersStripped();\n    }\n\n    [Category]\n    [BaseType(typeof(UIImage))]\n    interface UIImage_MaterialRtl\n    {\n        [Export(\"mdf_imageWithHorizontallyFlippedOrientation\")]\n        UIImage MdfGetImageWithHorizontallyFlippedOrientation();\n    }\n\n    [Category]\n    [BaseType(typeof(UIView))]\n    interface UIView_MaterialRtl\n    {\n        [Export(\"mdf_semanticContentAttribute\")]\n        UISemanticContentAttribute MdfGetSemanticContentAttribute();\n\n        [Export(\"mdf_setSemanticContentAttribute:\")]\n        void MdfSetSemanticContentAttribute(UISemanticContentAttribute value);\n\n        [Export(\"mdf_effectiveUserInterfaceLayoutDirection\")]\n        UIUserInterfaceLayoutDirection MdfGetEffectiveUserInterfaceLayoutDirection();\n    }\n\n    [Static]\n    interface UIViewMaterialRtl\n    {\n        [Static]\n        [Export(\"mdf_userInterfaceLayoutDirectionForSemanticContentAttribute:\")]\n        UIUserInterfaceLayoutDirection MdfGetUserInterfaceLayoutDirection(UISemanticContentAttribute semanticContentAttribute);\n\n        [Static]\n        [Export(\"mdf_userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:\")]\n        UIUserInterfaceLayoutDirection MdfGetUserInterfaceLayoutDirection(UISemanticContentAttribute semanticContentAttribute, UIUserInterfaceLayoutDirection layoutDirection);\n    }\n}","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"b2a1eba43aea133fbe8292901985d2880f7e42d6","subject":"Cleaned up some things and added text\/plain support.","message":"Cleaned up some things and added text\/plain support.\n","repos":"NaosFramework\/Naos.FluentUri,NaosProject\/Naos.FluentUri","old_file":"Naos.FluentUri\/Naos.FluentUri.cs","new_file":"Naos.FluentUri\/Naos.FluentUri.cs","new_contents":"\ufeff\/\/ --------------------------------------------------------------------------------------------------------------------\n\/\/ <copyright file=\"Naos.FluentUri.cs\" company=\"Naos\">\n\/\/    Copyright (c) Naos 2017. All Rights Reserved.\n\/\/ <\/copyright>\n\/\/ <auto-generated>\n\/\/   If this is in a project then it is sourced from NuGet package,\n\/\/   it will be overwritten with package update except in Naos.Recipes.FluentUri source.\n\/\/ <\/auto-generated>\n\/\/ --------------------------------------------------------------------------------------------------------------------\n\n#if NaosFluentUri\nnamespace Naos.FluentUri\n#else\n    namespace Naos.Recipes.FluentUri\n#endif\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Collections.Specialized;\n    using System.IO;\n    using System.Linq;\n    using System.Net;\n    using System.Text;\n    using System.Web;\n\n    using Naos.Serialization.Domain;\n    using Naos.Serialization.Json;\n\n    using Spritely.Recipes;\n\n    using static System.FormattableString;\n\n    \/\/\/ <summary>\n    \/\/\/ Verbs that can be used for HTTP calls.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    internal\n#endif\n        enum HttpVerb\n    {\n        \/\/\/ <summary>\n        \/\/\/ Get verb.\n        \/\/\/ <\/summary>\n        Get,\n\n        \/\/\/ <summary>\n        \/\/\/ Post verb.\n        \/\/\/ <\/summary>\n        Post,\n\n        \/\/\/ <summary>\n        \/\/\/ Put verb.\n        \/\/\/ <\/summary>\n        Put,\n\n        \/\/\/ <summary>\n        \/\/\/ Delete verb.\n        \/\/\/ <\/summary>\n        Delete,\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Content type to use for HTTP calls.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    internal\n#endif\n        enum ContentType\n    {\n        \/\/\/ <summary>\n        \/\/\/ Application\/JSON type.\n        \/\/\/ <\/summary>\n        ApplicationJson,\n\n        \/\/\/ <summary>\n        \/\/\/ Text\/plain type.\n        \/\/\/ <\/summary>\n        TextPlain,\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Exception object for duplicate calls in chain.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n    internal\n#endif\n        class DuplicateCallUsingFluentGrammarException : Exception\n    {\n        \/\/\/ <summary>\n        \/\/\/ Initializes a new instance of the <see cref=\"DuplicateCallUsingFluentGrammarException\"\/> class.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"message\">Message of the exception.<\/param>\n        public DuplicateCallUsingFluentGrammarException(string message)\n            : base(message)\n        {\n        }\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Type to use for generics that indicates the lack of a return.\n    \/\/\/ <\/summary>\n    [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Microsoft.Design\", \"CA1053:StaticHolderTypesShouldNotHaveConstructors\", Justification = \"Need this to not be static.\")]\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n    internal\n#endif\n        class VoidResultType\n    {\n        \/\/\/ <summary>\n        \/\/\/ Gets the default object to use for return.\n        \/\/\/ <\/summary>\n        public static VoidResultType Default { get; } = new VoidResultType();\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Extension methods to create a single item array from an object.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n    internal\n#endif\n        static class ObjectToArrayExtensionMethod\n    {\n        \/\/\/ <summary>\n        \/\/\/ Converts the object into a single element array.\n        \/\/\/ <\/summary>\n        \/\/\/ <typeparam name=\"T\">Type of the object being used.<\/typeparam>\n        \/\/\/ <param name=\"objectToEncapsulateInArray\">Object that extension method operates on.<\/param>\n        \/\/\/ <returns>New array containing the single item.<\/returns>\n        public static T[] ToSingleElementArray<T>(this T objectToEncapsulateInArray)\n        {\n            return new[] { objectToEncapsulateInArray };\n        }\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Extension methods to convert the two types of cookies.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n    internal\n#endif\n        static class CookieConvertionExtensionMethods\n    {\n        \/\/\/ <summary>\n        \/\/\/ Extension method to convert a System.Web.HttpCookie to a System.Net.Cookie object.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"cookie\">HttpCookie to translate.<\/param>\n        \/\/\/ <returns>Translated Cookie.<\/returns>\n        public static Cookie ToSystemNetCookie(this HttpCookie cookie)\n        {\n            new { cookie }.Must().NotBeNull().OrThrow();\n\n            var ret = new Cookie\n            {\n                Domain = cookie.Domain,\n                Expires = cookie.Expires,\n                Name = cookie.Name,\n                Path = cookie.Path,\n                Secure = cookie.Secure,\n                Value = cookie.Value,\n            };\n\n            return ret;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Extension method to convert a System.Net.Cookie to a System.Web.HttpCookie object.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"cookie\">Cookie to translate.<\/param>\n        \/\/\/ <returns>Translated HttpCookie.<\/returns>\n        public static HttpCookie ToSystemWebHttpCookie(this Cookie cookie)\n        {\n            new { cookie }.Must().NotBeNull().OrThrow();\n\n            var ret = new HttpCookie(cookie.Name)\n            {\n                Domain = cookie.Domain,\n                Expires = cookie.Expires,\n                Name = cookie.Name,\n                Path = cookie.Path,\n                Secure = cookie.Secure,\n                Value = cookie.Value,\n            };\n\n            return ret;\n        }\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Container to hold different types of cookies.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n    internal\n#endif\n        class CookieJar\n    {\n        private readonly List<Cookie> cookies = new List<Cookie>();\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the cookies.\n        \/\/\/ <\/summary>\n        [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Microsoft.Performance\", \"CA1819:PropertiesShouldNotReturnArrays\", Justification = \"Want this to be an array.\")]\n        public Cookie[] Cookies => this.cookies.ToArray();\n\n        \/\/\/ <summary>\n        \/\/\/ Adds the cookie to the set of cookie to use for a request.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"cookie\">Cookie to add to request.<\/param>\n        public void AddCookie(Cookie cookie)\n        {\n            new { cookie }.Must().NotBeNull().OrThrow();\n\n            this.cookies.Add(cookie);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Adds the cookie to the set of cookie to use for a request.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"cookie\">Cookie to add to request.<\/param>\n        public void AddCookie(HttpCookie cookie)\n        {\n            new { cookie }.Must().NotBeNull().OrThrow();\n\n            this.cookies.Add(cookie.ToSystemNetCookie());\n        }\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Utility methods to convert between different types of header collections.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n    internal\n#endif\n        static class HeaderConvertionExtensionMethods\n    {\n        \/\/\/ <summary>\n        \/\/\/ Gets the header in question if present (requires second level check...).\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"headers\">The headers set to look at.<\/param>\n        \/\/\/ <param name=\"name\">The header name to find.<\/param>\n        \/\/\/ <returns>The value of the specified key if present.<\/returns>\n        public static string GetHeaderByName(this NameValueCollection headers, string name)\n        {\n            var values = headers?.GetValues(name);\n\n            return values?.FirstOrDefault();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the header in question if present (requires second level check...).\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"headers\">The headers set to look at.<\/param>\n        \/\/\/ <param name=\"name\">The header name to find.<\/param>\n        \/\/\/ <returns>The value of the specified key if present.<\/returns>\n        public static string GetHeaderByName(this WebHeaderCollection headers, string name)\n        {\n            var values = headers?.GetValues(name);\n\n            return values?.FirstOrDefault();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the collection as a key value pair array.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"collection\">Collection of items as a name value collection.<\/param>\n        \/\/\/ <returns>Array of key value pairs of the items name and value.<\/returns>\n        public static KeyValuePair<string, string>[] ToKeyValuePairArray(this NameValueCollection collection)\n        {\n            var ret = new List<KeyValuePair<string, string>>();\n            if (collection != null)\n            {\n                foreach (var key in collection.AllKeys)\n                {\n                    var values = collection.GetValues(key);\n                    if (values != null)\n                    {\n                        foreach (var value in values)\n                        {\n                            ret.Add(new KeyValuePair<string, string>(key, value));\n                        }\n                    }\n                }\n            }\n\n            return ret.ToArray();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the headers collection as a key value pair array.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"headers\">Headers as a web header collection.<\/param>\n        \/\/\/ <returns>Array of key value pairs of the header name and value.<\/returns>\n        public static KeyValuePair<string, string>[] ToKeyValuePairArray(this WebHeaderCollection headers)\n        {\n            var ret = new List<KeyValuePair<string, string>>();\n            if (headers != null)\n            {\n                foreach (var key in headers.AllKeys)\n                {\n                    var values = headers.GetValues(key);\n                    if (values != null)\n                    {\n                        foreach (var value in values)\n                        {\n                            ret.Add(new KeyValuePair<string, string>(key, value));\n                        }\n                    }\n                }\n            }\n\n            return ret.ToArray();\n        }\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Container to hold different types of headers.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n    internal\n#endif\n        class HeaderJar\n    {\n        private readonly List<KeyValuePair<string, string>> headerCollection = new List<KeyValuePair<string, string>>();\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the headers.\n        \/\/\/ <\/summary>\n        [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Microsoft.Performance\", \"CA1819:PropertiesShouldNotReturnArrays\", Justification = \"Want this to be an array.\")]\n        public KeyValuePair<string, string>[] Headers => this.headerCollection.ToArray();\n\n        \/\/\/ <summary>\n        \/\/\/ Adds the headers to the set of headers to use in the request.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"headers\">Headers to add to set.<\/param>\n        public void Add(NameValueCollection headers)\n        {\n            new { headers }.Must().NotBeNull().OrThrow();\n\n            var transformedHeaders = headers.ToKeyValuePairArray();\n            this.headerCollection.AddRange(transformedHeaders);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Adds the headers to the set of headers to use in the request.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"headers\">Headers to add to set.<\/param>\n        public void Add(WebHeaderCollection headers)\n        {\n            new { headers }.Must().NotBeNull().OrThrow();\n\n            var transformedHeaders = headers.ToKeyValuePairArray();\n            this.headerCollection.AddRange(transformedHeaders);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Adds the headers to the set of headers to use in the request.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"headers\">Headers to add to set.<\/param>\n        public void Add(KeyValuePair<string, string>[] headers)\n        {\n            new { headers }.Must().NotBeNull().OrThrow();\n\n            this.headerCollection.AddRange(headers);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Adds the headers to the set of headers to use in the request.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\">Name of header to add to set.<\/param>\n        \/\/\/ <param name=\"value\">Value of header to add to set.<\/param>\n        public void Add(string name, string value)\n        {\n            new { name }.Must().NotBeNull().And().NotBeWhiteSpace().OrThrowFirstFailure();\n            new { value }.Must().NotBeNull().And().NotBeWhiteSpace().OrThrowFirstFailure();\n\n            this.headerCollection.Add(new KeyValuePair<string, string>(name, value));\n        }\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Methods to wrap WebRequest usage\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n    internal\n#endif\n        static class Operator\n    {\n        \/\/\/ <summary>\n        \/\/\/ Makes a restful call using supplied information.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri to make the request against.<\/param>\n        \/\/\/ <param name=\"httpVerb\">HTTP verb to use.<\/param>\n        \/\/\/ <param name=\"body\">Optional body object to send (use null if not needed).<\/param>\n        \/\/\/ <param name=\"cookieJar\">Optional cookie to use (use null if not needed).<\/param>\n        \/\/\/ <param name=\"headerJar\">Optional headers to use (use null if not needed).<\/param>\n        \/\/\/ <param name=\"saveResponseHeadersAction\">Optional action to use to save response headers (use null if not needed).<\/param>\n        \/\/\/ <param name=\"contentType\">Content type to use for request.<\/param>\n        \/\/\/ <param name=\"acceptType\">Content type to use for response.<\/param>\n        \/\/\/ <param name=\"timeout\">Timeout to use.<\/param>\n        \/\/\/ <param name=\"serializer\">Serializer to use.<\/param>\n        \/\/\/ <typeparam name=\"TResult\">Return type to convert response to (if you provide VoidResultType then null will be returned - basically a void call).<\/typeparam>\n        \/\/\/ <returns>Converted response to the specified type.<\/returns>\n        public static TResult Call<TResult>(\n            Uri uri,\n            HttpVerb httpVerb,\n            object body,\n            CookieJar cookieJar,\n            HeaderJar headerJar,\n            Action<KeyValuePair<string, string>[]> saveResponseHeadersAction,\n            ContentType contentType,\n            ContentType acceptType,\n            TimeSpan timeout,\n            IStringSerializeAndDeserialize serializer) where TResult : class\n        {\n            var httpVerbAsString = httpVerb.ToString().ToUpperInvariant();\n            return Call<TResult>(\n                uri,\n                httpVerbAsString,\n                body,\n                cookieJar,\n                headerJar,\n                saveResponseHeadersAction,\n                contentType,\n                acceptType,\n                timeout,\n                serializer);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Makes a restful call using supplied information.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri to make the request against.<\/param>\n        \/\/\/ <param name=\"httpVerb\">HTTP verb to use.<\/param>\n        \/\/\/ <param name=\"body\">Optional body object to send (use null if not needed).<\/param>\n        \/\/\/ <param name=\"cookieJar\">Optional cookie to use (use null if not needed).<\/param>\n        \/\/\/ <param name=\"headerJar\">Optional headers to use (use null if not needed).<\/param>\n        \/\/\/ <param name=\"saveResponseHeadersAction\">Optional action to use to save response headers (use null if not needed).<\/param>\n        \/\/\/ <param name=\"contentType\">Content type to use for request.<\/param>\n        \/\/\/ <param name=\"acceptType\">Content type to use for response.<\/param>\n        \/\/\/ <param name=\"timeout\">Timeout to use.<\/param>\n        \/\/\/ <param name=\"serializer\">Serializer to use.<\/param>\n        \/\/\/ <typeparam name=\"TResult\">Return type to convert response to (if you provide VoidResultType then null will be returned - basically a void call).<\/typeparam>\n        \/\/\/ <returns>Converted response to the specified type.<\/returns>\n        public static TResult Call<TResult>(\n            Uri uri,\n            string httpVerb,\n            object body,\n            CookieJar cookieJar,\n            HeaderJar headerJar,\n            Action<KeyValuePair<string, string>[]> saveResponseHeadersAction,\n            ContentType contentType,\n            ContentType acceptType,\n            TimeSpan timeout,\n            IStringSerializeAndDeserialize serializer) where TResult : class\n        {\n            new { uri }.Must().NotBeNull().OrThrow();\n            new { httpVerb }.Must().NotBeNull().And().NotBeWhiteSpace().OrThrowFirstFailure();\n            new { serializer }.Must().NotBeNull().OrThrow();\n\n            if (acceptType == ContentType.TextPlain && typeof(TResult) != typeof(string))\n            {\n                throw new ArgumentException(\"Must have return of string when accepting text type.\");\n            }\n\n            if (contentType != ContentType.ApplicationJson)\n            {\n                throw new ArgumentException(\"ContentType: \" + contentType + \" not supported at this time.\", nameof(contentType));\n            }\n\n            if (acceptType != ContentType.ApplicationJson && acceptType != ContentType.TextPlain)\n            {\n                throw new ArgumentException(\"AcceptType: \" + contentType + \" not supported at this time.\", nameof(acceptType));\n            }\n\n            if (timeout == default(TimeSpan))\n            {\n                timeout = TimeSpan.FromSeconds(100);\n            }\n\n            var cookieContainer = new CookieContainer();\n            foreach (var cookie in cookieJar.Cookies)\n            {\n                cookieContainer.Add(cookie);\n            }\n\n            \/\/ ReSharper disable once AccessToStaticMemberViaDerivedType - want to call this method...\n            HttpWebRequest request = (HttpWebRequest)HttpWebRequest.Create(uri);\n            request.CookieContainer = cookieContainer;\n            request.ContentType = contentType.ToStringValue();\n            request.Accept = acceptType.ToStringValue();\n            request.Method = httpVerb;\n            request.Timeout = (int)timeout.TotalMilliseconds;\n\n            LoadRequestHeaders(request, headerJar);\n\n            string bodyAsString = null;\n            if (contentType == ContentType.ApplicationJson && body != null)\n            {\n                bodyAsString = serializer.SerializeToString(body);\n            }\n\n            if (httpVerb != HttpVerb.Get.ToString().ToUpperInvariant() && !string.IsNullOrWhiteSpace(bodyAsString))\n            {\n                request.ContentLength = bodyAsString.Length;\n                using (var requestWriter = new StreamWriter(request.GetRequestStream(), Encoding.ASCII))\n                {\n                    requestWriter.Write(bodyAsString);\n                    requestWriter.Close();\n                }\n            }\n\n            string contents = null;\n            WebHeaderCollection responseHeadersRaw;\n            using (var resp = request.GetResponse())\n            {\n                responseHeadersRaw = resp.Headers;\n\n                var responseStream = resp.GetResponseStream();\n                if (responseStream != null)\n                {\n                    using (var reader = new StreamReader(responseStream))\n                    {\n                        contents = reader.ReadToEnd();\n                    }\n                }\n            }\n\n            TResult ret = default(TResult);\n            if (typeof(TResult) == typeof(VoidResultType))\n            {\n                return ret; \/\/ this will just be null and should only be used when you don't want a return\n            }\n            else if (acceptType == ContentType.ApplicationJson)\n            {\n                ret = serializer.Deserialize<TResult>(contents);\n            }\n            else if (acceptType == ContentType.TextPlain)\n            {\n                ret = contents as TResult;\n            }\n            else\n            {\n                throw new ArgumentException(\"AcceptType: \" + acceptType + \" not supported at this time.\", nameof(acceptType));\n            }\n\n            var responseHeaders = responseHeadersRaw == null\n                                      ? new KeyValuePair<string, string>[0]\n                                      : responseHeadersRaw.ToKeyValuePairArray();\n\n            saveResponseHeadersAction?.Invoke(responseHeaders);\n\n            return ret;\n        }\n\n        private static void LoadRequestHeaders(HttpWebRequest request, HeaderJar headerJar)\n        {\n            new { request }.Must().NotBeNull().OrThrowFirstFailure();\n\n            if (headerJar?.Headers != null)\n            {\n                foreach (var header in headerJar.Headers)\n                {\n                    request.Headers.Add(header.Key, header.Value);\n                }\n            }\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Convert the enumeration value of Content Type to the appropriate string value.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"contentType\">Enumeration content type.<\/param>\n        \/\/\/ <returns>Appropriate string value of the enumeration.<\/returns>\n        public static string ToStringValue(this ContentType contentType)\n        {\n            switch (contentType)\n            {\n                case ContentType.ApplicationJson:\n                    return \"application\/json\";\n                case ContentType.TextPlain:\n                    return \"text\/plain\";\n                default:\n                    throw new ArgumentException(\"Unsupported content type: \" + contentType, nameof(contentType));\n            }\n        }\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Interface of the call for execute methods.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    internal\n#endif\n        interface ICallOnUriVerb\n    {\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a GET without a response.\n        \/\/\/ <\/summary>\n        void Get();\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a GET with a response to the provided type.\n        \/\/\/ <\/summary>\n        \/\/\/ <typeparam name=\"TResult\">Type to convert the response to.<\/typeparam>\n        \/\/\/ <returns>Converted output from the call.<\/returns>\n        TResult Get<TResult>() where TResult : class;\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a POST without a response.\n        \/\/\/ <\/summary>\n        void Post();\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a POST with a response to the provided type.\n        \/\/\/ <\/summary>\n        \/\/\/ <typeparam name=\"TResult\">Type to convert the response to.<\/typeparam>\n        \/\/\/ <returns>Converted output from the call.<\/returns>\n        TResult Post<TResult>() where TResult : class;\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a PUT without a response.\n        \/\/\/ <\/summary>\n        void Put();\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a PUT with a response to the provided type.\n        \/\/\/ <\/summary>\n        \/\/\/ <typeparam name=\"TResult\">Type to convert the response to.<\/typeparam>\n        \/\/\/ <returns>Converted output from the call.<\/returns>\n        TResult Put<TResult>() where TResult : class;\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a DELETE without a response.\n        \/\/\/ <\/summary>\n        void Delete();\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a DELETE with a response to the provided type.\n        \/\/\/ <\/summary>\n        \/\/\/ <typeparam name=\"TResult\">Type to convert the response to.<\/typeparam>\n        \/\/\/ <returns>Converted output from the call.<\/returns>\n        TResult Delete<TResult>() where TResult : class;\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain using the specified verb without a response.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"httpVerb\">Specified HTTP verb to use.<\/param>\n        void CallWithVerb(string httpVerb);\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain using the specified verb with a response to the provided type.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"httpVerb\">Specified HTTP verb to use.<\/param>\n        \/\/\/ <typeparam name=\"TResult\">Type to convert the response to.<\/typeparam>\n        \/\/\/ <returns>Converted output from the call.<\/returns>\n        TResult CallWithVerb<TResult>(string httpVerb) where TResult : class;\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Interface of the call for just the accept type.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    internal\n#endif\n        interface ICallOnUriAcceptType\n    {\n        \/\/\/ <summary>\n        \/\/\/ Updates the accept type of the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"acceptType\">Accept type to use.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        ICallOnUriAll WithAcceptType(ContentType acceptType);\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Interface of the call for just the content type.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    internal\n#endif\n        interface ICallOnUriContentType\n    {\n        \/\/\/ <summary>\n        \/\/\/ Updates the content type of the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"contentType\">Content type to use.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        ICallOnUriAll WithContentType(ContentType contentType);\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Interface of the call for just the timeout.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    internal\n#endif\n        interface ICallOnUriTimeout\n    {\n        \/\/\/ <summary>\n        \/\/\/ Updates the timeout of the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"timeout\">Timeout to use.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        ICallOnUriAll WithTimeout(TimeSpan timeout);\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Interface of the call for execute methods.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    internal\n#endif\n        interface ICallOnUriResponseHeaderSaveAction\n    {\n        \/\/\/ <summary>\n        \/\/\/ Save response headers by sending to an output action on execution.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"outputAction\">Output parameter of the response headers.<\/param>\n        \/\/\/ <returns>Response headers as an array of key value pair elements.<\/returns>\n        ICallOnUriAll WithResponseHeaderSaveAction(Action<KeyValuePair<string, string>[]> outputAction);\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Interface of the call for just the headers.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    internal\n#endif\n        interface ICallOnUriHeaders\n    {\n        \/\/\/ <summary>\n        \/\/\/ Adds the headers to the set of headers to use in the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\">Name of header to add to set.<\/param>\n        \/\/\/ <param name=\"value\">Value of header to add to set.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        ICallOnUriAll WithHeader(string name, string value);\n\n        \/\/\/ <summary>\n        \/\/\/ Adds the headers to the set of headers to use in the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"headers\">Headers to add to call.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        ICallOnUriAll WithHeaders(NameValueCollection headers);\n\n        \/\/\/ <summary>\n        \/\/\/ Adds the headers to the set of headers to use in the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"headers\">Headers to add to call.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        ICallOnUriAll WithHeaders(WebHeaderCollection headers);\n\n        \/\/\/ <summary>\n        \/\/\/ Adds the headers to the set of headers to use in the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"headers\">Headers to add to call.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        ICallOnUriAll WithHeaders(KeyValuePair<string, string>[] headers);\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Interface of the call for just the cookie.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    internal\n#endif\n        interface ICallOnUriCookie\n    {\n        \/\/\/ <summary>\n        \/\/\/ Add a system net cookie to the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"cookie\">Cookie to use.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        ICallOnUriAll WithCookie(Cookie cookie);\n\n        \/\/\/ <summary>\n        \/\/\/ Add a system web HTTP cookie to the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"cookie\">Cookie to use.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        ICallOnUriAll WithCookie(HttpCookie cookie);\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Interface of the call for just the body.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    internal\n#endif\n        interface ICallOnUriBody\n    {\n        \/\/\/ <summary>\n        \/\/\/ Updates the body of the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"body\">Body to use.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        ICallOnUriAll WithBody(object body);\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Interface of the call for setting the serializer.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    internal\n#endif\n        interface ICallOnUriSerializer\n    {\n        \/\/\/ <summary>\n        \/\/\/ Updates the serializer of the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"serializer\">Serializer to use.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        ICallOnUriAll WithSerializer(IStringSerializeAndDeserialize serializer);\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Interface of the call for all methods.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    internal\n#endif\n        interface ICallOnUriAll : ICallOnUriHeaders, ICallOnUriCookie, ICallOnUriTimeout, ICallOnUriBody, ICallOnUriResponseHeaderSaveAction, ICallOnUriVerb, ICallOnUriSerializer, ICallOnUriAcceptType, ICallOnUriContentType\n    {\n    }\n\n    \/\/\/ <inheritdoc \/>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n    internal\n#endif\n        class ImplementationForICallOnUriAll : ICallOnUriAll\n    {\n        private readonly IDictionary<string, bool> decoratorsCalled = new Dictionary<string, bool>();\n\n        private readonly Uri uri;\n\n        private readonly HeaderJar headerJar = new HeaderJar();\n\n        private readonly CookieJar cookieJar = new CookieJar();\n\n        private TimeSpan timeout;\n\n        private object body;\n\n        private Action<KeyValuePair<string, string>[]> saveResponseHeadersAction;\n\n        private IStringSerializeAndDeserialize serializerForPostBodyAndResponse = new NaosJsonSerializer();\n\n        private ContentType acceptTypeForCall = ContentType.ApplicationJson;\n\n        private ContentType contentTypeForCall = ContentType.ApplicationJson;\n\n        \/\/\/ <summary>\n        \/\/\/ Initializes a new instance of the <see cref=\"ImplementationForICallOnUriAll\"\/> class.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri of the call.<\/param>\n        public ImplementationForICallOnUriAll(Uri uri)\n        {\n            new { uri }.Must().NotBeNull().OrThrow();\n\n            this.uri = uri;\n            this.timeout = TimeSpan.FromSeconds(30);\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public ICallOnUriAll WithAcceptType(ContentType acceptType)\n        {\n            this.acceptTypeForCall = acceptType;\n            return this;\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public ICallOnUriAll WithContentType(ContentType contentType)\n        {\n            this.contentTypeForCall = contentType;\n            return this;\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public ICallOnUriAll WithSerializer(IStringSerializeAndDeserialize serializer)\n        {\n            new { serializer }.Must().NotBeNull().OrThrow();\n\n            this.UpdateCallListThrowIfAlreadyCalled(nameof(this.WithSerializer));\n\n            this.serializerForPostBodyAndResponse = serializer;\n            return this;\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public ICallOnUriAll WithBody(object bodyObject)\n        {\n            this.UpdateCallListThrowIfAlreadyCalled(nameof(this.WithBody));\n\n            this.body = bodyObject;\n            return this;\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public ICallOnUriAll WithHeader(string name, string value)\n        {\n            new { name }.Must().NotBeNull().And().NotBeWhiteSpace().OrThrowFirstFailure();\n            new { value }.Must().NotBeNull().And().NotBeWhiteSpace().OrThrowFirstFailure();\n\n            this.headerJar.Add(name, value);\n            return this;\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public ICallOnUriAll WithHeaders(NameValueCollection headers)\n        {\n            new { headers }.Must().NotBeNull().OrThrow();\n\n            this.headerJar.Add(headers);\n            return this;\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public ICallOnUriAll WithHeaders(WebHeaderCollection headers)\n        {\n            new { headers }.Must().NotBeNull().OrThrow();\n\n            this.headerJar.Add(headers);\n            return this;\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public ICallOnUriAll WithHeaders(KeyValuePair<string, string>[] headers)\n        {\n            new { headers }.Must().NotBeNull().OrThrow();\n\n            this.headerJar.Add(headers);\n            return this;\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public ICallOnUriAll WithCookie(Cookie cookie)\n        {\n            new { cookie }.Must().NotBeNull().OrThrow();\n\n            this.cookieJar.AddCookie(cookie);\n            return this;\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public ICallOnUriAll WithCookie(HttpCookie cookie)\n        {\n            new { cookie }.Must().NotBeNull().OrThrow();\n\n            this.cookieJar.AddCookie(cookie);\n            return this;\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public ICallOnUriAll WithTimeout(TimeSpan callTimeout)\n        {\n            this.UpdateCallListThrowIfAlreadyCalled(nameof(this.WithTimeout));\n\n            this.timeout = callTimeout;\n            return this;\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public ICallOnUriAll WithResponseHeaderSaveAction(Action<KeyValuePair<string, string>[]> saveAction)\n        {\n            new { saveAction }.Must().NotBeNull().OrThrow();\n\n            this.UpdateCallListThrowIfAlreadyCalled(nameof(this.WithResponseHeaderSaveAction));\n\n            this.saveResponseHeadersAction = saveAction;\n            return this;\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public void Get()\n        {\n            Operator.Call<VoidResultType>(\n                this.uri,\n                HttpVerb.Get,\n                this.body,\n                this.cookieJar,\n                this.headerJar,\n                this.saveResponseHeadersAction,\n                this.contentTypeForCall,\n                this.acceptTypeForCall,\n                this.timeout,\n                this.serializerForPostBodyAndResponse);\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public TResult Get<TResult>() where TResult : class\n        {\n            return Operator.Call<TResult>(\n                this.uri,\n                HttpVerb.Get,\n                this.body,\n                this.cookieJar,\n                this.headerJar,\n                this.saveResponseHeadersAction,\n                this.contentTypeForCall,\n                this.acceptTypeForCall,\n                this.timeout,\n                this.serializerForPostBodyAndResponse);\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public void Post()\n        {\n            Operator.Call<VoidResultType>(\n                this.uri,\n                HttpVerb.Post,\n                this.body,\n                this.cookieJar,\n                this.headerJar,\n                this.saveResponseHeadersAction,\n                this.contentTypeForCall,\n                this.acceptTypeForCall,\n                this.timeout,\n                this.serializerForPostBodyAndResponse);\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public TResult Post<TResult>() where TResult : class\n        {\n            return Operator.Call<TResult>(\n                this.uri,\n                HttpVerb.Post,\n                this.body,\n                this.cookieJar,\n                this.headerJar,\n                this.saveResponseHeadersAction,\n                this.contentTypeForCall,\n                this.acceptTypeForCall,\n                this.timeout,\n                this.serializerForPostBodyAndResponse);\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public void Put()\n        {\n            Operator.Call<VoidResultType>(\n                this.uri,\n                HttpVerb.Put,\n                this.body,\n                this.cookieJar,\n                this.headerJar,\n                this.saveResponseHeadersAction,\n                this.contentTypeForCall,\n                this.acceptTypeForCall,\n                this.timeout,\n                this.serializerForPostBodyAndResponse);\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public TResult Put<TResult>() where TResult : class\n        {\n            return Operator.Call<TResult>(\n                this.uri,\n                HttpVerb.Put,\n                this.body,\n                this.cookieJar,\n                this.headerJar,\n                this.saveResponseHeadersAction,\n                this.contentTypeForCall,\n                this.acceptTypeForCall,\n                this.timeout,\n                this.serializerForPostBodyAndResponse);\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public void Delete()\n        {\n            Operator.Call<VoidResultType>(\n                this.uri,\n                HttpVerb.Delete,\n                this.body,\n                this.cookieJar,\n                this.headerJar,\n                this.saveResponseHeadersAction,\n                this.contentTypeForCall,\n                this.acceptTypeForCall,\n                this.timeout,\n                this.serializerForPostBodyAndResponse);\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public TResult Delete<TResult>() where TResult : class\n        {\n            return Operator.Call<TResult>(\n                this.uri,\n                HttpVerb.Delete,\n                this.body,\n                this.cookieJar,\n                this.headerJar,\n                this.saveResponseHeadersAction,\n                this.contentTypeForCall,\n                this.acceptTypeForCall,\n                this.timeout,\n                this.serializerForPostBodyAndResponse);\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public void CallWithVerb(string httpVerb)\n        {\n            new { httpVerb }.Must().NotBeNull().And().NotBeWhiteSpace().OrThrowFirstFailure();\n\n            Operator.Call<VoidResultType>(\n                this.uri,\n                httpVerb,\n                this.body,\n                this.cookieJar,\n                this.headerJar,\n                this.saveResponseHeadersAction,\n                this.contentTypeForCall,\n                this.acceptTypeForCall,\n                this.timeout,\n                this.serializerForPostBodyAndResponse);\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public TResult CallWithVerb<TResult>(string httpVerb) where TResult : class\n        {\n            new { httpVerb }.Must().NotBeNull().And().NotBeWhiteSpace().OrThrowFirstFailure();\n\n            return Operator.Call<TResult>(\n                this.uri,\n                httpVerb,\n                this.body,\n                this.cookieJar,\n                this.headerJar,\n                this.saveResponseHeadersAction,\n                this.contentTypeForCall,\n                this.acceptTypeForCall,\n                this.timeout,\n                this.serializerForPostBodyAndResponse);\n        }\n\n        private void UpdateCallListThrowIfAlreadyCalled(string methodName)\n        {\n            var callMade = this.decoratorsCalled.TryGetValue(methodName, out var keyExists);\n            if (keyExists && callMade)\n            {\n                throw new DuplicateCallUsingFluentGrammarException(\n                    \"Cannot call '\" + methodName + \"' twice, please update chain to only call once...\");\n            }\n            else\n            {\n                this.decoratorsCalled.Add(methodName, true);\n            }\n        }\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Class with extension methods for building a Uri using a fluent grammar.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n    internal\n#endif\n        static class UriExtensionMethodsForBuilding\n    {\n        \/\/\/ <summary>\n        \/\/\/ Appends a path segment to the uri.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri to operate on.<\/param>\n        \/\/\/ <param name=\"pathSegment\">Path segment to append.<\/param>\n        \/\/\/ <returns>New Uri with adjustments to the url.<\/returns>\n        public static Uri AppendPathSegment(this Uri uri, string pathSegment)\n        {\n            new { uri }.Must().NotBeNull().OrThrow();\n            new { pathSegment }.Must().NotBeNull().OrThrow();\n\n            var uriBuilder = new UriBuilder(uri);\n\n            if (!uriBuilder.Path.EndsWith(\"\/\", StringComparison.OrdinalIgnoreCase))\n            {\n                uriBuilder.Path += \"\/\";\n            }\n\n            uriBuilder.Path += pathSegment;\n\n            return uriBuilder.Uri;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Appends a query string parameter to the uri.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri to operate on.<\/param>\n        \/\/\/ <param name=\"name\">Name of the query string parameter.<\/param>\n        \/\/\/ <param name=\"value\">Value of the query string parameter.<\/param>\n        \/\/\/ <returns>New Uri with adjustments to the url.<\/returns>\n        public static Uri AppendQueryStringParam(this Uri uri, string name, string value)\n        {\n            new { uri }.Must().NotBeNull().OrThrow();\n            new { value }.Must().NotBeNull().OrThrow();\n\n            var list = new KeyValuePair<string, string>(name, value).ToSingleElementArray();\n            return uri.AppendQueryStringParams(list);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Appends a set of query string parameters to the uri.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri to operate on.<\/param>\n        \/\/\/ <param name=\"queryStringParams\">Query string parameters to add.<\/param>\n        \/\/\/ <returns>New Uri with adjustments to the url.<\/returns>\n        [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Microsoft.Naming\", \"CA1704:IdentifiersShouldBeSpelledCorrectly\", MessageId = \"Params\", Justification = \"Spelling\/name is correct.\")]\n        public static Uri AppendQueryStringParams(this Uri uri, IDictionary<string, string> queryStringParams)\n        {\n            new { uri }.Must().NotBeNull().OrThrow();\n            new { queryStringParams }.Must().NotBeNull().OrThrow();\n\n            var list = queryStringParams.ToList();\n            return uri.AppendQueryStringParams(list);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Appends a set of query string parameters to the uri.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri to operate on.<\/param>\n        \/\/\/ <param name=\"queryStringParams\">Query string parameters to add.<\/param>\n        \/\/\/ <returns>New Uri with adjustments to the url.<\/returns>\n        [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Microsoft.Naming\", \"CA1704:IdentifiersShouldBeSpelledCorrectly\", MessageId = \"Params\", Justification = \"Spelling\/name is correct.\")]\n        public static Uri AppendQueryStringParams(this Uri uri, ICollection<KeyValuePair<string, string>> queryStringParams)\n        {\n            new { uri }.Must().NotBeNull().OrThrow();\n            new { queryStringParams }.Must().NotBeNull().OrThrow();\n\n            var collection = HttpUtility.ParseQueryString(uri.Query);\n\n            \/\/ add or updates key-value pair\n            foreach (var item in queryStringParams)\n            {\n                collection.Set(item.Key, item.Value);\n            }\n\n            var builder = new StringBuilder();\n            var thisIsFirstItem = true;\n            var separator = '&';\n\n            foreach (var item in collection.ToKeyValuePairArray())\n            {\n                if (!thisIsFirstItem)\n                {\n                    \/\/ don't need to separator on first item...\n                    builder.Append(separator);\n                }\n\n                var valueToAppend = item.Key == null ? item.Value : item.Key + \"=\" + item.Value;\n                builder.Append(valueToAppend);\n                thisIsFirstItem = false;\n            }\n\n            var queryString = builder.ToString();\n\n            var ret = new UriBuilder(uri) { Query = queryString };\n\n            return ret.Uri;\n        }\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Class of extension methods on the Uri object.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n    internal\n#endif\n        static class UriExtensionMethodsForCall\n    {\n        \/\/\/ <summary>\n        \/\/\/ Update the serializer for the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <param name=\"serializer\">Serializer to use.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        public static ICallOnUriAll WithSerializer(this Uri uri, IStringSerializeAndDeserialize serializer)\n        {\n            return new ImplementationForICallOnUriAll(uri).WithSerializer(serializer);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Add a system net cookie to the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <param name=\"cookie\">Cookie to use.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        public static ICallOnUriAll WithCookie(this Uri uri, HttpCookie cookie)\n        {\n            return new ImplementationForICallOnUriAll(uri).WithCookie(cookie);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Add a system web HTTP cookie to the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <param name=\"cookie\">Cookie to use.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        public static ICallOnUriAll WithCookie(this Uri uri, Cookie cookie)\n        {\n            return new ImplementationForICallOnUriAll(uri).WithCookie(cookie);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Updates the timeout of the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <param name=\"timeout\">Timeout to use.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        public static ICallOnUriAll WithTimeout(this Uri uri, TimeSpan timeout)\n        {\n            return new ImplementationForICallOnUriAll(uri).WithTimeout(timeout);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Adds the headers to the set of headers to use in the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <param name=\"name\">Name of header to add to set.<\/param>\n        \/\/\/ <param name=\"value\">Value of header to add to set.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        public static ICallOnUriAll WithHeader(this Uri uri, string name, string value)\n        {\n            return new ImplementationForICallOnUriAll(uri).WithHeader(name, value);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Adds the headers to the set of headers to use in the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <param name=\"headers\">Headers to add to call.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        public static ICallOnUriAll WithHeaders(this Uri uri, NameValueCollection headers)\n        {\n            return new ImplementationForICallOnUriAll(uri).WithHeaders(headers);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Adds the headers to the set of headers to use in the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <param name=\"headers\">Headers to add to call.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        public static ICallOnUriAll WithHeaders(this Uri uri, WebHeaderCollection headers)\n        {\n            return new ImplementationForICallOnUriAll(uri).WithHeaders(headers);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Adds the headers to the set of headers to use in the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <param name=\"headers\">Headers to add to call.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        public static ICallOnUriAll WithHeaders(this Uri uri, KeyValuePair<string, string>[] headers)\n        {\n            return new ImplementationForICallOnUriAll(uri).WithHeaders(headers);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Updates the body of the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <param name=\"body\">Body to use.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        public static ICallOnUriAll WithBody(this Uri uri, object body)\n        {\n            return new ImplementationForICallOnUriAll(uri).WithBody(body);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Save response headers by sending to an output action on execution.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <param name=\"outputAction\">Output parameter of the response headers.<\/param>\n        \/\/\/ <returns>Response headers as an array of key value pair elements.<\/returns>\n        public static ICallOnUriAll WithResponseHeaderSaveAction(this Uri uri, Action<KeyValuePair<string, string>[]> outputAction)\n        {\n            return new ImplementationForICallOnUriAll(uri).WithResponseHeaderSaveAction(outputAction);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a GET without a response.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        public static void Get(this Uri uri)\n        {\n            new ImplementationForICallOnUriAll(uri).Get();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a GET with a response to the provided type.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <typeparam name=\"TResult\">Type to convert the response to.<\/typeparam>\n        \/\/\/ <returns>Converted output from the call.<\/returns>\n        public static TResult Get<TResult>(this Uri uri) where TResult : class\n        {\n            return new ImplementationForICallOnUriAll(uri).Get<TResult>();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a POST without a response.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        public static void Post(this Uri uri)\n        {\n            new ImplementationForICallOnUriAll(uri).Post();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a POST with a response to the provided type.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <typeparam name=\"TResult\">Type to convert the response to.<\/typeparam>\n        \/\/\/ <returns>Converted output from the call.<\/returns>\n        public static TResult Post<TResult>(this Uri uri) where TResult : class\n        {\n            return new ImplementationForICallOnUriAll(uri).Post<TResult>();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a PUT without a response.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        public static void Put(this Uri uri)\n        {\n            new ImplementationForICallOnUriAll(uri).Put();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a PUT with a response to the provided type.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <typeparam name=\"TResult\">Type to convert the response to.<\/typeparam>\n        \/\/\/ <returns>Converted output from the call.<\/returns>\n        public static TResult Put<TResult>(this Uri uri) where TResult : class\n        {\n            return new ImplementationForICallOnUriAll(uri).Put<TResult>();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a DELETE without a response.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        public static void Delete(this Uri uri)\n        {\n            new ImplementationForICallOnUriAll(uri).Delete();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a DELETE with a response to the provided type.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <typeparam name=\"TResult\">Type to convert the response to.<\/typeparam>\n        \/\/\/ <returns>Converted output from the call.<\/returns>\n        public static TResult Delete<TResult>(this Uri uri) where TResult : class\n        {\n            return new ImplementationForICallOnUriAll(uri).Delete<TResult>();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain using the specified HTTP verb without a response.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <param name=\"httpVerb\">Specified HTTP verb to use.<\/param>\n        public static void CallWithVerb(this Uri uri, string httpVerb)\n        {\n            new ImplementationForICallOnUriAll(uri).CallWithVerb(httpVerb);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain using the specified HTTP verb with a response to the provided type.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <param name=\"httpVerb\">Specified HTTP verb to use.<\/param>\n        \/\/\/ <typeparam name=\"TResult\">Type to convert the response to.<\/typeparam>\n        \/\/\/ <returns>Converted output from the call.<\/returns>\n        public static TResult CallWithVerb<TResult>(this Uri uri, string httpVerb) where TResult : class\n        {\n            return new ImplementationForICallOnUriAll(uri).CallWithVerb<TResult>(httpVerb);\n        }\n    }\n}","old_contents":"\ufeff\/\/ --------------------------------------------------------------------------------------------------------------------\n\/\/ <copyright file=\"Naos.FluentUri.cs\" company=\"Naos\">\n\/\/    Copyright (c) Naos 2017. All Rights Reserved.\n\/\/ <\/copyright>\n\/\/ <auto-generated>\n\/\/   If this is in a project then it is sourced from NuGet package,\n\/\/   it will be overwritten with package update except in Naos.Recipes.FluentUri source.\n\/\/ <\/auto-generated>\n\/\/ --------------------------------------------------------------------------------------------------------------------\n\n#if NaosFluentUri\n    namespace Naos.FluentUri\n#else\n    namespace Naos.Recipes.FluentUri\n#endif\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Collections.Specialized;\n    using System.IO;\n    using System.Linq;\n    using System.Net;\n    using System.Text;\n    using System.Web;\n\n    using Naos.Serialization.Domain;\n    using Naos.Serialization.Json;\n\n    using Spritely.Recipes;\n\n    \/\/\/ <summary>\n    \/\/\/ Verbs that can be used for HTTP calls.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    internal\n#endif\n        enum HttpVerb\n    {\n        \/\/\/ <summary>\n        \/\/\/ Get verb.\n        \/\/\/ <\/summary>\n        Get,\n\n        \/\/\/ <summary>\n        \/\/\/ Post verb.\n        \/\/\/ <\/summary>\n        Post,\n\n        \/\/\/ <summary>\n        \/\/\/ Put verb.\n        \/\/\/ <\/summary>\n        Put,\n\n        \/\/\/ <summary>\n        \/\/\/ Delete verb.\n        \/\/\/ <\/summary>\n        Delete,\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Content type to use for HTTP calls.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    internal\n#endif\n        enum ContentType\n    {\n        \/\/\/ <summary>\n        \/\/\/ Application JSON type.\n        \/\/\/ <\/summary>\n        ApplicationJson,\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Exception object for duplicate calls in chain.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n    internal\n#endif\n        class DuplicateCallUsingFluentGrammarException : Exception\n    {\n        \/\/\/ <summary>\n        \/\/\/ Initializes a new instance of the <see cref=\"DuplicateCallUsingFluentGrammarException\"\/> class.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"message\">Message of the exception.<\/param>\n        public DuplicateCallUsingFluentGrammarException(string message)\n            : base(message)\n        {\n        }\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Type to use for generics that indicates the lack of a return.\n    \/\/\/ <\/summary>\n    [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Microsoft.Design\", \"CA1053:StaticHolderTypesShouldNotHaveConstructors\", Justification = \"Need this to not be static.\")]\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n    internal\n#endif\n        class VoidResultType\n    {\n        \/\/\/ <summary>\n        \/\/\/ Gets the default object to use for return.\n        \/\/\/ <\/summary>\n        public static VoidResultType Default { get; } = new VoidResultType();\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Extension methods to create a single item array from an object.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n    internal\n#endif\n        static class ObjectToArrayExtensionMethod\n    {\n        \/\/\/ <summary>\n        \/\/\/ Converts the object into a single element array.\n        \/\/\/ <\/summary>\n        \/\/\/ <typeparam name=\"T\">Type of the object being used.<\/typeparam>\n        \/\/\/ <param name=\"objectToEncapsulateInArray\">Object that extension method operates on.<\/param>\n        \/\/\/ <returns>New array containing the single item.<\/returns>\n        public static T[] ToSingleElementArray<T>(this T objectToEncapsulateInArray)\n        {\n            return new[] { objectToEncapsulateInArray };\n        }\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Extension methods to convert the two types of cookies.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n    internal\n#endif\n        static class CookieConvertionExtensionMethods\n    {\n        \/\/\/ <summary>\n        \/\/\/ Extension method to convert a System.Web.HttpCookie to a System.Net.Cookie object.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"cookie\">HttpCookie to translate.<\/param>\n        \/\/\/ <returns>Translated Cookie.<\/returns>\n        public static Cookie ToSystemNetCookie(this HttpCookie cookie)\n        {\n            new { cookie }.Must().NotBeNull().OrThrow();\n\n            var ret = new Cookie\n            {\n                Domain = cookie.Domain,\n                Expires = cookie.Expires,\n                Name = cookie.Name,\n                Path = cookie.Path,\n                Secure = cookie.Secure,\n                Value = cookie.Value,\n            };\n\n            return ret;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Extension method to convert a System.Net.Cookie to a System.Web.HttpCookie object.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"cookie\">Cookie to translate.<\/param>\n        \/\/\/ <returns>Translated HttpCookie.<\/returns>\n        public static HttpCookie ToSystemWebHttpCookie(this Cookie cookie)\n        {\n            new { cookie }.Must().NotBeNull().OrThrow();\n\n            var ret = new HttpCookie(cookie.Name)\n            {\n                Domain = cookie.Domain,\n                Expires = cookie.Expires,\n                Name = cookie.Name,\n                Path = cookie.Path,\n                Secure = cookie.Secure,\n                Value = cookie.Value,\n            };\n\n            return ret;\n        }\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Container to hold different types of cookies.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n    internal\n#endif\n        class CookieJar\n    {\n        private readonly List<Cookie> cookies = new List<Cookie>();\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the cookies.\n        \/\/\/ <\/summary>\n        [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Microsoft.Performance\", \"CA1819:PropertiesShouldNotReturnArrays\", Justification = \"Want this to be an array.\")]\n        public Cookie[] Cookies => this.cookies.ToArray();\n\n        \/\/\/ <summary>\n        \/\/\/ Adds the cookie to the set of cookie to use for a request.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"cookie\">Cookie to add to request.<\/param>\n        public void AddCookie(Cookie cookie)\n        {\n            new { cookie }.Must().NotBeNull().OrThrow();\n\n            this.cookies.Add(cookie);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Adds the cookie to the set of cookie to use for a request.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"cookie\">Cookie to add to request.<\/param>\n        public void AddCookie(HttpCookie cookie)\n        {\n            new { cookie }.Must().NotBeNull().OrThrow();\n\n            this.cookies.Add(cookie.ToSystemNetCookie());\n        }\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Utility methods to convert between different types of header collections.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n    internal\n#endif\n        static class HeaderConvertionExtensionMethods\n    {\n        \/\/\/ <summary>\n        \/\/\/ Gets the header in question if present (requires second level check...).\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"headers\">The headers set to look at.<\/param>\n        \/\/\/ <param name=\"name\">The header name to find.<\/param>\n        \/\/\/ <returns>The value of the specified key if present.<\/returns>\n        public static string GetHeaderByName(this NameValueCollection headers, string name)\n        {\n            var values = headers?.GetValues(name);\n\n            return values?.FirstOrDefault();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the header in question if present (requires second level check...).\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"headers\">The headers set to look at.<\/param>\n        \/\/\/ <param name=\"name\">The header name to find.<\/param>\n        \/\/\/ <returns>The value of the specified key if present.<\/returns>\n        public static string GetHeaderByName(this WebHeaderCollection headers, string name)\n        {\n            var values = headers?.GetValues(name);\n\n            return values?.FirstOrDefault();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the collection as a key value pair array.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"collection\">Collection of items as a name value collection.<\/param>\n        \/\/\/ <returns>Array of key value pairs of the items name and value.<\/returns>\n        public static KeyValuePair<string, string>[] ToKeyValuePairArray(this NameValueCollection collection)\n        {\n            var ret = new List<KeyValuePair<string, string>>();\n            if (collection != null)\n            {\n                foreach (var key in collection.AllKeys)\n                {\n                    var values = collection.GetValues(key);\n                    if (values != null)\n                    {\n                        foreach (var value in values)\n                        {\n                            ret.Add(new KeyValuePair<string, string>(key, value));\n                        }\n                    }\n                }\n            }\n\n            return ret.ToArray();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the headers collection as a key value pair array.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"headers\">Headers as a web header collection.<\/param>\n        \/\/\/ <returns>Array of key value pairs of the header name and value.<\/returns>\n        public static KeyValuePair<string, string>[] ToKeyValuePairArray(this WebHeaderCollection headers)\n        {\n            var ret = new List<KeyValuePair<string, string>>();\n            if (headers != null)\n            {\n                foreach (var key in headers.AllKeys)\n                {\n                    var values = headers.GetValues(key);\n                    if (values != null)\n                    {\n                        foreach (var value in values)\n                        {\n                            ret.Add(new KeyValuePair<string, string>(key, value));\n                        }\n                    }\n                }\n            }\n\n            return ret.ToArray();\n        }\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Container to hold different types of headers.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n    internal\n#endif\n        class HeaderJar\n    {\n        private readonly List<KeyValuePair<string, string>> headerCollection = new List<KeyValuePair<string, string>>();\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the headers.\n        \/\/\/ <\/summary>\n        [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Microsoft.Performance\", \"CA1819:PropertiesShouldNotReturnArrays\", Justification = \"Want this to be an array.\")]\n        public KeyValuePair<string, string>[] Headers => this.headerCollection.ToArray();\n\n        \/\/\/ <summary>\n        \/\/\/ Adds the headers to the set of headers to use in the request.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"headers\">Headers to add to set.<\/param>\n        public void Add(NameValueCollection headers)\n        {\n            new { headers }.Must().NotBeNull().OrThrow();\n\n            var transformedHeaders = headers.ToKeyValuePairArray();\n            this.headerCollection.AddRange(transformedHeaders);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Adds the headers to the set of headers to use in the request.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"headers\">Headers to add to set.<\/param>\n        public void Add(WebHeaderCollection headers)\n        {\n            new { headers }.Must().NotBeNull().OrThrow();\n\n            var transformedHeaders = headers.ToKeyValuePairArray();\n            this.headerCollection.AddRange(transformedHeaders);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Adds the headers to the set of headers to use in the request.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"headers\">Headers to add to set.<\/param>\n        public void Add(KeyValuePair<string, string>[] headers)\n        {\n            new { headers }.Must().NotBeNull().OrThrow();\n\n            this.headerCollection.AddRange(headers);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Adds the headers to the set of headers to use in the request.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\">Name of header to add to set.<\/param>\n        \/\/\/ <param name=\"value\">Value of header to add to set.<\/param>\n        public void Add(string name, string value)\n        {\n            new { name }.Must().NotBeNull().And().NotBeWhiteSpace().OrThrowFirstFailure();\n            new { value }.Must().NotBeNull().And().NotBeWhiteSpace().OrThrowFirstFailure();\n\n            this.headerCollection.Add(new KeyValuePair<string, string>(name, value));\n        }\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Methods to wrap WebRequest usage\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n    internal\n#endif\n        static class Operator\n    {\n        \/\/\/ <summary>\n        \/\/\/ Makes a restful call using supplied information.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri to make the request against.<\/param>\n        \/\/\/ <param name=\"httpVerb\">HTTP verb to use.<\/param>\n        \/\/\/ <param name=\"body\">Optional body object to send (use null if not needed).<\/param>\n        \/\/\/ <param name=\"cookieJar\">Optional cookie to use (use null if not needed).<\/param>\n        \/\/\/ <param name=\"headers\">Optional headers to use (use null if not needed).<\/param>\n        \/\/\/ <param name=\"saveResponseHeadersAction\">Optional action to use to save response headers (use null if not needed).<\/param>\n        \/\/\/ <param name=\"contentType\">Content type to use for request.<\/param>\n        \/\/\/ <param name=\"acceptType\">Content type to use for response.<\/param>\n        \/\/\/ <param name=\"timeout\">Timeout to use.<\/param>\n        \/\/\/ <param name=\"serializer\">Serializer to use.<\/param>\n        \/\/\/ <typeparam name=\"TResult\">Return type to convert response to (if you provide VoidResultType then null will be returned - basically a void call).<\/typeparam>\n        \/\/\/ <returns>Converted response to the specified type.<\/returns>\n        public static TResult Call<TResult>(\n            Uri uri,\n            HttpVerb httpVerb,\n            object body,\n            CookieJar cookieJar,\n            KeyValuePair<string, string>[] headers,\n            Action<KeyValuePair<string, string>[]> saveResponseHeadersAction,\n            ContentType contentType,\n            ContentType acceptType,\n            TimeSpan timeout,\n            IStringSerializeAndDeserialize serializer)\n        {\n            var httpVerbAsString = httpVerb.ToString().ToUpperInvariant();\n            return Call<TResult>(\n                uri,\n                httpVerbAsString,\n                body,\n                cookieJar,\n                headers,\n                saveResponseHeadersAction,\n                contentType,\n                acceptType,\n                timeout,\n                serializer);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Makes a restful call using supplied information.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri to make the request against.<\/param>\n        \/\/\/ <param name=\"httpVerb\">HTTP verb to use.<\/param>\n        \/\/\/ <param name=\"body\">Optional body object to send (use null if not needed).<\/param>\n        \/\/\/ <param name=\"cookieJar\">Optional cookie to use (use null if not needed).<\/param>\n        \/\/\/ <param name=\"headers\">Optional headers to use (use null if not needed).<\/param>\n        \/\/\/ <param name=\"saveResponseHeadersAction\">Optional action to use to save response headers (use null if not needed).<\/param>\n        \/\/\/ <param name=\"contentType\">Content type to use for request.<\/param>\n        \/\/\/ <param name=\"acceptType\">Content type to use for response.<\/param>\n        \/\/\/ <param name=\"timeout\">Timeout to use.<\/param>\n        \/\/\/ <param name=\"serializer\">Serializer to use.<\/param>\n        \/\/\/ <typeparam name=\"TResult\">Return type to convert response to (if you provide VoidResultType then null will be returned - basically a void call).<\/typeparam>\n        \/\/\/ <returns>Converted response to the specified type.<\/returns>\n        public static TResult Call<TResult>(\n            Uri uri,\n            string httpVerb,\n            object body,\n            CookieJar cookieJar,\n            KeyValuePair<string, string>[] headers,\n            Action<KeyValuePair<string, string>[]> saveResponseHeadersAction,\n            ContentType contentType,\n            ContentType acceptType,\n            TimeSpan timeout,\n            IStringSerializeAndDeserialize serializer)\n        {\n            new { uri }.Must().NotBeNull().OrThrow();\n            new { httpVerb }.Must().NotBeNull().And().NotBeWhiteSpace().OrThrowFirstFailure();\n            new { serializer }.Must().NotBeNull().OrThrow();\n\n            if (contentType != ContentType.ApplicationJson)\n            {\n                throw new ArgumentException(\"ContentType: \" + contentType + \" not supported at this time.\", nameof(contentType));\n            }\n\n            if (acceptType != ContentType.ApplicationJson)\n            {\n                throw new ArgumentException(\"AcceptType: \" + contentType + \" not supported at this time.\", nameof(acceptType));\n            }\n\n            if (timeout == default(TimeSpan))\n            {\n                timeout = TimeSpan.FromSeconds(100);\n            }\n\n            var cookieContainer = new CookieContainer();\n            foreach (var cookie in cookieJar.Cookies)\n            {\n                cookieContainer.Add(cookie);\n            }\n\n            \/\/ ReSharper disable once AccessToStaticMemberViaDerivedType - want to call this method...\n            HttpWebRequest req = (HttpWebRequest)HttpWebRequest.Create(uri);\n            req.CookieContainer = cookieContainer;\n            req.ContentType = contentType.ToStringValue();\n            req.Accept = acceptType.ToStringValue();\n            req.Method = httpVerb;\n            req.Timeout = (int)timeout.TotalMilliseconds;\n\n            if (headers != null)\n            {\n                foreach (var header in headers)\n                {\n                    req.Headers.Add(header.Key, header.Value);\n                }\n            }\n\n            string bodyAsString = null;\n            if (contentType == ContentType.ApplicationJson && body != null)\n            {\n                bodyAsString = serializer.SerializeToString(body);\n            }\n\n            if (httpVerb != HttpVerb.Get.ToString().ToUpperInvariant() && !string.IsNullOrWhiteSpace(bodyAsString))\n            {\n                req.ContentLength = bodyAsString.Length;\n                using (var requestWriter = new StreamWriter(req.GetRequestStream(), Encoding.ASCII))\n                {\n                    requestWriter.Write(bodyAsString);\n                    requestWriter.Close();\n                }\n            }\n\n            string contents = null;\n            WebHeaderCollection responseHeadersRaw;\n            using (var resp = req.GetResponse())\n            {\n                responseHeadersRaw = resp.Headers;\n\n                var responseStream = resp.GetResponseStream();\n                if (responseStream != null)\n                {\n                    using (var reader = new StreamReader(responseStream))\n                    {\n                        contents = reader.ReadToEnd();\n                    }\n                }\n            }\n\n            TResult ret = default(TResult);\n            if (typeof(TResult) == typeof(VoidResultType))\n            {\n                return ret; \/\/ this will just be null and should only be used when you don't want a return\n            }\n            else if (acceptType == ContentType.ApplicationJson)\n            {\n                ret = serializer.Deserialize<TResult>(contents);\n            }\n            else\n            {\n                throw new ArgumentException(\"AcceptType: \" + acceptType + \" not supported at this time.\", nameof(acceptType));\n            }\n\n            var responseHeaders = responseHeadersRaw == null\n                                      ? new KeyValuePair<string, string>[0]\n                                      : responseHeadersRaw.ToKeyValuePairArray();\n\n            saveResponseHeadersAction?.Invoke(responseHeaders);\n\n            return ret;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Convert the enumeration value of Content Type to the appropriate string value.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"contentType\">Enumeration content type.<\/param>\n        \/\/\/ <returns>Appropriate string value of the enumeration.<\/returns>\n        public static string ToStringValue(this ContentType contentType)\n        {\n            switch (contentType)\n            {\n                case ContentType.ApplicationJson:\n                    return \"application\/json\";\n                default:\n                    throw new ArgumentException(\"Unsupported content type: \" + contentType, nameof(contentType));\n            }\n        }\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Interface of the call for execute methods.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    internal\n#endif\n        interface ICallOnUriVerb\n    {\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a GET without a response.\n        \/\/\/ <\/summary>\n        void Get();\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a GET with a response to the provided type.\n        \/\/\/ <\/summary>\n        \/\/\/ <typeparam name=\"TResult\">Type to convert the response to.<\/typeparam>\n        \/\/\/ <returns>Converted output from the call.<\/returns>\n        TResult Get<TResult>();\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a POST without a response.\n        \/\/\/ <\/summary>\n        void Post();\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a POST with a response to the provided type.\n        \/\/\/ <\/summary>\n        \/\/\/ <typeparam name=\"TResult\">Type to convert the response to.<\/typeparam>\n        \/\/\/ <returns>Converted output from the call.<\/returns>\n        TResult Post<TResult>();\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a PUT without a response.\n        \/\/\/ <\/summary>\n        void Put();\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a PUT with a response to the provided type.\n        \/\/\/ <\/summary>\n        \/\/\/ <typeparam name=\"TResult\">Type to convert the response to.<\/typeparam>\n        \/\/\/ <returns>Converted output from the call.<\/returns>\n        TResult Put<TResult>();\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a DELETE without a response.\n        \/\/\/ <\/summary>\n        void Delete();\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a DELETE with a response to the provided type.\n        \/\/\/ <\/summary>\n        \/\/\/ <typeparam name=\"TResult\">Type to convert the response to.<\/typeparam>\n        \/\/\/ <returns>Converted output from the call.<\/returns>\n        TResult Delete<TResult>();\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain using the specified verb without a response.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"httpVerb\">Specified HTTP verb to use.<\/param>\n        void CallWithVerb(string httpVerb);\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain using the specified verb with a response to the provided type.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"httpVerb\">Specified HTTP verb to use.<\/param>\n        \/\/\/ <typeparam name=\"TResult\">Type to convert the response to.<\/typeparam>\n        \/\/\/ <returns>Converted output from the call.<\/returns>\n        TResult CallWithVerb<TResult>(string httpVerb);\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Interface of the call for just the timeout.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    internal\n#endif\n        interface ICallOnUriTimeout\n    {\n        \/\/\/ <summary>\n        \/\/\/ Updates the timeout of the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"timeout\">Timeout to use.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        ICallOnUriAll WithTimeout(TimeSpan timeout);\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Interface of the call for execute methods.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    internal\n#endif\n        interface ICallOnUriResponseHeaderSaveAction\n    {\n        \/\/\/ <summary>\n        \/\/\/ Save response headers by sending to an output action on execution.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"outputAction\">Output parameter of the response headers.<\/param>\n        \/\/\/ <returns>Response headers as an array of key value pair elements.<\/returns>\n        ICallOnUriAll WithResponseHeaderSaveAction(Action<KeyValuePair<string, string>[]> outputAction);\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Interface of the call for just the headers.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    internal\n#endif\n        interface ICallOnUriHeaders\n    {\n        \/\/\/ <summary>\n        \/\/\/ Adds the headers to the set of headers to use in the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"name\">Name of header to add to set.<\/param>\n        \/\/\/ <param name=\"value\">Value of header to add to set.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        ICallOnUriAll WithHeader(string name, string value);\n\n        \/\/\/ <summary>\n        \/\/\/ Adds the headers to the set of headers to use in the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"headers\">Headers to add to call.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        ICallOnUriAll WithHeaders(NameValueCollection headers);\n\n        \/\/\/ <summary>\n        \/\/\/ Adds the headers to the set of headers to use in the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"headers\">Headers to add to call.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        ICallOnUriAll WithHeaders(WebHeaderCollection headers);\n\n        \/\/\/ <summary>\n        \/\/\/ Adds the headers to the set of headers to use in the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"headers\">Headers to add to call.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        ICallOnUriAll WithHeaders(KeyValuePair<string, string>[] headers);\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Interface of the call for just the cookie.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    internal\n#endif\n        interface ICallOnUriCookie\n    {\n        \/\/\/ <summary>\n        \/\/\/ Add a system net cookie to the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"cookie\">Cookie to use.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        ICallOnUriAll WithCookie(Cookie cookie);\n\n        \/\/\/ <summary>\n        \/\/\/ Add a system web HTTP cookie to the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"cookie\">Cookie to use.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        ICallOnUriAll WithCookie(HttpCookie cookie);\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Interface of the call for just the body.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    internal\n#endif\n        interface ICallOnUriBody\n    {\n        \/\/\/ <summary>\n        \/\/\/ Updates the body of the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"body\">Body to use.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        ICallOnUriAll WithBody(object body);\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Interface of the call for setting the serializer.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    internal\n#endif\n        interface ICallOnUriSerializer\n    {\n        \/\/\/ <summary>\n        \/\/\/ Updates the serializer of the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"serializer\">Serializer to use.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        ICallOnUriAll WithSerializer(IStringSerializeAndDeserialize serializer);\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Interface of the call for all methods.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    internal\n#endif\n        interface ICallOnUriAll : ICallOnUriHeaders, ICallOnUriCookie, ICallOnUriTimeout, ICallOnUriBody, ICallOnUriResponseHeaderSaveAction, ICallOnUriVerb, ICallOnUriSerializer\n    {\n    }\n\n    \/\/\/ <inheritdoc \/>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n    internal\n#endif\n        class ImplementationForICallOnUriAll : ICallOnUriAll\n    {\n        private readonly IDictionary<string, bool> decoratorsCalled = new Dictionary<string, bool>();\n\n        private readonly Uri uri;\n\n        private readonly HeaderJar headerJar = new HeaderJar();\n\n        private readonly CookieJar cookieJar = new CookieJar();\n\n        private TimeSpan timeout;\n\n        private object body;\n\n        private Action<KeyValuePair<string, string>[]> saveResponseHeadersAction;\n\n        private IStringSerializeAndDeserialize serializerForPostBodyAndResponse = new NaosJsonSerializer();\n\n        \/\/\/ <summary>\n        \/\/\/ Initializes a new instance of the <see cref=\"ImplementationForICallOnUriAll\"\/> class.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri of the call.<\/param>\n        public ImplementationForICallOnUriAll(Uri uri)\n        {\n            new { uri }.Must().NotBeNull().OrThrow();\n\n            this.uri = uri;\n            this.timeout = TimeSpan.FromSeconds(30);\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public ICallOnUriAll WithSerializer(IStringSerializeAndDeserialize serializer)\n        {\n            new { serializer }.Must().NotBeNull().OrThrow();\n\n            this.UpdateCallListThrowIfAlreadyCalled(nameof(this.WithSerializer));\n\n            this.serializerForPostBodyAndResponse = serializer;\n            return this;\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public ICallOnUriAll WithBody(object bodyObject)\n        {\n            this.UpdateCallListThrowIfAlreadyCalled(nameof(this.WithBody));\n\n            this.body = bodyObject;\n            return this;\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public ICallOnUriAll WithHeader(string name, string value)\n        {\n            new { name }.Must().NotBeNull().And().NotBeWhiteSpace().OrThrowFirstFailure();\n            new { value }.Must().NotBeNull().And().NotBeWhiteSpace().OrThrowFirstFailure();\n\n            this.headerJar.Add(name, value);\n            return this;\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public ICallOnUriAll WithHeaders(NameValueCollection headers)\n        {\n            new { headers }.Must().NotBeNull().OrThrow();\n\n            this.headerJar.Add(headers);\n            return this;\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public ICallOnUriAll WithHeaders(WebHeaderCollection headers)\n        {\n            new { headers }.Must().NotBeNull().OrThrow();\n\n            this.headerJar.Add(headers);\n            return this;\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public ICallOnUriAll WithHeaders(KeyValuePair<string, string>[] headers)\n        {\n            new { headers }.Must().NotBeNull().OrThrow();\n\n            this.headerJar.Add(headers);\n            return this;\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public ICallOnUriAll WithCookie(Cookie cookie)\n        {\n            new { cookie }.Must().NotBeNull().OrThrow();\n\n            this.cookieJar.AddCookie(cookie);\n            return this;\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public ICallOnUriAll WithCookie(HttpCookie cookie)\n        {\n            new { cookie }.Must().NotBeNull().OrThrow();\n\n            this.cookieJar.AddCookie(cookie);\n            return this;\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public ICallOnUriAll WithTimeout(TimeSpan callTimeout)\n        {\n            this.UpdateCallListThrowIfAlreadyCalled(nameof(this.WithTimeout));\n\n            this.timeout = callTimeout;\n            return this;\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public ICallOnUriAll WithResponseHeaderSaveAction(Action<KeyValuePair<string, string>[]> saveAction)\n        {\n            new { saveAction }.Must().NotBeNull().OrThrow();\n\n            this.UpdateCallListThrowIfAlreadyCalled(nameof(this.WithResponseHeaderSaveAction));\n\n            this.saveResponseHeadersAction = saveAction;\n            return this;\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public void Get()\n        {\n            Operator.Call<VoidResultType>(\n                this.uri,\n                HttpVerb.Get,\n                this.body,\n                this.cookieJar,\n                this.headerJar.Headers,\n                this.saveResponseHeadersAction,\n                ContentType.ApplicationJson,\n                ContentType.ApplicationJson,\n                this.timeout,\n                this.serializerForPostBodyAndResponse);\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public TResult Get<TResult>()\n        {\n            return Operator.Call<TResult>(\n                this.uri,\n                HttpVerb.Get,\n                this.body,\n                this.cookieJar,\n                this.headerJar.Headers,\n                this.saveResponseHeadersAction,\n                ContentType.ApplicationJson,\n                ContentType.ApplicationJson,\n                this.timeout,\n                this.serializerForPostBodyAndResponse);\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public void Post()\n        {\n            Operator.Call<VoidResultType>(\n                this.uri,\n                HttpVerb.Post,\n                this.body,\n                this.cookieJar,\n                this.headerJar.Headers,\n                this.saveResponseHeadersAction,\n                ContentType.ApplicationJson,\n                ContentType.ApplicationJson,\n                this.timeout,\n                this.serializerForPostBodyAndResponse);\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public TResult Post<TResult>()\n        {\n            return Operator.Call<TResult>(\n                this.uri,\n                HttpVerb.Post,\n                this.body,\n                this.cookieJar,\n                this.headerJar.Headers,\n                this.saveResponseHeadersAction,\n                ContentType.ApplicationJson,\n                ContentType.ApplicationJson,\n                this.timeout,\n                this.serializerForPostBodyAndResponse);\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public void Put()\n        {\n            Operator.Call<VoidResultType>(\n                this.uri,\n                HttpVerb.Put,\n                this.body,\n                this.cookieJar,\n                this.headerJar.Headers,\n                this.saveResponseHeadersAction,\n                ContentType.ApplicationJson,\n                ContentType.ApplicationJson,\n                this.timeout,\n                this.serializerForPostBodyAndResponse);\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public TResult Put<TResult>()\n        {\n            return Operator.Call<TResult>(\n                this.uri,\n                HttpVerb.Put,\n                this.body,\n                this.cookieJar,\n                this.headerJar.Headers,\n                this.saveResponseHeadersAction,\n                ContentType.ApplicationJson,\n                ContentType.ApplicationJson,\n                this.timeout,\n                this.serializerForPostBodyAndResponse);\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public void Delete()\n        {\n            Operator.Call<VoidResultType>(\n                this.uri,\n                HttpVerb.Delete,\n                this.body,\n                this.cookieJar,\n                this.headerJar.Headers,\n                this.saveResponseHeadersAction,\n                ContentType.ApplicationJson,\n                ContentType.ApplicationJson,\n                this.timeout,\n                this.serializerForPostBodyAndResponse);\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public TResult Delete<TResult>()\n        {\n            return Operator.Call<TResult>(\n                this.uri,\n                HttpVerb.Delete,\n                this.body,\n                this.cookieJar,\n                this.headerJar.Headers,\n                this.saveResponseHeadersAction,\n                ContentType.ApplicationJson,\n                ContentType.ApplicationJson,\n                this.timeout,\n                this.serializerForPostBodyAndResponse);\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public void CallWithVerb(string httpVerb)\n        {\n            new { httpVerb }.Must().NotBeNull().And().NotBeWhiteSpace().OrThrowFirstFailure();\n\n            Operator.Call<VoidResultType>(\n                this.uri,\n                httpVerb,\n                this.body,\n                this.cookieJar,\n                this.headerJar.Headers,\n                this.saveResponseHeadersAction,\n                ContentType.ApplicationJson,\n                ContentType.ApplicationJson,\n                this.timeout,\n                this.serializerForPostBodyAndResponse);\n        }\n\n        \/\/\/ <inheritdoc \/>\n        public TResult CallWithVerb<TResult>(string httpVerb)\n        {\n            new { httpVerb }.Must().NotBeNull().And().NotBeWhiteSpace().OrThrowFirstFailure();\n\n            return Operator.Call<TResult>(\n                this.uri,\n                httpVerb,\n                this.body,\n                this.cookieJar,\n                this.headerJar.Headers,\n                this.saveResponseHeadersAction,\n                ContentType.ApplicationJson,\n                ContentType.ApplicationJson,\n                this.timeout,\n                this.serializerForPostBodyAndResponse);\n        }\n\n        private void UpdateCallListThrowIfAlreadyCalled(string methodName)\n        {\n            var callMade = this.decoratorsCalled.TryGetValue(methodName, out var keyExists);\n            if (keyExists && callMade)\n            {\n                throw new DuplicateCallUsingFluentGrammarException(\n                    \"Cannot call '\" + methodName + \"' twice, please update chain to only call once...\");\n            }\n            else\n            {\n                this.decoratorsCalled.Add(methodName, true);\n            }\n        }\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Class with extension methods for building a Uri using a fluent grammar.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n    internal\n#endif\n        static class UriExtensionMethodsForBuilding\n    {\n        \/\/\/ <summary>\n        \/\/\/ Appends a path segment to the uri.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri to operate on.<\/param>\n        \/\/\/ <param name=\"pathSegment\">Path segment to append.<\/param>\n        \/\/\/ <returns>New Uri with adjustments to the url.<\/returns>\n        public static Uri AppendPathSegment(this Uri uri, string pathSegment)\n        {\n            new { uri }.Must().NotBeNull().OrThrow();\n            new { pathSegment }.Must().NotBeNull().OrThrow();\n\n            var uriBuilder = new UriBuilder(uri);\n\n            if (!uriBuilder.Path.EndsWith(\"\/\", StringComparison.OrdinalIgnoreCase))\n            {\n                uriBuilder.Path += \"\/\";\n            }\n\n            uriBuilder.Path += pathSegment;\n\n            return uriBuilder.Uri;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Appends a query string parameter to the uri.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri to operate on.<\/param>\n        \/\/\/ <param name=\"name\">Name of the query string parameter.<\/param>\n        \/\/\/ <param name=\"value\">Value of the query string parameter.<\/param>\n        \/\/\/ <returns>New Uri with adjustments to the url.<\/returns>\n        public static Uri AppendQueryStringParam(this Uri uri, string name, string value)\n        {\n            new { uri }.Must().NotBeNull().OrThrow();\n            new { value }.Must().NotBeNull().OrThrow();\n\n            var list = new KeyValuePair<string, string>(name, value).ToSingleElementArray();\n            return uri.AppendQueryStringParams(list);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Appends a set of query string parameters to the uri.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri to operate on.<\/param>\n        \/\/\/ <param name=\"queryStringParams\">Query string parameters to add.<\/param>\n        \/\/\/ <returns>New Uri with adjustments to the url.<\/returns>\n        [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Microsoft.Naming\", \"CA1704:IdentifiersShouldBeSpelledCorrectly\", MessageId = \"Params\", Justification = \"Spelling\/name is correct.\")]\n        public static Uri AppendQueryStringParams(this Uri uri, IDictionary<string, string> queryStringParams)\n        {\n            new { uri }.Must().NotBeNull().OrThrow();\n            new { queryStringParams }.Must().NotBeNull().OrThrow();\n\n            var list = queryStringParams.ToList();\n            return uri.AppendQueryStringParams(list);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Appends a set of query string parameters to the uri.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri to operate on.<\/param>\n        \/\/\/ <param name=\"queryStringParams\">Query string parameters to add.<\/param>\n        \/\/\/ <returns>New Uri with adjustments to the url.<\/returns>\n        [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Microsoft.Naming\", \"CA1704:IdentifiersShouldBeSpelledCorrectly\", MessageId = \"Params\", Justification = \"Spelling\/name is correct.\")]\n        public static Uri AppendQueryStringParams(this Uri uri, ICollection<KeyValuePair<string, string>> queryStringParams)\n        {\n            new { uri }.Must().NotBeNull().OrThrow();\n            new { queryStringParams }.Must().NotBeNull().OrThrow();\n\n            var collection = HttpUtility.ParseQueryString(uri.Query);\n\n            \/\/ add or updates key-value pair\n            foreach (var item in queryStringParams)\n            {\n                collection.Set(item.Key, item.Value);\n            }\n\n            var builder = new StringBuilder();\n            var thisIsFirstItem = true;\n            var separator = '&';\n\n            foreach (var item in collection.ToKeyValuePairArray())\n            {\n                if (!thisIsFirstItem)\n                {\n                    \/\/ don't need to separator on first item...\n                    builder.Append(separator);\n                }\n\n                var valueToAppend = item.Key == null ? item.Value : item.Key + \"=\" + item.Value;\n                builder.Append(valueToAppend);\n                thisIsFirstItem = false;\n            }\n\n            var queryString = builder.ToString();\n\n            var ret = new UriBuilder(uri) { Query = queryString };\n\n            return ret.Uri;\n        }\n    }\n\n    \/\/\/ <summary>\n    \/\/\/ Class of extension methods on the Uri object.\n    \/\/\/ <\/summary>\n    [System.CodeDom.Compiler.GeneratedCode(\"Naos.Recipes.FluentUri\", \"See package version number\")]\n#if NaosFluentUri\n    public\n#else\n    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n    internal\n#endif\n        static class UriExtensionMethodsForCall\n    {\n        \/\/\/ <summary>\n        \/\/\/ Update the serializer for the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <param name=\"serializer\">Serializer to use.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        public static ICallOnUriAll WithSerializer(this Uri uri, IStringSerializeAndDeserialize serializer)\n        {\n            return new ImplementationForICallOnUriAll(uri).WithSerializer(serializer);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Add a system net cookie to the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <param name=\"cookie\">Cookie to use.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        public static ICallOnUriAll WithCookie(this Uri uri, HttpCookie cookie)\n        {\n            return new ImplementationForICallOnUriAll(uri).WithCookie(cookie);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Add a system web HTTP cookie to the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <param name=\"cookie\">Cookie to use.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        public static ICallOnUriAll WithCookie(this Uri uri, Cookie cookie)\n        {\n            return new ImplementationForICallOnUriAll(uri).WithCookie(cookie);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Updates the timeout of the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <param name=\"timeout\">Timeout to use.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        public static ICallOnUriAll WithTimeout(this Uri uri, TimeSpan timeout)\n        {\n            return new ImplementationForICallOnUriAll(uri).WithTimeout(timeout);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Adds the headers to the set of headers to use in the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <param name=\"name\">Name of header to add to set.<\/param>\n        \/\/\/ <param name=\"value\">Value of header to add to set.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        public static ICallOnUriAll WithHeader(this Uri uri, string name, string value)\n        {\n            return new ImplementationForICallOnUriAll(uri).WithHeader(name, value);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Adds the headers to the set of headers to use in the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <param name=\"headers\">Headers to add to call.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        public static ICallOnUriAll WithHeaders(this Uri uri, NameValueCollection headers)\n        {\n            return new ImplementationForICallOnUriAll(uri).WithHeaders(headers);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Adds the headers to the set of headers to use in the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <param name=\"headers\">Headers to add to call.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        public static ICallOnUriAll WithHeaders(this Uri uri, WebHeaderCollection headers)\n        {\n            return new ImplementationForICallOnUriAll(uri).WithHeaders(headers);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Adds the headers to the set of headers to use in the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <param name=\"headers\">Headers to add to call.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        public static ICallOnUriAll WithHeaders(this Uri uri, KeyValuePair<string, string>[] headers)\n        {\n            return new ImplementationForICallOnUriAll(uri).WithHeaders(headers);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Updates the body of the call.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <param name=\"body\">Body to use.<\/param>\n        \/\/\/ <returns>Updated fluent grammar chain.<\/returns>\n        public static ICallOnUriAll WithBody(this Uri uri, object body)\n        {\n            return new ImplementationForICallOnUriAll(uri).WithBody(body);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Save response headers by sending to an output action on execution.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <param name=\"outputAction\">Output parameter of the response headers.<\/param>\n        \/\/\/ <returns>Response headers as an array of key value pair elements.<\/returns>\n        public static ICallOnUriAll WithResponseHeaderSaveAction(this Uri uri, Action<KeyValuePair<string, string>[]> outputAction)\n        {\n            return new ImplementationForICallOnUriAll(uri).WithResponseHeaderSaveAction(outputAction);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a GET without a response.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        public static void Get(this Uri uri)\n        {\n            new ImplementationForICallOnUriAll(uri).Get();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a GET with a response to the provided type.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <typeparam name=\"TResult\">Type to convert the response to.<\/typeparam>\n        \/\/\/ <returns>Converted output from the call.<\/returns>\n        public static TResult Get<TResult>(this Uri uri)\n        {\n            return new ImplementationForICallOnUriAll(uri).Get<TResult>();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a POST without a response.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        public static void Post(this Uri uri)\n        {\n            new ImplementationForICallOnUriAll(uri).Post();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a POST with a response to the provided type.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <typeparam name=\"TResult\">Type to convert the response to.<\/typeparam>\n        \/\/\/ <returns>Converted output from the call.<\/returns>\n        public static TResult Post<TResult>(this Uri uri)\n        {\n            return new ImplementationForICallOnUriAll(uri).Post<TResult>();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a PUT without a response.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        public static void Put(this Uri uri)\n        {\n            new ImplementationForICallOnUriAll(uri).Put();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a PUT with a response to the provided type.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <typeparam name=\"TResult\">Type to convert the response to.<\/typeparam>\n        \/\/\/ <returns>Converted output from the call.<\/returns>\n        public static TResult Put<TResult>(this Uri uri)\n        {\n            return new ImplementationForICallOnUriAll(uri).Put<TResult>();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a DELETE without a response.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        public static void Delete(this Uri uri)\n        {\n            new ImplementationForICallOnUriAll(uri).Delete();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain as a DELETE with a response to the provided type.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <typeparam name=\"TResult\">Type to convert the response to.<\/typeparam>\n        \/\/\/ <returns>Converted output from the call.<\/returns>\n        public static TResult Delete<TResult>(this Uri uri)\n        {\n            return new ImplementationForICallOnUriAll(uri).Delete<TResult>();\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain using the specified HTTP verb without a response.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <param name=\"httpVerb\">Specified HTTP verb to use.<\/param>\n        public static void CallWithVerb(this Uri uri, string httpVerb)\n        {\n            new ImplementationForICallOnUriAll(uri).CallWithVerb(httpVerb);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the chain using the specified HTTP verb with a response to the provided type.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"uri\">Uri (extension method variable) to use for chain.<\/param>\n        \/\/\/ <param name=\"httpVerb\">Specified HTTP verb to use.<\/param>\n        \/\/\/ <typeparam name=\"TResult\">Type to convert the response to.<\/typeparam>\n        \/\/\/ <returns>Converted output from the call.<\/returns>\n        public static TResult CallWithVerb<TResult>(this Uri uri, string httpVerb)\n        {\n            return new ImplementationForICallOnUriAll(uri).CallWithVerb<TResult>(httpVerb);\n        }\n    }\n}","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"6db35caf69734b1cd1aa72c5a20a75a512b7d3b9","subject":"Bump.","message":"Bump.\n","repos":"lstefano71\/Nowin,Bobris\/Nowin,lstefano71\/Nowin,Bobris\/Nowin,lstefano71\/Nowin,Bobris\/Nowin","old_file":"Nowin\/Properties\/AssemblyInfo.cs","new_file":"Nowin\/Properties\/AssemblyInfo.cs","new_contents":"\ufeffusing System.Reflection;\nusing System.Runtime.InteropServices;\n\n\/\/ General Information about an assembly is controlled through the following \n\/\/ set of attributes. Change these attribute values to modify the information\n\/\/ associated with an assembly.\n[assembly: AssemblyTitle(\"Nowin\")]\n[assembly: AssemblyDescription(\"\")]\n[assembly: AssemblyConfiguration(\"\")]\n[assembly: AssemblyCompany(\"Boris Letocha\")]\n[assembly: AssemblyProduct(\"Nowin\")]\n[assembly: AssemblyCopyright(\"Copyright \u00a9 2015\")]\n[assembly: AssemblyTrademark(\"\")]\n[assembly: AssemblyCulture(\"\")]\n\n\/\/ Setting ComVisible to false makes the types in this assembly not visible \n\/\/ to COM components.  If you need to access a type in this assembly from \n\/\/ COM, set the ComVisible attribute to true on that type.\n[assembly: ComVisible(false)]\n\n\/\/ The following GUID is for the ID of the typelib if this project is exposed to COM\n[assembly: Guid(\"fd085b68-3766-42af-ab6d-351b7741c685\")]\n\n\/\/ Version information for an assembly consists of the following four values:\n\/\/\n\/\/      Major Version\n\/\/      Minor Version \n\/\/      Build Number\n\/\/      Revision\n\/\/\n\/\/ You can specify all the values or you can default the Build and Revision Numbers \n\/\/ by using the '*' as shown below:\n\/\/ [assembly: AssemblyVersion(\"1.0.*\")]\n[assembly: AssemblyVersion(\"0.20.0.0\")]\n[assembly: AssemblyFileVersion(\"0.20.0.0\")]\n","old_contents":"\ufeffusing System.Reflection;\nusing System.Runtime.InteropServices;\n\n\/\/ General Information about an assembly is controlled through the following \n\/\/ set of attributes. Change these attribute values to modify the information\n\/\/ associated with an assembly.\n[assembly: AssemblyTitle(\"Nowin\")]\n[assembly: AssemblyDescription(\"\")]\n[assembly: AssemblyConfiguration(\"\")]\n[assembly: AssemblyCompany(\"Boris Letocha\")]\n[assembly: AssemblyProduct(\"Nowin\")]\n[assembly: AssemblyCopyright(\"Copyright \u00a9 2015\")]\n[assembly: AssemblyTrademark(\"\")]\n[assembly: AssemblyCulture(\"\")]\n\n\/\/ Setting ComVisible to false makes the types in this assembly not visible \n\/\/ to COM components.  If you need to access a type in this assembly from \n\/\/ COM, set the ComVisible attribute to true on that type.\n[assembly: ComVisible(false)]\n\n\/\/ The following GUID is for the ID of the typelib if this project is exposed to COM\n[assembly: Guid(\"fd085b68-3766-42af-ab6d-351b7741c685\")]\n\n\/\/ Version information for an assembly consists of the following four values:\n\/\/\n\/\/      Major Version\n\/\/      Minor Version \n\/\/      Build Number\n\/\/      Revision\n\/\/\n\/\/ You can specify all the values or you can default the Build and Revision Numbers \n\/\/ by using the '*' as shown below:\n\/\/ [assembly: AssemblyVersion(\"1.0.*\")]\n[assembly: AssemblyVersion(\"0.19.0.0\")]\n[assembly: AssemblyFileVersion(\"0.19.0.0\")]\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"832c8232ca5eaf548c4f0af9c67d1fd1d8d99eea","subject":"Fixes #6, was not using the bool in another location (my bad).","message":"Fixes #6, was not using the bool in another location (my bad).\n","repos":"BenPhegan\/NuGet.Extensions","old_file":"NuGet.Extensions\/Commands\/Get.cs","new_file":"NuGet.Extensions\/Commands\/Get.cs","new_contents":"\ufeffusing System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.ComponentModel.Composition;\nusing System.Diagnostics;\nusing System.Diagnostics.Contracts;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Runtime.CompilerServices;\nusing NuGet.Commands;\nusing NuGet.Common;\nusing NuGet.Extras.Comparers;\nusing NuGet.Extras.ExtensionMethods;\nusing NuGet.Extras.PackageReferences;\nusing NuGet.Extras.Packages;\nusing NuGet.Extras.Repositories;\nusing NuGet.Extras.Caches;\n\n\/\/HACK to enable us to test some of the Internal stuff more easily.  Still not sure how many kittens die when we use this.....\n[assembly: InternalsVisibleTo(\"NuGet.Extensions.Tests\")]\n\nnamespace NuGet.Extensions.Commands\n{\n    [Command(typeof(GetResources), \"get\", \"GetCommandDescription\", MinArgs = 1)]\n    public class Get : Command\n    {\n        private IPackageRepository _cacheRepository;\n        private readonly List<string> _sources = new List<string>();\n        private INuGetCacheManager _cacheManager;\n        protected IFileSystem OutputFileSystem;\n        private IPackageRepository _repository;\n        private IPackageResolutionManager _packageResolutionManager;\n        private IPackageCache _packageCache;\n\n        [Option(typeof(GetResources), \"GetCommandSourceDescription\")]\n        public ICollection<string> Source\n        {\n            get { return _sources; }\n        }\n\n        [Option(typeof(GetResources), \"GetCommandOutputDirectoryDescription\")]\n        public string OutputDirectory { get; set; }\n\n        [Option(typeof(GetResources), \"GetCommandExcludeVersionDescription\", AltName = \"x\")]\n        public bool ExcludeVersion { get; set; }\n\n        [Option(typeof(GetResources), \"GetCommandLatestDescription\")]\n        public bool Latest { get; set; }\n\n        [Option(typeof(GetResources), \"GetCommandPrerelease\")]\n        public bool Prerelease { get; set; }\n\n        [Option(typeof(GetResources), \"GetCommandUseCacheDescription\")]\n        public bool NoCache { get; set; }\n\n        [Option(typeof(GetResources), \"GetCommandNoFeedSpecificCache\", AltName = \"nfsp\")]\n        public bool NoFeedSpecificCache { get; set; }\n\n        [Option(typeof(GetResources), \"GetCommandCleanDescription\")]\n        public bool Clean { get; set; }\n\n        [Option(typeof(GetResources), \"GetCommandIncludeDependenciesDescription\", AltName = \"r\")]\n        public bool IncludeDependencies { get; set; }\n\n        public IPackageRepositoryFactory RepositoryFactory { get; private set; }\n\n        public IPackageSourceProvider SourceProvider { get; private set; }\n\n        \/\/\/ <remarks>\n        \/\/\/ Meant for unit testing.\n        \/\/\/ <\/remarks>\n        protected IPackageRepository CacheRepository\n        {\n            get { return _cacheRepository; }\n        }\n\n        private bool AllowMultipleVersions\n        {\n            get { return !ExcludeVersion; }\n        }\n\n        [ImportingConstructor]\n        public Get(IPackageRepositoryFactory packageRepositoryFactory, IPackageSourceProvider sourceProvider)\n        {\n            Contract.Assert(packageRepositoryFactory != null);\n            Contract.Assert(sourceProvider != null);\n\n            RepositoryFactory = packageRepositoryFactory;\n            SourceProvider = sourceProvider;\n        }\n\n        public Get(IPackageRepositoryFactory packageRepositoryFactory, IPackageSourceProvider sourceProvider, IPackageRepository cacheRepository, IFileSystem fileSystem, IPackageCache packageCache)\n            :this(packageRepositoryFactory, sourceProvider)\n        {\n            _cacheRepository = cacheRepository;\n            OutputFileSystem = fileSystem;\n            _packageCache = packageCache;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the command.\n        \/\/\/ <\/summary>\n        public override void ExecuteCommand()\n        {\n            \/\/Probably need some better return code logic here...\n            if (Arguments[0] == null) return;\n            try\n            {\n                if (Source.Count == 1 && !NoFeedSpecificCache && !NoCache)\n                {\n                    _cacheManager = new NuGetCacheManager(Console);\n                    _cacheManager.SetFeedSpecificCacheDirectory(_sources[0]);\n                }\n\n                if (!NoCache)\n                    if (_cacheRepository == null)\n                        _cacheRepository = MachineCache.Default;\n\n                \/\/TODO This needs injecting....\n                if (_packageCache == null)\n                    _packageCache = new MemoryBasedPackageCache(Console);\n\n                _repository = GetRepository();\n                _packageResolutionManager = new PackageResolutionManager(Console, Latest, _packageCache);\n\n                \/\/HACK need to inject somehow...\n                _packageResolutionManager = _packageResolutionManager ?? new PackageResolutionManager(Console, Latest, new MemoryBasedPackageCache(Console));\n\n                \/\/Working on a package.config\n                if (Path.GetFileName(Arguments[0]).Equals(Constants.PackageReferenceFile, StringComparison.OrdinalIgnoreCase))\n                {\n                    OutputFileSystem = CreateFileSystem(Path.GetPathRoot(Arguments[0]));\n                    GetByPackagesConfig(OutputFileSystem);\n                }\n                else\n                {\n                    OutputFileSystem = CreateFileSystem(Directory.GetParent(Arguments[0]).FullName);\n                    GetByDirectoryPath(OutputFileSystem);\n                }\n            }\n            catch (Exception e)\n            {\n                Console.WriteError(e.Message);\n            }\n        }\n\n        private void GetByDirectoryPath(IFileSystem baseFileSystem)\n        {\n            if (baseFileSystem.DirectoryExists(Arguments[0]))\n            {\n                var repositoryGroupManager = new RepositoryGroupManager(Arguments[0], baseFileSystem);\n                var repositoryManagers = new ConcurrentBag<RepositoryManager>(repositoryGroupManager.RepositoryManagers);\n\n                var totalTime = new Stopwatch();\n                totalTime.Start();\n\n                int totalPackageUpdates = 0;\n\n                bool exitWithFailure = false;\n                Array.ForEach(repositoryManagers.ToArray(), (repositoryManager) =>\n                    {\n                        string packagesConfigDiretory = null;\n\n                        if (repositoryManager.RepositoryConfig.Directory != null)\n                            packagesConfigDiretory = repositoryManager.RepositoryConfig.Directory.FullName;\n                        \n                        using (var packageAggregator = new PackageAggregator(baseFileSystem, repositoryManager, new PackageEnumerator()))\n                        {\n                            packageAggregator.Compute((min, max) =>\n                                {\n                                    totalPackageUpdates += Convert.ToInt16(min);\n                                    Console.WriteLine(\"Getting {0} distinct packages from a total of {1} from {2}\",min, max,repositoryManager.RepositoryConfig.FullName);\n                                },\n                                Latest ? PackageReferenceEqualityComparer.IdAndAllowedVersions : PackageReferenceEqualityComparer.IdVersionAndAllowedVersions , new PackageReferenceSetResolver());\n\n                            if (packageAggregator.PackageResolveFailures.Any())\n                            {\n                                LogAllPackageConstraintSatisfactionErrors(repositoryGroupManager, packageAggregator);\n                                exitWithFailure = true;\n                            }\n                            else\n                            {\n                                var tempPackageConfig = packageAggregator.Save(packagesConfigDiretory);\n                                InstallPackagesFromConfigFile(packagesConfigDiretory, GetPackageReferenceFile(baseFileSystem, tempPackageConfig.FullName));\n                            }\n                        }\n                    });\n\n                totalTime.Stop();\n                if (exitWithFailure)\n                {\n                    Console.WriteError(string.Format(\"Failed : {0} package directories, {1} packages in {2} seconds\",\n                                                     repositoryManagers.Count, totalPackageUpdates,\n                                                     totalTime.Elapsed.TotalSeconds));\n                    Environment.Exit(1);\n                }\n                else\n                {\n                    Console.WriteLine(string.Format(\"Updated : {0} package directories, {1} packages in {2} seconds\",\n                                                    repositoryManagers.Count, totalPackageUpdates,\n                                                    totalTime.Elapsed.TotalSeconds));\n                }\n            }\n        }\n\n        private void GetByPackagesConfig(IFileSystem fileSystem)\n        {\n            if (fileSystem.FileExists(Arguments[0]))\n            {\n                \/\/Try and infer the output directory if it is null\n                OutputDirectory = OutputDirectory ?? ResolvePackagesDirectory(fileSystem, Path.GetDirectoryName(Arguments[0]));\n\n                if (!string.IsNullOrEmpty(OutputDirectory))\n                    InstallPackagesFromConfigFile(OutputDirectory, GetPackageReferenceFile(fileSystem, Arguments[0]));\n                else\n                    Console.WriteError(string.Format(\"Could not find packages directory based on {0}\", Arguments[0]));\n            }\n            else\n            {\n                Console.WriteError(String.Format(\"Could not find file : {0}\", Arguments[0]));\n            }\n        }\n\n        private string ResolvePackagesDirectory(IFileSystem fileSystem, string parentPath)\n        {\n            var possiblePackagesPath = Path.Combine(parentPath, \"packages\");\n            if (fileSystem.DirectoryExists(possiblePackagesPath))\n                return possiblePackagesPath;\n\n            if (Path.GetPathRoot(parentPath) == parentPath)\n                return null;\n\n            return ResolvePackagesDirectory(fileSystem, Directory.GetParent(parentPath).FullName);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Logs all package constraint satisfaction errors.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"repositoryGroupManager\">The repository group manager.<\/param>\n        \/\/\/ <param name=\"packageAggregator\">The package aggregator.<\/param>\n        private void LogAllPackageConstraintSatisfactionErrors(RepositoryGroupManager repositoryGroupManager, PackageAggregator packageAggregator)\n        {\n            \/\/HACK #UGLY #WTF There must be a better way....\n            foreach (var p in packageAggregator.PackageResolveFailures)\n            {\n                foreach (var rp in repositoryGroupManager.RepositoryManagers)\n                {\n                    foreach (var prf in rp.PackageReferenceFiles)\n                    {\n                        if (prf.GetPackageReferences().Contains(p))\n                        {\n                            LogSatisfactionFailure(p, prf);\n                        }\n                    }\n                }\n            }\n        }\n\n        \/\/TODO HACK HACK #WTF #EVIL Check the access to a private property.  This requires a change to the PackageReferenceFile otherwise, which would take a long time.....\n        \/\/\/ <summary>\n        \/\/\/ Logs the satisfaction failure.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"p\">The p.<\/param>\n        \/\/\/ <param name=\"prf\">The PRF.<\/param>\n        private void LogSatisfactionFailure(PackageReference p, PackageReferenceFile prf)\n        {\n            Console.WriteError(\"{0} {1}{2} in {3} could not be satisfied.\", p.Id, p.Version, p.VersionConstraint != null ? \" using constraint \" + p.VersionConstraint : string.Empty, GetPackageConfigLocationUsingUltimateEvil(prf));\n        }\n\n        private static string GetPackageConfigLocationUsingUltimateEvil(PackageReferenceFile prf)\n        {\n            var blah = prf.GetPrivateProperty<IFileSystem>(\"FileSystem\");\n            return blah.GetFullPath(prf.GetPrivateField<string>(\"_path\"));\n        }\n\n        protected virtual PackageReferenceFile GetPackageReferenceFile(IFileSystem filesystem, string path)\n        {\n            return new PackageReferenceFile(filesystem, path);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the repository.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns><\/returns>\n        private IPackageRepository GetRepository()\n        {\n            var repository = AggregateRepositoryHelper.CreateAggregateRepositoryFromSources(RepositoryFactory, SourceProvider, Source);\n            bool ignoreFailingRepositories = repository.IgnoreFailingRepositories;\n            if (!NoCache)\n            {\n                repository = new AggregateRepository(new[] { CacheRepository, repository }){ IgnoreFailingRepositories = ignoreFailingRepositories, Logger = Console};\n            }\n            repository.Logger = Console;\n            return repository;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Installs the packages from config file.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"fileSystem\">The file system.<\/param>\n        \/\/\/ <param name=\"file\">The file.<\/param>\n        private void InstallPackagesFromConfigFile(string packagesDirectory, PackageReferenceFile file)\n        {\n            var packageReferences = file.GetPackageReferences().ToList();\n\n            \/\/We need to create a damn filesystem at the packages directory, so that the ROOT is correct.  Ahuh...\n            var fileSystem = CreateFileSystem(packagesDirectory);\n\n            if (!NoCache)\n                Console.WriteLine(\"Using cache....\");\n            PackageManager packageManager = CreatePackageManager(fileSystem, useMachineCache: !NoCache);\n\n            if (Clean)\n                packageManager.CleanPackageFolders();\n\n            bool installedAny = false;\n            foreach (var packageReference in packageReferences)\n            {\n                if (String.IsNullOrEmpty(packageReference.Id))\n                {\n                    \/\/ GetPackageReferences returns all records without validating values. We'll throw if we encounter packages\n                    \/\/ with malformed ids \/ Versions.\n                    throw new InvalidDataException(String.Format(CultureInfo.CurrentCulture, GetResources.GetCommandInvalidPackageReference, Arguments[0]));\n                }\n                else if (packageReference.Version == null)\n                {\n                    throw new InvalidDataException(String.Format(CultureInfo.CurrentCulture, GetResources.GetCommandPackageReferenceInvalidVersion, packageReference.Id));\n                }\n\n                IPackage package = _packageResolutionManager.ResolveLatestInstallablePackage(_repository, packageReference);\n                if (package == null)\n                {\n                    SemanticVersion version = _packageResolutionManager.ResolveInstallableVersion(_repository, packageReference);\n                    installedAny |= InstallPackage(packageManager, fileSystem, packageReference.Id, version ?? packageReference.Version);\n                }\n                else\n                {\n                    \/\/We got it straight from the server, check whether we get a cache hit, else just install\n                    var resolvedPackage = _packageResolutionManager.FindPackageInAllLocalSources(packageManager.LocalRepository, packageManager.SourceRepository, package);\n                    packageManager.InstallPackage(resolvedPackage ?? package, !IncludeDependencies, false);\n                }\n                \/\/ Note that we ignore dependencies here because packages.config already contains the full closure\n            }\n\n            if (!installedAny && packageReferences.Any())\n            {\n                Console.WriteLine(GetResources.GetCommandNothingToInstall, Constants.PackageReferenceFile);\n            }\n        }\n\n\n        \/\/\/ <summary>\n        \/\/\/ Installs the package.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"packageManager\">The package manager.<\/param>\n        \/\/\/ <param name=\"fileSystem\">The file system.<\/param>\n        \/\/\/ <param name=\"packageId\">The package id.<\/param>\n        \/\/\/ <param name=\"version\">The version.<\/param>\n        \/\/\/ <param name=\"allowPreReleaseVersion\"> <\/param>\n        \/\/\/ <returns><\/returns>\n        internal bool InstallPackage(PackageManager packageManager, IFileSystem fileSystem, string packageId, SemanticVersion version, Boolean allowPreReleaseVersion = true)\n        {\n            if (packageManager.IsPackageInstalled(packageId, version))\n            {\n                return false;\n            }\n\n            if (!AllowMultipleVersions)\n            {\n                var installedPackage = packageManager.LocalRepository.FindPackage(packageId);\n                if (installedPackage != null)\n                {\n                    if (version != null && installedPackage.Version >= version)\n                    {\n                        \/\/ If the package is already installed (or the version being installed is lower), then we do not need to do anything. \n                        return false;\n                    }\n                    else if (packageManager.SourceRepository.Exists(packageId, version))\n                    {\n                        \/\/ If the package is already installed, but\n                        \/\/ (a) the version we require is different from the one that is installed, \n                        \/\/ (b) side-by-side is disabled\n                        \/\/ we need to uninstall it.\n                        \/\/ However, before uninstalling, make sure the package exists in the source repository. \n                        packageManager.UninstallPackage(installedPackage, forceRemove: true, removeDependencies: false);\n                    }\n                }\n            }\n            \/\/TODO Will need to expose the last boolean here......\n            var package = _packageResolutionManager.ResolvePackage(packageManager.LocalRepository, _repository, packageId, version, allowPreReleaseVersion);\n            packageManager.InstallPackage(package, ignoreDependencies: !IncludeDependencies, allowPrereleaseVersions: allowPreReleaseVersion);\n            \/\/packageManager.InstallPackage(packageId, version, !IncludeDependencies, allowPreReleaseVersion);\n            return true;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Creates the package manager.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"fileSystem\">The file system.<\/param>\n        \/\/\/ <param name=\"useMachineCache\">if set to <c>true<\/c> [use machine cache].<\/param>\n        \/\/\/ <returns><\/returns>\n        protected virtual PackageManager CreatePackageManager(IFileSystem fileSystem, bool useMachineCache = false)\n        {\n            var pathResolver = new DefaultPackagePathResolver(fileSystem, useSideBySidePaths: AllowMultipleVersions);\n            var packageManager = new PackageManager(_repository, pathResolver, fileSystem, new LocalPackageRepository(pathResolver, fileSystem));\n            packageManager.Logger = Console;\n\n            return packageManager;\n        }\n\n        protected virtual IFileSystem CreateFileSystem(string pathRoot)\n        {\n            \/\/ Use the passed in install path if any, and default to the current dir\n            return new PhysicalFileSystem(pathRoot);\n        }\n    }\n}\n","old_contents":"\ufeffusing System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.ComponentModel.Composition;\nusing System.Diagnostics;\nusing System.Diagnostics.Contracts;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Runtime.CompilerServices;\nusing NuGet.Commands;\nusing NuGet.Common;\nusing NuGet.Extras.Comparers;\nusing NuGet.Extras.ExtensionMethods;\nusing NuGet.Extras.PackageReferences;\nusing NuGet.Extras.Packages;\nusing NuGet.Extras.Repositories;\nusing NuGet.Extras.Caches;\n\n\/\/HACK to enable us to test some of the Internal stuff more easily.  Still not sure how many kittens die when we use this.....\n[assembly: InternalsVisibleTo(\"NuGet.Extensions.Tests\")]\n\nnamespace NuGet.Extensions.Commands\n{\n    [Command(typeof(GetResources), \"get\", \"GetCommandDescription\", MinArgs = 1)]\n    public class Get : Command\n    {\n        private IPackageRepository _cacheRepository;\n        private readonly List<string> _sources = new List<string>();\n        private INuGetCacheManager _cacheManager;\n        protected IFileSystem OutputFileSystem;\n        private IPackageRepository _repository;\n        private IPackageResolutionManager _packageResolutionManager;\n        private IPackageCache _packageCache;\n\n        [Option(typeof(GetResources), \"GetCommandSourceDescription\")]\n        public ICollection<string> Source\n        {\n            get { return _sources; }\n        }\n\n        [Option(typeof(GetResources), \"GetCommandOutputDirectoryDescription\")]\n        public string OutputDirectory { get; set; }\n\n        [Option(typeof(GetResources), \"GetCommandExcludeVersionDescription\", AltName = \"x\")]\n        public bool ExcludeVersion { get; set; }\n\n        [Option(typeof(GetResources), \"GetCommandLatestDescription\")]\n        public bool Latest { get; set; }\n\n        [Option(typeof(GetResources), \"GetCommandPrerelease\")]\n        public bool Prerelease { get; set; }\n\n        [Option(typeof(GetResources), \"GetCommandUseCacheDescription\")]\n        public bool NoCache { get; set; }\n\n        [Option(typeof(GetResources), \"GetCommandNoFeedSpecificCache\", AltName = \"nfsp\")]\n        public bool NoFeedSpecificCache { get; set; }\n\n        [Option(typeof(GetResources), \"GetCommandCleanDescription\")]\n        public bool Clean { get; set; }\n\n        [Option(typeof(GetResources), \"GetCommandIncludeDependenciesDescription\", AltName = \"r\")]\n        public bool IncludeDependencies { get; set; }\n\n        public IPackageRepositoryFactory RepositoryFactory { get; private set; }\n\n        public IPackageSourceProvider SourceProvider { get; private set; }\n\n        \/\/\/ <remarks>\n        \/\/\/ Meant for unit testing.\n        \/\/\/ <\/remarks>\n        protected IPackageRepository CacheRepository\n        {\n            get { return _cacheRepository; }\n        }\n\n        private bool AllowMultipleVersions\n        {\n            get { return !ExcludeVersion; }\n        }\n\n        [ImportingConstructor]\n        public Get(IPackageRepositoryFactory packageRepositoryFactory, IPackageSourceProvider sourceProvider)\n        {\n            Contract.Assert(packageRepositoryFactory != null);\n            Contract.Assert(sourceProvider != null);\n\n            RepositoryFactory = packageRepositoryFactory;\n            SourceProvider = sourceProvider;\n        }\n\n        public Get(IPackageRepositoryFactory packageRepositoryFactory, IPackageSourceProvider sourceProvider, IPackageRepository cacheRepository, IFileSystem fileSystem, IPackageCache packageCache)\n            :this(packageRepositoryFactory, sourceProvider)\n        {\n            _cacheRepository = cacheRepository;\n            OutputFileSystem = fileSystem;\n            _packageCache = packageCache;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the command.\n        \/\/\/ <\/summary>\n        public override void ExecuteCommand()\n        {\n            \/\/Probably need some better return code logic here...\n            if (Arguments[0] == null) return;\n            try\n            {\n                if (Source.Count == 1 && !NoFeedSpecificCache && !NoCache)\n                {\n                    _cacheManager = new NuGetCacheManager(Console);\n                    _cacheManager.SetFeedSpecificCacheDirectory(_sources[0]);\n                }\n\n                if (!NoCache)\n                    if (_cacheRepository == null)\n                        _cacheRepository = MachineCache.Default;\n\n                \/\/TODO This needs injecting....\n                if (_packageCache == null)\n                    _packageCache = new MemoryBasedPackageCache(Console);\n\n                _repository = GetRepository();\n                _packageResolutionManager = new PackageResolutionManager(Console, Latest, _packageCache);\n\n                \/\/HACK need to inject somehow...\n                _packageResolutionManager = _packageResolutionManager ?? new PackageResolutionManager(Console, Latest, new MemoryBasedPackageCache(Console));\n\n                \/\/Working on a package.config\n                if (Path.GetFileName(Arguments[0]).Equals(Constants.PackageReferenceFile, StringComparison.OrdinalIgnoreCase))\n                {\n                    OutputFileSystem = CreateFileSystem(Path.GetPathRoot(Arguments[0]));\n                    GetByPackagesConfig(OutputFileSystem);\n                }\n                else\n                {\n                    OutputFileSystem = CreateFileSystem(Directory.GetParent(Arguments[0]).FullName);\n                    GetByDirectoryPath(OutputFileSystem);\n                }\n            }\n            catch (Exception e)\n            {\n                Console.WriteError(e.Message);\n            }\n        }\n\n        private void GetByDirectoryPath(IFileSystem baseFileSystem)\n        {\n            if (baseFileSystem.DirectoryExists(Arguments[0]))\n            {\n                var repositoryGroupManager = new RepositoryGroupManager(Arguments[0], baseFileSystem);\n                var repositoryManagers = new ConcurrentBag<RepositoryManager>(repositoryGroupManager.RepositoryManagers);\n\n                var totalTime = new Stopwatch();\n                totalTime.Start();\n\n                int totalPackageUpdates = 0;\n\n                bool exitWithFailure = false;\n                Array.ForEach(repositoryManagers.ToArray(), (repositoryManager) =>\n                    {\n                        string packagesConfigDiretory = null;\n\n                        if (repositoryManager.RepositoryConfig.Directory != null)\n                            packagesConfigDiretory = repositoryManager.RepositoryConfig.Directory.FullName;\n                        \n                        using (var packageAggregator = new PackageAggregator(baseFileSystem, repositoryManager, new PackageEnumerator()))\n                        {\n                            packageAggregator.Compute((min, max) =>\n                                {\n                                    totalPackageUpdates += Convert.ToInt16(min);\n                                    Console.WriteLine(\"Getting {0} distinct packages from a total of {1} from {2}\",min, max,repositoryManager.RepositoryConfig.FullName);\n                                },\n                                Latest ? PackageReferenceEqualityComparer.IdAndAllowedVersions : PackageReferenceEqualityComparer.IdVersionAndAllowedVersions , new PackageReferenceSetResolver());\n\n                            if (packageAggregator.PackageResolveFailures.Any())\n                            {\n                                LogAllPackageConstraintSatisfactionErrors(repositoryGroupManager, packageAggregator);\n                                exitWithFailure = true;\n                            }\n                            else\n                            {\n                                var tempPackageConfig = packageAggregator.Save(packagesConfigDiretory);\n                                InstallPackagesFromConfigFile(packagesConfigDiretory, GetPackageReferenceFile(baseFileSystem, tempPackageConfig.FullName));\n                            }\n                        }\n                    });\n\n                totalTime.Stop();\n                if (exitWithFailure)\n                {\n                    Console.WriteError(string.Format(\"Failed : {0} package directories, {1} packages in {2} seconds\",\n                                                     repositoryManagers.Count, totalPackageUpdates,\n                                                     totalTime.Elapsed.TotalSeconds));\n                    Environment.Exit(1);\n                }\n                else\n                {\n                    Console.WriteLine(string.Format(\"Updated : {0} package directories, {1} packages in {2} seconds\",\n                                                    repositoryManagers.Count, totalPackageUpdates,\n                                                    totalTime.Elapsed.TotalSeconds));\n                }\n            }\n        }\n\n        private void GetByPackagesConfig(IFileSystem fileSystem)\n        {\n            if (fileSystem.FileExists(Arguments[0]))\n            {\n                \/\/Try and infer the output directory if it is null\n                OutputDirectory = OutputDirectory ?? ResolvePackagesDirectory(fileSystem, Path.GetDirectoryName(Arguments[0]));\n\n                if (!string.IsNullOrEmpty(OutputDirectory))\n                    InstallPackagesFromConfigFile(OutputDirectory, GetPackageReferenceFile(fileSystem, Arguments[0]));\n                else\n                    Console.WriteError(string.Format(\"Could not find packages directory based on {0}\", Arguments[0]));\n            }\n            else\n            {\n                Console.WriteError(String.Format(\"Could not find file : {0}\", Arguments[0]));\n            }\n        }\n\n        private string ResolvePackagesDirectory(IFileSystem fileSystem, string parentPath)\n        {\n            var possiblePackagesPath = Path.Combine(parentPath, \"packages\");\n            if (fileSystem.DirectoryExists(possiblePackagesPath))\n                return possiblePackagesPath;\n\n            if (Path.GetPathRoot(parentPath) == parentPath)\n                return null;\n\n            return ResolvePackagesDirectory(fileSystem, Directory.GetParent(parentPath).FullName);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Logs all package constraint satisfaction errors.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"repositoryGroupManager\">The repository group manager.<\/param>\n        \/\/\/ <param name=\"packageAggregator\">The package aggregator.<\/param>\n        private void LogAllPackageConstraintSatisfactionErrors(RepositoryGroupManager repositoryGroupManager, PackageAggregator packageAggregator)\n        {\n            \/\/HACK #UGLY #WTF There must be a better way....\n            foreach (var p in packageAggregator.PackageResolveFailures)\n            {\n                foreach (var rp in repositoryGroupManager.RepositoryManagers)\n                {\n                    foreach (var prf in rp.PackageReferenceFiles)\n                    {\n                        if (prf.GetPackageReferences().Contains(p))\n                        {\n                            LogSatisfactionFailure(p, prf);\n                        }\n                    }\n                }\n            }\n        }\n\n        \/\/TODO HACK HACK #WTF #EVIL Check the access to a private property.  This requires a change to the PackageReferenceFile otherwise, which would take a long time.....\n        \/\/\/ <summary>\n        \/\/\/ Logs the satisfaction failure.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"p\">The p.<\/param>\n        \/\/\/ <param name=\"prf\">The PRF.<\/param>\n        private void LogSatisfactionFailure(PackageReference p, PackageReferenceFile prf)\n        {\n            Console.WriteError(\"{0} {1}{2} in {3} could not be satisfied.\", p.Id, p.Version, p.VersionConstraint != null ? \" using constraint \" + p.VersionConstraint : string.Empty, GetPackageConfigLocationUsingUltimateEvil(prf));\n        }\n\n        private static string GetPackageConfigLocationUsingUltimateEvil(PackageReferenceFile prf)\n        {\n            var blah = prf.GetPrivateProperty<IFileSystem>(\"FileSystem\");\n            return blah.GetFullPath(prf.GetPrivateField<string>(\"_path\"));\n        }\n\n        protected virtual PackageReferenceFile GetPackageReferenceFile(IFileSystem filesystem, string path)\n        {\n            return new PackageReferenceFile(filesystem, path);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the repository.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns><\/returns>\n        private IPackageRepository GetRepository()\n        {\n            var repository = AggregateRepositoryHelper.CreateAggregateRepositoryFromSources(RepositoryFactory, SourceProvider, Source);\n            bool ignoreFailingRepositories = repository.IgnoreFailingRepositories;\n            if (!NoCache)\n            {\n                repository = new AggregateRepository(new[] { CacheRepository, repository }){ IgnoreFailingRepositories = ignoreFailingRepositories, Logger = Console};\n            }\n            repository.Logger = Console;\n            return repository;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Installs the packages from config file.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"fileSystem\">The file system.<\/param>\n        \/\/\/ <param name=\"file\">The file.<\/param>\n        private void InstallPackagesFromConfigFile(string packagesDirectory, PackageReferenceFile file)\n        {\n            var packageReferences = file.GetPackageReferences().ToList();\n\n            \/\/We need to create a damn filesystem at the packages directory, so that the ROOT is correct.  Ahuh...\n            var fileSystem = CreateFileSystem(packagesDirectory);\n\n            if (!NoCache)\n                Console.WriteLine(\"Using cache....\");\n            PackageManager packageManager = CreatePackageManager(fileSystem, useMachineCache: !NoCache);\n\n            if (Clean)\n                packageManager.CleanPackageFolders();\n\n            bool installedAny = false;\n            foreach (var packageReference in packageReferences)\n            {\n                if (String.IsNullOrEmpty(packageReference.Id))\n                {\n                    \/\/ GetPackageReferences returns all records without validating values. We'll throw if we encounter packages\n                    \/\/ with malformed ids \/ Versions.\n                    throw new InvalidDataException(String.Format(CultureInfo.CurrentCulture, GetResources.GetCommandInvalidPackageReference, Arguments[0]));\n                }\n                else if (packageReference.Version == null)\n                {\n                    throw new InvalidDataException(String.Format(CultureInfo.CurrentCulture, GetResources.GetCommandPackageReferenceInvalidVersion, packageReference.Id));\n                }\n\n                IPackage package = _packageResolutionManager.ResolveLatestInstallablePackage(_repository, packageReference);\n                if (package == null)\n                {\n                    SemanticVersion version = _packageResolutionManager.ResolveInstallableVersion(_repository, packageReference);\n                    installedAny |= InstallPackage(packageManager, fileSystem, packageReference.Id, version ?? packageReference.Version);\n                }\n                else\n                {\n                    \/\/We got it straight from the server, check whether we get a cache hit, else just install\n                    var resolvedPackage = _packageResolutionManager.FindPackageInAllLocalSources(packageManager.LocalRepository, packageManager.SourceRepository, package);\n                    packageManager.InstallPackage(resolvedPackage ?? package, true, false);\n                }\n                \/\/ Note that we ignore dependencies here because packages.config already contains the full closure\n            }\n\n            if (!installedAny && packageReferences.Any())\n            {\n                Console.WriteLine(GetResources.GetCommandNothingToInstall, Constants.PackageReferenceFile);\n            }\n        }\n\n\n        \/\/\/ <summary>\n        \/\/\/ Installs the package.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"packageManager\">The package manager.<\/param>\n        \/\/\/ <param name=\"fileSystem\">The file system.<\/param>\n        \/\/\/ <param name=\"packageId\">The package id.<\/param>\n        \/\/\/ <param name=\"version\">The version.<\/param>\n        \/\/\/ <param name=\"allowPreReleaseVersion\"> <\/param>\n        \/\/\/ <returns><\/returns>\n        internal bool InstallPackage(PackageManager packageManager, IFileSystem fileSystem, string packageId, SemanticVersion version, Boolean allowPreReleaseVersion = true)\n        {\n            if (packageManager.IsPackageInstalled(packageId, version))\n            {\n                return false;\n            }\n\n            if (!AllowMultipleVersions)\n            {\n                var installedPackage = packageManager.LocalRepository.FindPackage(packageId);\n                if (installedPackage != null)\n                {\n                    if (version != null && installedPackage.Version >= version)\n                    {\n                        \/\/ If the package is already installed (or the version being installed is lower), then we do not need to do anything. \n                        return false;\n                    }\n                    else if (packageManager.SourceRepository.Exists(packageId, version))\n                    {\n                        \/\/ If the package is already installed, but\n                        \/\/ (a) the version we require is different from the one that is installed, \n                        \/\/ (b) side-by-side is disabled\n                        \/\/ we need to uninstall it.\n                        \/\/ However, before uninstalling, make sure the package exists in the source repository. \n                        packageManager.UninstallPackage(installedPackage, forceRemove: true, removeDependencies: false);\n                    }\n                }\n            }\n            \/\/TODO Will need to expose the last boolean here......\n            var package = _packageResolutionManager.ResolvePackage(packageManager.LocalRepository, _repository, packageId, version, allowPreReleaseVersion);\n            packageManager.InstallPackage(package, ignoreDependencies: !IncludeDependencies, allowPrereleaseVersions: allowPreReleaseVersion);\n            \/\/packageManager.InstallPackage(packageId, version, !IncludeDependencies, allowPreReleaseVersion);\n            return true;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Creates the package manager.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"fileSystem\">The file system.<\/param>\n        \/\/\/ <param name=\"useMachineCache\">if set to <c>true<\/c> [use machine cache].<\/param>\n        \/\/\/ <returns><\/returns>\n        protected virtual PackageManager CreatePackageManager(IFileSystem fileSystem, bool useMachineCache = false)\n        {\n            var pathResolver = new DefaultPackagePathResolver(fileSystem, useSideBySidePaths: AllowMultipleVersions);\n            var packageManager = new PackageManager(_repository, pathResolver, fileSystem, new LocalPackageRepository(pathResolver, fileSystem));\n            packageManager.Logger = Console;\n\n            return packageManager;\n        }\n\n        protected virtual IFileSystem CreateFileSystem(string pathRoot)\n        {\n            \/\/ Use the passed in install path if any, and default to the current dir\n            return new PhysicalFileSystem(pathRoot);\n        }\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}
{"commit":"dde2577041444a6ad149b1a87cca8eba3e2848b4","subject":"Quick fix to ensure that the output packages.config has been updated when we are using a -latest flag","message":"Quick fix to ensure that the output packages.config has been updated when we are using a -latest flag\n","repos":"BenPhegan\/NuGet.Extensions","old_file":"NuGet.Extensions\/Commands\/Get.cs","new_file":"NuGet.Extensions\/Commands\/Get.cs","new_contents":"\ufeffusing System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.ComponentModel.Composition;\nusing System.Diagnostics;\nusing System.Diagnostics.Contracts;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Runtime.CompilerServices;\nusing System.Xml.Linq;\nusing NuGet.Commands;\nusing NuGet.Common;\nusing NuGet.Extras.Comparers;\nusing NuGet.Extras.ExtensionMethods;\nusing NuGet.Extras.PackageReferences;\nusing NuGet.Extras.Packages;\nusing NuGet.Extras.Repositories;\nusing NuGet.Extras.Caches;\n\n\/\/HACK to enable us to test some of the Internal stuff more easily.  Still not sure how many kittens die when we use this.....\n[assembly: InternalsVisibleTo(\"NuGet.Extensions.Tests\")]\n\nnamespace NuGet.Extensions.Commands\n{\n    [Command(typeof(GetResources), \"get\", \"GetCommandDescription\", MinArgs = 1)]\n    public class Get : Command\n    {\n        private IPackageRepository _cacheRepository;\n        private readonly List<string> _sources = new List<string>();\n        private INuGetCacheManager _cacheManager;\n        protected IFileSystem OutputFileSystem;\n        private IPackageRepository _repository;\n        private IPackageResolutionManager _packageResolutionManager;\n        private IPackageCache _packageCache;\n        private string _baseDirectory;\n\n        [Option(typeof(GetResources), \"GetCommandSourceDescription\")]\n        public ICollection<string> Source\n        {\n            get { return _sources; }\n        }\n\n        [Option(typeof(GetResources), \"GetCommandOutputDirectoryDescription\")]\n        public string OutputDirectory { get; set; }\n\n        [Option(typeof(GetResources), \"GetCommandExcludeVersionDescription\", AltName = \"x\")]\n        public bool ExcludeVersion { get; set; }\n\n        [Option(typeof(GetResources), \"GetCommandLatestDescription\")]\n        public bool Latest { get; set; }\n\n        [Option(typeof(GetResources), \"GetCommandPrerelease\")]\n        public bool Prerelease { get; set; }\n\n        [Option(typeof(GetResources), \"GetCommandUseCacheDescription\")]\n        public bool NoCache { get; set; }\n\n        [Option(typeof(GetResources), \"GetCommandNoFeedSpecificCache\", AltName = \"nfsp\")]\n        public bool NoFeedSpecificCache { get; set; }\n\n        [Option(typeof(GetResources), \"GetCommandCleanDescription\")]\n        public bool Clean { get; set; }\n\n        [Option(typeof(GetResources), \"GetCommandIncludeDependenciesDescription\", AltName = \"r\")]\n        public bool IncludeDependencies { get; set; }\n\n        [Option(\"Output TeamCity compatible nuget.xml file for NuGet install details.\", AltName = \"t\")]\n        public bool TeamCityNugetXml { get; set; }\n\n        [Option(\"Output directory for the TeamCity compatible nuget.xml file.\", AltName = \"to\")]\n        public string TeamCityNuGetXmlOutputDirectory { get; set; }\n\n        public IPackageRepositoryFactory RepositoryFactory { get; private set; }\n\n        public IPackageSourceProvider SourceProvider { get; private set; }\n\n        \/\/\/ <remarks>\n        \/\/\/ Meant for unit testing.\n        \/\/\/ <\/remarks>\n        protected IPackageRepository CacheRepository\n        {\n            get { return _cacheRepository; }\n        }\n\n        public string BaseDirectory\n        {\n            get { return _baseDirectory; }\n            set { _baseDirectory = value; }\n        }\n\n        private bool AllowMultipleVersions\n        {\n            get { return !ExcludeVersion; }\n        }\n\n        [ImportingConstructor]\n        public Get(IPackageRepositoryFactory packageRepositoryFactory, IPackageSourceProvider sourceProvider)\n        {\n            Contract.Assert(packageRepositoryFactory != null);\n            Contract.Assert(sourceProvider != null);\n\n            RepositoryFactory = packageRepositoryFactory;\n            SourceProvider = sourceProvider;\n        }\n\n        public Get(IPackageRepositoryFactory packageRepositoryFactory, IPackageSourceProvider sourceProvider, IPackageRepository cacheRepository, IFileSystem fileSystem, IPackageCache packageCache)\n            :this(packageRepositoryFactory, sourceProvider)\n        {\n            _cacheRepository = cacheRepository;\n            OutputFileSystem = fileSystem;\n            _packageCache = packageCache;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the command.\n        \/\/\/ <\/summary>\n        public override void ExecuteCommand()\n        {\n            \/\/Probably need some better return code logic here...\n            if (Arguments[0] == null) return;\n            try\n            {\n                if (Source.Count == 1 && !NoFeedSpecificCache && !NoCache)\n                {\n                    _cacheManager = new NuGetCacheManager(Console);\n                    _cacheManager.SetFeedSpecificCacheDirectory(_sources[0]);\n                }\n\n                if (!NoCache)\n                    if (_cacheRepository == null)\n                        _cacheRepository = MachineCache.Default;\n\n                \/\/TODO This needs injecting....\n                if (_packageCache == null)\n                    _packageCache = new MemoryBasedPackageCache(Console);\n\n                _repository = GetRepository();\n                _packageResolutionManager = new PackageResolutionManager(Console, Latest, _packageCache);\n\n                \/\/HACK need to inject somehow...\n                _packageResolutionManager = _packageResolutionManager ?? new PackageResolutionManager(Console, Latest, new MemoryBasedPackageCache(Console));\n\n                \/\/Working on a package.config\n                if (string.IsNullOrEmpty(_baseDirectory))\n                    _baseDirectory = Environment.CurrentDirectory;\n\n                var target = Arguments[0] == Path.GetFullPath(Arguments[0]) ? Arguments[0] : Path.GetFullPath(Path.Combine(_baseDirectory, Arguments[0]));\n                if (Path.GetFileName(target).Equals(Constants.PackageReferenceFile, StringComparison.OrdinalIgnoreCase))\n                {\n                    OutputFileSystem = CreateFileSystem(Path.GetPathRoot(target));\n                    GetByPackagesConfig(OutputFileSystem, target);\n                }\n                else\n                {\n                    OutputFileSystem = CreateFileSystem(Directory.GetParent(target).FullName);\n                    GetByDirectoryPath(OutputFileSystem, target);\n                }\n            }\n            catch (Exception e)\n            {\n                \/\/HACK big catch here, but if anything goes wrong we want to log it and ensure a non-zero exit code...\n                throw new CommandLineException(String.Format(\"GET Failed: {0}\",e.Message),e);\n            }\n        }\n\n        private void GetByDirectoryPath(IFileSystem baseFileSystem, string target)\n        {\n            if (baseFileSystem.DirectoryExists(target))\n            {\n                var repositoryGroupManager = new RepositoryGroupManager(target, baseFileSystem);\n                var repositoryManagers = new ConcurrentBag<RepositoryManager>(repositoryGroupManager.RepositoryManagers);\n\n                var totalTime = new Stopwatch();\n                totalTime.Start();\n\n                int totalPackageUpdates = 0;\n\n                bool exitWithFailure = false;\n                Array.ForEach(repositoryManagers.ToArray(), (repositoryManager) =>\n                    {\n                        string packagesConfigDiretory = null;\n\n                        if (repositoryManager.RepositoryConfig.Directory != null)\n                            packagesConfigDiretory = repositoryManager.RepositoryConfig.Directory.FullName;\n                        \n                        using (var packageAggregator = new PackageAggregator(baseFileSystem, repositoryManager, new PackageEnumerator()))\n                        {\n                            packageAggregator.Compute((min, max) =>\n                                {\n                                    totalPackageUpdates += Convert.ToInt16(min);\n                                    Console.WriteLine(\"Getting {0} distinct packages from a total of {1} from {2}\",min, max,repositoryManager.RepositoryConfig.FullName);\n                                },\n                                Latest ? PackageReferenceEqualityComparer.IdAndAllowedVersions : PackageReferenceEqualityComparer.IdVersionAndAllowedVersions , new PackageReferenceSetResolver());\n\n                            if (packageAggregator.PackageResolveFailures.Any())\n                            {\n                                LogAllPackageConstraintSatisfactionErrors(repositoryGroupManager, packageAggregator);\n                                exitWithFailure = true;\n                            }\n                            else\n                            {\n                                var tempPackageConfig = packageAggregator.Save(packagesConfigDiretory);\n                                InstallPackagesFromConfigFile(packagesConfigDiretory, GetPackageReferenceFile(baseFileSystem, tempPackageConfig.FullName), target);\n                                if (TeamCityNugetXml)\n                                    SaveNuGetXml(tempPackageConfig, TeamCityNuGetXmlOutputDirectory);\n                            }\n                        }\n                    });\n\n                totalTime.Stop();\n\n                if (exitWithFailure)\n                {\n                    var errorMessage = string.Format(\"Failed : {0} package directories, {1} packages in {2} seconds\",\n                                                     repositoryManagers.Count, totalPackageUpdates,\n                                                     totalTime.Elapsed.TotalSeconds);\n                    throw new CommandLineException(errorMessage);\n                }\n\n                Console.WriteLine(string.Format(\"Updated : {0} package directories, {1} packages in {2} seconds\",\n                                                    repositoryManagers.Count, totalPackageUpdates,\n                                                    totalTime.Elapsed.TotalSeconds));\n            }\n        }\n\n        private static void SaveNuGetXml(FileInfo packageConfig, string outputDirectory = null)\n        {\n            var packageConfigXml = XElement.Load(packageConfig.FullName);\n            var nugetXml = new XDocument(new XElement(\"nuget-dependencies\"));\n            nugetXml.Root.Add(new XElement(\"sources\"));\n            nugetXml.Root.Add(packageConfigXml);\n            if (string.IsNullOrEmpty(outputDirectory))\n                nugetXml.Save(\"nuget.xml\");\n            else\n            {\n                if (!Directory.Exists(outputDirectory))\n                    Directory.CreateDirectory(outputDirectory);\n                nugetXml.Save(Path.Combine(outputDirectory, \"nuget.xml\"));\n            }\n        }\n\n        private void GetByPackagesConfig(IFileSystem fileSystem, string target)\n        {\n            if (fileSystem.FileExists(target))\n            {\n                \/\/Try and infer the output directory if it is null\n                OutputDirectory = OutputDirectory ?? ResolvePackagesDirectory(fileSystem, Path.GetDirectoryName(target));\n\n                if (!string.IsNullOrEmpty(OutputDirectory))\n                    InstallPackagesFromConfigFile(OutputDirectory, GetPackageReferenceFile(fileSystem, target), target);\n                else\n                    Console.WriteError(string.Format(\"Could not find packages directory based on {0}\", target));\n            }\n            else\n            {\n                Console.WriteError(String.Format(\"Could not find file : {0}\", target));\n            }\n        }\n\n        private string ResolvePackagesDirectory(IFileSystem fileSystem, string parentPath)\n        {\n            var possiblePackagesPath = Path.Combine(parentPath, \"packages\");\n            if (fileSystem.DirectoryExists(possiblePackagesPath))\n                return possiblePackagesPath;\n\n            if (Path.GetPathRoot(parentPath) == parentPath)\n                return null;\n\n            return ResolvePackagesDirectory(fileSystem, Directory.GetParent(parentPath).FullName);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Logs all package constraint satisfaction errors.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"repositoryGroupManager\">The repository group manager.<\/param>\n        \/\/\/ <param name=\"packageAggregator\">The package aggregator.<\/param>\n        private void LogAllPackageConstraintSatisfactionErrors(RepositoryGroupManager repositoryGroupManager, PackageAggregator packageAggregator)\n        {\n            \/\/HACK #UGLY #WTF There must be a better way....\n            foreach (var p in packageAggregator.PackageResolveFailures)\n            {\n                foreach (var rp in repositoryGroupManager.RepositoryManagers)\n                {\n                    foreach (var prf in rp.PackageReferenceFiles)\n                    {\n                        if (prf.GetPackageReferences().Contains(p))\n                        {\n                            LogSatisfactionFailure(p, prf);\n                        }\n                    }\n                }\n            }\n        }\n\n        \/\/TODO HACK HACK #WTF #EVIL Check the access to a private property.  This requires a change to the PackageReferenceFile otherwise, which would take a long time.....\n        \/\/\/ <summary>\n        \/\/\/ Logs the satisfaction failure.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"p\">The p.<\/param>\n        \/\/\/ <param name=\"prf\">The PRF.<\/param>\n        private void LogSatisfactionFailure(PackageReference p, PackageReferenceFile prf)\n        {\n            Console.WriteError(\"{0} {1}{2} in {3} could not be satisfied.\", p.Id, p.Version, p.VersionConstraint != null ? \" using constraint \" + p.VersionConstraint : string.Empty, GetPackageConfigLocationUsingUltimateEvil(prf));\n        }\n\n        private static string GetPackageConfigLocationUsingUltimateEvil(PackageReferenceFile prf)\n        {\n            var blah = prf.GetPrivateProperty<IFileSystem>(\"FileSystem\");\n            return blah.GetFullPath(prf.GetPrivateField<string>(\"_path\"));\n        }\n\n        protected virtual PackageReferenceFile GetPackageReferenceFile(IFileSystem filesystem, string path)\n        {\n            return new PackageReferenceFile(filesystem, path);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the repository.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns><\/returns>\n        private IPackageRepository GetRepository()\n        {\n            var repository = AggregateRepositoryHelper.CreateAggregateRepositoryFromSources(RepositoryFactory, SourceProvider, Source);\n            bool ignoreFailingRepositories = repository.IgnoreFailingRepositories;\n            if (!NoCache)\n            {\n                repository = new AggregateRepository(new[] { CacheRepository, repository }){ IgnoreFailingRepositories = ignoreFailingRepositories, Logger = Console};\n            }\n            repository.Logger = Console;\n            return repository;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Installs the packages from config file.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"fileSystem\">The file system.<\/param>\n        \/\/\/ <param name=\"file\">The file.<\/param>\n        \/\/\/ <param name=\"target\"> <\/param>\n        private void InstallPackagesFromConfigFile(string packagesDirectory, PackageReferenceFile file, string target)\n        {\n            var packageReferences = file.GetPackageReferences().ToList();\n            var installedPackages = new List<PackageReference>();\n\n            \/\/We need to create a damn filesystem at the packages directory, so that the ROOT is correct.  Ahuh...\n            var fileSystem = CreateFileSystem(packagesDirectory);\n\n            if (!NoCache)\n                Console.WriteLine(\"Using cache....\");\n            PackageManager packageManager = CreatePackageManager(fileSystem, useMachineCache: !NoCache);\n\n            if (Clean)\n                packageManager.CleanPackageFolders();\n\n            bool installedAny = false;\n            foreach (var packageReference in packageReferences)\n            {\n                if (String.IsNullOrEmpty(packageReference.Id))\n                {\n                    \/\/ GetPackageReferences returns all records without validating values. We'll throw if we encounter packages\n                    \/\/ with malformed ids \/ Versions.\n                    throw new InvalidDataException(String.Format(CultureInfo.CurrentCulture, GetResources.GetCommandInvalidPackageReference, target));\n                }\n                else if (packageReference.Version == null)\n                {\n                    throw new InvalidDataException(String.Format(CultureInfo.CurrentCulture, GetResources.GetCommandPackageReferenceInvalidVersion, packageReference.Id));\n                }\n\n                IPackage package = _packageResolutionManager.ResolveLatestInstallablePackage(_repository, packageReference);\n                if (package == null)\n                {\n                    SemanticVersion version = _packageResolutionManager.ResolveInstallableVersion(_repository, packageReference);\n                    installedAny |= InstallPackage(packageManager, fileSystem, packageReference.Id, version ?? packageReference.Version);\n                    installedPackages.Add(new PackageReference(packageReference.Id, version ?? packageReference.Version, null));\n                }\n                else\n                {\n                    \/\/We got it straight from the server, check whether we get a cache hit, else just install\n                    var resolvedPackage = _packageResolutionManager.FindPackageInAllLocalSources(packageManager.LocalRepository, packageManager.SourceRepository, package);\n                    packageManager.InstallPackage(resolvedPackage ?? package, !IncludeDependencies, false);\n                    installedPackages.Add(new PackageReference(package.Id, resolvedPackage != null ? resolvedPackage.Version : package.Version, null));\n                }\n                \/\/ Note that we ignore dependencies here because packages.config already contains the full closure\n            }\n\n            if (!installedAny && packageReferences.Any())\n            {\n                Console.WriteLine(GetResources.GetCommandNothingToInstall, Constants.PackageReferenceFile);\n            }\n            \n            if (packageReferences != installedPackages)\n            {\n                foreach (var reference in file.GetPackageReferences())\n                    file.DeleteEntry(reference.Id, reference.Version);\n                foreach (var installedPackage in installedPackages)\n                {\n                    file.AddEntry(installedPackage.Id,installedPackage.Version);\n                }\n            }\n        }\n\n\n        \/\/\/ <summary>\n        \/\/\/ Installs the package.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"packageManager\">The package manager.<\/param>\n        \/\/\/ <param name=\"fileSystem\">The file system.<\/param>\n        \/\/\/ <param name=\"packageId\">The package id.<\/param>\n        \/\/\/ <param name=\"version\">The version.<\/param>\n        \/\/\/ <param name=\"allowPreReleaseVersion\"> <\/param>\n        \/\/\/ <returns><\/returns>\n        internal bool InstallPackage(PackageManager packageManager, IFileSystem fileSystem, string packageId, SemanticVersion version, Boolean allowPreReleaseVersion = true)\n        {\n            if (packageManager.IsPackageInstalled(packageId, version))\n            {\n                return false;\n            }\n\n            if (!AllowMultipleVersions)\n            {\n                var installedPackage = packageManager.LocalRepository.FindPackage(packageId);\n                if (installedPackage != null)\n                {\n                    if (version != null && installedPackage.Version >= version)\n                    {\n                        \/\/ If the package is already installed (or the version being installed is lower), then we do not need to do anything. \n                        return false;\n                    }\n                    else if (packageManager.SourceRepository.Exists(packageId, version))\n                    {\n                        \/\/ If the package is already installed, but\n                        \/\/ (a) the version we require is different from the one that is installed, \n                        \/\/ (b) side-by-side is disabled\n                        \/\/ we need to uninstall it.\n                        \/\/ However, before uninstalling, make sure the package exists in the source repository. \n                        packageManager.UninstallPackage(installedPackage, forceRemove: true, removeDependencies: false);\n                    }\n                }\n            }\n            \/\/TODO Will need to expose the last boolean here......\n            var package = _packageResolutionManager.ResolvePackage(packageManager.LocalRepository, _repository, packageId, version, allowPreReleaseVersion);\n            packageManager.InstallPackage(package, ignoreDependencies: !IncludeDependencies, allowPrereleaseVersions: allowPreReleaseVersion);\n            \/\/packageManager.InstallPackage(packageId, version, !IncludeDependencies, allowPreReleaseVersion);\n            return true;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Creates the package manager.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"fileSystem\">The file system.<\/param>\n        \/\/\/ <param name=\"useMachineCache\">if set to <c>true<\/c> [use machine cache].<\/param>\n        \/\/\/ <returns><\/returns>\n        protected virtual PackageManager CreatePackageManager(IFileSystem fileSystem, bool useMachineCache = false)\n        {\n            var pathResolver = new DefaultPackagePathResolver(fileSystem, useSideBySidePaths: AllowMultipleVersions);\n            var packageManager = new PackageManager(_repository, pathResolver, fileSystem, new LocalPackageRepository(pathResolver, fileSystem));\n            packageManager.Logger = Console;\n\n            return packageManager;\n        }\n\n        protected virtual IFileSystem CreateFileSystem(string pathRoot)\n        {\n            \/\/ Use the passed in install path if any, and default to the current dir\n            return new PhysicalFileSystem(pathRoot);\n        }\n    }\n}\n","old_contents":"\ufeffusing System;\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.ComponentModel.Composition;\nusing System.Diagnostics;\nusing System.Diagnostics.Contracts;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Runtime.CompilerServices;\nusing System.Xml.Linq;\nusing NuGet.Commands;\nusing NuGet.Common;\nusing NuGet.Extras.Comparers;\nusing NuGet.Extras.ExtensionMethods;\nusing NuGet.Extras.PackageReferences;\nusing NuGet.Extras.Packages;\nusing NuGet.Extras.Repositories;\nusing NuGet.Extras.Caches;\n\n\/\/HACK to enable us to test some of the Internal stuff more easily.  Still not sure how many kittens die when we use this.....\n[assembly: InternalsVisibleTo(\"NuGet.Extensions.Tests\")]\n\nnamespace NuGet.Extensions.Commands\n{\n    [Command(typeof(GetResources), \"get\", \"GetCommandDescription\", MinArgs = 1)]\n    public class Get : Command\n    {\n        private IPackageRepository _cacheRepository;\n        private readonly List<string> _sources = new List<string>();\n        private INuGetCacheManager _cacheManager;\n        protected IFileSystem OutputFileSystem;\n        private IPackageRepository _repository;\n        private IPackageResolutionManager _packageResolutionManager;\n        private IPackageCache _packageCache;\n        private string _baseDirectory;\n\n        [Option(typeof(GetResources), \"GetCommandSourceDescription\")]\n        public ICollection<string> Source\n        {\n            get { return _sources; }\n        }\n\n        [Option(typeof(GetResources), \"GetCommandOutputDirectoryDescription\")]\n        public string OutputDirectory { get; set; }\n\n        [Option(typeof(GetResources), \"GetCommandExcludeVersionDescription\", AltName = \"x\")]\n        public bool ExcludeVersion { get; set; }\n\n        [Option(typeof(GetResources), \"GetCommandLatestDescription\")]\n        public bool Latest { get; set; }\n\n        [Option(typeof(GetResources), \"GetCommandPrerelease\")]\n        public bool Prerelease { get; set; }\n\n        [Option(typeof(GetResources), \"GetCommandUseCacheDescription\")]\n        public bool NoCache { get; set; }\n\n        [Option(typeof(GetResources), \"GetCommandNoFeedSpecificCache\", AltName = \"nfsp\")]\n        public bool NoFeedSpecificCache { get; set; }\n\n        [Option(typeof(GetResources), \"GetCommandCleanDescription\")]\n        public bool Clean { get; set; }\n\n        [Option(typeof(GetResources), \"GetCommandIncludeDependenciesDescription\", AltName = \"r\")]\n        public bool IncludeDependencies { get; set; }\n\n        [Option(\"Output TeamCity compatible nuget.xml file for NuGet install details.\", AltName = \"t\")]\n        public bool TeamCityNugetXml { get; set; }\n\n        [Option(\"Output directory for the TeamCity compatible nuget.xml file.\", AltName = \"to\")]\n        public string TeamCityNuGetXmlOutputDirectory { get; set; }\n\n        public IPackageRepositoryFactory RepositoryFactory { get; private set; }\n\n        public IPackageSourceProvider SourceProvider { get; private set; }\n\n        \/\/\/ <remarks>\n        \/\/\/ Meant for unit testing.\n        \/\/\/ <\/remarks>\n        protected IPackageRepository CacheRepository\n        {\n            get { return _cacheRepository; }\n        }\n\n        public string BaseDirectory\n        {\n            get { return _baseDirectory; }\n            set { _baseDirectory = value; }\n        }\n\n        private bool AllowMultipleVersions\n        {\n            get { return !ExcludeVersion; }\n        }\n\n        [ImportingConstructor]\n        public Get(IPackageRepositoryFactory packageRepositoryFactory, IPackageSourceProvider sourceProvider)\n        {\n            Contract.Assert(packageRepositoryFactory != null);\n            Contract.Assert(sourceProvider != null);\n\n            RepositoryFactory = packageRepositoryFactory;\n            SourceProvider = sourceProvider;\n        }\n\n        public Get(IPackageRepositoryFactory packageRepositoryFactory, IPackageSourceProvider sourceProvider, IPackageRepository cacheRepository, IFileSystem fileSystem, IPackageCache packageCache)\n            :this(packageRepositoryFactory, sourceProvider)\n        {\n            _cacheRepository = cacheRepository;\n            OutputFileSystem = fileSystem;\n            _packageCache = packageCache;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Executes the command.\n        \/\/\/ <\/summary>\n        public override void ExecuteCommand()\n        {\n            \/\/Probably need some better return code logic here...\n            if (Arguments[0] == null) return;\n            try\n            {\n                if (Source.Count == 1 && !NoFeedSpecificCache && !NoCache)\n                {\n                    _cacheManager = new NuGetCacheManager(Console);\n                    _cacheManager.SetFeedSpecificCacheDirectory(_sources[0]);\n                }\n\n                if (!NoCache)\n                    if (_cacheRepository == null)\n                        _cacheRepository = MachineCache.Default;\n\n                \/\/TODO This needs injecting....\n                if (_packageCache == null)\n                    _packageCache = new MemoryBasedPackageCache(Console);\n\n                _repository = GetRepository();\n                _packageResolutionManager = new PackageResolutionManager(Console, Latest, _packageCache);\n\n                \/\/HACK need to inject somehow...\n                _packageResolutionManager = _packageResolutionManager ?? new PackageResolutionManager(Console, Latest, new MemoryBasedPackageCache(Console));\n\n                \/\/Working on a package.config\n                if (string.IsNullOrEmpty(_baseDirectory))\n                    _baseDirectory = Environment.CurrentDirectory;\n\n                var target = Arguments[0] == Path.GetFullPath(Arguments[0]) ? Arguments[0] : Path.GetFullPath(Path.Combine(_baseDirectory, Arguments[0]));\n                if (Path.GetFileName(target).Equals(Constants.PackageReferenceFile, StringComparison.OrdinalIgnoreCase))\n                {\n                    OutputFileSystem = CreateFileSystem(Path.GetPathRoot(target));\n                    GetByPackagesConfig(OutputFileSystem, target);\n                }\n                else\n                {\n                    OutputFileSystem = CreateFileSystem(Directory.GetParent(target).FullName);\n                    GetByDirectoryPath(OutputFileSystem, target);\n                }\n            }\n            catch (Exception e)\n            {\n                \/\/HACK big catch here, but if anything goes wrong we want to log it and ensure a non-zero exit code...\n                throw new CommandLineException(String.Format(\"GET Failed: {0}\",e.Message),e);\n            }\n        }\n\n        private void GetByDirectoryPath(IFileSystem baseFileSystem, string target)\n        {\n            if (baseFileSystem.DirectoryExists(target))\n            {\n                var repositoryGroupManager = new RepositoryGroupManager(target, baseFileSystem);\n                var repositoryManagers = new ConcurrentBag<RepositoryManager>(repositoryGroupManager.RepositoryManagers);\n\n                var totalTime = new Stopwatch();\n                totalTime.Start();\n\n                int totalPackageUpdates = 0;\n\n                bool exitWithFailure = false;\n                Array.ForEach(repositoryManagers.ToArray(), (repositoryManager) =>\n                    {\n                        string packagesConfigDiretory = null;\n\n                        if (repositoryManager.RepositoryConfig.Directory != null)\n                            packagesConfigDiretory = repositoryManager.RepositoryConfig.Directory.FullName;\n                        \n                        using (var packageAggregator = new PackageAggregator(baseFileSystem, repositoryManager, new PackageEnumerator()))\n                        {\n                            packageAggregator.Compute((min, max) =>\n                                {\n                                    totalPackageUpdates += Convert.ToInt16(min);\n                                    Console.WriteLine(\"Getting {0} distinct packages from a total of {1} from {2}\",min, max,repositoryManager.RepositoryConfig.FullName);\n                                },\n                                Latest ? PackageReferenceEqualityComparer.IdAndAllowedVersions : PackageReferenceEqualityComparer.IdVersionAndAllowedVersions , new PackageReferenceSetResolver());\n\n                            if (packageAggregator.PackageResolveFailures.Any())\n                            {\n                                LogAllPackageConstraintSatisfactionErrors(repositoryGroupManager, packageAggregator);\n                                exitWithFailure = true;\n                            }\n                            else\n                            {\n                                var tempPackageConfig = packageAggregator.Save(packagesConfigDiretory);\n                                if (TeamCityNugetXml)\n                                    SaveNuGetXml(tempPackageConfig,TeamCityNuGetXmlOutputDirectory);\n                                InstallPackagesFromConfigFile(packagesConfigDiretory, GetPackageReferenceFile(baseFileSystem, tempPackageConfig.FullName), target);\n                            }\n                        }\n                    });\n\n                totalTime.Stop();\n\n                if (exitWithFailure)\n                {\n                    var errorMessage = string.Format(\"Failed : {0} package directories, {1} packages in {2} seconds\",\n                                                     repositoryManagers.Count, totalPackageUpdates,\n                                                     totalTime.Elapsed.TotalSeconds);\n                    throw new CommandLineException(errorMessage);\n                }\n\n                Console.WriteLine(string.Format(\"Updated : {0} package directories, {1} packages in {2} seconds\",\n                                                    repositoryManagers.Count, totalPackageUpdates,\n                                                    totalTime.Elapsed.TotalSeconds));\n            }\n        }\n\n        private static void SaveNuGetXml(FileInfo packageConfig, string outputDirectory = null)\n        {\n            var packageConfigXml = XElement.Load(packageConfig.FullName);\n            var nugetXml = new XDocument(new XElement(\"nuget-dependencies\"));\n            nugetXml.Root.Add(new XElement(\"sources\"));\n            nugetXml.Root.Add(packageConfigXml);\n            if (string.IsNullOrEmpty(outputDirectory))\n                nugetXml.Save(\"nuget.xml\");\n            else\n            {\n                if (!Directory.Exists(outputDirectory))\n                    Directory.CreateDirectory(outputDirectory);\n                nugetXml.Save(Path.Combine(outputDirectory, \"nuget.xml\"));\n            }\n        }\n\n        private void GetByPackagesConfig(IFileSystem fileSystem, string target)\n        {\n            if (fileSystem.FileExists(target))\n            {\n                \/\/Try and infer the output directory if it is null\n                OutputDirectory = OutputDirectory ?? ResolvePackagesDirectory(fileSystem, Path.GetDirectoryName(target));\n\n                if (!string.IsNullOrEmpty(OutputDirectory))\n                    InstallPackagesFromConfigFile(OutputDirectory, GetPackageReferenceFile(fileSystem, target), target);\n                else\n                    Console.WriteError(string.Format(\"Could not find packages directory based on {0}\", target));\n            }\n            else\n            {\n                Console.WriteError(String.Format(\"Could not find file : {0}\", target));\n            }\n        }\n\n        private string ResolvePackagesDirectory(IFileSystem fileSystem, string parentPath)\n        {\n            var possiblePackagesPath = Path.Combine(parentPath, \"packages\");\n            if (fileSystem.DirectoryExists(possiblePackagesPath))\n                return possiblePackagesPath;\n\n            if (Path.GetPathRoot(parentPath) == parentPath)\n                return null;\n\n            return ResolvePackagesDirectory(fileSystem, Directory.GetParent(parentPath).FullName);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Logs all package constraint satisfaction errors.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"repositoryGroupManager\">The repository group manager.<\/param>\n        \/\/\/ <param name=\"packageAggregator\">The package aggregator.<\/param>\n        private void LogAllPackageConstraintSatisfactionErrors(RepositoryGroupManager repositoryGroupManager, PackageAggregator packageAggregator)\n        {\n            \/\/HACK #UGLY #WTF There must be a better way....\n            foreach (var p in packageAggregator.PackageResolveFailures)\n            {\n                foreach (var rp in repositoryGroupManager.RepositoryManagers)\n                {\n                    foreach (var prf in rp.PackageReferenceFiles)\n                    {\n                        if (prf.GetPackageReferences().Contains(p))\n                        {\n                            LogSatisfactionFailure(p, prf);\n                        }\n                    }\n                }\n            }\n        }\n\n        \/\/TODO HACK HACK #WTF #EVIL Check the access to a private property.  This requires a change to the PackageReferenceFile otherwise, which would take a long time.....\n        \/\/\/ <summary>\n        \/\/\/ Logs the satisfaction failure.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"p\">The p.<\/param>\n        \/\/\/ <param name=\"prf\">The PRF.<\/param>\n        private void LogSatisfactionFailure(PackageReference p, PackageReferenceFile prf)\n        {\n            Console.WriteError(\"{0} {1}{2} in {3} could not be satisfied.\", p.Id, p.Version, p.VersionConstraint != null ? \" using constraint \" + p.VersionConstraint : string.Empty, GetPackageConfigLocationUsingUltimateEvil(prf));\n        }\n\n        private static string GetPackageConfigLocationUsingUltimateEvil(PackageReferenceFile prf)\n        {\n            var blah = prf.GetPrivateProperty<IFileSystem>(\"FileSystem\");\n            return blah.GetFullPath(prf.GetPrivateField<string>(\"_path\"));\n        }\n\n        protected virtual PackageReferenceFile GetPackageReferenceFile(IFileSystem filesystem, string path)\n        {\n            return new PackageReferenceFile(filesystem, path);\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Gets the repository.\n        \/\/\/ <\/summary>\n        \/\/\/ <returns><\/returns>\n        private IPackageRepository GetRepository()\n        {\n            var repository = AggregateRepositoryHelper.CreateAggregateRepositoryFromSources(RepositoryFactory, SourceProvider, Source);\n            bool ignoreFailingRepositories = repository.IgnoreFailingRepositories;\n            if (!NoCache)\n            {\n                repository = new AggregateRepository(new[] { CacheRepository, repository }){ IgnoreFailingRepositories = ignoreFailingRepositories, Logger = Console};\n            }\n            repository.Logger = Console;\n            return repository;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Installs the packages from config file.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"fileSystem\">The file system.<\/param>\n        \/\/\/ <param name=\"file\">The file.<\/param>\n        \/\/\/ <param name=\"target\"> <\/param>\n        private void InstallPackagesFromConfigFile(string packagesDirectory, PackageReferenceFile file, string target)\n        {\n            var packageReferences = file.GetPackageReferences().ToList();\n\n            \/\/We need to create a damn filesystem at the packages directory, so that the ROOT is correct.  Ahuh...\n            var fileSystem = CreateFileSystem(packagesDirectory);\n\n            if (!NoCache)\n                Console.WriteLine(\"Using cache....\");\n            PackageManager packageManager = CreatePackageManager(fileSystem, useMachineCache: !NoCache);\n\n            if (Clean)\n                packageManager.CleanPackageFolders();\n\n            bool installedAny = false;\n            foreach (var packageReference in packageReferences)\n            {\n                if (String.IsNullOrEmpty(packageReference.Id))\n                {\n                    \/\/ GetPackageReferences returns all records without validating values. We'll throw if we encounter packages\n                    \/\/ with malformed ids \/ Versions.\n                    throw new InvalidDataException(String.Format(CultureInfo.CurrentCulture, GetResources.GetCommandInvalidPackageReference, target));\n                }\n                else if (packageReference.Version == null)\n                {\n                    throw new InvalidDataException(String.Format(CultureInfo.CurrentCulture, GetResources.GetCommandPackageReferenceInvalidVersion, packageReference.Id));\n                }\n\n                IPackage package = _packageResolutionManager.ResolveLatestInstallablePackage(_repository, packageReference);\n                if (package == null)\n                {\n                    SemanticVersion version = _packageResolutionManager.ResolveInstallableVersion(_repository, packageReference);\n                    installedAny |= InstallPackage(packageManager, fileSystem, packageReference.Id, version ?? packageReference.Version);\n                }\n                else\n                {\n                    \/\/We got it straight from the server, check whether we get a cache hit, else just install\n                    var resolvedPackage = _packageResolutionManager.FindPackageInAllLocalSources(packageManager.LocalRepository, packageManager.SourceRepository, package);\n                    packageManager.InstallPackage(resolvedPackage ?? package, !IncludeDependencies, false);\n                }\n                \/\/ Note that we ignore dependencies here because packages.config already contains the full closure\n            }\n\n            if (!installedAny && packageReferences.Any())\n            {\n                Console.WriteLine(GetResources.GetCommandNothingToInstall, Constants.PackageReferenceFile);\n            }\n        }\n\n\n        \/\/\/ <summary>\n        \/\/\/ Installs the package.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"packageManager\">The package manager.<\/param>\n        \/\/\/ <param name=\"fileSystem\">The file system.<\/param>\n        \/\/\/ <param name=\"packageId\">The package id.<\/param>\n        \/\/\/ <param name=\"version\">The version.<\/param>\n        \/\/\/ <param name=\"allowPreReleaseVersion\"> <\/param>\n        \/\/\/ <returns><\/returns>\n        internal bool InstallPackage(PackageManager packageManager, IFileSystem fileSystem, string packageId, SemanticVersion version, Boolean allowPreReleaseVersion = true)\n        {\n            if (packageManager.IsPackageInstalled(packageId, version))\n            {\n                return false;\n            }\n\n            if (!AllowMultipleVersions)\n            {\n                var installedPackage = packageManager.LocalRepository.FindPackage(packageId);\n                if (installedPackage != null)\n                {\n                    if (version != null && installedPackage.Version >= version)\n                    {\n                        \/\/ If the package is already installed (or the version being installed is lower), then we do not need to do anything. \n                        return false;\n                    }\n                    else if (packageManager.SourceRepository.Exists(packageId, version))\n                    {\n                        \/\/ If the package is already installed, but\n                        \/\/ (a) the version we require is different from the one that is installed, \n                        \/\/ (b) side-by-side is disabled\n                        \/\/ we need to uninstall it.\n                        \/\/ However, before uninstalling, make sure the package exists in the source repository. \n                        packageManager.UninstallPackage(installedPackage, forceRemove: true, removeDependencies: false);\n                    }\n                }\n            }\n            \/\/TODO Will need to expose the last boolean here......\n            var package = _packageResolutionManager.ResolvePackage(packageManager.LocalRepository, _repository, packageId, version, allowPreReleaseVersion);\n            packageManager.InstallPackage(package, ignoreDependencies: !IncludeDependencies, allowPrereleaseVersions: allowPreReleaseVersion);\n            \/\/packageManager.InstallPackage(packageId, version, !IncludeDependencies, allowPreReleaseVersion);\n            return true;\n        }\n\n        \/\/\/ <summary>\n        \/\/\/ Creates the package manager.\n        \/\/\/ <\/summary>\n        \/\/\/ <param name=\"fileSystem\">The file system.<\/param>\n        \/\/\/ <param name=\"useMachineCache\">if set to <c>true<\/c> [use machine cache].<\/param>\n        \/\/\/ <returns><\/returns>\n        protected virtual PackageManager CreatePackageManager(IFileSystem fileSystem, bool useMachineCache = false)\n        {\n            var pathResolver = new DefaultPackagePathResolver(fileSystem, useSideBySidePaths: AllowMultipleVersions);\n            var packageManager = new PackageManager(_repository, pathResolver, fileSystem, new LocalPackageRepository(pathResolver, fileSystem));\n            packageManager.Logger = Console;\n\n            return packageManager;\n        }\n\n        protected virtual IFileSystem CreateFileSystem(string pathRoot)\n        {\n            \/\/ Use the passed in install path if any, and default to the current dir\n            return new PhysicalFileSystem(pathRoot);\n        }\n    }\n}\n","returncode":0,"stderr":"","license":"mit","lang":"C#"}